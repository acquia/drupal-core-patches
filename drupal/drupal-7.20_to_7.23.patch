diff --git a/.htaccess b/.htaccess
index 246edc2..7ccb6a2 100644
--- a/.htaccess
+++ b/.htaccess
@@ -3,7 +3,7 @@
 #
 
 # Protect files and directories from prying eyes.
-<FilesMatch "\.(engine|inc|info|install|make|module|profile|test|po|sh|.*sql|theme|tpl(\.php)?|xtmpl)$|^(\..*|Entries.*|Repository|Root|Tag|Template)$">
+<FilesMatch "\.(engine|inc|info|install|make|module|profile|test|po|sh|.*sql|theme|tpl(\.php)?|xtmpl)(~|\.sw[op]|\.bak|\.orig|\.save)?$|^(\..*|Entries.*|Repository|Root|Tag|Template)$|^#.*#$|\.php(~|\.sw[op]|\.bak|\.orig\.save)$">
   Order allow,deny
 </FilesMatch>
 
@@ -56,6 +56,17 @@ DirectoryIndex index.php index.html index.htm
 <IfModule mod_rewrite.c>
   RewriteEngine on
 
+  # Set "protossl" to "s" if we were accessed via https://.  This is used later
+  # if you enable "www." stripping or enforcement, in order to ensure that
+  # you don't bounce between http and https.
+  RewriteRule ^ - [E=protossl]
+  RewriteCond %{HTTPS} on
+  RewriteRule ^ - [E=protossl:s]
+
+  # Make sure Authorization HTTP header is available to PHP
+  # even when running as CGI or FastCGI.
+  RewriteRule ^ - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
+
   # Block access to "hidden" directories whose names begin with a period. This
   # includes directories used by version control systems such as Subversion or
   # Git to store control files. Files whose names begin with a period, as well
@@ -78,14 +89,15 @@ DirectoryIndex index.php index.html index.htm
   # To redirect all users to access the site WITH the 'www.' prefix,
   # (http://example.com/... will be redirected to http://www.example.com/...)
   # uncomment the following:
+  # RewriteCond %{HTTP_HOST} .
   # RewriteCond %{HTTP_HOST} !^www\. [NC]
-  # RewriteRule ^ http://www.%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
+  # RewriteRule ^ http%{ENV:protossl}://www.%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
   #
   # To redirect all users to access the site WITHOUT the 'www.' prefix,
   # (http://www.example.com/... will be redirected to http://example.com/...)
   # uncomment the following:
   # RewriteCond %{HTTP_HOST} ^www\.(.+)$ [NC]
-  # RewriteRule ^ http://%1%{REQUEST_URI} [L,R=301]
+  # RewriteRule ^ http%{ENV:protossl}://%1%{REQUEST_URI} [L,R=301]
 
   # Modify the RewriteBase if you are using Drupal in a subdirectory or in a
   # VirtualDocumentRoot and the rewrite rules are not working properly.
diff --git a/CHANGELOG.txt b/CHANGELOG.txt
index 750aabb..464f5ef 100644
--- a/CHANGELOG.txt
+++ b/CHANGELOG.txt
@@ -1,4 +1,124 @@
 
+Drupal 7.23, 2013-08-07
+-----------------------
+- Fixed a fatal error on PostgreSQL databases when updating the Taxonomy module
+  from Drupal 6 to Drupal 7.
+- Fixed the default ordering of CSS files for sites using right-to-left
+  languages, to consistently place the right-to-left override file immediately
+  after the CSS it is overriding (API change: https://drupal.org/node/2058463).
+- Added a drupal_check_memory_limit() API function to allow the memory limit to
+  be checked consistently (API addition).
+- Changed the default web.config file for IIS servers to allow favicon.ico
+  files which are present in the filesystem to be accessed.
+- Fixed inconsistent support for the 'tel' protocol in Drupal's URL filtering
+  functions.
+- Performance improvement: Allowed all hooks to be included in the
+  module_implements() cache, even those that are only invoked on HTTP POST
+  requests.
+- Made the database system replace truncate queries with delete queries when
+  inside a transaction, to fix issues with PostgreSQL and other databases.
+- Fixed a bug which caused nested contextual links to display improperly.
+- Fixed a bug which prevented cached image derivatives from being flushed for
+  private files and other non-default file schemes.
+- Fixed drupal_render() to always return an empty string when there is no
+  output, rather than sometimes returning NULL (minor API change).
+- Added protection to cache_clear_all() to ensure that non-cache tables cannot
+  be truncated (API addition: a new isValidBin() method has been added to the
+  default database cache implementation).
+- Changed the default .htaccess file to support HTTP authorization in CGI
+  environments.
+- Changed the password reset form to pre-fill the username when requested via a
+  URL query parameter, and used this in the error message that appears after a
+  failed login attempt (minor data structure and behavior change).
+- Fixed broken support for foreign keys in the field API.
+- Fixed "No active batch" error when a user cancels their own account.
+- Added a description to the "access content overview" permission on the
+  permissions page (string change).
+- Added a drupal_array_diff_assoc_recursive() function to allow associative
+  arrays to be compared recursively (API addition).
+- Added human-readable labels to image styles, in addition to the existing
+  machine-readable name (API change: https://drupal.org/node/2058503).
+- Moved the drupal_get_hash_salt() function to bootstrap.inc and used it in
+  additional places in the code, for added security in the case where there is
+  no hash salt in settings.php.
+- Fixed a regression in Drupal 7.22 that caused internal server errors for
+  sites running on very old Apache 1.x web servers.
+- Numerous small bug fixes.
+- Numerous API documentation improvements.
+- Additional automated test coverage.
+
+Drupal 7.22, 2013-04-03
+-----------------------
+- Allowed the drupal_http_request() function to be overridden so that
+  additional HTTP request capabilities can be added by contributed modules.
+- Changed the Simpletest module to allow PSR-0 test classes to be used in
+  Drupal 7.
+- Removed an unnecessary "Content-Disposition" header from private file
+  downloads; it prevented many private files from being viewed inline in a web
+  browser.
+- Changed various field API functions to allow them to optionally act on a
+  single field within an entity (API addition: http://drupal.org/node/1825844).
+- Fixed a bug which prevented Drupal's file transfer functionality from working
+  on some PHP 5.4 systems.
+- Fixed incorrect log message when theme() is called for a theme hook that does
+  not exist (minor string change).
+- Fixed Drupal's token-replacement system to allow spaces in the token value.
+- Changed the default behavior after a user creates a node they do not have
+  access to view. The user will now be redirected to the front page rather than
+  an access denied page.
+- Fixed a bug which prevented empty HTTP headers (such as "0") from being set.
+  (Minor behavior change: Callers of drupal_add_http_header() must now set
+  FALSE explicitly to prevent a header from being sent at all; this was already
+  indicated in the function's documentation.)
+- Fixed OpenID errors when more than one module implements hook_openid(). The
+  behavior is now changed so that if more than one module tries to set the same
+  parameter, the last module's change takes effect.
+- Fixed a serious documentation bug: The $name variable in the
+  taxonomy-term.tpl.php theme template was incorrectly documented as being
+  sanitized when in fact it is not.
+- Fixed a bug which prevented Drupal 6 to Drupal 7 upgrades on sites which had
+  duplicate permission names in the User module's database tables.
+- Added an empty "datatype" attribute to taxonomy term and username links to
+  make the RDFa markup upward compatible with RDFa 1.1 (minor markup addition).
+- Fixed a bug which caused the denial-of-service protection added in Drupal
+  7.20 to break certain valid image URLs that had an extra slash in them.
+- Fixed a bug with update queries in the SQLite database driver that prevented
+  Drupal from being installed with SQLite on PHP 5.4.
+- Fixed enforced dependencies errors updating to recent versions of Drupal 7 on
+  certain non-MySQL databases.
+- Refactored the Field module's caching behavior to obtain large improvements
+  in memory usage for sites with many fields and instances (API addition:
+  http://drupal.org/node/1915646).
+- Fixed entity argument not being passed to implementations of
+  hook_file_download_access_alter(). The fix adds an additional context
+  parameter that can be passed when calling drupal_alter() for any hook (API
+  change: http://drupal.org/node/1882722).
+- Fixed broken support for translatable comment fields (API change:
+  http://drupal.org/node/1874724).
+- Added an assertThemeOutput() method to Simpletest to allow tests to check
+  that themed output matches an expected HTML string (API addition).
+- Added a link to "Install another module" after a module has been successfully
+  downloaded via the Update Manager (UI change).
+- Added an optional "exclusive" flag to installation profile .info files which
+  allows Drupal distributions to force a profile to be selected during
+  installation (API addition: http://drupal.org/node/1961012).
+- Fixed a bug which caused the database API to not properly close database
+  connections.
+- Added a link to the URL for running cron from outside the site to the Cron
+  settings page (UI change).
+- Fixed a bug which prevented image styles from being reverted on PHP 5.4.
+- Made the default .htaccess rules protocol sensitive to improve security for
+  sites which use HTTPS and redirect between "www" and non-"www" versions of
+  the page.
+- Numerous small bug fixes.
+- Numerous API documentation improvements.
+- Additional automated test coverage.
+
+Drupal 7.21, 2013-03-06
+-----------------------
+- Allowed sites using the 'image_allow_insecure_derivatives' variable to still
+  have partial protection from the security issues fixed in Drupal 7.20.
+
 Drupal 7.20, 2013-02-20
 -----------------------
 - Fixed security issues (denial of service). See SA-CORE-2013-002.
diff --git a/authorize.php b/authorize.php
index d14fa6e..3ea2b20 100644
--- a/authorize.php
+++ b/authorize.php
@@ -4,16 +4,16 @@
  * @file
  * Administrative script for running authorized file operations.
  *
- * Using this script, the site owner (the user actually owning the files on
- * the webserver) can authorize certain file-related operations to proceed
- * with elevated privileges, for example to deploy and upgrade modules or
- * themes. Users should not visit this page directly, but instead use an
- * administrative user interface which knows how to redirect the user to this
- * script as part of a multistep process. This script actually performs the
- * selected operations without loading all of Drupal, to be able to more
- * gracefully recover from errors. Access to the script is controlled by a
- * global killswitch in settings.php ('allow_authorize_operations') and via
- * the 'administer software updates' permission.
+ * Using this script, the site owner (the user actually owning the files on the
+ * webserver) can authorize certain file-related operations to proceed with
+ * elevated privileges, for example to deploy and upgrade modules or themes.
+ * Users should not visit this page directly, but instead use an administrative
+ * user interface which knows how to redirect the user to this script as part of
+ * a multistep process. This script actually performs the selected operations
+ * without loading all of Drupal, to be able to more gracefully recover from
+ * errors. Access to the script is controlled by a global killswitch in
+ * settings.php ('allow_authorize_operations') and via the 'administer software
+ * updates' permission.
  *
  * There are helper functions for setting up an operation to run via this
  * system in modules/system/system.module. For more information, see:
@@ -21,16 +21,17 @@
  */
 
 /**
- * Root directory of Drupal installation.
+ * Defines the root directory of the Drupal installation.
  */
 define('DRUPAL_ROOT', getcwd());
 
 /**
- * Global flag to identify update.php and authorize.php runs, and so
- * avoid various unwanted operations, such as hook_init() and
- * hook_exit() invokes, css/js preprocessing and translation, and
- * solve some theming issues. This flag is checked on several places
- * in Drupal code (not just authorize.php).
+ * Global flag to identify update.php and authorize.php runs.
+ *
+ * Identifies update.php and authorize.php runs, avoiding unwanted operations
+ * such as hook_init() and hook_exit() invokes, css/js preprocessing and
+ * translation, and solves some theming issues. The flag is checked in other
+ * places in Drupal code (not just authorize.php).
  */
 define('MAINTENANCE_MODE', 'update');
 
@@ -51,7 +52,7 @@ function authorize_access_denied_page() {
  * have access to the 'administer software updates' permission.
  *
  * @return
- *   TRUE if the current user can run authorize.php, otherwise FALSE.
+ *   TRUE if the current user can run authorize.php, and FALSE if not.
  */
 function authorize_access_allowed() {
   return variable_get('allow_authorize_operations', TRUE) && user_access('administer software updates');
diff --git a/includes/ajax.inc b/includes/ajax.inc
index 4107029..ab0111c 100644
--- a/includes/ajax.inc
+++ b/includes/ajax.inc
@@ -251,8 +251,8 @@ function ajax_render($commands = array()) {
       //   reliably diffed with array_diff_key(), since the number can change
       //   due to factors unrelated to the inline content, so for now, we strip
       //   the inline items from Ajax responses, and can add support for them
-      //   when drupal_add_css() and drupal_add_js() are changed to using md5()
-      //   or some other hash of the inline content.
+      //   when drupal_add_css() and drupal_add_js() are changed to use a hash
+      //   of the inline content as the array key.
       foreach ($items[$type] as $key => $item) {
         if (is_numeric($key)) {
           unset($items[$type][$key]);
@@ -836,7 +836,8 @@ function ajax_command_insert($selector, $html, $settings = NULL) {
  * @return
  *   An array suitable for use with the ajax_render() function.
  *
- * See @link http://docs.jquery.com/Manipulation/replaceWith#content jQuery replaceWith command @endlink
+ * See
+ * @link http://docs.jquery.com/Manipulation/replaceWith#content jQuery replaceWith command @endlink
  */
 function ajax_command_replace($selector, $html, $settings = NULL) {
   return array(
diff --git a/includes/bootstrap.inc b/includes/bootstrap.inc
index 2cfdfe9..d27f8d1 100644
--- a/includes/bootstrap.inc
+++ b/includes/bootstrap.inc
@@ -8,7 +8,7 @@
 /**
  * The current system version.
  */
-define('VERSION', '7.20');
+define('VERSION', '7.23');
 
 /**
  * Core API compatibility.
@@ -218,12 +218,16 @@ define('LANGUAGE_RTL', 1);
 define('REQUEST_TIME', (int) $_SERVER['REQUEST_TIME']);
 
 /**
- * Flag for drupal_set_title(); text is not sanitized, so run check_plain().
+ * Flag used to indicate that text is not sanitized, so run check_plain().
+ *
+ * @see drupal_set_title()
  */
 define('CHECK_PLAIN', 0);
 
 /**
- * Flag for drupal_set_title(); text has already been sanitized.
+ * Flag used to indicate that text has already been sanitized.
+ *
+ * @see drupal_set_title()
  */
 define('PASS_THROUGH', -1);
 
@@ -380,11 +384,11 @@ abstract class DrupalCacheArray implements ArrayAccess {
    * without necessarily writing back to the persistent cache at the end.
    *
    * @param $offset
-   *   The array offset that was request.
+   *   The array offset that was requested.
    * @param $persist
    *   Optional boolean to specify whether the offset should be persisted or
    *   not, defaults to TRUE. When called with $persist = FALSE the offset will
-   *   be unflagged so that it will not written at the end of the request.
+   *   be unflagged so that it will not be written at the end of the request.
    */
   protected function persist($offset, $persist = TRUE) {
     $this->keysToPersist[$offset] = $persist;
@@ -716,7 +720,6 @@ function drupal_settings_initialize() {
   if (isset($base_url)) {
     // Parse fixed base URL from settings.php.
     $parts = parse_url($base_url);
-    $http_protocol = $parts['scheme'];
     if (!isset($parts['path'])) {
       $parts['path'] = '';
     }
@@ -792,7 +795,7 @@ function drupal_settings_initialize() {
  *
  * This function plays a key role in allowing Drupal's resources (modules
  * and themes) to be located in different places depending on a site's
- * configuration. For example, a module 'foo' may legally be be located
+ * configuration. For example, a module 'foo' may legally be located
  * in any of these three places:
  *
  * modules/foo/foo.module
@@ -803,7 +806,7 @@ function drupal_settings_initialize() {
  * the above, depending on where the module is located.
  *
  * @param $type
- *   The type of the item (i.e. theme, theme_engine, module, profile).
+ *   The type of the item (theme, theme_engine, module, profile).
  * @param $name
  *   The name of the item for which the filename is requested.
  * @param $filename
@@ -811,7 +814,7 @@ function drupal_settings_initialize() {
  *   than by consulting the database.
  *
  * @return
- *   The filename of the requested item.
+ *   The filename of the requested item or NULL if the item is not found.
  */
 function drupal_get_filename($type, $name, $filename = NULL) {
   // The location of files will not change during the request, so do not use
@@ -1186,10 +1189,11 @@ function _drupal_set_preferred_header_name($name = NULL) {
  * Headers are set in drupal_add_http_header(). Default headers are not set
  * if they have been replaced or unset using drupal_add_http_header().
  *
- * @param $default_headers
- *   An array of headers as name/value pairs.
- * @param $single
- *   If TRUE and headers have already be sent, send only the specified header.
+ * @param array $default_headers
+ *   (optional) An array of headers as name/value pairs.
+ * @param bool $only_default
+ *   (optional) If TRUE and headers have already been sent, send only the
+ *   specified headers.
  */
 function drupal_send_headers($default_headers = array(), $only_default = FALSE) {
   $headers_sent = &drupal_static(__FUNCTION__, FALSE);
@@ -1212,7 +1216,7 @@ function drupal_send_headers($default_headers = array(), $only_default = FALSE)
       header($_SERVER['SERVER_PROTOCOL'] . ' ' . $value);
     }
     // Skip headers that have been unset.
-    elseif ($value) {
+    elseif ($value !== FALSE) {
       header($header_names[$name_lower] . ': ' . $value);
     }
   }
@@ -1405,6 +1409,7 @@ function drupal_unpack($obj, $field = 'data') {
  * more information, including recommendations on how to break up or not
  * break up strings for translation.
  *
+ * @section sec_translating_vars Translating Variables
  * You should never use t() to translate variables, such as calling
  * @code t($text); @endcode, unless the text that the variable holds has been
  * passed through t() elsewhere (e.g., $text is one of several translated
@@ -1420,9 +1425,11 @@ function drupal_unpack($obj, $field = 'data') {
  * Basically, you can put variables like @name into your string, and t() will
  * substitute their sanitized values at translation time. (See the
  * Localization API pages referenced above and the documentation of
- * format_string() for details.) Translators can then rearrange the string as
- * necessary for the language (e.g., in Spanish, it might be "blog de @name").
+ * format_string() for details about how to define variables in your string.)
+ * Translators can then rearrange the string as necessary for the language
+ * (e.g., in Spanish, it might be "blog de @name").
  *
+ * @section sec_alt_funcs_install Use During Installation Phase
  * During the Drupal installation phase, some resources used by t() wil not be
  * available to code that needs localization. See st() and get_t() for
  * alternatives.
@@ -1484,21 +1491,34 @@ function t($string, array $args = array(), array $options = array()) {
 }
 
 /**
- * Replaces placeholders with sanitized values in a string.
+ * Formats a string for HTML display by replacing variable placeholders.
+ *
+ * This function replaces variable placeholders in a string with the requested
+ * values and escapes the values so they can be safely displayed as HTML. It
+ * should be used on any unknown text that is intended to be printed to an HTML
+ * page (especially text that may have come from untrusted users, since in that
+ * case it prevents cross-site scripting and other security problems).
+ *
+ * In most cases, you should use t() rather than calling this function
+ * directly, since it will translate the text (on non-English-only sites) in
+ * addition to formatting it.
  *
  * @param $string
  *   A string containing placeholders.
  * @param $args
  *   An associative array of replacements to make. Occurrences in $string of
- *   any key in $args are replaced with the corresponding value, after
- *   sanitization. The sanitization function depends on the first character of
- *   the key:
- *   - !variable: Inserted as is. Use this for text that has already been
- *     sanitized.
- *   - @variable: Escaped to HTML using check_plain(). Use this for anything
- *     displayed on a page on the site.
- *   - %variable: Escaped as a placeholder for user-submitted content using
- *     drupal_placeholder(), which shows up as <em>emphasized</em> text.
+ *   any key in $args are replaced with the corresponding value, after optional
+ *   sanitization and formatting. The type of sanitization and formatting
+ *   depends on the first character of the key:
+ *   - @variable: Escaped to HTML using check_plain(). Use this as the default
+ *     choice for anything displayed on a page on the site.
+ *   - %variable: Escaped to HTML and formatted using drupal_placeholder(),
+ *     which makes it display as <em>emphasized</em> text.
+ *   - !variable: Inserted as is, with no sanitization or formatting. Only use
+ *     this for text that has already been prepared for HTML display (for
+ *     example, user-supplied text that has already been run through
+ *     check_plain() previously, or is expected to contain some limited HTML
+ *     tags and has already been run through filter_xss() previously).
  *
  * @see t()
  * @ingroup sanitization
@@ -2219,6 +2239,19 @@ function drupal_get_user_timezone() {
 }
 
 /**
+ * Gets a salt useful for hardening against SQL injection.
+ *
+ * @return
+ *   A salt based on information in settings.php, not in the database.
+ */
+function drupal_get_hash_salt() {
+  global $drupal_hash_salt, $databases;
+  // If the $drupal_hash_salt variable is empty, a hash of the serialized
+  // database credentials is used as a fallback salt.
+  return empty($drupal_hash_salt) ? hash('sha256', serialize($databases)) : $drupal_hash_salt;
+}
+
+/**
  * Provides custom PHP error handling.
  *
  * @param $error_level
@@ -2438,7 +2471,6 @@ function drupal_get_bootstrap_phase() {
  *   HMAC and timestamp.
  */
 function drupal_valid_test_ua() {
-  global $drupal_hash_salt;
   // No reason to reset this.
   static $test_prefix;
 
@@ -2452,7 +2484,7 @@ function drupal_valid_test_ua() {
     // We use the salt from settings.php to make the HMAC key, since
     // the database is not yet initialized and we can't access any Drupal variables.
     // The file properties add more entropy not easily accessible to others.
-    $key = $drupal_hash_salt . filectime(__FILE__) . fileinode(__FILE__);
+    $key = drupal_get_hash_salt() . filectime(__FILE__) . fileinode(__FILE__);
     $time_diff = REQUEST_TIME - $time;
     // Since we are making a local request a 5 second time window is allowed,
     // and the HMAC must match.
@@ -2470,14 +2502,13 @@ function drupal_valid_test_ua() {
  * Generates a user agent string with a HMAC and timestamp for simpletest.
  */
 function drupal_generate_test_ua($prefix) {
-  global $drupal_hash_salt;
   static $key;
 
   if (!isset($key)) {
     // We use the salt from settings.php to make the HMAC key, since
     // the database is not yet initialized and we can't access any Drupal variables.
     // The file properties add more entropy not easily accessible to others.
-    $key = $drupal_hash_salt . filectime(__FILE__) . fileinode(__FILE__);
+    $key = drupal_get_hash_salt() . filectime(__FILE__) . fileinode(__FILE__);
   }
   // Generate a moderately secure HMAC based on the database credentials.
   $salt = uniqid('', TRUE);
@@ -3383,3 +3414,32 @@ function _drupal_shutdown_function() {
     }
   }
 }
+
+/**
+ * Compares the memory required for an operation to the available memory.
+ *
+ * @param $required
+ *   The memory required for the operation, expressed as a number of bytes with
+ *   optional SI or IEC binary unit prefix (e.g. 2, 3K, 5MB, 10G, 6GiB, 8bytes,
+ *   9mbytes).
+ * @param $memory_limit
+ *   (optional) The memory limit for the operation, expressed as a number of
+ *   bytes with optional SI or IEC binary unit prefix (e.g. 2, 3K, 5MB, 10G,
+ *   6GiB, 8bytes, 9mbytes). If no value is passed, the current PHP
+ *   memory_limit will be used. Defaults to NULL.
+ *
+ * @return
+ *   TRUE if there is sufficient memory to allow the operation, or FALSE
+ *   otherwise.
+ */
+function drupal_check_memory_limit($required, $memory_limit = NULL) {
+  if (!isset($memory_limit)) {
+    $memory_limit = ini_get('memory_limit');
+  }
+
+  // There is sufficient memory if:
+  // - No memory limit is set.
+  // - The memory limit is set to unlimited (-1).
+  // - The memory limit is greater than the memory required for the operation.
+  return ((!$memory_limit) || ($memory_limit == -1) || (parse_size($memory_limit) >= parse_size($required)));
+}
diff --git a/includes/cache.inc b/includes/cache.inc
index a19d3c3..09f4d75 100644
--- a/includes/cache.inc
+++ b/includes/cache.inc
@@ -80,43 +80,15 @@ function cache_get_multiple(array &$cids, $bin = 'cache') {
  * same name. Other implementations might want to store several bins in data
  * structures that get flushed together. While it is not a problem for most
  * cache bins if the entries in them are flushed before their expire time, some
- * might break functionality or are extremely expensive to recalculate. These
- * will be marked with a (*). The other bins expired automatically by core.
- * Contributed modules can add additional bins and get them expired
- * automatically by implementing hook_flush_caches().
- *
- *  - cache: Generic cache storage bin (used for variables, theme registry,
- *  locale date, list of simpletest tests etc).
- *
- *  - cache_block: Stores the content of various blocks.
- *
- *  - cache field: Stores the field data belonging to a given object.
- *
- *  - cache_filter: Stores filtered pieces of content.
- *
- *  - cache_form(*): Stores multistep forms. Flushing this bin means that some
- *  forms displayed to users lose their state and the data already submitted
- *  to them.
- *
- *  - cache_menu: Stores the structure of visible navigation menus per page.
- *
- *  - cache_page: Stores generated pages for anonymous users. It is flushed
- *  very often, whenever a page changes, at least for every ode and comment
- *  submission. This is the only bin affected by the page cache setting on
- *  the administrator panel.
- *
- *  - cache path: Stores the system paths that have an alias.
- *
- *  - cache update(*): Stores available releases. The update server (for
- *  example, drupal.org) needs to produce the relevant XML for every project
- *  installed on the current site. As this is different for (almost) every
- *  site, it's very expensive to recalculate for the update server.
+ * might break functionality or are extremely expensive to recalculate. The
+ * other bins are expired automatically by core. Contributed modules can add
+ * additional bins and get them expired automatically by implementing
+ * hook_flush_caches().
  *
  * The reasons for having several bins are as follows:
- *
- * - smaller bins mean smaller database tables and allow for faster selects and
- *   inserts
- * - we try to put fast changing cache items and rather static ones into
+ * - Smaller bins mean smaller database tables and allow for faster selects and
+ *   inserts.
+ * - We try to put fast changing cache items and rather static ones into
  *   different bins. The effect is that only the fast changing bins will need a
  *   lot of writes to disk. The more static bins will also be better cacheable
  *   with MySQL's query cache.
@@ -125,13 +97,27 @@ function cache_get_multiple(array &$cids, $bin = 'cache') {
  *   The cache ID of the data to store.
  * @param $data
  *   The data to store in the cache. Complex data types will be automatically
- *   serialized before insertion.
- *   Strings will be stored as plain text and not serialized.
+ *   serialized before insertion. Strings will be stored as plain text and are
+ *   not serialized.
  * @param $bin
- *   The cache bin to store the data in. Valid core values are 'cache_block',
- *   'cache_bootstrap', 'cache_field', 'cache_filter', 'cache_form',
- *   'cache_menu', 'cache_page', 'cache_update' or 'cache' for the default
- *   cache.
+ *   The cache bin to store the data in. Valid core values are:
+ *   - cache: (default) Generic cache storage bin (used for theme registry,
+ *     locale date, list of simpletest tests, etc.).
+ *   - cache_block: Stores the content of various blocks.
+ *   - cache_bootstrap: Stores the class registry, the system list of modules,
+ *     the list of which modules implement which hooks, and the Drupal variable
+ *     list.
+ *   - cache_field: Stores the field data belonging to a given object.
+ *   - cache_filter: Stores filtered pieces of content.
+ *   - cache_form: Stores multistep forms. Flushing this bin means that some
+ *     forms displayed to users lose their state and the data already submitted
+ *     to them. This bin should not be flushed before its expired time.
+ *   - cache_menu: Stores the structure of visible navigation menus per page.
+ *   - cache_page: Stores generated pages for anonymous users. It is flushed
+ *     very often, whenever a page changes, at least for every node and comment
+ *     submission. This is the only bin affected by the page cache setting on
+ *     the administrator panel.
+ *   - cache_path: Stores the system paths that have an alias.
  * @param $expire
  *   One of the following values:
  *   - CACHE_PERMANENT: Indicates that the item should never be removed unless
@@ -141,6 +127,7 @@ function cache_get_multiple(array &$cids, $bin = 'cache') {
  *   - A Unix timestamp: Indicates that the item should be kept at least until
  *     the given time, after which it behaves like CACHE_TEMPORARY.
  *
+ * @see _update_cache_set()
  * @see cache_get()
  */
 function cache_set($cid, $data, $bin = 'cache', $expire = CACHE_PERMANENT) {
@@ -150,18 +137,20 @@ function cache_set($cid, $data, $bin = 'cache', $expire = CACHE_PERMANENT) {
 /**
  * Expires data from the cache.
  *
- * If called without arguments, expirable entries will be cleared from the
- * cache_page and cache_block bins.
+ * If called with the arguments $cid and $bin set to NULL or omitted, then
+ * expirable entries will be cleared from the cache_page and cache_block bins,
+ * and the $wildcard argument is ignored.
  *
  * @param $cid
- *   If set, the cache ID to delete. Otherwise, all cache entries that can
- *   expire are deleted.
+ *   If set, the cache ID or an array of cache IDs. Otherwise, all cache entries
+ *   that can expire are deleted. The $wildcard argument will be ignored if set
+ *   to NULL.
  * @param $bin
  *   If set, the cache bin to delete from. Mandatory argument if $cid is set.
  * @param $wildcard
- *   If TRUE, cache IDs starting with $cid are deleted in addition to the
- *   exact cache ID specified by $cid. If $wildcard is TRUE and $cid is '*',
- *   the entire cache bin is emptied.
+ *   If TRUE, the $cid argument must contain a string value and cache IDs
+ *   starting with $cid are deleted in addition to the exact cache ID specified
+ *   by $cid. If $wildcard is TRUE and $cid is '*', the entire cache is emptied.
  */
 function cache_clear_all($cid = NULL, $bin = NULL, $wildcard = FALSE) {
   if (!isset($cid) && !isset($bin)) {
@@ -230,13 +219,6 @@ function cache_is_empty($bin) {
  * @see DrupalDatabaseCache
  */
 interface DrupalCacheInterface {
-  /**
-   * Constructs a new cache interface.
-   *
-   * @param $bin
-   *   The cache bin for which the object is created.
-   */
-  function __construct($bin);
 
   /**
    * Returns data from the persistent cache.
@@ -293,12 +275,14 @@ interface DrupalCacheInterface {
    * cache_page and cache_block bins.
    *
    * @param $cid
-   *   If set, the cache ID to delete. Otherwise, all cache entries that can
-   *   expire are deleted.
+   *   If set, the cache ID or an array of cache IDs. Otherwise, all cache
+   *   entries that can expire are deleted. The $wildcard argument will be
+   *   ignored if set to NULL.
    * @param $wildcard
-   *   If set to TRUE, the $cid is treated as a substring
-   *   to match rather than a complete ID. The match is a right hand
-   *   match. If '*' is given as $cid, the bin $bin will be emptied.
+   *   If TRUE, the $cid argument must contain a string value and cache IDs
+   *   starting with $cid are deleted in addition to the exact cache ID
+   *   specified by $cid. If $wildcard is TRUE and $cid is '*', the entire
+   *   cache is emptied.
    */
   function clear($cid = NULL, $wildcard = FALSE);
 
@@ -324,7 +308,10 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
   protected $bin;
 
   /**
-   * Constructs a new DrupalDatabaseCache object.
+   * Constructs a DrupalDatabaseCache object.
+   *
+   * @param $bin
+   *   The cache bin for which the object is created.
    */
   function __construct($bin) {
     $this->bin = $bin;
@@ -518,7 +505,16 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
     else {
       if ($wildcard) {
         if ($cid == '*') {
-          db_truncate($this->bin)->execute();
+          // Check if $this->bin is a cache table before truncating. Other
+          // cache_clear_all() operations throw a PDO error in this situation,
+          // so we don't need to verify them first. This ensures that non-cache
+          // tables cannot be truncated accidentally.
+          if ($this->isValidBin()) {
+            db_truncate($this->bin)->execute();
+          }
+          else {
+            throw new Exception(t('Invalid or missing cache bin specified: %bin', array('%bin' => $this->bin)));
+          }
         }
         else {
           db_delete($this->bin)
@@ -555,4 +551,25 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
       ->fetchField();
     return empty($result);
   }
+
+  /**
+   * Checks if $this->bin represents a valid cache table.
+   *
+   * This check is required to ensure that non-cache tables are not truncated
+   * accidentally when calling cache_clear_all().
+   *
+   * @return boolean
+   */
+  function isValidBin() {
+    if ($this->bin == 'cache' || substr($this->bin, 0, 6) == 'cache_') {
+      // Skip schema check for bins with standard table names.
+      return TRUE;
+    }
+    // These fields are required for any cache table.
+    $fields = array('cid', 'data', 'expire', 'created', 'serialized');
+    // Load the table schema.
+    $schema = drupal_get_schema($this->bin);
+    // Confirm that all fields are present.
+    return isset($schema['fields']) && !array_diff($fields, array_keys($schema['fields']));
+  }
 }
diff --git a/includes/common.inc b/includes/common.inc
index 8276576..262e1c5 100644
--- a/includes/common.inc
+++ b/includes/common.inc
@@ -281,7 +281,7 @@ function drupal_get_rdf_namespaces() {
 /**
  * Adds output to the HEAD tag of the HTML page.
  *
- * This function can be called as long the headers aren't sent. Pass no
+ * This function can be called as long as the headers aren't sent. Pass no
  * arguments (or NULL for both) to retrieve the currently stored elements.
  *
  * @param $data
@@ -641,7 +641,7 @@ function drupal_encode_path($path) {
 }
 
 /**
- * Sends the user to a different Drupal page.
+ * Sends the user to a different page.
  *
  * This issues an on-site HTTP redirect. The function makes sure the redirected
  * URL is formatted correctly.
@@ -785,6 +785,13 @@ function drupal_access_denied() {
  *   - data: A string containing the response body that was received.
  */
 function drupal_http_request($url, array $options = array()) {
+  // Allow an alternate HTTP client library to replace Drupal's default
+  // implementation.
+  $override_function = variable_get('drupal_http_request_function', FALSE);
+  if (!empty($override_function) && function_exists($override_function)) {
+    return $override_function($url, $options);
+  }
+
   $result = new stdClass();
 
   // Parse the URL and make sure we can handle the schema.
@@ -1167,7 +1174,8 @@ function fix_gpc_magic() {
 /**
  * Verifies the syntax of the given e-mail address.
  *
- * See @link http://tools.ietf.org/html/rfc5321 RFC 5321 @endlink for details.
+ * This uses the
+ * @link http://php.net/manual/filter.filters.validate.php PHP e-mail validation filter. @endlink
  *
  * @param $mail
  *   A string containing an e-mail address.
@@ -2078,6 +2086,9 @@ function _format_date_callback(array $matches = NULL, $new_langcode = NULL) {
 /**
  * Format a username.
  *
+ * This is also the label callback implementation of
+ * callback_entity_info_label() for user_entity_info().
+ *
  * By default, the passed-in object's 'name' property is used if it exists, or
  * else, the site-defined value for the 'anonymous' variable. However, a module
  * may override this by implementing hook_username_alter(&$name, $account).
@@ -2379,6 +2390,14 @@ function drupal_attributes(array $attributes = array()) {
  * internal links output by modules should be generated by this function if
  * possible.
  *
+ * However, for links enclosed in translatable text you should use t() and
+ * embed the HTML anchor tag directly in the translated string. For example:
+ * @code
+ * t('Visit the <a href="@url">settings</a> page', array('@url' => url('admin')));
+ * @endcode
+ * This keeps the context of the link title ('settings' in the example) for
+ * translators.
+ *
  * @param string $text
  *   The translated link text for the anchor tag.
  * @param string $path
@@ -2779,7 +2798,7 @@ function drupal_set_time_limit($time_limit) {
  *   The name of the item for which the path is requested.
  *
  * @return
- *   The path to the requested item.
+ *   The path to the requested item or an empty string if the item is not found.
  */
 function drupal_get_path($type, $name) {
   return dirname(drupal_get_filename($type, $name));
@@ -3869,7 +3888,16 @@ function drupal_html_id($id) {
       // requested id. $_POST['ajax_html_ids'] contains the ids as they were
       // returned by this function, potentially with the appended counter, so
       // we parse that to reconstruct the $seen_ids array.
-      foreach ($_POST['ajax_html_ids'] as $seen_id) {
+      if (isset($_POST['ajax_html_ids'][0]) && strpos($_POST['ajax_html_ids'][0], ',') === FALSE) {
+        $ajax_html_ids = $_POST['ajax_html_ids'];
+      }
+      else {
+        // jquery.form.js may send the server a comma-separated string as the
+        // first element of an array (see http://drupal.org/node/1575060), so
+        // we need to convert it to an array in that case.
+        $ajax_html_ids = explode(',', $_POST['ajax_html_ids'][0]);
+      }
+      foreach ($ajax_html_ids as $seen_id) {
         // We rely on '--' being used solely for separating a base id from the
         // counter, which this function ensures when returning an id.
         $parts = explode('--', $seen_id, 2);
@@ -5007,19 +5035,6 @@ function drupal_json_output($var = NULL) {
 }
 
 /**
- * Gets a salt useful for hardening against SQL injection.
- *
- * @return
- *   A salt based on information in settings.php, not in the database.
- */
-function drupal_get_hash_salt() {
-  global $drupal_hash_salt, $databases;
-  // If the $drupal_hash_salt variable is empty, a hash of the serialized
-  // database credentials is used as a fallback salt.
-  return empty($drupal_hash_salt) ? hash('sha256', serialize($databases)) : $drupal_hash_salt;
-}
-
-/**
  * Ensures the private key variable used to generate tokens is set.
  *
  * @return
@@ -5038,6 +5053,13 @@ function drupal_get_private_key() {
  *
  * @param $value
  *   An additional value to base the token on.
+ *
+ * @return string
+ *   A 43-character URL-safe token for validation, based on the user session ID,
+ *   the hash salt provided from drupal_get_hash_salt(), and the
+ *   'drupal_private_key' configuration variable.
+ *
+ * @see drupal_get_hash_salt()
  */
 function drupal_get_token($value = '') {
   return drupal_hmac_base64($value, session_id() . drupal_get_private_key() . drupal_get_hash_salt());
@@ -5568,7 +5590,7 @@ function drupal_pre_render_link($element) {
  * @code
  * $node->content['links'] = array(
  *   '#theme' => 'links__node',
- *   '#pre_render' = array('drupal_pre_render_links'),
+ *   '#pre_render' => array('drupal_pre_render_links'),
  *   'comment' => array(
  *     '#theme' => 'links__node__comment',
  *     '#links' => array(
@@ -5773,23 +5795,23 @@ function drupal_render_page($page) {
  * array to be rendered independently and prevents them from being rendered
  * more than once on subsequent calls to drupal_render() (e.g., as part of a
  * larger array). If the same array or array element is passed more than once
- * to drupal_render(), it simply returns a NULL value.
+ * to drupal_render(), it simply returns an empty string.
  *
- * @param $elements
+ * @param array $elements
  *   The structured array describing the data to be rendered.
  *
- * @return
+ * @return string
  *   The rendered HTML.
  */
 function drupal_render(&$elements) {
   // Early-return nothing if user does not have access.
   if (empty($elements) || (isset($elements['#access']) && !$elements['#access'])) {
-    return;
+    return '';
   }
 
   // Do not print elements twice.
   if (!empty($elements['#printed'])) {
-    return;
+    return '';
   }
 
   // Try to fetch the element's markup from cache and return.
@@ -5825,7 +5847,7 @@ function drupal_render(&$elements) {
 
   // Allow #pre_render to abort rendering.
   if (!empty($elements['#printed'])) {
-    return;
+    return '';
   }
 
   // Get the children of the element, sorted by weight.
@@ -6448,6 +6470,44 @@ function element_set_attributes(array &$element, array $map) {
 }
 
 /**
+ * Recursively computes the difference of arrays with additional index check.
+ *
+ * This is a version of array_diff_assoc() that supports multidimensional
+ * arrays.
+ *
+ * @param array $array1
+ *   The array to compare from.
+ * @param array $array2
+ *   The array to compare to.
+ *
+ * @return array
+ *   Returns an array containing all the values from array1 that are not present
+ *   in array2.
+ */
+function drupal_array_diff_assoc_recursive($array1, $array2) {
+  $difference = array();
+
+  foreach ($array1 as $key => $value) {
+    if (is_array($value)) {
+      if (!array_key_exists($key, $array2) || !is_array($array2[$key])) {
+        $difference[$key] = $value;
+      }
+      else {
+        $new_diff = drupal_array_diff_assoc_recursive($value, $array2[$key]);
+        if (!empty($new_diff)) {
+          $difference[$key] = $new_diff;
+        }
+      }
+    }
+    elseif (!array_key_exists($key, $array2) || $array2[$key] !== $value) {
+      $difference[$key] = $value;
+    }
+  }
+
+  return $difference;
+}
+
+/**
  * Sets a value in a nested array with variable depth.
  *
  * This helper function should be used when the depth of the array element you
diff --git a/includes/database/database.inc b/includes/database/database.inc
index cae50fb..339c9b0 100644
--- a/includes/database/database.inc
+++ b/includes/database/database.inc
@@ -167,7 +167,7 @@
  * }
  * @endcode
  *
- * @link http://drupal.org/developing/api/database @endlink
+ * @see http://drupal.org/developing/api/database
  */
 
 
@@ -194,7 +194,7 @@ abstract class DatabaseConnection extends PDO {
 
   /**
    * The key representing this connection.
-   * 
+   *
    * The key is a unique string which identifies a database connection. A
    * connection can be a single server or a cluster of master and slaves (use
    * target to pick between master and slave).
@@ -303,13 +303,29 @@ abstract class DatabaseConnection extends PDO {
     // Call PDO::__construct and PDO::setAttribute.
     parent::__construct($dsn, $username, $password, $driver_options);
 
-    // Set a specific PDOStatement class if the driver requires that.
+    // Set a Statement class, unless the driver opted out.
     if (!empty($this->statementClass)) {
       $this->setAttribute(PDO::ATTR_STATEMENT_CLASS, array($this->statementClass, array($this)));
     }
   }
 
   /**
+   * Destroys this Connection object.
+   *
+   * PHP does not destruct an object if it is still referenced in other
+   * variables. In case of PDO database connection objects, PHP only closes the
+   * connection when the PDO object is destructed, so any references to this
+   * object may cause the number of maximum allowed connections to be exceeded.
+   */
+  public function destroy() {
+    // Destroy all references to this connection by setting them to NULL.
+    // The Statement class attribute only accepts a new value that presents a
+    // proper callable, so we reset it to PDOStatement.
+    $this->setAttribute(PDO::ATTR_STATEMENT_CLASS, array('PDOStatement', array()));
+    $this->schema = NULL;
+  }
+
+  /**
    * Returns the default query options for any given query.
    *
    * A given query can be customized with a number of option flags in an
@@ -1627,8 +1643,8 @@ abstract class Database {
    */
   final public static function removeConnection($key) {
     if (isset(self::$databaseInfo[$key])) {
+      self::closeConnection(NULL, $key);
       unset(self::$databaseInfo[$key]);
-      unset(self::$connections[$key]);
       return TRUE;
     }
     else {
@@ -1694,11 +1710,24 @@ abstract class Database {
     if (!isset($key)) {
       $key = self::$activeKey;
     }
-    // To close the connection, we need to unset the static variable.
+    // To close a connection, it needs to be set to NULL and removed from the
+    // static variable. In all cases, closeConnection() might be called for a
+    // connection that was not opened yet, in which case the key is not defined
+    // yet and we just ensure that the connection key is undefined.
     if (isset($target)) {
+      if (isset(self::$connections[$key][$target])) {
+        self::$connections[$key][$target]->destroy();
+        self::$connections[$key][$target] = NULL;
+      }
       unset(self::$connections[$key][$target]);
     }
     else {
+      if (isset(self::$connections[$key])) {
+        foreach (self::$connections[$key] as $target => $connection) {
+          self::$connections[$key][$target]->destroy();
+          self::$connections[$key][$target] = NULL;
+        }
+      }
       unset(self::$connections[$key]);
     }
   }
@@ -1852,8 +1881,8 @@ class DatabaseTransaction {
    */
   protected $name;
 
-  public function __construct(DatabaseConnection &$connection, $name = NULL) {
-    $this->connection = &$connection;
+  public function __construct(DatabaseConnection $connection, $name = NULL) {
+    $this->connection = $connection;
     // If there is no transaction depth, then no transaction has started. Name
     // the transaction 'drupal_transaction'.
     if (!$depth = $connection->transactionDepth()) {
diff --git a/includes/database/mysql/database.inc b/includes/database/mysql/database.inc
index 7ad019e..00d81f4 100644
--- a/includes/database/mysql/database.inc
+++ b/includes/database/mysql/database.inc
@@ -13,11 +13,11 @@
 class DatabaseConnection_mysql extends DatabaseConnection {
 
   /**
-   * Flag to indicate if we have registered the nextID cleanup function.
+   * Flag to indicate if the cleanup function in __destruct() should run.
    *
    * @var boolean
    */
-  protected $shutdownRegistered = FALSE;
+  protected $needsCleanup = FALSE;
 
   public function __construct(array $connection_options = array()) {
     // This driver defaults to transaction support, except if explicitly passed FALSE.
@@ -78,6 +78,12 @@ class DatabaseConnection_mysql extends DatabaseConnection {
     $this->exec(implode('; ', $connection_options['init_commands']));
   }
 
+  public function __destruct() {
+    if ($this->needsCleanup) {
+      $this->nextIdDelete();
+    }
+  }
+
   public function queryRange($query, $from, $count, array $args = array(), array $options = array()) {
     return $this->query($query . ' LIMIT ' . (int) $from . ', ' . (int) $count, $args, $options);
   }
@@ -115,12 +121,7 @@ class DatabaseConnection_mysql extends DatabaseConnection {
       $this->query('INSERT INTO {sequences} (value) VALUES (:value) ON DUPLICATE KEY UPDATE value = value', array(':value' => $existing_id));
       $new_id = $this->query('INSERT INTO {sequences} () VALUES ()', array(), array('return' => Database::RETURN_INSERT_ID));
     }
-    if (!$this->shutdownRegistered) {
-      // Use register_shutdown_function() here to keep the database system
-      // independent of Drupal.
-      register_shutdown_function(array($this, 'nextIdDelete'));
-      $shutdownRegistered = TRUE;
-    }
+    $this->needsCleanup = TRUE;
     return $new_id;
   }
 
diff --git a/includes/database/mysql/query.inc b/includes/database/mysql/query.inc
index 2609aba..fa698d9 100644
--- a/includes/database/mysql/query.inc
+++ b/includes/database/mysql/query.inc
@@ -86,21 +86,7 @@ class InsertQuery_mysql extends InsertQuery {
   }
 }
 
-class TruncateQuery_mysql extends TruncateQuery {
-  public function __toString() {
-    // TRUNCATE is actually a DDL statement on MySQL, and DDL statements are
-    // not transactional, and result in an implicit COMMIT. When we are in a
-    // transaction, fallback to the slower, but transactional, DELETE.
-    if ($this->connection->inTransaction()) {
-      // Create a comment string to prepend to the query.
-      $comments = $this->connection->makeComment($this->comments);
-      return $comments . 'DELETE FROM {' . $this->connection->escapeTable($this->table) . '}';
-    }
-    else {
-      return parent::__toString();
-    }
-  }
-}
+class TruncateQuery_mysql extends TruncateQuery { }
 
 /**
  * @} End of "addtogroup database".
diff --git a/includes/database/query.inc b/includes/database/query.inc
index 612985e..6649527 100644
--- a/includes/database/query.inc
+++ b/includes/database/query.inc
@@ -83,7 +83,7 @@ interface QueryConditionInterface {
 
   /**
    * Sets a condition that the specified subquery returns values.
-   * 
+   *
    * @param SelectQueryInterface $select
    *   The subquery that must contain results.
    *
@@ -91,10 +91,10 @@ interface QueryConditionInterface {
    *   The called object.
    */
   public function exists(SelectQueryInterface $select);
-  
+
   /**
    * Sets a condition that the specified subquery returns no values.
-   * 
+   *
    * @param SelectQueryInterface $select
    *   The subquery that must not contain results.
    *
@@ -102,7 +102,7 @@ interface QueryConditionInterface {
    *   The called object.
    */
   public function notExists(SelectQueryInterface $select);
-  
+
   /**
    * Gets a complete list of all conditions in this conditional clause.
    *
@@ -283,14 +283,14 @@ abstract class Query implements QueryPlaceholderInterface {
 
   /**
    * The target of the connection object.
-   * 
+   *
    * @var string
    */
   protected $connectionTarget;
 
   /**
    * The key of the connection object.
-   * 
+   *
    * @var string
    */
   protected $connectionKey;
@@ -804,7 +804,7 @@ class DeleteQuery extends Query implements QueryConditionInterface {
     $this->condition->notExists($select);
     return $this;
   }
-  
+
   /**
    * Implements QueryConditionInterface::conditions().
    */
@@ -942,7 +942,17 @@ class TruncateQuery extends Query {
     // Create a sanitized comment string to prepend to the query.
     $comments = $this->connection->makeComment($this->comments);
 
-    return $comments . 'TRUNCATE {' . $this->connection->escapeTable($this->table) . '} ';
+    // In most cases, TRUNCATE is not a transaction safe statement as it is a
+    // DDL statement which results in an implicit COMMIT. When we are in a
+    // transaction, fallback to the slower, but transactional, DELETE.
+    // PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
+    // the concurrency with other transactions.
+    if ($this->connection->inTransaction()) {
+      return $comments . 'DELETE FROM {' . $this->connection->escapeTable($this->table) . '}';
+    }
+    else {
+      return $comments . 'TRUNCATE {' . $this->connection->escapeTable($this->table) . '} ';
+    }
   }
 }
 
@@ -1053,7 +1063,7 @@ class UpdateQuery extends Query implements QueryConditionInterface {
     $this->condition->notExists($select);
     return $this;
   }
-  
+
   /**
    * Implements QueryConditionInterface::conditions().
    */
@@ -1545,7 +1555,7 @@ class MergeQuery extends Query implements QueryConditionInterface {
     $this->condition->notExists($select);
     return $this;
   }
-  
+
   /**
    * Implements QueryConditionInterface::conditions().
    */
@@ -1762,14 +1772,14 @@ class DatabaseCondition implements QueryConditionInterface, Countable {
   public function exists(SelectQueryInterface $select) {
     return $this->condition('', $select, 'EXISTS');
   }
-  
+
   /**
    * Implements QueryConditionInterface::notExists().
    */
   public function notExists(SelectQueryInterface $select) {
     return $this->condition('', $select, 'NOT EXISTS');
   }
-  
+
   /**
    * Implements QueryConditionInterface::conditions().
    */
@@ -1898,8 +1908,13 @@ class DatabaseCondition implements QueryConditionInterface, Countable {
   function __clone() {
     $this->changed = TRUE;
     foreach ($this->conditions as $key => $condition) {
-      if ($key !== '#conjunction' && $condition['field'] instanceOf QueryConditionInterface) {
-        $this->conditions[$key]['field'] = clone($condition['field']);
+      if ($key !== '#conjunction') {
+        if ($condition['field'] instanceOf QueryConditionInterface) {
+          $this->conditions[$key]['field'] = clone($condition['field']);
+        }
+        if ($condition['value'] instanceOf SelectQueryInterface) {
+          $this->conditions[$key]['value'] = clone($condition['value']);
+        }
       }
     }
   }
diff --git a/includes/database/sqlite/query.inc b/includes/database/sqlite/query.inc
index 74ff9ba..1bf609d 100644
--- a/includes/database/sqlite/query.inc
+++ b/includes/database/sqlite/query.inc
@@ -57,39 +57,18 @@ class InsertQuery_sqlite extends InsertQuery {
  * we don't select those rows.
  *
  * A query like this one:
- *   UPDATE test SET name = 'newname' WHERE tid = 1
+ *   UPDATE test SET col1 = 'newcol1', col2 = 'newcol2' WHERE tid = 1
  * will become:
- *   UPDATE test SET name = 'newname' WHERE tid = 1 AND name <> 'newname'
+ *   UPDATE test SET col1 = 'newcol1', col2 = 'newcol2' WHERE tid = 1 AND (col1 <> 'newcol1' OR col2 <> 'newcol2')
  */
 class UpdateQuery_sqlite extends UpdateQuery {
-  /**
-   * Helper function that removes the fields that are already in a condition.
-   *
-   * @param $fields
-   *   The fields.
-   * @param QueryConditionInterface $condition
-   *   A database condition.
-   */
-  protected function removeFieldsInCondition(&$fields, QueryConditionInterface $condition) {
-    foreach ($condition->conditions() as $child_condition) {
-      if ($child_condition['field'] instanceof QueryConditionInterface) {
-        $this->removeFieldsInCondition($fields, $child_condition['field']);
-      }
-      else {
-        unset($fields[$child_condition['field']]);
-      }
-    }
-  }
-
   public function execute() {
     if (!empty($this->queryOptions['sqlite_return_matched_rows'])) {
       return parent::execute();
     }
 
-    // Get the fields used in the update query, and remove those that are already
-    // in the condition.
+    // Get the fields used in the update query.
     $fields = $this->expressionFields + $this->fields;
-    $this->removeFieldsInCondition($fields, $this->condition);
 
     // Add the inverse of the fields to the condition.
     $condition = new DatabaseCondition('OR');
diff --git a/includes/entity.inc b/includes/entity.inc
index 2fefd59..25f7584 100644
--- a/includes/entity.inc
+++ b/includes/entity.inc
@@ -14,14 +14,6 @@
 interface DrupalEntityControllerInterface {
 
   /**
-   * Constructor.
-   *
-   * @param $entityType
-   *   The entity type for which the instance is created.
-   */
-  public function __construct($entityType);
-
-  /**
    * Resets the internal, static entity cache.
    *
    * @param $ids
@@ -119,6 +111,9 @@ class DrupalDefaultEntityController implements DrupalEntityControllerInterface {
 
   /**
    * Constructor: sets basic variables.
+   *
+   * @param $entityType
+   *   The entity type for which the instance is created.
    */
   public function __construct($entityType) {
     $this->entityType = $entityType;
@@ -634,7 +629,7 @@ class EntityFieldQuery {
 
   /**
    * Adds a condition on field values.
-   * 
+   *
    * Note that entities with empty field values will be excluded from the
    * EntityFieldQuery results when using this method.
    *
diff --git a/includes/errors.inc b/includes/errors.inc
index 7fd2de2..fcf9ca8 100644
--- a/includes/errors.inc
+++ b/includes/errors.inc
@@ -169,7 +169,7 @@ function error_displayable($error = NULL) {
  *   TRUE if the error is fatal.
  */
 function _drupal_log_error($error, $fatal = FALSE) {
-  // Initialize a maintenance theme if the boostrap was not complete.
+  // Initialize a maintenance theme if the bootstrap was not complete.
   // Do it early because drupal_set_message() triggers a drupal_theme_initialize().
   if ($fatal && (drupal_get_bootstrap_phase() != DRUPAL_BOOTSTRAP_FULL)) {
     unset($GLOBALS['theme']);
diff --git a/includes/file.inc b/includes/file.inc
index 278be3d..06657cf 100644
--- a/includes/file.inc
+++ b/includes/file.inc
@@ -89,7 +89,7 @@ define('FILE_STATUS_PERMANENT', 1);
  * wrappers that are appropriate for particular usage. For example, this returns
  * only stream wrappers that use local file storage:
  * @code
- *   $local_stream_wrappers = file_get_stream_wrappers(STEAM_WRAPPERS_LOCAL);
+ *   $local_stream_wrappers = file_get_stream_wrappers(STREAM_WRAPPERS_LOCAL);
  * @endcode
  *
  * The $filter parameter can only filter to types containing a particular flag.
@@ -99,7 +99,7 @@ define('FILE_STATUS_PERMANENT', 1);
  * array_diff_key() function can be used to help with this. For example, this
  * returns only stream wrappers that do not use local file storage:
  * @code
- *   $remote_stream_wrappers = array_diff_key(file_get_stream_wrappers(STREAM_WRAPPERS_ALL), file_get_stream_wrappers(STEAM_WRAPPERS_LOCAL));
+ *   $remote_stream_wrappers = array_diff_key(file_get_stream_wrappers(STREAM_WRAPPERS_ALL), file_get_stream_wrappers(STREAM_WRAPPERS_LOCAL));
  * @endcode
  *
  * @param $filter
@@ -282,10 +282,6 @@ function file_stream_wrapper_uri_normalize($uri) {
       $uri = $scheme . '://' . $target;
     }
   }
-  else {
-    // The default scheme is file://
-    $url = 'file://' . $uri;
-  }
   return $uri;
 }
 
@@ -834,9 +830,8 @@ function file_valid_uri($uri) {
  *   A string specifying the filepath or URI of the source file.
  * @param $destination
  *   A URI containing the destination that $source should be copied to. The
- *   URI may be a bare filepath (without a scheme) and in that case the default
- *   scheme (file://) will be used. If this value is omitted, Drupal's default
- *   files scheme will be used, usually "public://".
+ *   URI may be a bare filepath (without a scheme). If this value is omitted,
+ *   Drupal's default files scheme will be used, usually "public://".
  * @param $replace
  *   Replace behavior when the destination file already exists:
  *   - FILE_EXISTS_REPLACE - Replace the existing file.
@@ -892,7 +887,7 @@ function file_unmanaged_copy($source, $destination = NULL, $replace = FILE_EXIST
   $destination = file_destination($destination, $replace);
   if ($destination === FALSE) {
     drupal_set_message(t('The file %file could not be copied because a file by that name already exists in the destination directory.', array('%file' => $original_source)), 'error');
-    watchdog('file', 'File %file could not be copied because a file by that name already exists in the destination directory (%directory)', array('%file' => $original_source, '%destination' => $destination));
+    watchdog('file', 'File %file could not be copied because a file by that name already exists in the destination directory (%directory)', array('%file' => $original_source, '%directory' => $destination));
     return FALSE;
   }
 
@@ -2204,29 +2199,21 @@ function drupal_unlink($uri, $context = NULL) {
 }
 
 /**
- * Returns the absolute local filesystem path of a stream URI.
+ * Resolves the absolute filepath of a local URI or filepath.
  *
- * This function was originally written to ease the conversion of 6.x code to
- * use 7.x stream wrappers. However, it assumes that every URI may be resolved
- * to an absolute local filesystem path, and this assumption fails when stream
- * wrappers are used to support remote file storage. Remote stream wrappers
- * may implement the realpath method by always returning FALSE. The use of
- * drupal_realpath() is discouraged, and is slowly being removed from core
- * functions where possible.
+ * The use of drupal_realpath() is discouraged, because it does not work for
+ * remote URIs. Except in rare cases, URIs should not be manually resolved.
  *
  * Only use this function if you know that the stream wrapper in the URI uses
  * the local file system, and you need to pass an absolute path to a function
  * that is incompatible with stream URIs.
  *
- * @param $uri
- *   A stream wrapper URI or a filesystem path, possibly including one or more
- *   symbolic links.
+ * @param string $uri
+ *   A stream wrapper URI or a filepath, possibly including one or more symbolic
+ *   links.
  *
- * @return
- *   The absolute local filesystem path (with no symbolic links), or FALSE on
- *   failure.
- *
- * @todo This function is deprecated, and should be removed wherever possible.
+ * @return string|false
+ *   The absolute local filepath (with no symbolic links), or FALSE on failure.
  *
  * @see DrupalStreamWrapperInterface::realpath()
  * @see http://php.net/manual/function.realpath.php
@@ -2481,20 +2468,10 @@ function file_directory_temp() {
 function file_get_content_headers($file) {
   $name = mime_header_encode($file->filename);
   $type = mime_header_encode($file->filemime);
-  // Serve images, text, and flash content for display rather than download.
-  $inline_types = variable_get('file_inline_types', array('^text/', '^image/', 'flash$'));
-  $disposition = 'attachment';
-  foreach ($inline_types as $inline_type) {
-    // Exclamation marks are used as delimiters to avoid escaping slashes.
-    if (preg_match('!' . $inline_type . '!', $file->filemime)) {
-      $disposition = 'inline';
-    }
-  }
 
   return array(
     'Content-Type' => $type,
     'Content-Length' => $file->filesize,
-    'Content-Disposition' => $disposition . '; filename="' . $name . '"',
     'Cache-Control' => 'private',
   );
 }
diff --git a/includes/filetransfer/filetransfer.inc b/includes/filetransfer/filetransfer.inc
index 023b866..6c55b2f 100644
--- a/includes/filetransfer/filetransfer.inc
+++ b/includes/filetransfer/filetransfer.inc
@@ -406,10 +406,20 @@ class SkipDotsRecursiveDirectoryIterator extends RecursiveDirectoryIterator {
    */
   function __construct($path) {
     parent::__construct($path);
+    $this->skipdots();
+  }
+
+  function rewind() {
+    parent::rewind();
+    $this->skipdots();
   }
 
   function next() {
     parent::next();
+    $this->skipdots();
+  }
+
+  protected function skipdots() {
     while ($this->isDot()) {
       parent::next();
     }
diff --git a/includes/form.inc b/includes/form.inc
index aa90eca..8ca048a 100644
--- a/includes/form.inc
+++ b/includes/form.inc
@@ -727,8 +727,9 @@ function drupal_retrieve_form($form_id, &$form_state) {
   // Record the filepath of the include file containing the original form, so
   // the form builder callbacks can be loaded when the form is being rebuilt
   // from cache on a different path (such as 'system/ajax'). See
-  // form_get_cache().
-  // $menu_get_item() is not available during installation.
+  // form_get_cache(). Don't do this in maintenance mode as Drupal may not be
+  // fully bootstrapped (i.e. during installation) in which case
+  // menu_get_item() is not available.
   if (!isset($form_state['build_info']['files']['menu']) && !defined('MAINTENANCE_MODE')) {
     $item = menu_get_item();
     if (!empty($item['include_file'])) {
@@ -3058,7 +3059,6 @@ function form_process_radios($element) {
  */
 function theme_checkbox($variables) {
   $element = $variables['element'];
-  $t = get_t();
   $element['#attributes']['type'] = 'checkbox';
   element_set_attributes($element, array('id', 'name', '#return_value' => 'value'));
 
@@ -3662,35 +3662,6 @@ function form_pre_render_fieldset($element) {
 /**
  * Creates a group formatted as vertical tabs.
  *
- * Note that autocomplete callbacks should include special handling as the
- * user's input may contain forward slashes. If the user-submitted string has a
- * '/' in the text that is sent in the autocomplete request, the menu system
- * will split the text and pass it to the callback as multiple arguments.
- *
- * Suppose your autocomplete path in the menu system is 'mymodule_autocomplete.'
- * In your form you have:
- * @code
- * '#autocomplete_path' => 'mymodule_autocomplete/' . $some_key . '/' . $some_id,
- * @endcode
- * The user types in "keywords" so the full path called is:
- * 'mymodule_autocomplete/$some_key/$some_id/keywords'
- *
- * You should include code similar to the following to handle slashes in the
- * input:
- * @code
- * function mymodule_autocomplete_callback($arg1, $arg2, $keywords) {
- *   $args = func_get_args();
- *   // We need to remove $arg1 and $arg2 from the beginning of the array so we
- *   // are left with the keywords.
- *   array_shift($args);
- *   array_shift($args);
- *   // We store the user's original input in $keywords, including any slashes.
- *   $keywords = implode('/', $args);
- *
- *   // Your code here.
- * }
- * @endcode
- *
  * @param $element
  *   An associative array containing the properties and children of the
  *   fieldset.
@@ -4039,8 +4010,6 @@ function theme_file($variables) {
  */
 function theme_form_element($variables) {
   $element = &$variables['element'];
-  // This is also used in the installer, pre-database setup.
-  $t = get_t();
 
   // This function is invoked as theme wrapper, but the rendered form element
   // may not necessarily have been processed by form_builder().
@@ -4199,7 +4168,7 @@ function _form_set_class(&$element, $class = array()) {
   if (!empty($element['#required'])) {
     $element['#attributes']['class'][] = 'required';
   }
-  if (isset($element['#parents']) && form_get_error($element) !== NULL) {
+  if (isset($element['#parents']) && form_get_error($element) !== NULL && !empty($element['#validated'])) {
     $element['#attributes']['class'][] = 'error';
   }
 }
diff --git a/includes/image.inc b/includes/image.inc
index ee5a086..e30a338 100644
--- a/includes/image.inc
+++ b/includes/image.inc
@@ -233,11 +233,11 @@ function image_dimensions_scale(array &$dimensions, $width = NULL, $height = NUL
  * @param $image
  *   An image object returned by image_load().
  * @param $width
- *   The target width, in pixels. This value is omitted then the scaling will
- *   based only on the height value.
+ *   The target width, in pixels. If this value is NULL then the scaling will
+ *   be based only on the height value.
  * @param $height
- *   The target height, in pixels. This value is omitted then the scaling will
- *   based only on the width value.
+ *   The target height, in pixels. If this value is NULL then the scaling will
+ *   be based only on the width value.
  * @param $upscale
  *   Boolean indicating that files smaller than the dimensions will be scaled
  *   up. This generally results in a low quality image.
diff --git a/includes/install.core.inc b/includes/install.core.inc
index 9805e1c..7a694e9 100644
--- a/includes/install.core.inc
+++ b/includes/install.core.inc
@@ -1041,7 +1041,21 @@ function install_select_profile(&$install_state) {
 }
 
 /**
- * Selects an installation profile from a list or from a $_POST submission.
+ * Selects an installation profile.
+ *
+ * A profile will be selected if:
+ * - Only one profile is available,
+ * - A profile was submitted through $_POST,
+ * - Exactly one of the profiles is marked as "exclusive".
+ * If multiple profiles are marked as "exclusive" then no profile will be
+ * selected.
+ *
+ * @param array $profiles
+ *   An associative array of profiles with the machine-readable names as keys.
+ *
+ * @return
+ *   The machine-readable name of the selected profile or NULL if no profile was
+ *   selected.
  */
 function _install_select_profile($profiles) {
   if (sizeof($profiles) == 0) {
@@ -1061,6 +1075,23 @@ function _install_select_profile($profiles) {
       }
     }
   }
+  // Check for a profile marked as "exclusive" and ensure that only one
+  // profile is marked as such.
+  $exclusive_profile = NULL;
+  foreach ($profiles as $profile) {
+    $profile_info = install_profile_info($profile->name);
+    if (!empty($profile_info['exclusive'])) {
+      if (empty($exclusive_profile)) {
+        $exclusive_profile = $profile->name;
+      }
+      else {
+        // We found a second "exclusive" profile. There's no way to choose
+        // between them, so we ignore the property.
+        return;
+      }
+    }
+  }
+  return $exclusive_profile;
 }
 
 /**
diff --git a/includes/install.inc b/includes/install.inc
index 0372483..3631c36 100644
--- a/includes/install.inc
+++ b/includes/install.inc
@@ -741,20 +741,27 @@ function drupal_install_system() {
 }
 
 /**
- * Uninstalls a given list of modules.
+ * Uninstalls a given list of disabled modules.
  *
- * @param $module_list
- *   The modules to uninstall.
- * @param $uninstall_dependents
- *   If TRUE, the function will check that all modules which depend on the
- *   passed-in module list either are already uninstalled or contained in the
- *   list, and it will ensure that the modules are uninstalled in the correct
- *   order. This incurs a significant performance cost, so use FALSE if you
- *   know $module_list is already complete and in the correct order.
+ * @param array $module_list
+ *   The modules to uninstall. It is the caller's responsibility to ensure that
+ *   all modules in this list have already been disabled before this function
+ *   is called.
+ * @param bool $uninstall_dependents
+ *   (optional) If TRUE, the function will check that all modules which depend
+ *   on the passed-in module list either are already uninstalled or contained in
+ *   the list, and it will ensure that the modules are uninstalled in the
+ *   correct order. This incurs a significant performance cost, so use FALSE if
+ *   you know $module_list is already complete and in the correct order.
+ *   Defaults to TRUE.
  *
- * @return
- *   FALSE if one or more dependent modules are missing from the list, TRUE
- *   otherwise.
+ * @return bool
+ *   Returns TRUE if the operation succeeds or FALSE if it aborts due to an
+ *   unsafe condition, namely, $uninstall_dependents is TRUE and a module in
+ *   $module_list has dependents which are not already uninstalled and not also
+ *   included in $module_list).
+ *
+ * @see module_disable()
  */
 function drupal_uninstall_modules($module_list = array(), $uninstall_dependents = TRUE) {
   if ($uninstall_dependents) {
@@ -766,7 +773,7 @@ function drupal_uninstall_modules($module_list = array(), $uninstall_dependents
     $profile = drupal_get_profile();
     while (list($module) = each($module_list)) {
       if (!isset($module_data[$module]) || drupal_get_installed_schema_version($module) == SCHEMA_UNINSTALLED) {
-        // This module doesn't exist or is already uninstalled, skip it.
+        // This module doesn't exist or is already uninstalled. Skip it.
         unset($module_list[$module]);
         continue;
       }
@@ -799,7 +806,7 @@ function drupal_uninstall_modules($module_list = array(), $uninstall_dependents
   }
 
   if (!empty($module_list)) {
-    // Call hook_module_uninstall to let other modules act
+    // Let other modules react.
     module_invoke_all('modules_uninstalled', $module_list);
   }
 
@@ -1244,6 +1251,12 @@ function drupal_check_module($module) {
  * - distribution_name: The name of the Drupal distribution that is being
  *   installed, to be shown throughout the installation process. Defaults to
  *   'Drupal'.
+ * - exclusive: If the install profile is intended to be the only eligible
+ *   choice in a distribution, setting exclusive = TRUE will auto-select it
+ *   during installation, and the install profile selection screen will be
+ *   skipped. If more than one profile is found where exclusive = TRUE then
+ *   this property will have no effect and the profile selection screen will
+ *   be shown as normal with all available profiles shown.
  *
  * Note that this function does an expensive file system scan to get info file
  * information for dependencies. If you only need information from the info
diff --git a/includes/language.inc b/includes/language.inc
index d0ea831..ea63948 100644
--- a/includes/language.inc
+++ b/includes/language.inc
@@ -2,7 +2,9 @@
 
 /**
  * @file
- * Multiple language handling functionality.
+ * Language Negotiation API.
+ *
+ * @see http://drupal.org/node/1497272
  */
 
 /**
@@ -11,7 +13,96 @@
 define('LANGUAGE_NEGOTIATION_DEFAULT', 'language-default');
 
 /**
- * Return all the defined language types.
+ * @defgroup language_negotiation Language Negotiation API functionality
+ * @{
+ * Functions to customize the language types and the negotiation process.
+ *
+ * The language negotiation API is based on two major concepts:
+ * - Language types: types of translatable data (the types of data that a user
+ *   can view or request).
+ * - Language negotiation providers: functions for determining which language to
+ *   use to present a particular piece of data to the user.
+ * Both language types and language negotiation providers are customizable.
+ *
+ * Drupal defines three built-in language types:
+ * - Interface language: The page's main language, used to present translated
+ *   user interface elements such as titles, labels, help text, and messages.
+ * - Content language: The language used to present content that is available
+ *   in more than one language (see
+ *   @link field_language Field Language API @endlink for details).
+ * - URL language: The language associated with URLs. When generating a URL,
+ *   this value will be used by url() as a default if no explicit preference is
+ *   provided.
+ * Modules can define additional language types through
+ * hook_language_types_info(), and alter existing language type definitions
+ * through hook_language_types_info_alter().
+ *
+ * Language types may be configurable or fixed. The language negotiation
+ * providers associated with a configurable language type can be explicitly
+ * set through the user interface. A fixed language type has predetermined
+ * (module-defined) language negotiation settings and, thus, does not appear in
+ * the configuration page. Here is a code snippet that makes the content
+ * language (which by default inherits the interface language's values)
+ * configurable:
+ * @code
+ * function mymodule_language_types_info_alter(&$language_types) {
+ *   unset($language_types[LANGUAGE_TYPE_CONTENT]['fixed']);
+ * }
+ * @endcode
+ *
+ * Every language type can have a different set of language negotiation
+ * providers assigned to it. Different language types often share the same
+ * language negotiation settings, but they can have independent settings if
+ * needed. If two language types are configured the same way, their language
+ * switcher configuration will be functionally identical and the same settings
+ * will act on both language types.
+ *
+ * Drupal defines the following built-in language negotiation providers:
+ * - URL: Determine the language from the URL (path prefix or domain).
+ * - Session: Determine the language from a request/session parameter.
+ * - User: Follow the user's language preference.
+ * - Browser: Determine the language from the browser's language settings.
+ * - Default language: Use the default site language.
+ * Language negotiation providers are simple callback functions that implement a
+ * particular logic to return a language code. For instance, the URL provider
+ * searches for a valid path prefix or domain name in the current request URL.
+ * If a language negotiation provider does not return a valid language code, the
+ * next provider associated to the language type (based on provider weight) is
+ * invoked.
+ *
+ * Modules can define additional language negotiation providers through
+ * hook_language_negotiation_info(), and alter existing providers through
+ * hook_language_negotiation_info_alter(). Here is an example snippet that lets
+ * path prefixes be ignored for administrative paths:
+ * @code
+ * function mymodule_language_negotiation_info_alter(&$negotiation_info) {
+ *   // Replace the core function with our own function.
+ *   module_load_include('language', 'inc', 'language.negotiation');
+ *   $negotiation_info[LANGUAGE_NEGOTIATION_URL]['callbacks']['negotiation'] = 'mymodule_from_url';
+ *   $negotiation_info[LANGUAGE_NEGOTIATION_URL]['file'] = drupal_get_path('module', 'mymodule') . '/mymodule.module';
+ * }
+ *
+ * function mymodule_from_url($languages) {
+ *   // Use the core URL language negotiation provider to get a valid language
+ *   // code.
+ *   module_load_include('language', 'inc', 'language.negotiation');
+ *   $langcode = language_from_url($languages);
+ *
+ *   // If we are on an administrative path, override with the default language.
+ *   if (isset($_GET['q']) && strtok($_GET['q'], '/') == 'admin') {
+ *     return language_default()->langcode;
+ *   }
+ *   return $langcode;
+ * }
+ * ?>
+ * @endcode
+ *
+ * For more information, see
+ * @link http://drupal.org/node/1497272 Language Negotiation API @endlink
+ */
+
+/**
+ * Returns all the defined language types.
  *
  * @return
  *   An array of language type names. The name will be used as the global
@@ -30,11 +121,11 @@ function language_types_info() {
 }
 
 /**
- * Return only the configurable language types.
+ * Returns only the configurable language types.
  *
  * A language type maybe configurable or fixed. A fixed language type is a type
- * whose negotiation values are unchangeable and defined while defining the
- * language type itself.
+ * whose language negotiation providers are module-defined and not altered
+ * through the user interface.
  *
  * @param $stored
  *   Optional. By default retrieves values from the 'language_types' variable to
@@ -68,7 +159,7 @@ function language_types_configurable($stored = TRUE) {
 }
 
 /**
- * Disable the given language types.
+ * Disables the given language types.
  *
  * @param $types
  *   An array of language types.
@@ -122,16 +213,17 @@ function language_types_set() {
 }
 
 /**
- * Check if a language provider is enabled.
+ * Checks whether a language negotiation provider is enabled for a language type.
  *
  * This has two possible behaviors:
  *  - If $provider_id is given return its ID if enabled, FALSE otherwise.
- *  - If no ID is passed the first enabled language provider is returned.
+ *  - If no ID is passed the first enabled language negotiation provider is
+ *    returned.
  *
  * @param $type
- *   The language negotiation type.
+ *   The language negotiation provider type.
  * @param $provider_id
- *   The language provider ID.
+ *   The language negotiation provider ID.
  *
  * @return
  *   The provider ID if it is enabled, FALSE otherwise.
@@ -155,14 +247,13 @@ function language_negotiation_get($type, $provider_id = NULL) {
 }
 
 /**
- * Check if the given language provider is enabled for any configurable language
- * type.
+ * Checks if the language negotiation provider is enabled for any language type.
  *
  * @param $provider_id
- *   The language provider ID.
+ *   The language negotiation provider ID.
  *
  * @return
- *   TRUE if there is at least one language type for which the give language
+ *   TRUE if there is at least one language type for which the given language
  *   provider is enabled, FALSE otherwise.
  */
 function language_negotiation_get_any($provider_id) {
@@ -176,7 +267,7 @@ function language_negotiation_get_any($provider_id) {
 }
 
 /**
- * Return the language switch links for the given language.
+ * Returns the language switch links for the given language.
  *
  * @param $type
  *   The language negotiation type.
@@ -223,7 +314,7 @@ function language_negotiation_get_switch_links($type, $path) {
 }
 
 /**
- * Updates language configuration to remove any language provider that is no longer defined.
+ * Removes any unused language negotation providers from the configuration.
  */
 function language_negotiation_purge() {
   // Ensure that we are getting the defined language negotiation information. An
@@ -246,12 +337,12 @@ function language_negotiation_purge() {
 }
 
 /**
- * Save a list of language providers.
+ * Saves a list of language negotiation providers.
  *
  * @param $type
  *   The language negotiation type.
  * @param $language_providers
- *   An array of language provider weights keyed by id.
+ *   An array of language negotiation provider weights keyed by provider ID.
  *   @see language_provider_weight()
  */
 function language_negotiation_set($type, $language_providers) {
@@ -277,7 +368,7 @@ function language_negotiation_set($type, $language_providers) {
       // If the provider does not express any preference about types, make it
       // available for any configurable type.
       $types = array_flip(isset($provider['types']) ? $provider['types'] : $default_types);
-      // Check if the provider is defined and has the right type.
+      // Check whether the provider is defined and has the right type.
       if (isset($types[$type])) {
         $provider_data = array();
         foreach ($provider_fields as $field) {
@@ -294,10 +385,10 @@ function language_negotiation_set($type, $language_providers) {
 }
 
 /**
- * Return all the defined language providers.
+ * Returns all the defined language negotiation providers.
  *
  * @return
- *   An array of language providers.
+ *   An array of language negotiation providers.
  */
 function language_negotiation_info() {
   $language_providers = &drupal_static(__FUNCTION__);
@@ -306,7 +397,7 @@ function language_negotiation_info() {
     // Collect all the module-defined language negotiation providers.
     $language_providers = module_invoke_all('language_negotiation_info');
 
-    // Add the default language provider.
+    // Add the default language negotiation provider.
     $language_providers[LANGUAGE_NEGOTIATION_DEFAULT] = array(
       'callbacks' => array('language' => 'language_from_default'),
       'weight' => 10,
@@ -314,7 +405,7 @@ function language_negotiation_info() {
       'description' => t('Use the default site language (@language_name).', array('@language_name' => language_default()->native)),
     );
 
-    // Let other modules alter the list of language providers.
+    // Let other modules alter the list of language negotiation providers.
     drupal_alter('language_negotiation_info', $language_providers);
   }
 
@@ -322,16 +413,17 @@ function language_negotiation_info() {
 }
 
 /**
- * Helper function used to cache the language providers results.
+ * Helper function used to cache the language negotiation providers results.
  *
  * @param $provider_id
- *   The language provider ID.
+ *   The language negotiation provider's identifier.
  * @param $provider
- *   The language provider to be invoked. If not passed it will be explicitly
- *   loaded through language_negotiation_info().
+ *   (optional) An associative array of information about the provider to be
+ *   invoked (see hook_language_negotiation_info() for details). If not passed
+ *   in, it will be loaded through language_negotiation_info().
  *
  * @return
- *   The language provider's return value.
+ *   A language object representing the language chosen by the provider.
  */
 function language_provider_invoke($provider_id, $provider = NULL) {
   $results = &drupal_static(__FUNCTION__);
@@ -352,25 +444,26 @@ function language_provider_invoke($provider_id, $provider = NULL) {
       require_once DRUPAL_ROOT . '/' . $provider['file'];
     }
 
-    // If the language provider has no cache preference or this is satisfied
-    // we can execute the callback.
+    // If the language negotiation provider has no cache preference or this is
+    // satisfied we can execute the callback.
     $cache = !isset($provider['cache']) || $user->uid || $provider['cache'] == variable_get('cache', 0);
     $callback = isset($provider['callbacks']['language']) ? $provider['callbacks']['language'] : FALSE;
     $langcode = $cache && function_exists($callback) ? $callback($languages) : FALSE;
     $results[$provider_id] = isset($languages[$langcode]) ? $languages[$langcode] : FALSE;
   }
 
-  // Since objects are resources we need to return a clone to prevent the
-  // provider cache to be unintentionally altered. The same providers might be
-  // used with different language types based on configuration.
+  // Since objects are resources, we need to return a clone to prevent the
+  // language negotiation provider cache from being unintentionally altered. The
+  // same providers might be used with different language types based on
+  // configuration.
   return !empty($results[$provider_id]) ? clone($results[$provider_id]) : $results[$provider_id];
 }
 
 /**
- * Return the passed language provider weight or a default value.
+ * Returns the passed language negotiation provider weight or a default value.
  *
  * @param $provider
- *   A language provider data structure.
+ *   A language negotiation provider data structure.
  *
  * @return
  *   A numeric weight.
@@ -381,16 +474,16 @@ function language_provider_weight($provider) {
 }
 
 /**
- * Choose a language for the given type based on language negotiation settings.
+ * Chooses a language based on language negotiation provider settings.
  *
  * @param $type
- *   The language type.
+ *   The language type key to find the language for.
  *
  * @return
  *   The negotiated language object.
  */
 function language_initialize($type) {
-  // Execute the language providers in the order they were set up and return the
+  // Execute the language negotiation providers in the order they were set up and return the
   // first valid language found.
   $negotiation = variable_get("language_negotiation_$type", array());
 
@@ -409,7 +502,7 @@ function language_initialize($type) {
 }
 
 /**
- * Default language provider.
+ * Returns the default language negotiation provider.
  *
  * @return
  *   The default language code.
@@ -421,8 +514,8 @@ function language_from_default() {
 /**
  * Splits the given path into prefix and actual path.
  *
- * Parse the given path and return the language object identified by the
- * prefix and the actual path.
+ * Parse the given path and return the language object identified by the prefix
+ * and the actual path.
  *
  * @param $path
  *   The path to split.
@@ -482,3 +575,7 @@ function language_fallback_get_candidates($type = LANGUAGE_TYPE_CONTENT) {
 
   return $fallback_candidates;
 }
+
+/**
+ * @} End of "language_negotiation"
+ */
diff --git a/includes/mail.inc b/includes/mail.inc
index 8479d8e..bbb5535 100644
--- a/includes/mail.inc
+++ b/includes/mail.inc
@@ -93,7 +93,9 @@ define('MAIL_LINE_ENDINGS', isset($_SERVER['WINDIR']) || strpos($_SERVER['SERVER
  *   will be {$module}_{$key}.
  * @param $to
  *   The e-mail address or addresses where the message will be sent to. The
- *   formatting of this string must comply with RFC 2822. Some examples are:
+ *   formatting of this string will be validated with the
+ *   @link http://php.net/manual/filter.filters.validate.php PHP e-mail validation filter. @endlink
+ *   Some examples are:
  *   - user@example.com
  *   - user@example.com, anotheruser@example.com
  *   - User <user@example.com>
@@ -212,9 +214,9 @@ function drupal_mail($module, $key, $to, $language, $params = array(), $from = N
  * 'mail_system', which is a keyed array.  The default implementation
  * is the class whose name is the value of 'default-system' key. A more specific
  * match first to key and then to module will be used in preference to the
- * default. To specificy a different class for all mail sent by one module, set
+ * default. To specify a different class for all mail sent by one module, set
  * the class name as the value for the key corresponding to the module name. To
- * specificy a class for a particular message sent by one module, set the class
+ * specify a class for a particular message sent by one module, set the class
  * name as the value for the array key that is the message id, which is
  * "${module}_${key}".
  *
@@ -307,19 +309,21 @@ interface MailSystemInterface {
    *   - id: A unique identifier of the e-mail type. Examples: 'contact_user_copy',
    *     'user_password_reset'.
    *   - to: The mail address or addresses where the message will be sent to.
-   *     The formatting of this string must comply with RFC 2822. Some examples:
+   *     The formatting of this string will be validated with the
+   *     @link http://php.net/manual/filter.filters.validate.php PHP e-mail validation filter. @endlink
+   *     Some examples are:
    *     - user@example.com
    *     - user@example.com, anotheruser@example.com
    *     - User <user@example.com>
    *     - User <user@example.com>, Another User <anotheruser@example.com>
-   *    - subject: Subject of the e-mail to be sent. This must not contain any
-   *      newline characters, or the mail may not be sent properly.
-   *    - body: Message to be sent. Accepts both CRLF and LF line-endings.
-   *      E-mail bodies must be wrapped. You can use drupal_wrap_mail() for
-   *      smart plain text wrapping.
-   *    - headers: Associative array containing all additional mail headers not
-   *      defined by one of the other parameters.  PHP's mail() looks for Cc
-   *      and Bcc headers and sends the mail to addresses in these headers too.
+   *   - subject: Subject of the e-mail to be sent. This must not contain any
+   *     newline characters, or the mail may not be sent properly.
+   *   - body: Message to be sent. Accepts both CRLF and LF line-endings.
+   *     E-mail bodies must be wrapped. You can use drupal_wrap_mail() for
+   *     smart plain text wrapping.
+   *   - headers: Associative array containing all additional mail headers not
+   *     defined by one of the other parameters.  PHP's mail() looks for Cc and
+   *     Bcc headers and sends the mail to addresses in these headers too.
    *
    * @return
    *   TRUE if the mail was successfully accepted for delivery, otherwise FALSE.
diff --git a/includes/menu.inc b/includes/menu.inc
index 0cb9d23..a93ddad 100644
--- a/includes/menu.inc
+++ b/includes/menu.inc
@@ -309,7 +309,7 @@ define('MENU_PREFERRED_LINK', '1cf698d64d1aa4b83907cf6ed55db3a7f8e92c91');
  * actually exists. This list of 'masks' is built in menu_rebuild().
  *
  * @param $parts
- *   An array of path parts, for the above example
+ *   An array of path parts; for the above example, 
  *   array('node', '12345', 'edit').
  *
  * @return
@@ -430,7 +430,7 @@ function menu_set_item($path, $router_item) {
  * Gets a router item.
  *
  * @param $path
- *   The path, for example node/5. The function will find the corresponding
+ *   The path; for example, 'node/5'. The function will find the corresponding
  *   node/% item and return that.
  * @param $router_item
  *   Internal use only.
@@ -542,7 +542,7 @@ function menu_execute_active_handler($path = NULL, $deliver = TRUE) {
  * @param $item
  *   A menu router or menu link item
  * @param $map
- *   An array of path arguments (ex: array('node', '5'))
+ *   An array of path arguments; for example, array('node', '5').
  *
  * @return
  *   Returns TRUE for success, FALSE if an object cannot be loaded.
@@ -612,12 +612,13 @@ function _menu_load_objects(&$item, &$map) {
  * @param $item
  *   A menu router or menu link item
  * @param $map
- *   An array of path arguments (ex: array('node', '5'))
+ *   An array of path arguments; for example, array('node', '5').
  *
  * @return
  *   $item['access'] becomes TRUE if the item is accessible, FALSE otherwise.
  */
 function _menu_check_access(&$item, $map) {
+  $item['access'] = FALSE;
   // Determine access callback, which will decide whether or not the current
   // user has access to this path.
   $callback = empty($item['access_callback']) ? 0 : trim($item['access_callback']);
@@ -737,7 +738,7 @@ function _menu_item_localize(&$item, $map, $link_translate = FALSE) {
  * @param $router_item
  *   A menu router item
  * @param $map
- *   An array of path arguments (ex: array('node', '5'))
+ *   An array of path arguments; for example, array('node', '5').
  * @param $to_arg
  *   Execute $item['to_arg_functions'] or not. Use only if you want to render a
  *   path from the menu table, for example tabs.
@@ -800,9 +801,9 @@ function _menu_translate(&$router_item, $map, $to_arg = FALSE) {
  * Translates the path elements in the map using any to_arg helper function.
  *
  * @param $map
- *   An array of path arguments (ex: array('node', '5'))
+ *   An array of path arguments; for example, array('node', '5').
  * @param $to_arg_functions
- *   An array of helper function (ex: array(2 => 'menu_tail_to_arg'))
+ *   An array of helper functions; for example, array(2 => 'menu_tail_to_arg').
  *
  * @see hook_menu()
  */
@@ -2138,7 +2139,7 @@ function menu_local_tasks($level = 0) {
  *   example 'node' or 'admin/structure/block/manage'.
  * @param $args
  *   A list of dynamic path arguments to append to $parent_path to form the
- *   fully-qualified menu router path, for example array(123) for a certain
+ *   fully-qualified menu router path; for example, array(123) for a certain
  *   node or array('system', 'navigation') for a certain block.
  *
  * @return
@@ -2429,7 +2430,7 @@ function menu_set_active_trail($new_trail = NULL) {
  * Looks up the preferred menu link for a given system path.
  *
  * @param $path
- *   The path, for example 'node/5'. The function will find the corresponding
+ *   The path; for example, 'node/5'. The function will find the corresponding
  *   menu link ('node/5' if it exists, or fallback to 'node/%').
  * @param $selected_menu
  *   The name of a menu used to restrict the search for a preferred menu link.
diff --git a/includes/module.inc b/includes/module.inc
index d932f07..fe2a980 100644
--- a/includes/module.inc
+++ b/includes/module.inc
@@ -610,9 +610,40 @@ function module_disable($module_list, $disable_dependents = TRUE) {
  * just models that you can modify. Only the hooks implemented within modules
  * are executed when running Drupal.
  *
- * See also @link themeable the themeable group page. @endlink
+ * @see themeable
+ * @see callbacks
  */
 
+ /**
+  * @defgroup callbacks Callbacks
+  * @{
+  * Callback function signatures.
+  *
+  * Drupal's API sometimes uses callback functions to allow you to define how
+  * some type of processing happens. A callback is a function with a defined
+  * signature, which you define in a module. Then you pass the function name as
+  * a parameter to a Drupal API function or return it as part of a hook
+  * implementation return value, and your function is called at an appropriate
+  * time. For instance, when setting up batch processing you might need to
+  * provide a callback function for each processing step and/or a callback for
+  * when processing is finished; you would do that by defining these functions
+  * and passing their names into the batch setup function.
+  *
+  * Callback function signatures, like hook definitions, are described by
+  * creating and documenting dummy functions in a *.api.php file; normally, the
+  * dummy callback function's name should start with "callback_", and you should
+  * document the parameters and return value and provide a sample function body.
+  * Then your API documentation can refer to this callback function in its
+  * documentation. A user of your API can usually name their callback function
+  * anything they want, although a standard name would be to replace "callback_"
+  * with the module name.
+  *
+  * @see hooks
+  * @see themeable
+  *
+  * @}
+  */
+
 /**
  * Determines whether a module implements a hook.
  *
@@ -803,10 +834,7 @@ function module_hook_info() {
  */
 function module_implements_write_cache() {
   $implementations = &drupal_static('module_implements');
-  // Check whether we need to write the cache. We do not want to cache hooks
-  // which are only invoked on HTTP POST requests since these do not need to be
-  // optimized as tightly, and not doing so keeps the cache entry smaller.
-  if (isset($implementations['#write_cache']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD')) {
+  if (isset($implementations['#write_cache'])) {
     unset($implementations['#write_cache']);
     cache_set('module_implements', $implementations, 'cache_bootstrap');
   }
@@ -815,6 +843,9 @@ function module_implements_write_cache() {
 /**
  * Invokes a hook in a particular module.
  *
+ * All arguments are passed by value. Use drupal_alter() if you need to pass
+ * arguments by reference.
+ *
  * @param $module
  *   The name of the module (without the .module extension).
  * @param $hook
@@ -824,6 +855,8 @@ function module_implements_write_cache() {
  *
  * @return
  *   The return value of the hook implementation.
+ *
+ * @see drupal_alter()
  */
 function module_invoke($module, $hook) {
   $args = func_get_args();
@@ -837,6 +870,9 @@ function module_invoke($module, $hook) {
 /**
  * Invokes a hook in all enabled modules that implement it.
  *
+ * All arguments are passed by value. Use drupal_alter() if you need to pass
+ * arguments by reference.
+ *
  * @param $hook
  *   The name of the hook to invoke.
  * @param ...
@@ -845,6 +881,8 @@ function module_invoke($module, $hook) {
  * @return
  *   An array of return values of the hook implementations. If modules return
  *   arrays from their implementations, those are merged into one array.
+ *
+ * @see drupal_alter()
  */
 function module_invoke_all($hook) {
   $args = func_get_args();
@@ -898,9 +936,10 @@ function drupal_required_modules() {
  * hook_TYPE_alter() implementations in modules. It ensures a consistent
  * interface for all altering operations.
  *
- * A maximum of 2 alterable arguments is supported. In case more arguments need
- * to be passed and alterable, modules provide additional variables assigned by
- * reference in the last $context argument:
+ * A maximum of 2 alterable arguments is supported (a third is supported for
+ * legacy reasons, but should not be used in new code). In case more arguments
+ * need to be passed and alterable, modules provide additional variables
+ * assigned by reference in the last $context argument:
  * @code
  *   $context = array(
  *     'alterable' => &$alterable,
@@ -939,8 +978,14 @@ function drupal_required_modules() {
  *   (optional) An additional variable that is passed by reference. If more
  *   context needs to be provided to implementations, then this should be an
  *   associative array as described above.
+ * @param $context3
+ *   (optional) An additional variable that is passed by reference. This
+ *   parameter is deprecated and will not exist in Drupal 8; consequently, it
+ *   should not be used for new Drupal 7 code either. It is here only for
+ *   backwards compatibility with older code that passed additional arguments
+ *   to drupal_alter().
  */
-function drupal_alter($type, &$data, &$context1 = NULL, &$context2 = NULL) {
+function drupal_alter($type, &$data, &$context1 = NULL, &$context2 = NULL, &$context3 = NULL) {
   // Use the advanced drupal_static() pattern, since this is called very often.
   static $drupal_static_fast;
   if (!isset($drupal_static_fast)) {
@@ -1053,6 +1098,6 @@ function drupal_alter($type, &$data, &$context1 = NULL, &$context2 = NULL) {
   }
 
   foreach ($functions[$cid] as $function) {
-    $function($data, $context1, $context2);
+    $function($data, $context1, $context2, $context3);
   }
 }
diff --git a/includes/password.inc b/includes/password.inc
index d4f5f73..3d5a400 100644
--- a/includes/password.inc
+++ b/includes/password.inc
@@ -43,7 +43,7 @@ function _password_itoa64() {
 }
 
 /**
- * Encode bytes into printable base 64 using the *nix standard from crypt().
+ * Encodes bytes into printable base 64 using the *nix standard from crypt().
  *
  * @param $input
  *   The string containing bytes to encode.
diff --git a/includes/path.inc b/includes/path.inc
index 411a7a7..234430e 100644
--- a/includes/path.inc
+++ b/includes/path.inc
@@ -386,7 +386,7 @@ function drupal_path_alias_whitelist_rebuild($source = NULL) {
 }
 
 /**
- * Fetch a specific URL alias from the database.
+ * Fetches a specific URL alias from the database.
  *
  * @param $conditions
  *   A string representing the source, a number representing the pid, or an
@@ -475,11 +475,11 @@ function path_delete($criteria) {
 }
 
 /**
- * Determine whether a path is in the administrative section of the site.
+ * Determines whether a path is in the administrative section of the site.
  *
- * By default, paths are considered to be non-administrative. If a path does not
- * match any of the patterns in path_get_admin_paths(), or if it matches both
- * administrative and non-administrative patterns, it is considered
+ * By default, paths are considered to be non-administrative. If a path does
+ * not match any of the patterns in path_get_admin_paths(), or if it matches
+ * both administrative and non-administrative patterns, it is considered
  * non-administrative.
  *
  * @param $path
@@ -503,7 +503,7 @@ function path_is_admin($path) {
 }
 
 /**
- * Get a list of administrative and non-administrative paths.
+ * Gets a list of administrative and non-administrative paths.
  *
  * @return array
  *   An associative array containing the following keys:
diff --git a/includes/session.inc b/includes/session.inc
index b04c18e..16727df 100644
--- a/includes/session.inc
+++ b/includes/session.inc
@@ -274,7 +274,7 @@ function drupal_session_initialize() {
 }
 
 /**
- * Forcefully starts a session, preserving already set session data.
+ * Starts a session forcefully, preserving already set session data.
  *
  * @ingroup php_wrappers
  */
diff --git a/includes/tablesort.inc b/includes/tablesort.inc
index 121a1b9..e589526 100644
--- a/includes/tablesort.inc
+++ b/includes/tablesort.inc
@@ -55,7 +55,7 @@ class TableSort extends SelectQueryExtender {
   }
 
   /**
-   * Initialize the table sort context.
+   * Initializes the table sort context.
    */
   protected function init() {
     $ts = $this->order();
@@ -115,7 +115,7 @@ function tablesort_init($header) {
 }
 
 /**
- * Format a column header.
+ * Formats a column header.
  *
  * If the cell in question is the column header for the current sort criterion,
  * it gets special formatting. All possible sort criteria become links.
@@ -126,6 +126,7 @@ function tablesort_init($header) {
  *   An array of column headers in the format described in theme_table().
  * @param $ts
  *   The current table sort context as returned from tablesort_init().
+ *
  * @return
  *   A properly formatted cell, ready for _theme_table_cell().
  */
@@ -151,7 +152,7 @@ function tablesort_header($cell, $header, $ts) {
 }
 
 /**
- * Format a table cell.
+ * Formats a table cell.
  *
  * Adds a class attribute to all cells in the currently active column.
  *
@@ -163,6 +164,7 @@ function tablesort_header($cell, $header, $ts) {
  *   The current table sort context as returned from tablesort_init().
  * @param $i
  *   The index of the cell's table column.
+ *
  * @return
  *   A properly formatted cell, ready for _theme_table_cell().
  */
@@ -179,7 +181,7 @@ function tablesort_cell($cell, $header, $ts, $i) {
 }
 
 /**
- * Compose a URL query parameter array for table sorting links.
+ * Composes a URL query parameter array for table sorting links.
  *
  * @return
  *   A URL query parameter array that consists of all components of the current
@@ -190,10 +192,11 @@ function tablesort_get_query_parameters() {
 }
 
 /**
- * Determine the current sort criterion.
+ * Determines the current sort criterion.
  *
  * @param $headers
  *   An array of column headers in the format described in theme_table().
+ *
  * @return
  *   An associative array describing the criterion, containing the keys:
  *   - "name": The localized title of the table column.
@@ -226,10 +229,11 @@ function tablesort_get_order($headers) {
 }
 
 /**
- * Determine the current sort direction.
+ * Determines the current sort direction.
  *
  * @param $headers
  *   An array of column headers in the format described in theme_table().
+ *
  * @return
  *   The current sort direction ("asc" or "desc").
  */
diff --git a/includes/theme.inc b/includes/theme.inc
index 777922f..ee73965 100644
--- a/includes/theme.inc
+++ b/includes/theme.inc
@@ -65,7 +65,7 @@ function _drupal_theme_access($theme) {
 }
 
 /**
- * Initialize the theme system by loading the theme.
+ * Initializes the theme system by loading the theme.
  */
 function drupal_theme_initialize() {
   global $theme, $user, $theme_key;
@@ -113,8 +113,9 @@ function drupal_theme_initialize() {
 }
 
 /**
- * Initialize the theme system given already loaded information. This
- * function is useful to initialize a theme when no database is present.
+ * Initializes the theme system given already loaded information.
+ *
+ * This function is useful to initialize a theme when no database is present.
  *
  * @param $theme
  *   An object with the following information:
@@ -235,7 +236,7 @@ function _drupal_theme_initialize($theme, $base_theme = array(), $registry_callb
 }
 
 /**
- * Get the theme registry.
+ * Gets the theme registry.
  *
  * @param $complete
  *   Optional boolean to indicate whether to return the complete theme registry
@@ -280,7 +281,7 @@ function theme_get_registry($complete = TRUE) {
 }
 
 /**
- * Set the callback that will be used by theme_get_registry() to fetch the registry.
+ * Sets the callback that will be used by theme_get_registry().
  *
  * @param $callback
  *   The name of the callback function.
@@ -296,7 +297,7 @@ function _theme_registry_callback($callback = NULL, array $arguments = array())
 }
 
 /**
- * Get the theme_registry cache; if it doesn't exist, build it.
+ * Gets the theme_registry cache; if it doesn't exist, builds it.
  *
  * @param $theme
  *   The loaded $theme object as returned by list_themes().
@@ -336,16 +337,17 @@ function _theme_load_registry($theme, $base_theme = NULL, $theme_engine = NULL,
 }
 
 /**
- * Write the theme_registry cache into the database.
+ * Writes the theme_registry cache into the database.
  */
 function _theme_save_registry($theme, $registry) {
   cache_set("theme_registry:$theme->name", $registry);
 }
 
 /**
- * Force the system to rebuild the theme registry; this should be called
- * when modules are added to the system, or when a dynamic system needs
- * to add more theme hooks.
+ * Forces the system to rebuild the theme registry.
+ *
+ * This function should be called when modules are added to the system, or when
+ * a dynamic system needs to add more theme hooks.
  */
 function drupal_theme_rebuild() {
   drupal_static_reset('theme_get_registry');
@@ -506,7 +508,7 @@ class ThemeRegistry Extends DrupalCacheArray {
  *   themes/bartik.
  *
  * @see theme()
- * @see _theme_process_registry()
+ * @see _theme_build_registry()
  * @see hook_theme()
  * @see list_themes()
  */
@@ -635,7 +637,8 @@ function _theme_process_registry(&$cache, $name, $type, $theme, $path) {
     $cache = $result + $cache;
   }
 
-  // Let themes have variable processors even if they didn't register a template.
+  // Let themes have variable processors even if they didn't register a
+  // template.
   if ($type == 'theme' || $type == 'base_theme') {
     foreach ($cache as $hook => $info) {
       // Check only if not registered by the theme or engine.
@@ -662,7 +665,7 @@ function _theme_process_registry(&$cache, $name, $type, $theme, $path) {
 }
 
 /**
- * Build the theme registry cache.
+ * Builds the theme registry cache.
  *
  * @param $theme
  *   The loaded $theme object as returned by list_themes().
@@ -724,7 +727,7 @@ function _theme_build_registry($theme, $base_theme, $theme_engine) {
 }
 
 /**
- * Return a list of all currently available themes.
+ * Returns a list of all currently available themes.
  *
  * Retrieved from the database, if available and the site is not in maintenance
  * mode; otherwise compiled freshly from the filesystem.
@@ -766,7 +769,7 @@ function _theme_build_registry($theme, $base_theme, $theme_engine) {
  *     their base theme), direct sub-themes of sub-themes, etc. The keys are
  *     the themes' machine names, and the values are the themes' human-readable
  *     names. This element is not set if there are no themes on the system that
- *     declare this theme as their base theme. 
+ *     declare this theme as their base theme.
 */
 function list_themes($refresh = FALSE) {
   $list = &drupal_static(__FUNCTION__, array());
@@ -866,11 +869,18 @@ function drupal_find_base_themes($themes, $key, $used_keys = array()) {
 /**
  * Generates themed output.
  *
- * All requests for themed output must go through this function. It examines
- * the request and routes it to the appropriate
+ * All requests for themed output must go through this function (however,
+ * calling the theme() function directly is strongly discouraged - see next
+ * paragraph). It examines the request and routes it to the appropriate
  * @link themeable theme function or template @endlink, by checking the theme
  * registry.
  *
+ * Avoid calling this function directly. It is preferable to replace direct
+ * calls to the theme() function with calls to drupal_render() by passing a
+ * render array with a #theme key to drupal_render(), which in turn calls
+ * theme().
+ *
+ * @section sec_theme_hooks Theme Hooks
  * Most commonly, the first argument to this function is the name of the theme
  * hook. For instance, to theme a taxonomy term, the theme hook name is
  * 'taxonomy_term'. Modules register theme hooks within a hook_theme()
@@ -882,6 +892,7 @@ function drupal_find_base_themes($themes, $key, $used_keys = array()) {
  * underscores changed to hyphens, so for the 'taxonomy_term' theme hook, the
  * default template is 'taxonomy-term.tpl.php'.
  *
+ * @subsection sub_overriding_theme_hooks Overriding Theme Hooks
  * Themes may also register new theme hooks within a hook_theme()
  * implementation, but it is more common for themes to override default
  * implementations provided by modules than to register entirely new theme
@@ -894,21 +905,22 @@ function drupal_find_base_themes($themes, $key, $used_keys = array()) {
  * rendering engine, it overrides the default implementation of the 'page' theme
  * hook by containing a 'page.tpl.php' file within its folder structure).
  *
+ * @subsection sub_preprocess_templates Preprocessing for Template Files
  * If the implementation is a template file, several functions are called
  * before the template file is invoked, to modify the $variables array. These
  * fall into the "preprocessing" phase and the "processing" phase, and are
  * executed (if they exist), in the following order (note that in the following
  * list, HOOK indicates the theme hook name, MODULE indicates a module name,
  * THEME indicates a theme name, and ENGINE indicates a theme engine name):
- * - template_preprocess(&$variables, $hook): Creates a default set of variables
- *   for all theme hooks with template implementations.
+ * - template_preprocess(&$variables, $hook): Creates a default set of
+ *   variables for all theme hooks with template implementations.
  * - template_preprocess_HOOK(&$variables): Should be implemented by the module
  *   that registers the theme hook, to set up default variables.
  * - MODULE_preprocess(&$variables, $hook): hook_preprocess() is invoked on all
  *   implementing modules.
  * - MODULE_preprocess_HOOK(&$variables): hook_preprocess_HOOK() is invoked on
- *   all implementing modules, so that modules that didn't define the theme hook
- *   can alter the variables.
+ *   all implementing modules, so that modules that didn't define the theme
+ *   hook can alter the variables.
  * - ENGINE_engine_preprocess(&$variables, $hook): Allows the theme engine to
  *   set necessary variables for all theme hooks with template implementations.
  * - ENGINE_engine_preprocess_HOOK(&$variables): Allows the theme engine to set
@@ -942,12 +954,14 @@ function drupal_find_base_themes($themes, $key, $used_keys = array()) {
  * - THEME_process_HOOK(&$variables):  Allows the theme to process the
  *   variables specific to the theme hook.
  *
+ * @subsection sub_preprocess_theme_funcs Preprocessing for Theme Functions
  * If the implementation is a function, only the theme-hook-specific preprocess
  * and process functions (the ones ending in _HOOK) are called from the
  * list above. This is because theme hooks with function implementations
  * need to be fast, and calling the non-theme-hook-specific preprocess and
  * process functions for them would incur a noticeable performance penalty.
  *
+ * @subsection sub_alternate_suggestions Suggesting Alternate Hooks
  * There are two special variables that these preprocess and process functions
  * can set: 'theme_hook_suggestion' and 'theme_hook_suggestions'. These will be
  * merged together to form a list of 'suggested' alternate theme hooks to use,
@@ -963,10 +977,10 @@ function drupal_find_base_themes($themes, $key, $used_keys = array()) {
  * @param $hook
  *   The name of the theme hook to call. If the name contains a
  *   double-underscore ('__') and there isn't an implementation for the full
- *   name, the part before the '__' is checked. This allows a fallback to a more
- *   generic implementation. For example, if theme('links__node', ...) is
- *   called, but there is no implementation of that theme hook, then the 'links'
- *   implementation is used. This process is iterative, so if
+ *   name, the part before the '__' is checked. This allows a fallback to a
+ *   more generic implementation. For example, if theme('links__node', ...) is
+ *   called, but there is no implementation of that theme hook, then the
+ *   'links' implementation is used. This process is iterative, so if
  *   theme('links__contextual__node', ...) is called, theme() checks for the
  *   following implementations, and uses the first one that exists:
  *   - links__contextual__node
@@ -989,6 +1003,7 @@ function drupal_find_base_themes($themes, $key, $used_keys = array()) {
  * @return
  *   An HTML string representing the themed output.
  *
+ * @see drupal_render()
  * @see themeable
  * @see hook_theme()
  * @see template_preprocess()
@@ -1030,7 +1045,7 @@ function theme($hook, $variables = array()) {
       // Only log a message when not trying theme suggestions ($hook being an
       // array).
       if (!isset($candidate)) {
-        watchdog('theme', 'Theme key "@key" not found.', array('@key' => $hook), WATCHDOG_WARNING);
+        watchdog('theme', 'Theme hook %hook not found.', array('%hook' => $hook), WATCHDOG_WARNING);
       }
       return '';
     }
@@ -1042,7 +1057,8 @@ function theme($hook, $variables = array()) {
   // point path_to_theme() to the currently used theme path:
   $theme_path = $info['theme path'];
 
-  // Include a file if the theme function or variable processor is held elsewhere.
+  // Include a file if the theme function or variable processor is held
+  // elsewhere.
   if (!empty($info['includes'])) {
     foreach ($info['includes'] as $include_file) {
       include_once DRUPAL_ROOT . '/' . $include_file;
@@ -1191,14 +1207,14 @@ function theme($hook, $variables = array()) {
 }
 
 /**
- * Return the path to the current themed element.
- *
- * It can point to the active theme or the module handling a themed implementation.
- * For example, when invoked within the scope of a theming call it will depend
- * on where the theming function is handled. If implemented from a module, it
- * will point to the module. If implemented from the active theme, it will point
- * to the active theme. When called outside the scope of a theming call, it will
- * always point to the active theme.
+ * Returns the path to the current themed element.
+ *
+ * It can point to the active theme or the module handling a themed
+ * implementation. For example, when invoked within the scope of a theming call
+ * it will depend on where the theming function is handled. If implemented from
+ * a module, it will point to the module. If implemented from the active theme,
+ * it will point to the active theme. When called outside the scope of a
+ * theming call, it will always point to the active theme.
  */
 function path_to_theme() {
   global $theme_path;
@@ -1211,7 +1227,7 @@ function path_to_theme() {
 }
 
 /**
- * Allow themes and/or theme engines to easily discover overridden theme functions.
+ * Allows themes and/or theme engines to discover overridden theme functions.
  *
  * @param $cache
  *   The existing cache of theme hooks to test against.
@@ -1268,7 +1284,7 @@ function drupal_find_theme_functions($cache, $prefixes) {
 }
 
 /**
- * Allow themes and/or theme engines to easily discover overridden templates.
+ * Allows themes and/or theme engines to easily discover overridden templates.
  *
  * @param $cache
  *   The existing cache of theme hooks to test against.
@@ -1345,7 +1361,8 @@ function drupal_find_theme_templates($cache, $extension, $path) {
       if ($matches) {
         foreach ($matches as $match) {
           $file = substr($match, 0, strpos($match, '.'));
-          // Put the underscores back in for the hook name and register this pattern.
+          // Put the underscores back in for the hook name and register this
+          // pattern.
           $arg_name = isset($info['variables']) ? 'variables' : 'render element';
           $implementations[strtr($file, '-', '_')] = array(
             'template' => $file,
@@ -1361,7 +1378,7 @@ function drupal_find_theme_templates($cache, $extension, $path) {
 }
 
 /**
- * Retrieve a setting for the current theme or for a given theme.
+ * Retrieves a setting for the current theme or for a given theme.
  *
  * The final setting is obtained from the last value found in the following
  * sources:
@@ -1479,7 +1496,7 @@ function theme_get_setting($setting_name, $theme = NULL) {
 }
 
 /**
- * Render a system default template, which is essentially a PHP template.
+ * Renders a system default template, which is essentially a PHP template.
  *
  * @param $template_file
  *   The filename of the template to render.
@@ -1490,14 +1507,21 @@ function theme_get_setting($setting_name, $theme = NULL) {
  *   The output generated by the template.
  */
 function theme_render_template($template_file, $variables) {
-  extract($variables, EXTR_SKIP);               // Extract the variables to a local namespace
-  ob_start();                                   // Start output buffering
-  include DRUPAL_ROOT . '/' . $template_file;   // Include the template file
-  return ob_get_clean();                        // End buffering and return its contents
+  // Extract the variables to a local namespace
+  extract($variables, EXTR_SKIP);
+
+  // Start output buffering
+  ob_start();
+
+  // Include the template file
+  include DRUPAL_ROOT . '/' . $template_file;
+
+  // End buffering and return its contents
+  return ob_get_clean();
 }
 
 /**
- * Enable a given list of themes.
+ * Enables a given list of themes.
  *
  * @param $theme_list
  *   An array of theme names.
@@ -1522,7 +1546,7 @@ function theme_enable($theme_list) {
 }
 
 /**
- * Disable a given list of themes.
+ * Disables a given list of themes.
  *
  * @param $theme_list
  *   An array of theme names.
@@ -1608,13 +1632,13 @@ function theme_status_messages($variables) {
  * theme('link') for rendering the anchor tag.
  *
  * To optimize performance for sites that don't need custom theming of links,
- * the l() function includes an inline copy of this function, and uses that copy
- * if none of the enabled modules or the active theme implement any preprocess
- * or process functions or override this theme implementation.
+ * the l() function includes an inline copy of this function, and uses that
+ * copy if none of the enabled modules or the active theme implement any
+ * preprocess or process functions or override this theme implementation.
  *
  * @param $variables
- *   An associative array containing the keys 'text', 'path', and 'options'. See
- *   the l() function for information about these variables.
+ *   An associative array containing the keys 'text', 'path', and 'options'.
+ *   See the l() function for information about these variables.
  *
  * @see l()
  */
@@ -1635,15 +1659,16 @@ function theme_link($variables) {
  *       item in the links list.
  *     - html: (optional) Whether or not 'title' is HTML. If set, the title
  *       will not be passed through check_plain().
- *     - attributes: (optional) Attributes for the anchor, or for the <span> tag
- *       used in its place if no 'href' is supplied. If element 'class' is
+ *     - attributes: (optional) Attributes for the anchor, or for the <span>
+ *       tag used in its place if no 'href' is supplied. If element 'class' is
  *       included, it must be an array of one or more class names.
- *     If the 'href' element is supplied, the entire link array is passed to l()
- *     as its $options parameter.
+ *     If the 'href' element is supplied, the entire link array is passed to
+ *     l() as its $options parameter.
  *   - attributes: A keyed array of attributes for the UL containing the
  *     list of links.
- *   - heading: (optional) A heading to precede the links. May be an associative
- *     array or a string. If it's an array, it can have the following elements:
+ *   - heading: (optional) A heading to precede the links. May be an
+ *     associative array or a string. If it's an array, it can have the
+ *     following elements:
  *     - text: The heading text.
  *     - level: The heading level (e.g. 'h2', 'h3').
  *     - class: (optional) An array of the CSS classes for the heading.
@@ -1747,8 +1772,8 @@ function theme_links($variables) {
  *     attribute to be omitted in some cases. Therefore, this variable defaults
  *     to an empty string, but can be set to NULL for the attribute to be
  *     omitted. Usually, neither omission nor an empty string satisfies
- *     accessibility requirements, so it is strongly encouraged for code calling
- *     theme('image') to pass a meaningful value for this variable.
+ *     accessibility requirements, so it is strongly encouraged for code
+ *     calling theme('image') to pass a meaningful value for this variable.
  *     - http://www.w3.org/TR/REC-html40/struct/objects.html#h-13.8
  *     - http://www.w3.org/TR/xhtml1/dtds.html
  *     - http://dev.w3.org/html5/spec/Overview.html#alt
@@ -1801,7 +1826,9 @@ function theme_breadcrumb($variables) {
  *     - "data": The localized title of the table column.
  *     - "field": The database field represented in the table column (required
  *       if user is to be able to sort on this column).
- *     - "sort": A default sort order for this column ("asc" or "desc").
+ *     - "sort": A default sort order for this column ("asc" or "desc"). Only
+ *       one column should be given a default sort order because table sorting
+ *       only applies to one column at a time.
  *     - Any HTML attributes, such as "colspan", to apply to the column header
  *       cell.
  *   - rows: An array of table rows. Every row is an array of cells, or an
@@ -1960,25 +1987,24 @@ function theme_table($variables) {
     $flip = array('even' => 'odd', 'odd' => 'even');
     $class = 'even';
     foreach ($rows as $number => $row) {
-      $attributes = array();
-
       // Check if we're dealing with a simple or complex row
       if (isset($row['data'])) {
-        foreach ($row as $key => $value) {
-          if ($key == 'data') {
-            $cells = $value;
-          }
-          else {
-            $attributes[$key] = $value;
-          }
-        }
+        $cells = $row['data'];
+        $no_striping = isset($row['no_striping']) ? $row['no_striping'] : FALSE;
+
+        // Set the attributes array and exclude 'data' and 'no_striping'.
+        $attributes = $row;
+        unset($attributes['data']);
+        unset($attributes['no_striping']);
       }
       else {
         $cells = $row;
+        $attributes = array();
+        $no_striping = FALSE;
       }
       if (count($cells)) {
         // Add odd/even class
-        if (empty($row['no_striping'])) {
+        if (!$no_striping) {
           $class = $flip[$class];
           $attributes['class'][] = $class;
         }
@@ -2005,7 +2031,8 @@ function theme_table($variables) {
  *
  * @param $variables
  *   An associative array containing:
- *   - style: Set to either 'asc' or 'desc', this determines which icon to show.
+ *   - style: Set to either 'asc' or 'desc', this determines which icon to
+ *     show.
  */
 function theme_tablesort_indicator($variables) {
   if ($variables['style'] == "asc") {
@@ -2148,7 +2175,8 @@ function theme_feed_icon($variables) {
  *       - script: To load JavaScript.
  *     - #attributes: (optional) An array of HTML attributes to apply to the
  *       tag.
- *     - #value: (optional) A string containing tag content, such as inline CSS.
+ *     - #value: (optional) A string containing tag content, such as inline
+ *       CSS.
  *     - #value_prefix: (optional) A string to prepend to #value, e.g. a CDATA
  *       wrapper prefix.
  *     - #value_suffix: (optional) A string to append to #value, e.g. a CDATA
@@ -2316,8 +2344,9 @@ function template_preprocess(&$variables, $hook) {
   global $user;
   static $count = array();
 
-  // Track run count for each hook to provide zebra striping.
-  // See "template_preprocess_block()" which provides the same feature specific to blocks.
+  // Track run count for each hook to provide zebra striping. See
+  // "template_preprocess_block()" which provides the same feature specific to
+  // blocks.
   $count[$hook] = isset($count[$hook]) && is_int($count[$hook]) ? $count[$hook] : 1;
   $variables['zebra'] = ($count[$hook] % 2) ? 'odd' : 'even';
   $variables['id'] = $count[$hook]++;
@@ -2677,13 +2706,13 @@ function theme_get_suggestions($args, $base, $delimiter = '__') {
 }
 
 /**
- * The variables array generated here is a mirror of template_preprocess_page().
- * This preprocessor will run its course when theme_maintenance_page() is
- * invoked.
+ * Process variables for maintenance-page.tpl.php.
  *
- * An alternate template file of "maintenance-page--offline.tpl.php" can be
- * used when the database is offline to hide errors and completely replace the
- * content.
+ * The variables array generated here is a mirror of
+ * template_preprocess_page(). This preprocessor will run its course when
+ * theme_maintenance_page() is invoked. An alternate template file of
+ * maintenance-page--offline.tpl.php can be used when the database is offline to
+ * hide errors and completely replace the content.
  *
  * The $variables array contains the following arguments:
  * - $content
@@ -2777,10 +2806,13 @@ function template_preprocess_maintenance_page(&$variables) {
 }
 
 /**
+ * Theme process function for theme_maintenance_field().
+ *
  * The variables array generated here is a mirror of template_process_html().
  * This processor will run its course when theme_maintenance_page() is invoked.
  *
  * @see maintenance-page.tpl.php
+ * @see template_process_html()
  */
 function template_process_maintenance_page(&$variables) {
   $variables['head']    = drupal_get_html_head();
@@ -2792,7 +2824,7 @@ function template_process_maintenance_page(&$variables) {
 /**
  * Preprocess variables for region.tpl.php
  *
- * Prepare the values passed to the theme_region function to be passed into a
+ * Prepares the values passed to the theme_region function to be passed into a
  * pluggable template engine. Uses the region name to generate a template file
  * suggestions. If none are found, the default region.tpl.php is used.
  *
diff --git a/includes/theme.maintenance.inc b/includes/theme.maintenance.inc
index 218a8ad..6baf219 100644
--- a/includes/theme.maintenance.inc
+++ b/includes/theme.maintenance.inc
@@ -10,9 +10,9 @@
  *
  * Used for site installs, updates and when the site is in maintenance mode.
  * It also applies when the database is unavailable or bootstrap was not
- * complete. Seven is always used for the initial install and update operations.
- * In other cases, Bartik is used, but this can be overridden by setting a
- * "maintenance_theme" key in the $conf variable in settings.php.
+ * complete. Seven is always used for the initial install and update
+ * operations. In other cases, Bartik is used, but this can be overridden by
+ * setting a "maintenance_theme" key in the $conf variable in settings.php.
  */
 function _drupal_maintenance_theme() {
   global $theme, $theme_key, $conf;
@@ -85,7 +85,7 @@ function _drupal_maintenance_theme() {
 }
 
 /**
- * This builds the registry when the site needs to bypass any database calls.
+ * Builds the registry when the site needs to bypass any database calls.
  */
 function _theme_load_offline_registry($theme, $base_theme = NULL, $theme_engine = NULL) {
   return _theme_build_registry($theme, $base_theme, $theme_engine);
@@ -160,7 +160,7 @@ function theme_update_page($variables) {
 }
 
 /**
- * Returns HTML for a report of the results from an operation run via authorize.php.
+ * Returns HTML for a results report of an operation run by authorize.php.
  *
  * @param $variables
  *   An associative array containing:
diff --git a/includes/token.inc b/includes/token.inc
index 0b05c68..5e9ece8 100644
--- a/includes/token.inc
+++ b/includes/token.inc
@@ -113,13 +113,13 @@ function token_replace($text, array $data = array(), array $options = array()) {
  */
 function token_scan($text) {
   // Matches tokens with the following pattern: [$type:$name]
-  // $type and $name may not contain  [ ] or whitespace characters.
-  // $type may not contain : characters, but $name may.
+  // $type and $name may not contain  [ ] characters.
+  // $type may not contain : or whitespace characters, but $name may.
   preg_match_all('/
     \[             # [ - pattern start
     ([^\s\[\]:]*)  # match $type not containing whitespace : [ or ]
     :              # : - separator
-    ([^\s\[\]]*)   # match $name not containing whitespace [ or ]
+    ([^\[\]]*)     # match $name not containing [ or ]
     \]             # ] - pattern end
     /x', $text, $matches);
 
@@ -190,10 +190,10 @@ function token_generate($type, array $tokens, array $data = array(), array $opti
 }
 
 /**
- * Given a list of tokens, returns those that begin with a specific prefix.
+ * Returns a list of tokens that begin with a specific prefix.
  *
- * Used to extract a group of 'chained' tokens (such as [node:author:name]) from
- * the full list of tokens found in text. For example:
+ * Used to extract a group of 'chained' tokens (such as [node:author:name])
+ * from the full list of tokens found in text. For example:
  * @code
  *   $data = array(
  *     'author:name' => '[node:author:name]',
@@ -230,8 +230,10 @@ function token_find_with_prefix(array $tokens, $prefix, $delimiter = ':') {
 /**
  * Returns metadata describing supported tokens.
  *
- * The metadata array contains token type, name, and description data as well as
- * an optional pointer indicating that the token chains to another set of tokens.
+ * The metadata array contains token type, name, and description data as well
+ * as an optional pointer indicating that the token chains to another set of
+ * tokens.
+ *
  * For example:
  * @code
  *   $data['types']['node'] = array(
diff --git a/includes/unicode.inc b/includes/unicode.inc
index 81a0a4d..fd497cc 100644
--- a/includes/unicode.inc
+++ b/includes/unicode.inc
@@ -1,6 +1,11 @@
 <?php
 
 /**
+* @file
+* Provides Unicode-related conversions and operations.
+*/
+
+/**
  * Indicates an error during check for PHP unicode support.
  */
 define('UNICODE_ERROR', -1);
@@ -19,8 +24,6 @@ define('UNICODE_MULTIBYTE', 1);
 /**
  * Matches Unicode characters that are word boundaries.
  *
- * @see http://unicode.org/glossary
- *
  * Characters with the following General_category (gc) property values are used
  * as word boundaries. While this does not fully conform to the Word Boundaries
  * algorithm described in http://unicode.org/reports/tr29, as PCRE does not
@@ -39,6 +42,8 @@ define('UNICODE_MULTIBYTE', 1);
  * Note that the PCRE property matcher is not used because we wanted to be
  * compatible with Unicode 5.2.0 regardless of the PCRE version used (and any
  * bugs in PCRE property tables).
+ *
+ * @see http://unicode.org/glossary
  */
 define('PREG_CLASS_UNICODE_WORD_BOUNDARY',
   '\x{0}-\x{2F}\x{3A}-\x{40}\x{5B}-\x{60}\x{7B}-\x{A9}\x{AB}-\x{B1}\x{B4}' .
@@ -125,7 +130,7 @@ function _unicode_check() {
 }
 
 /**
- * Return Unicode library status and errors.
+ * Returns Unicode library status and errors.
  */
 function unicode_requirements() {
   // Ensure translations don't break during installation.
@@ -157,14 +162,14 @@ function unicode_requirements() {
 }
 
 /**
- * Prepare a new XML parser.
+ * Prepares a new XML parser.
  *
- * This is a wrapper around xml_parser_create() which extracts the encoding from
- * the XML data first and sets the output encoding to UTF-8. This function should
- * be used instead of xml_parser_create(), because PHP 4's XML parser doesn't
- * check the input encoding itself. "Starting from PHP 5, the input encoding is
- * automatically detected, so that the encoding parameter specifies only the
- * output encoding."
+ * This is a wrapper around xml_parser_create() which extracts the encoding
+ * from the XML data first and sets the output encoding to UTF-8. This function
+ * should be used instead of xml_parser_create(), because PHP 4's XML parser
+ * doesn't check the input encoding itself. "Starting from PHP 5, the input
+ * encoding is automatically detected, so that the encoding parameter specifies
+ * only the output encoding."
  *
  * This is also where unsupported encodings will be converted. Callers should
  * take this into account: $data might have been changed after the call.
@@ -213,7 +218,7 @@ function drupal_xml_parser_create(&$data) {
 }
 
 /**
- * Convert data to UTF-8
+ * Converts data to UTF-8.
  *
  * Requires the iconv, GNU recode or mbstring PHP extension.
  *
@@ -244,15 +249,15 @@ function drupal_convert_to_utf8($data, $encoding) {
 }
 
 /**
- * Truncate a UTF-8-encoded string safely to a number of bytes.
+ * Truncates a UTF-8-encoded string safely to a number of bytes.
  *
  * If the end position is in the middle of a UTF-8 sequence, it scans backwards
  * until the beginning of the byte sequence.
  *
  * Use this function whenever you want to chop off a string at an unsure
  * location. On the other hand, if you're sure that you're splitting on a
- * character boundary (e.g. after using strpos() or similar), you can safely use
- * substr() instead.
+ * character boundary (e.g. after using strpos() or similar), you can safely
+ * use substr() instead.
  *
  * @param $string
  *   The string to truncate.
@@ -306,7 +311,7 @@ function drupal_truncate_bytes($string, $len) {
  *   boundaries, giving you "See myverylongurl..." (assuming you had set
  *   $add_ellipses to TRUE).
  *
- * @return
+ * @return string
  *   The truncated string.
  */
 function truncate_utf8($string, $max_length, $wordsafe = FALSE, $add_ellipsis = FALSE, $min_wordsafe_length = 1) {
@@ -356,8 +361,7 @@ function truncate_utf8($string, $max_length, $wordsafe = FALSE, $add_ellipsis =
 }
 
 /**
- * Encodes MIME/HTTP header values that contain non-ASCII, UTF-8 encoded
- * characters.
+ * Encodes MIME/HTTP header values that contain incorrectly encoded characters.
  *
  * For example, mime_header_encode('tést.txt') returns "=?UTF-8?B?dMOpc3QudHh0?=".
  *
@@ -369,6 +373,14 @@ function truncate_utf8($string, $max_length, $wordsafe = FALSE, $add_ellipsis =
  *   each chunk starts and ends on a character boundary.
  * - Using \n as the chunk separator may cause problems on some systems and may
  *   have to be changed to \r\n or \r.
+ *
+ * @param $string
+ *   The header to encode.
+ *
+ * @return string
+ *   The mime-encoded header.
+ *
+ * @see mime_header_decode()
  */
 function mime_header_encode($string) {
   if (preg_match('/[^\x20-\x7E]/', $string)) {
@@ -388,7 +400,15 @@ function mime_header_encode($string) {
 }
 
 /**
- * Complement to mime_header_encode
+ * Decodes MIME/HTTP encoded header values.
+ *
+ * @param $header
+ *   The header to decode.
+ *
+ * @return string
+ *   The mime-decoded header.
+ *
+ * @see mime_header_encode()
  */
 function mime_header_decode($header) {
   // First step: encoded chunks followed by other encoded chunks (need to collapse whitespace)
@@ -398,7 +418,17 @@ function mime_header_decode($header) {
 }
 
 /**
- * Helper function to mime_header_decode
+ * Decodes encoded header data passed from mime_header_decode().
+ *
+ * Callback for preg_replace_callback() within mime_header_decode().
+ *
+ * @param $matches
+ *   The array of matches from preg_replace_callback().
+ *
+ * @return string
+ *   The mime-decoded string.
+ *
+ * @see mime_header_decode()
  */
 function _mime_header_decode($matches) {
   // Regexp groups:
@@ -415,9 +445,9 @@ function _mime_header_decode($matches) {
 /**
  * Decodes all HTML entities (including numerical ones) to regular UTF-8 bytes.
  *
- * Double-escaped entities will only be decoded once ("&amp;lt;" becomes "&lt;",
- * not "<"). Be careful when using this function, as decode_entities can revert
- * previous sanitization efforts (&lt;script&gt; will become <script>).
+ * Double-escaped entities will only be decoded once ("&amp;lt;" becomes "&lt;"
+ * , not "<"). Be careful when using this function, as decode_entities can
+ * revert previous sanitization efforts (&lt;script&gt; will become <script>).
  *
  * @param $text
  *   The text to decode entities in.
@@ -430,8 +460,15 @@ function decode_entities($text) {
 }
 
 /**
- * Count the amount of characters in a UTF-8 string. This is less than or
- * equal to the byte count.
+ * Counts the number of characters in a UTF-8 string.
+ *
+ * This is less than or equal to the byte count.
+ *
+ * @param $text
+ *   The string to run the operation on.
+ *
+ * @return integer
+ *   The length of the string.
  *
  * @ingroup php_wrappers
  */
@@ -449,6 +486,12 @@ function drupal_strlen($text) {
 /**
  * Uppercase a UTF-8 string.
  *
+ * @param $text
+ *   The string to run the operation on.
+ *
+ * @return string
+ *   The string in uppercase.
+ *
  * @ingroup php_wrappers
  */
 function drupal_strtoupper($text) {
@@ -468,6 +511,12 @@ function drupal_strtoupper($text) {
 /**
  * Lowercase a UTF-8 string.
  *
+ * @param $text
+ *   The string to run the operation on.
+ *
+ * @return string
+ *   The string in lowercase.
+ *
  * @ingroup php_wrappers
  */
 function drupal_strtolower($text) {
@@ -485,15 +534,28 @@ function drupal_strtolower($text) {
 }
 
 /**
- * Helper function for case conversion of Latin-1.
- * Used for flipping U+C0-U+DE to U+E0-U+FD and back.
+ * Flips U+C0-U+DE to U+E0-U+FD and back.
+ *
+ * @param $matches
+ *   An array of matches.
+ *
+ * @return array
+ *   The Latin-1 version of the array of matches.
+ *
+ * @see drupal_strtolower()
  */
 function _unicode_caseflip($matches) {
   return $matches[0][0] . chr(ord($matches[0][1]) ^ 32);
 }
 
 /**
- * Capitalize the first letter of a UTF-8 string.
+ * Capitalizes the first letter of a UTF-8 string.
+ *
+ * @param $text
+ *   The string to convert.
+ *
+ * @return
+ *   The string with the first letter as uppercase.
  *
  * @ingroup php_wrappers
  */
@@ -503,12 +565,21 @@ function drupal_ucfirst($text) {
 }
 
 /**
- * Cut off a piece of a string based on character indices and counts. Follows
- * the same behavior as PHP's own substr() function.
+ * Cuts off a piece of a string based on character indices and counts.
  *
- * Note that for cutting off a string at a known character/substring
- * location, the usage of PHP's normal strpos/substr is safe and
- * much faster.
+ * Follows the same behavior as PHP's own substr() function. Note that for
+ * cutting off a string at a known character/substring location, the usage of
+ * PHP's normal strpos/substr is safe and much faster.
+ *
+ * @param $text
+ *   The input string.
+ * @param $start
+ *   The position at which to start reading.
+ * @param $length
+ *   The number of characters to read.
+ *
+ * @return
+ *   The shortened string.
  *
  * @ingroup php_wrappers
  */
diff --git a/includes/update.inc b/includes/update.inc
index 5f1c233..a17161c 100644
--- a/includes/update.inc
+++ b/includes/update.inc
@@ -38,7 +38,7 @@ function update_fix_compatibility() {
 }
 
 /**
- * Helper function to test compatibility of a module or theme.
+ * Tests the compatibility of a module or theme.
  */
 function update_check_incompatibility($name, $type = 'module') {
   static $themes, $modules;
@@ -908,7 +908,7 @@ function update_get_d6_session_name() {
 }
 
 /**
- * Perform one update and store the results for display on finished page.
+ * Performs one update and stores the results for display on the results page.
  *
  * If an update function completes successfully, it should return a message
  * as a string indicating success, for example:
@@ -1008,7 +1008,7 @@ function update_do_one($module, $number, $dependency_map, &$context) {
 class DrupalUpdateException extends Exception { }
 
 /**
- * Start the database update batch process.
+ * Starts the database update batch process.
  *
  * @param $start
  *   An array whose keys contain the names of modules to be updated during the
@@ -1078,7 +1078,7 @@ function update_batch($start, $redirect = NULL, $url = NULL, $batch = array(), $
 }
 
 /**
- * Finish the update process and store results for eventual display.
+ * Finishes the update process and stores the results for eventual display.
  *
  * After the updates run, all caches are flushed. The update results are
  * stored into the session (for example, to be displayed on the update results
@@ -1115,7 +1115,7 @@ function update_finished($success, $results, $operations) {
 }
 
 /**
- * Return a list of all the pending database updates.
+ * Returns a list of all the pending database updates.
  *
  * @return
  *   An associative array keyed by module name which contains all information
@@ -1409,7 +1409,7 @@ function update_already_performed($module, $number) {
 }
 
 /**
- * Invoke hook_update_dependencies() in all installed modules.
+ * Invokes hook_update_dependencies() in all installed modules.
  *
  * This function is similar to module_invoke_all(), with the main difference
  * that it does not require that a module be enabled to invoke its hook, only
diff --git a/includes/utility.inc b/includes/utility.inc
index 5019852..f651fd6 100644
--- a/includes/utility.inc
+++ b/includes/utility.inc
@@ -12,6 +12,7 @@
  *   The variable to export.
  * @param $prefix
  *   A prefix that will be added at the beginning of every lines of the output.
+ *
  * @return
  *   The variable exported in a way compatible to Drupal's coding standards.
  */
diff --git a/install.php b/install.php
index 881ca5a..685d3b4 100644
--- a/install.php
+++ b/install.php
@@ -6,12 +6,12 @@
  */
 
 /**
- * Root directory of Drupal installation.
+ * Defines the root directory of the Drupal installation.
  */
 define('DRUPAL_ROOT', getcwd());
 
 /**
- * Global flag to indicate that site is in installation mode.
+ * Global flag to indicate the site is in installation mode.
  */
 define('MAINTENANCE_MODE', 'install');
 
diff --git a/misc/ajax.js b/misc/ajax.js
index 900ca1d..90c3bb8 100644
--- a/misc/ajax.js
+++ b/misc/ajax.js
@@ -396,7 +396,7 @@ Drupal.ajax.prototype.success = function (response, status) {
   Drupal.freezeHeight();
 
   for (var i in response) {
-    if (response[i]['command'] && this.commands[response[i]['command']]) {
+    if (response.hasOwnProperty(i) && response[i]['command'] && this.commands[response[i]['command']]) {
       this.commands[response[i]['command']](this, response[i], status);
     }
   }
diff --git a/misc/machine-name.js b/misc/machine-name.js
index ced8c4b..4678e0b 100644
--- a/misc/machine-name.js
+++ b/misc/machine-name.js
@@ -80,7 +80,7 @@ Drupal.behaviors.machineName = {
       // changes, but only if there is no machine name yet; i.e., only upon
       // initial creation, not when editing.
       if ($target.val() == '') {
-        $source.bind('keyup.machineName change.machineName', function () {
+        $source.bind('keyup.machineName change.machineName input.machineName', function () {
           machine = self.transliterate($(this).val(), options);
           // Set the machine name to the transliterated value.
           if (machine != '') {
diff --git a/misc/tableheader.js b/misc/tableheader.js
index a9f98a6..47201b2 100644
--- a/misc/tableheader.js
+++ b/misc/tableheader.js
@@ -126,7 +126,7 @@ Drupal.tableHeader.prototype.eventhandlerRecalculateStickyHeader = function (eve
         $stickyCell.css('display', 'none');
       }
     }
-    this.stickyTable.css('width', this.originalTable.css('width'));
+    this.stickyTable.css('width', this.originalTable.outerWidth());
   }
 };
 
diff --git a/modules/aggregator/aggregator-rtl.css b/modules/aggregator/aggregator-rtl.css
index ea59ca3..057d015 100644
--- a/modules/aggregator/aggregator-rtl.css
+++ b/modules/aggregator/aggregator-rtl.css
@@ -1,3 +1,6 @@
+/**
+ * Right-to-Left styles for theme in the Aggregator module.
+ */
 
 #aggregator .feed-source .feed-icon {
   float: left;
diff --git a/modules/aggregator/aggregator.admin.inc b/modules/aggregator/aggregator.admin.inc
index 8b817c0..443facb 100644
--- a/modules/aggregator/aggregator.admin.inc
+++ b/modules/aggregator/aggregator.admin.inc
@@ -2,11 +2,11 @@
 
 /**
  * @file
- * Admin page callbacks for the aggregator module.
+ * Administration page callbacks for the Aggregator module.
  */
 
 /**
- * Menu callback; displays the aggregator administration page.
+ * Page callback: Displays the Aggregator module administration page.
  */
 function aggregator_admin_overview() {
   return aggregator_view();
@@ -16,7 +16,7 @@ function aggregator_admin_overview() {
  * Displays the aggregator administration page.
  *
  * @return
- *   The page HTML.
+ *   A HTML-formatted string with administration page content.
  */
 function aggregator_view() {
   $result = db_query('SELECT f.fid, f.title, f.url, f.refresh, f.checked, f.link, f.description, f.hash, f.etag, f.modified, f.image, f.block, COUNT(i.iid) AS items FROM {aggregator_feed} f LEFT JOIN {aggregator_item} i ON f.fid = i.fid GROUP BY f.fid, f.title, f.url, f.refresh, f.checked, f.link, f.description, f.hash, f.etag, f.modified, f.image, f.block ORDER BY f.title');
@@ -56,8 +56,8 @@ function aggregator_view() {
  * Form constructor for adding and editing feed sources.
  *
  * @param $feed
- *   If editing a feed, the feed to edit as a PHP stdClass value; if adding a
- *   new feed, NULL.
+ *   (optional) If editing a feed, the feed to edit as a PHP stdClass value; if
+ *   adding a new feed, NULL. Defaults to NULL.
  *
  * @ingroup forms
  * @see aggregator_form_feed_validate()
@@ -165,6 +165,7 @@ function aggregator_form_feed_validate($form, &$form_state) {
  * Form submission handler for aggregator_form_feed().
  *
  * @see aggregator_form_feed_validate()
+ *
  * @todo Add delete confirmation dialog.
  */
 function aggregator_form_feed_submit($form, &$form_state) {
@@ -398,7 +399,7 @@ function _aggregator_parse_opml($opml) {
 }
 
 /**
- * Menu callback; refreshes a feed, then redirects to the overview page.
+ * Page callback: Refreshes a feed, then redirects to the overview page.
  *
  * @param $feed
  *   An object describing the feed to be refreshed.
@@ -590,6 +591,7 @@ function aggregator_form_category_validate($form, &$form_state) {
  * Form submission handler for aggregator_form_category().
  *
  * @see aggregator_form_category_validate()
+ *
  * @todo Add delete confirmation dialog.
  */
 function aggregator_form_category_submit($form, &$form_state) {
diff --git a/modules/aggregator/aggregator.api.php b/modules/aggregator/aggregator.api.php
index cd5e47b..d5cac4e 100644
--- a/modules/aggregator/aggregator.api.php
+++ b/modules/aggregator/aggregator.api.php
@@ -189,7 +189,7 @@ function hook_aggregator_process($feed) {
  *
  * @ingroup aggregator
  */
-function hook_aggregator_process_info($feed) {
+function hook_aggregator_process_info() {
   return array(
     'title' => t('Default processor'),
     'description' => t('Creates lightweight records of feed items.'),
diff --git a/modules/aggregator/aggregator.css b/modules/aggregator/aggregator.css
index 13c58ff..4285631 100644
--- a/modules/aggregator/aggregator.css
+++ b/modules/aggregator/aggregator.css
@@ -1,3 +1,6 @@
+/**
+ * Styles for theme in the Aggregator module.
+ */
 
 #aggregator .feed-source .feed-title {
   margin-top: 0;
diff --git a/modules/aggregator/aggregator.module b/modules/aggregator/aggregator.module
index 93457c6..70f8c5c 100644
--- a/modules/aggregator/aggregator.module
+++ b/modules/aggregator/aggregator.module
@@ -266,13 +266,13 @@ function aggregator_menu() {
 }
 
 /**
- * Title callback: Returns a title for aggregatory category pages.
+ * Title callback: Returns a title for aggregator category pages.
  *
  * @param $category
  *   An aggregator category.
  *
  * @return
- *   An aggregator category title.
+ *   A string with the aggregator category title.
  */
 function _aggregator_category_title($category) {
   return $category['title'];
@@ -723,7 +723,7 @@ function theme_aggregator_block_item($variables) {
 }
 
 /**
- * Safely renders HTML content, as allowed.
+ * Renders the HTML content safely, as allowed.
  *
  * @param $value
  *   The content to be filtered.
@@ -739,7 +739,7 @@ function aggregator_filter_xss($value) {
  * Checks and sanitizes the aggregator configuration.
  *
  * Goes through all fetchers, parsers and processors and checks whether they
- * are available. If one is missing resets to standard configuration.
+ * are available. If one is missing, resets to standard configuration.
  *
  * @return
  *   TRUE if this function resets the configuration; FALSE if not.
@@ -775,7 +775,7 @@ function aggregator_sanitize_configuration() {
  *   Items count.
  *
  * @return
- *   Plural-formatted "@count items"
+ *   A string that is plural-formatted as "@count items".
  */
 function _aggregator_items($count) {
   return format_plural($count, '1 item', '@count items');
diff --git a/modules/aggregator/aggregator.pages.inc b/modules/aggregator/aggregator.pages.inc
index cd1c4cb..bfba3ff 100644
--- a/modules/aggregator/aggregator.pages.inc
+++ b/modules/aggregator/aggregator.pages.inc
@@ -2,14 +2,14 @@
 
 /**
  * @file
- * User page callbacks for the aggregator module.
+ * User page callbacks for the Aggregator module.
  */
 
 /**
- * Menu callback; displays the most recent items gathered from any feed.
+ * Page callback: Displays the most recent items gathered from any feed.
  *
  * @return
- *   The items HTML.
+ *   The rendered list of items for the feed.
  */
 function aggregator_page_last() {
   drupal_add_feed('aggregator/rss', variable_get('site_name', 'Drupal') . ' ' . t('aggregator'));
@@ -20,13 +20,15 @@ function aggregator_page_last() {
 }
 
 /**
- * Menu callback; displays all the items captured from a particular feed.
+ * Page callback: Displays all the items captured from the particular feed.
  *
  * @param $feed
  *   The feed for which to display all items.
  *
  * @return
  *   The rendered list of items for a feed.
+ *
+ * @see aggregator_menu()
  */
 function aggregator_page_source($feed) {
   drupal_set_title($feed->title);
@@ -40,13 +42,13 @@ function aggregator_page_source($feed) {
 }
 
 /**
- * Menu callback; displays a form with all items captured from a feed.
+ * Page callback: Displays a form with all items captured from a feed.
  *
  * @param $feed
- *   The feed for which to list all the aggregated items.
+ *   The feed for which to list all of the aggregated items.
  *
  * @return
- *   The rendered list of items for a feed.
+ *   The rendered list of items for the feed.
  *
  * @see aggregator_page_source()
  */
@@ -55,13 +57,13 @@ function aggregator_page_source_form($form, $form_state, $feed) {
 }
 
 /**
- * Menu callback; displays all the items aggregated in a particular category.
+ * Page callback: Displays all the items aggregated in a particular category.
  *
  * @param $category
- *   The category for which to list all the aggregated items.
+ *   The category for which to list all of the aggregated items.
  *
  * @return
-*   The rendered list of items for a category.
+ *   The rendered list of items for the feed.
  */
 function aggregator_page_category($category) {
   drupal_add_feed('aggregator/rss/' . $category['cid'], variable_get('site_name', 'Drupal') . ' ' . t('aggregator - @title', array('@title' => $category['title'])));
@@ -74,13 +76,13 @@ function aggregator_page_category($category) {
 }
 
 /**
- * Menu callback; displays a form containing items aggregated in a category.
+ * Page callback: Displays a form containing items aggregated in a category.
  *
  * @param $category
- *   The category for which to list all the aggregated items.
+ *   The category for which to list all of the aggregated items.
  *
  * @return
-*   The rendered list of items for a category.
+ *   The rendered list of items for the feed.
  *
  * @see aggregator_page_category()
  */
@@ -166,7 +168,7 @@ function aggregator_feed_items_load($type, $data = NULL) {
  *   The feed source URL.
  *
  * @return
- *   The rendered list of items for a feed.
+ *   The rendered list of items for the feed.
  */
 function _aggregator_page_list($items, $op, $feed_source = '') {
   if (user_access('administer news feeds') && ($op == 'categorize')) {
@@ -191,10 +193,14 @@ function _aggregator_page_list($items, $op, $feed_source = '') {
  * @param $items
  *   An array of the feed items.
  * @param $feed_source
- *   The feed source URL.
+ *   (optional) The feed source URL. Defaults to an empty string.
+ *
+ * @return array
+ *   An array of FAPI elements.
  *
- * @ingroup forms
  * @see aggregator_categorize_items_submit()
+ * @see theme_aggregator_categorize_items()
+ * @ingroup forms
  */
 function aggregator_categorize_items($items, $feed_source = '') {
   $form['#submit'][] = 'aggregator_categorize_items_submit';
@@ -334,7 +340,12 @@ function template_preprocess_aggregator_item(&$variables) {
 }
 
 /**
- * Menu callback; displays all the feeds used by the aggregator.
+ * Page callback: Displays all the feeds used by the aggregator.
+ *
+ * @return
+ *   An HTML-formatted string.
+ *
+ * @see aggregator_menu()
  */
 function aggregator_page_sources() {
   $result = db_query('SELECT f.fid, f.title, f.description, f.image, MAX(i.timestamp) AS last FROM {aggregator_feed} f LEFT JOIN {aggregator_item} i ON f.fid = i.fid GROUP BY f.fid, f.title, f.description, f.image ORDER BY last DESC, f.title');
@@ -358,7 +369,12 @@ function aggregator_page_sources() {
 }
 
 /**
- * Menu callback; displays all the categories used by the aggregator.
+ * Page callback: Displays all the categories used by the Aggregator module.
+ *
+ * @return string
+ *   An HTML formatted string.
+ *
+ * @see aggregator_menu()
  */
 function aggregator_page_categories() {
   $result = db_query('SELECT c.cid, c.title, c.description FROM {aggregator_category} c LEFT JOIN {aggregator_category_item} ci ON c.cid = ci.cid LEFT JOIN {aggregator_item} i ON ci.iid = i.iid GROUP BY c.cid, c.title, c.description');
@@ -380,7 +396,10 @@ function aggregator_page_categories() {
 }
 
 /**
- * Menu callback; generate an RSS 0.92 feed of aggregator items or categories.
+ * Page callback: Generates an RSS 0.92 feed of aggregator items or categories.
+ *
+ * @return string
+ *   An HTML formatted string.
  */
 function aggregator_page_rss() {
   $result = NULL;
@@ -448,12 +467,14 @@ function theme_aggregator_page_rss($variables) {
 }
 
 /**
- * Menu callback; generates an OPML representation of all feeds.
+ * Page callback: Generates an OPML representation of all feeds.
  *
  * @param $cid
- *   If set, feeds are exported only from a category with this ID. Otherwise, all feeds are exported.
+ *   (optional) If set, feeds are exported only from a category with this ID.
+ *   Otherwise, all feeds are exported. Defaults to NULL.
+ *
  * @return
- *   The output XML.
+ *   An OPML formatted string.
  */
 function aggregator_page_opml($cid = NULL) {
   if ($cid) {
@@ -468,14 +489,12 @@ function aggregator_page_opml($cid = NULL) {
 }
 
 /**
- * Prints the OPML page for a feed.
+ * Prints the OPML page for the feed.
  *
  * @param $variables
  *   An associative array containing:
  *   - feeds: An array of the feeds to theme.
  *
- * @return void
- *
  * @ingroup themeable
  */
 function theme_aggregator_page_opml($variables) {
diff --git a/modules/aggregator/aggregator.processor.inc b/modules/aggregator/aggregator.processor.inc
index 3f1319c..44ed549 100644
--- a/modules/aggregator/aggregator.processor.inc
+++ b/modules/aggregator/aggregator.processor.inc
@@ -131,6 +131,12 @@ function aggregator_form_aggregator_admin_form_alter(&$form, $form_state) {
  *
  * Callback for drupal_map_assoc() within
  * aggregator_form_aggregator_admin_form_alter().
+ *
+ * @param $length
+ *   The desired length of teaser text, in bytes.
+ *
+ * @return
+ *   A translated string explaining the teaser string length.
  */
 function _aggregator_characters($length) {
   return ($length == 0) ? t('Unlimited') : format_plural($length, '1 character', '@count characters');
diff --git a/modules/aggregator/aggregator.test b/modules/aggregator/aggregator.test
index eff3102..8b95d6e 100644
--- a/modules/aggregator/aggregator.test
+++ b/modules/aggregator/aggregator.test
@@ -5,6 +5,9 @@
  * Tests for aggregator.module.
  */
 
+/**
+ * Defines a base class for testing the Aggregator module.
+ */
 class AggregatorTestCase extends DrupalWebTestCase {
   function setUp() {
     parent::setUp('aggregator', 'aggregator_test');
@@ -13,10 +16,15 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create an aggregator feed (simulate form submission on admin/config/services/aggregator/add/feed).
+   * Creates an aggregator feed.
+   *
+   * This method simulates the form submission on path
+   * admin/config/services/aggregator/add/feed.
    *
    * @param $feed_url
-   *   If given, feed will be created with this URL, otherwise /rss.xml will be used.
+   *   (optional) If given, feed will be created with this URL, otherwise
+   *   /rss.xml will be used. Defaults to NULL.
+   *
    * @return $feed
    *   Full feed object if possible.
    *
@@ -33,7 +41,7 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Delete an aggregator feed.
+   * Deletes an aggregator feed.
    *
    * @param $feed
    *   Feed object representing the feed.
@@ -44,10 +52,11 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Return a randomly generated feed edit array.
+   * Returns a randomly generated feed edit array.
    *
    * @param $feed_url
-   *   If given, feed will be created with this URL, otherwise /rss.xml will be used.
+   *   (optional) If given, feed will be created with this URL, otherwise
+   *   /rss.xml will be used. Defaults to NULL.
    * @return
    *   A feed array.
    */
@@ -68,7 +77,7 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Return the count of the randomly created feed array.
+   * Returns the count of the randomly created feed array.
    *
    * @return
    *   Number of feed items on default feed created by createFeed().
@@ -80,10 +89,13 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Update feed items (simulate click to admin/config/services/aggregator/update/$fid).
+   * Updates the feed items.
+   *
+   * This method simulates a click to
+   * admin/config/services/aggregator/update/$fid.
    *
    * @param $feed
-   *   Feed object representing the feed.
+   *   Feed object representing the feed, passed by reference.
    * @param $expected_count
    *   Expected number of feed items.
    */
@@ -112,7 +124,7 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Confirm item removal from a feed.
+   * Confirms an item removal from a feed.
    *
    * @param $feed
    *   Feed object representing the feed.
@@ -123,7 +135,7 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Add and remove feed items and ensure that the count is zero.
+   * Adds and removes feed items and ensure that the count is zero.
    *
    * @param $feed
    *   Feed object representing the feed.
@@ -140,7 +152,7 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Pull feed categories from aggregator_category_feed table.
+   * Pulls feed categories from {aggregator_category_feed} table.
    *
    * @param $feed
    *   Feed object representing the feed.
@@ -154,7 +166,11 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Pull categories from aggregator_category table.
+   * Pulls categories from {aggregator_category} table.
+   *
+   * @return
+   *   An associative array keyed by category ID and values are set to the
+   *   category names.
    */
   function getCategories() {
     $categories = array();
@@ -165,14 +181,14 @@ class AggregatorTestCase extends DrupalWebTestCase {
     return $categories;
   }
 
-
   /**
-   * Check if the feed name and URL is unique.
+   * Checks whether the feed name and URL are unique.
    *
    * @param $feed_name
    *   String containing the feed name to check.
    * @param $feed_url
    *   String containing the feed URL to check.
+   *
    * @return
    *   TRUE if feed is unique.
    */
@@ -182,10 +198,11 @@ class AggregatorTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create a valid OPML file from an array of feeds.
+   * Creates a valid OPML file from an array of feeds.
    *
    * @param $feeds
    *   An array of feeds.
+   *
    * @return
    *   Path to valid OPML file.
    */
@@ -223,7 +240,7 @@ EOF;
   }
 
   /**
-   * Create an invalid OPML file.
+   * Creates an invalid OPML file.
    *
    * @return
    *   Path to invalid OPML file.
@@ -240,7 +257,7 @@ EOF;
   }
 
   /**
-   * Create a valid but empty OPML file.
+   * Creates a valid but empty OPML file.
    *
    * @return
    *   Path to empty OPML file.
@@ -275,7 +292,7 @@ EOF;
    * Creates sample article nodes.
    *
    * @param $count
-   *   (optional) The number of nodes to generate.
+   *   (optional) The number of nodes to generate. Defaults to five.
    */
   function createSampleNodes($count = 5) {
     $langcode = LANGUAGE_NONE;
@@ -290,7 +307,7 @@ EOF;
 }
 
 /**
- * Tests aggregator configuration settings.
+ * Tests functionality of the configuration settings in the Aggregator module.
  */
 class AggregatorConfigurationTestCase extends AggregatorTestCase {
   public static function getInfo() {
@@ -321,6 +338,9 @@ class AggregatorConfigurationTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests adding aggregator feeds.
+ */
 class AddFeedTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -331,7 +351,7 @@ class AddFeedTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Create a feed, ensure that it is unique, check the source, and delete the feed.
+   * Creates and ensures that a feed is unique, checks source, and deletes feed.
    */
   function testAddFeed() {
     $feed = $this->createFeed();
@@ -381,6 +401,9 @@ class AddFeedTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests the categorize feed functionality in the Aggregator module.
+ */
 class CategorizeFeedTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -391,7 +414,7 @@ class CategorizeFeedTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Create a feed and make sure you can add more than one category to it.
+   * Creates a feed and makes sure you can add more than one category to it.
    */
   function testCategorizeFeed() {
 
@@ -424,6 +447,9 @@ class CategorizeFeedTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests functionality of updating the feed in the Aggregator module.
+ */
 class UpdateFeedTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -434,7 +460,7 @@ class UpdateFeedTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Create a feed and attempt to update it.
+   * Creates a feed and attempts to update it.
    */
   function testUpdateFeed() {
     $remamining_fields = array('title', 'url', '');
@@ -466,6 +492,9 @@ class UpdateFeedTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests functionality for removing feeds in the Aggregator module.
+ */
 class RemoveFeedTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -476,7 +505,7 @@ class RemoveFeedTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Remove a feed and ensure that all it services are removed.
+   * Removes a feed and ensures that all of its services are removed.
    */
   function testRemoveFeed() {
     $feed = $this->createFeed();
@@ -494,6 +523,9 @@ class RemoveFeedTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests functionality of updating a feed item in the Aggregator module.
+ */
 class UpdateFeedItemTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -504,7 +536,7 @@ class UpdateFeedItemTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Test running "update items" from the 'admin/config/services/aggregator' page.
+   * Tests running "update items" from 'admin/config/services/aggregator' page.
    */
   function testUpdateFeedItem() {
     $this->createSampleNodes();
@@ -564,7 +596,7 @@ class RemoveFeedItemTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Test running "remove items" from the 'admin/config/services/aggregator' page.
+   * Tests running "remove items" from 'admin/config/services/aggregator' page.
    */
   function testRemoveFeedItem() {
     // Create a bunch of test feeds.
@@ -592,6 +624,9 @@ class RemoveFeedItemTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests categorization functionality in the Aggregator module.
+ */
 class CategorizeFeedItemTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -602,6 +637,8 @@ class CategorizeFeedItemTestCase extends AggregatorTestCase {
   }
 
   /**
+   * Checks that children of a feed inherit a defined category.
+   *
    * If a feed has a category, make sure that the children inherit that
    * categorization.
    */
@@ -649,6 +686,9 @@ class CategorizeFeedItemTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests importing feeds from OPML functionality for the Aggregator module.
+ */
 class ImportOPMLTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -659,7 +699,7 @@ class ImportOPMLTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Open OPML import form.
+   * Opens OPML import form.
    */
   function openImportForm() {
     db_delete('aggregator_category')->execute();
@@ -681,7 +721,7 @@ class ImportOPMLTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Submit form filled with invalid fields.
+   * Submits form filled with invalid fields.
    */
   function validateImportFormFields() {
     $before = db_query('SELECT COUNT(*) FROM {aggregator_feed}')->fetchField();
@@ -707,7 +747,7 @@ class ImportOPMLTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Submit form with invalid, empty and valid OPML files.
+   * Submits form with invalid, empty, and valid OPML files.
    */
   function submitImportForm() {
     $before = db_query('SELECT COUNT(*) FROM {aggregator_feed}')->fetchField();
@@ -766,6 +806,9 @@ class ImportOPMLTestCase extends AggregatorTestCase {
     $this->assertTrue($category, 'Categories are correct.');
   }
 
+  /**
+   * Tests the import of an OPML file.
+   */
   function testOPMLImport() {
     $this->openImportForm();
     $this->validateImportFormFields();
@@ -773,6 +816,9 @@ class ImportOPMLTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests functionality of the cron process in the Aggregator module.
+ */
 class AggregatorCronTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -783,7 +829,7 @@ class AggregatorCronTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Add feeds update them on cron.
+   * Adds feeds and updates them via cron process.
    */
   public function testCron() {
     // Create feed and test basic updating on cron.
@@ -819,6 +865,9 @@ class AggregatorCronTestCase extends AggregatorTestCase {
   }
 }
 
+/**
+ * Tests rendering functionality in the Aggregator module.
+ */
 class AggregatorRenderingTestCase extends AggregatorTestCase {
   public static function getInfo() {
     return array(
@@ -829,9 +878,9 @@ class AggregatorRenderingTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Add a feed block to the page and checks its links.
+   * Adds a feed block to the page and checks its links.
    *
-   * TODO: Test the category block as well.
+   * @todo Test the category block as well.
    */
   public function testBlockLinks() {
     // Create feed.
@@ -890,7 +939,7 @@ class AggregatorRenderingTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Create a feed and check that feed's page.
+   * Creates a feed and checks that feed's page.
    */
   public function testFeedPage() {
     // Increase the number of items published in the rss.xml feed so we have
@@ -913,7 +962,7 @@ class AggregatorRenderingTestCase extends AggregatorTestCase {
 }
 
 /**
- * Tests for feed parsing.
+ * Tests feed parsing in the Aggregator module.
  */
 class FeedParserTestCase extends AggregatorTestCase {
   public static function getInfo() {
@@ -933,7 +982,7 @@ class FeedParserTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Test a feed that uses the RSS 0.91 format.
+   * Tests a feed that uses the RSS 0.91 format.
    */
   function testRSS091Sample() {
     $feed = $this->createFeed($this->getRSS091Sample());
@@ -955,7 +1004,7 @@ class FeedParserTestCase extends AggregatorTestCase {
   }
 
   /**
-   * Test a feed that uses the Atom format.
+   * Tests a feed that uses the Atom format.
    */
   function testAtomSample() {
     $feed = $this->createFeed($this->getAtomSample());
diff --git a/modules/block/block.module b/modules/block/block.module
index 70f55e5..3a988de 100644
--- a/modules/block/block.module
+++ b/modules/block/block.module
@@ -740,7 +740,7 @@ function _block_load_blocks() {
 /**
  * Implements hook_block_list_alter().
  *
- * Checks the page, user role, and user-specific visibilty settings.
+ * Checks the page, user role, and user-specific visibility settings.
  * Removes the block if the visibility conditions are not met.
  */
 function block_block_list_alter(&$blocks) {
@@ -840,15 +840,42 @@ function _block_render_blocks($region_blocks) {
   // preserve the submission of forms in blocks, by fetching from cache only
   // if the request method is 'GET' (or 'HEAD').
   $cacheable = !count(module_implements('node_grants')) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD');
+
+  // Proceed to loop over all blocks in order to compute their respective cache
+  // identifiers; this allows us to do one single cache_get_multiple() call
+  // instead of doing one cache_get() call per block.
+  $cached_blocks = array();
+  $cids = array();
+
+  if ($cacheable) {
+    foreach ($region_blocks as $key => $block) {
+      if (!isset($block->content)) {
+        if (($cid = _block_get_cache_id($block))) {
+          $cids[$key] = $cid;
+        }
+      }
+    }
+
+    if ($cids) {
+      // We cannot pass $cids in directly because cache_get_multiple() will
+      // modify it, and we need to use it later on in this function.
+      $cid_values = array_values($cids);
+      $cached_blocks = cache_get_multiple($cid_values, 'cache_block');
+    }
+  }
+
   foreach ($region_blocks as $key => $block) {
     // Render the block content if it has not been created already.
     if (!isset($block->content)) {
       // Erase the block from the static array - we'll put it back if it has
       // content.
       unset($region_blocks[$key]);
-      // Try fetching the block from cache.
-      if ($cacheable && ($cid = _block_get_cache_id($block)) && ($cache = cache_get($cid, 'cache_block'))) {
-        $array = $cache->data;
+
+      $cid = empty($cids[$key]) ? NULL : $cids[$key];
+
+      // Try fetching the block from the previously loaded cache entries.
+      if (isset($cached_blocks[$cid])) {
+        $array = $cached_blocks[$cid]->data;
       }
       else {
         $array = module_invoke($block->module, 'block_view', $block->delta);
diff --git a/modules/book/book-rtl.css b/modules/book/book-rtl.css
index f3a84c2..40dff0e 100644
--- a/modules/book/book-rtl.css
+++ b/modules/book/book-rtl.css
@@ -1,3 +1,7 @@
+/**
+ * @file
+ * Right-to-Left styling for the Book module.
+ */
 
 .book-navigation .menu {
   padding: 1em 3em 0 0;
diff --git a/modules/book/book.admin.inc b/modules/book/book.admin.inc
index 62c6e84..cc3f08f 100644
--- a/modules/book/book.admin.inc
+++ b/modules/book/book.admin.inc
@@ -2,11 +2,16 @@
 
 /**
  * @file
- * Admin page callbacks for the book module.
+ * Administration page callbacks for the Book module.
  */
 
 /**
  * Returns an administrative overview of all books.
+ *
+ * @return string
+ *   A HTML-formatted string with the administrative page content.
+ *
+ * @see book_menu()
  */
 function book_admin_overview() {
   $rows = array();
@@ -53,6 +58,8 @@ function book_admin_settings() {
 
 /**
  * Form validation handler for book_admin_settings().
+ *
+ * @see book_admin_settings_submit()
  */
 function book_admin_settings_validate($form, &$form_state) {
   $child_type = $form_state['values']['book_child_type'];
@@ -149,7 +156,7 @@ function book_admin_edit_submit($form, &$form_state) {
  * @param $node
  *   The node of the top-level page in the book.
  * @param $form
- *   The form that is being modified.
+ *   The form that is being modified, passed by reference.
  *
  * @see book_admin_edit()
  */
@@ -184,10 +191,10 @@ function _book_admin_table($node, &$form) {
  * @param $tree
  *   A subtree of the book menu hierarchy.
  * @param $form
- *   The form that is being modified.
+ *   The form that is being modified, passed by reference.
  *
  * @return
- *   The form that is being modified.
+ *   The modified form array.
  *
  * @see book_admin_edit()
  */
diff --git a/modules/book/book.css b/modules/book/book.css
index a8d2136..00e379e 100644
--- a/modules/book/book.css
+++ b/modules/book/book.css
@@ -1,3 +1,7 @@
+ /**
+  * @file
+  * Styling for the Book module.
+  */
 
 .book-navigation .menu {
   border-top: 1px solid #888;
diff --git a/modules/book/book.js b/modules/book/book.js
index 0853e8e..64f4aee 100644
--- a/modules/book/book.js
+++ b/modules/book/book.js
@@ -3,7 +3,6 @@
  * Javascript behaviors for the Book module.
  */
 
-
 (function ($) {
 
 Drupal.behaviors.bookFieldsetSummaries = {
diff --git a/modules/book/book.module b/modules/book/book.module
index 1fb0c0b..7afed9a 100644
--- a/modules/book/book.module
+++ b/modules/book/book.module
@@ -221,6 +221,9 @@ function _book_outline_remove_access($node) {
  *
  * A node can be removed from a book if it is actually in a book and it either
  * is not a top-level page or is a top-level page with no children.
+ *
+ * @param $node
+ *   The node to remove from the outline.
  */
 function _book_node_is_removable($node) {
   return (!empty($node->book['bid']) && (($node->book['bid'] != $node->nid) || !$node->book['has_children']));
@@ -734,7 +737,7 @@ function book_get_flat_menu($book_link) {
  * @param $tree
  *   A tree of menu links in an array.
  * @param $flat
- *   A flat array of the menu links from $tree.
+ *   A flat array of the menu links from $tree, passed by reference.
  *
  * @see book_get_flat_menu().
  */
@@ -1062,8 +1065,9 @@ function _book_link_defaults($nid) {
  * to the structured data but can also simply iterate over all elements and
  * render them (as in the default template).
  *
- * The $variables array contains the following elements:
- * - book_menus
+ * @param $variables
+ *   An associative array containing the following key:
+ *   - book_menus
  *
  * @see book-all-books-block.tpl.php
  */
@@ -1079,8 +1083,9 @@ function template_preprocess_book_all_books_block(&$variables) {
 /**
  * Processes variables for book-navigation.tpl.php.
  *
- * The $variables array contains the following elements:
- * - book_link
+ * @param $variables
+ *   An associative array containing the following key:
+ *   - book_link
  *
  * @see book-navigation.tpl.php
  */
@@ -1151,8 +1156,9 @@ function template_preprocess_book_navigation(&$variables) {
  *   Reference to the table of contents array. This is modified in place, so the
  *   function does not have a return value.
  * @param $exclude
- *   Optional array of menu link ID values. Any link whose menu link ID is in
- *   this array will be excluded (along with its children).
+ *   (optional) An array of menu link ID values. Any link whose menu link ID is
+ *   in this array will be excluded (along with its children). Defaults to an
+ *   empty array.
  * @param $depth_limit
  *   Any link deeper than this value will be excluded (along with its children).
  */
@@ -1198,10 +1204,11 @@ function book_toc($bid, $depth_limit, $exclude = array()) {
 /**
  * Processes variables for book-export-html.tpl.php.
  *
- * The $variables array contains the following elements:
- * - title
- * - contents
- * - depth
+ * @param $variables
+ *   An associative array containing the following keys:
+ *   - title
+ *   - contents
+ *   - depth
  *
  * @see book-export-html.tpl.php
  */
@@ -1261,7 +1268,8 @@ function book_export_traverse($tree, $visit_func) {
  * @param $node
  *   The node that will be output.
  * @param $children
- *   All the rendered child nodes within the current node.
+ *   (optional) All the rendered child nodes within the current node. Defaults
+ *   to an empty string.
  *
  * @return
  *   The HTML generated for the given node.
@@ -1280,9 +1288,10 @@ function book_node_export($node, $children = '') {
 /**
  * Processes variables for book-node-export-html.tpl.php.
  *
- * The $variables array contains the following elements:
- * - node
- * - children
+ * @param $variables
+ *   An associative array containing the following keys:
+ *   - node
+ *   - children
  *
  * @see book-node-export-html.tpl.php
  */
@@ -1294,6 +1303,12 @@ function template_preprocess_book_node_export_html(&$variables) {
 
 /**
  * Determine if a given node type is in the list of types allowed for books.
+ *
+ * @param $type
+ *   A node type.
+ *
+ * @return
+ *   A Boolean TRUE if the node type can be included in books; otherwise, FALSE.
  */
 function book_type_is_allowed($type) {
   return in_array($type, variable_get('book_allowed_types', array('book')));
@@ -1336,7 +1351,7 @@ function book_node_type_update($type) {
  *
  * @return
  *   A menu link, with the link translated for rendering and data added from the
- *   {book} table.
+ *   {book} table. FALSE if there is an error.
  */
 function book_link_load($mlid) {
   if ($item = db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = :mlid", array(
@@ -1360,7 +1375,7 @@ function book_link_load($mlid) {
  *   A fully loaded menu link.
  *
  * @return
- *   An subtree of menu links in an array, in the order they should be rendered.
+ *   A subtree of menu links in an array, in the order they should be rendered.
  */
 function book_menu_subtree_data($link) {
   $tree = &drupal_static(__FUNCTION__, array());
diff --git a/modules/book/book.pages.inc b/modules/book/book.pages.inc
index 63a1d15..ac4f357 100644
--- a/modules/book/book.pages.inc
+++ b/modules/book/book.pages.inc
@@ -7,6 +7,11 @@
 
 /**
  * Menu callback: Prints a listing of all books.
+ *
+ * @return string
+ *   A HTML-formatted string with the listing of all books content.
+ *
+ * @see book_menu()
  */
 function book_render() {
   $book_list = array();
@@ -36,6 +41,8 @@ function book_render() {
  * @return
  *   A string representing the node and its children in the book hierarchy in a
  *   format determined by the $type parameter.
+ *
+ * @see book_menu()
  */
 function book_export($type, $nid) {
   // Check that the node exists and that the current user has access to it.
@@ -79,7 +86,6 @@ function book_export($type, $nid) {
  */
 function book_export_html($nid) {
   if (user_access('access printer-friendly version')) {
-    $export_data = array();
     $node = node_load($nid);
     if (isset($node->book)) {
       $tree = book_menu_subtree_data($node->book);
@@ -100,6 +106,11 @@ function book_export_html($nid) {
  *
  * @param $node
  *   The book node for which to show the outline.
+ *
+ * @return string
+ *   A HTML-formatted string with the outline form for a single node.
+ *
+  * @see book_menu()
  */
 function book_outline($node) {
   drupal_set_title($node->title);
diff --git a/modules/book/book.test b/modules/book/book.test
index 2708e36..81f4524 100644
--- a/modules/book/book.test
+++ b/modules/book/book.test
@@ -5,14 +5,37 @@
  * Tests for book.module.
  */
 
+/**
+ * Tests the functionality of the Book module.
+ */
 class BookTestCase extends DrupalWebTestCase {
+
+  /**
+   * A book node.
+   *
+   * @var object
+   */
   protected $book;
-  // $book_author is a user with permission to create and edit books.
+
+  /**
+   * A user with permission to create and edit books.
+   *
+   * @var object
+   */
   protected $book_author;
-  // $web_user is a user with permission to view a book
-  // and access the printer-friendly version.
+
+  /**
+   * A user with permission to view a book and access printer-friendly version.
+   *
+   * @var object
+   */
   protected $web_user;
-  // $admin_user is a user with permission to create and edit books and to administer blocks.
+
+  /**
+   * A user with permission to create and edit books and to administer blocks.
+   *
+   * @var object
+   */
   protected $admin_user;
 
   public static function getInfo() {
@@ -36,7 +59,7 @@ class BookTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create a new book with a page hierarchy.
+   * Creates a new book with a page hierarchy.
    */
   function createBook() {
     // Create new book.
@@ -67,7 +90,7 @@ class BookTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test book functionality through node interfaces.
+   * Tests book functionality through node interfaces.
    */
   function testBook() {
     // Create new book.
@@ -106,18 +129,20 @@ class BookTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Check the outline of sub-pages; previous, up, and next; and printer friendly version.
+   * Checks the outline of sub-pages; previous, up, and next.
+   *
+   * Also checks the printer friendly version of the outline.
    *
    * @param $node
    *   Node to check.
    * @param $nodes
    *   Nodes that should be in outline.
    * @param $previous
-   *   Previous link node.
+   *   (optional) Previous link node. Defaults to FALSE.
    * @param $up
-   *   Up link node.
+   *   (optional) Up link node. Defaults to FALSE.
    * @param $next
-   *   Next link node.
+   *   (optional) Next link node. Defaults to FALSE.
    * @param $breadcrumb
    *   The nodes that should be displayed in the breadcrumb.
    */
@@ -129,23 +154,23 @@ class BookTestCase extends DrupalWebTestCase {
 
     // Check outline structure.
     if ($nodes !== NULL) {
-      $this->assertPattern($this->generateOutlinePattern($nodes), t('Node ' . $number . ' outline confirmed.'));
+      $this->assertPattern($this->generateOutlinePattern($nodes), format_string('Node %number outline confirmed.', array('%number' => $number)));
     }
     else {
-      $this->pass(t('Node ' . $number . ' doesn\'t have outline.'));
+      $this->pass(format_string('Node %number does not have outline.', array('%number' => $number)));
     }
 
     // Check previous, up, and next links.
     if ($previous) {
-      $this->assertRaw(l('‹ ' . $previous->title, 'node/' . $previous->nid, array('attributes' => array('class' => array('page-previous'), 'title' => t('Go to previous page')))), t('Previous page link found.'));
+      $this->assertRaw(l('‹ ' . $previous->title, 'node/' . $previous->nid, array('attributes' => array('class' => array('page-previous'), 'title' => t('Go to previous page')))), 'Previous page link found.');
     }
 
     if ($up) {
-      $this->assertRaw(l('up', 'node/' . $up->nid, array('attributes' => array('class' => array('page-up'), 'title' => t('Go to parent page')))), t('Up page link found.'));
+      $this->assertRaw(l('up', 'node/' . $up->nid, array('attributes' => array('class' => array('page-up'), 'title' => t('Go to parent page')))), 'Up page link found.');
     }
 
     if ($next) {
-      $this->assertRaw(l($next->title . ' ›', 'node/' . $next->nid, array('attributes' => array('class' => array('page-next'), 'title' => t('Go to next page')))), t('Next page link found.'));
+      $this->assertRaw(l($next->title . ' ›', 'node/' . $next->nid, array('attributes' => array('class' => array('page-next'), 'title' => t('Go to next page')))), 'Next page link found.');
     }
 
     // Compute the expected breadcrumb.
@@ -163,20 +188,24 @@ class BookTestCase extends DrupalWebTestCase {
     }
 
     // Compare expected and got breadcrumbs.
-    $this->assertIdentical($expected_breadcrumb, $got_breadcrumb, t('The breadcrumb is correctly displayed on the page.'));
+    $this->assertIdentical($expected_breadcrumb, $got_breadcrumb, 'The breadcrumb is correctly displayed on the page.');
 
     // Check printer friendly version.
     $this->drupalGet('book/export/html/' . $node->nid);
-    $this->assertText($node->title, t('Printer friendly title found.'));
-    $this->assertRaw(check_markup($node->body[LANGUAGE_NONE][0]['value'], $node->body[LANGUAGE_NONE][0]['format']), t('Printer friendly body found.'));
+    $this->assertText($node->title, 'Printer friendly title found.');
+    $this->assertRaw(check_markup($node->body[LANGUAGE_NONE][0]['value'], $node->body[LANGUAGE_NONE][0]['format']), 'Printer friendly body found.');
 
     $number++;
   }
 
   /**
-   * Create a regular expression to check for the sub-nodes in the outline.
+   * Creates a regular expression to check for the sub-nodes in the outline.
+   *
+   * @param array $nodes
+   *   An array of nodes to check in outline.
    *
-   * @param array $nodes Nodes to check in outline.
+   * @return
+   *   A regular expression that locates sub-nodes of the outline.
    */
   function generateOutlinePattern($nodes) {
     $outline = '';
@@ -188,10 +217,12 @@ class BookTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create book node.
+   * Creates a book node.
    *
-   * @param integer $book_nid Book node id or set to 'new' to create new book.
-   * @param integer $parent Parent book reference id.
+   * @param $book_nid
+   *   A book node ID or set to 'new' to create a new book.
+   * @param $parent
+   *   (optional) Parent book reference ID. Defaults to NULL.
    */
   function createBookNode($book_nid, $parent = NULL) {
     // $number does not use drupal_static as it should not be reset
@@ -216,7 +247,7 @@ class BookTestCase extends DrupalWebTestCase {
 
     // Check to make sure the book node was created.
     $node = $this->drupalGetNodeByTitle($edit['title']);
-    $this->assertNotNull(($node === FALSE ? NULL : $node), t('Book node found in database.'));
+    $this->assertNotNull(($node === FALSE ? NULL : $node), 'Book node found in database.');
     $number++;
 
     return $node;
@@ -236,28 +267,28 @@ class BookTestCase extends DrupalWebTestCase {
 
     // Make sure each part of the book is there.
     foreach ($nodes as $node) {
-      $this->assertText($node->title, t('Node title found in printer friendly version.'));
-      $this->assertRaw(check_markup($node->body[LANGUAGE_NONE][0]['value'], $node->body[LANGUAGE_NONE][0]['format']), t('Node body found in printer friendly version.'));
+      $this->assertText($node->title, 'Node title found in printer friendly version.');
+      $this->assertRaw(check_markup($node->body[LANGUAGE_NONE][0]['value'], $node->body[LANGUAGE_NONE][0]['format']), 'Node body found in printer friendly version.');
     }
 
     // Make sure we can't export an unsupported format.
     $this->drupalGet('book/export/foobar/' . $this->book->nid);
-    $this->assertResponse('404', t('Unsupported export format returned "not found".'));
+    $this->assertResponse('404', 'Unsupported export format returned "not found".');
 
     // Make sure we get a 404 on a not existing book node.
     $this->drupalGet('book/export/html/123');
-    $this->assertResponse('404', t('Not existing book node returned "not found".'));
+    $this->assertResponse('404', 'Not existing book node returned "not found".');
 
     // Make sure an anonymous user cannot view printer-friendly version.
     $this->drupalLogout();
 
     // Load the book and verify there is no printer-friendly version link.
     $this->drupalGet('node/' . $this->book->nid);
-    $this->assertNoLink(t('Printer-friendly version'), t('Anonymous user is not shown link to printer-friendly version.'));
+    $this->assertNoLink(t('Printer-friendly version'), 'Anonymous user is not shown link to printer-friendly version.');
 
     // Try getting the URL directly, and verify it fails.
     $this->drupalGet('book/export/html/' . $this->book->nid);
-    $this->assertResponse('403', t('Anonymous user properly forbidden.'));
+    $this->assertResponse('403', 'Anonymous user properly forbidden.');
 
     // Now grant anonymous users permission to view the printer-friendly
     // version and verify that node access restrictions still prevent them from
@@ -276,30 +307,30 @@ class BookTestCase extends DrupalWebTestCase {
     // Set block title to confirm that the interface is available.
     $block_title = $this->randomName(16);
     $this->drupalPost('admin/structure/block/manage/book/navigation/configure', array('title' => $block_title), t('Save block'));
-    $this->assertText(t('The block configuration has been saved.'), t('Block configuration set.'));
+    $this->assertText(t('The block configuration has been saved.'), 'Block configuration set.');
 
     // Set the block to a region to confirm block is available.
     $edit = array();
     $edit['blocks[book_navigation][region]'] = 'footer';
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
-    $this->assertText(t('The block settings have been updated.'), t('Block successfully move to footer region.'));
+    $this->assertText(t('The block settings have been updated.'), 'Block successfully move to footer region.');
 
      // Give anonymous users the permission 'node test view'.
      $edit = array();
      $edit[DRUPAL_ANONYMOUS_RID . '[node test view]'] = TRUE;
      $this->drupalPost('admin/people/permissions/' . DRUPAL_ANONYMOUS_RID, $edit, t('Save permissions'));
-     $this->assertText(t('The changes have been saved.'), t("Permission 'node test view' successfully assigned to anonymous users."));
+     $this->assertText(t('The changes have been saved.'), "Permission 'node test view' successfully assigned to anonymous users.");
 
     // Test correct display of the block.
     $nodes = $this->createBook();
     $this->drupalGet('<front>');
-    $this->assertText($block_title, t('Book navigation block is displayed.'));
-    $this->assertText($this->book->title, t('Link to book root (@title) is displayed.', array('@title' => $nodes[0]->title)));
-    $this->assertNoText($nodes[0]->title, t('No links to individual book pages are displayed.'));
+    $this->assertText($block_title, 'Book navigation block is displayed.');
+    $this->assertText($this->book->title, format_string('Link to book root (@title) is displayed.', array('@title' => $nodes[0]->title)));
+    $this->assertNoText($nodes[0]->title, 'No links to individual book pages are displayed.');
   }
 
   /**
-   * Test the book navigation block when an access module is enabled.
+   * Tests the book navigation block when an access module is enabled.
    */
    function testNavigationBlockOnAccessModuleEnabled() {
      $this->drupalLogin($this->admin_user);
@@ -312,19 +343,19 @@ class BookTestCase extends DrupalWebTestCase {
      // Set block display to 'Show block only on book pages'.
      $edit['book_block_mode'] = 'book pages';
      $this->drupalPost('admin/structure/block/manage/book/navigation/configure', $edit, t('Save block'));
-     $this->assertText(t('The block configuration has been saved.'), t('Block configuration set.'));
+     $this->assertText(t('The block configuration has been saved.'), 'Block configuration set.');
 
      // Set the block to a region to confirm block is available.
      $edit = array();
      $edit['blocks[book_navigation][region]'] = 'footer';
      $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
-     $this->assertText(t('The block settings have been updated.'), t('Block successfully move to footer region.'));
+     $this->assertText(t('The block settings have been updated.'), 'Block successfully move to footer region.');
 
      // Give anonymous users the permission 'node test view'.
      $edit = array();
      $edit[DRUPAL_ANONYMOUS_RID . '[node test view]'] = TRUE;
      $this->drupalPost('admin/people/permissions/' . DRUPAL_ANONYMOUS_RID, $edit, t('Save permissions'));
-     $this->assertText(t('The changes have been saved.'), t('Permission \'node test view\' successfully assigned to anonymous users.'));
+     $this->assertText(t('The changes have been saved.'), "Permission 'node test view' successfully assigned to anonymous users.");
 
      // Create a book.
      $this->createBook();
@@ -332,12 +363,12 @@ class BookTestCase extends DrupalWebTestCase {
      // Test correct display of the block to registered users.
      $this->drupalLogin($this->web_user);
      $this->drupalGet('node/' . $this->book->nid);
-     $this->assertText($block_title, t('Book navigation block is displayed to registered users.'));
+     $this->assertText($block_title, 'Book navigation block is displayed to registered users.');
      $this->drupalLogout();
 
      // Test correct display of the block to anonymous users.
      $this->drupalGet('node/' . $this->book->nid);
-     $this->assertText($block_title, t('Book navigation block is displayed to anonymous users.'));
+     $this->assertText($block_title, 'Book navigation block is displayed to anonymous users.');
    }
 
   /**
@@ -350,10 +381,10 @@ class BookTestCase extends DrupalWebTestCase {
 
      // Test access to delete top-level and child book nodes.
      $this->drupalGet('node/' . $this->book->nid . '/outline/remove');
-     $this->assertResponse('403', t('Deleting top-level book node properly forbidden.'));
+     $this->assertResponse('403', 'Deleting top-level book node properly forbidden.');
      $this->drupalPost('node/' . $nodes[4]->nid . '/outline/remove', $edit, t('Remove'));
      $node4 = node_load($nodes[4]->nid, NULL, TRUE);
-     $this->assertTrue(empty($node4->book), t('Deleting child book node properly allowed.'));
+     $this->assertTrue(empty($node4->book), 'Deleting child book node properly allowed.');
 
      // Delete all child book nodes and retest top-level node deletion.
      foreach ($nodes as $node) {
@@ -362,6 +393,6 @@ class BookTestCase extends DrupalWebTestCase {
      node_delete_multiple($nids);
      $this->drupalPost('node/' . $this->book->nid . '/outline/remove', $edit, t('Remove'));
      $node = node_load($this->book->nid, NULL, TRUE);
-     $this->assertTrue(empty($node->book), t('Deleting childless top-level book node properly allowed.'));
+     $this->assertTrue(empty($node->book), 'Deleting childless top-level book node properly allowed.');
    }
 }
diff --git a/modules/color/color.module b/modules/color/color.module
index 9ae7f73..53c54fb 100644
--- a/modules/color/color.module
+++ b/modules/color/color.module
@@ -346,9 +346,10 @@ function color_scheme_form_submit($form, &$form_state) {
     // memory_get_usage(), therefore we won't inadvertently reject a color
     // scheme change based on a faulty memory calculation.
     $usage = memory_get_usage(TRUE);
-    $limit = parse_size(ini_get('memory_limit'));
-    if ($usage + $required > $limit) {
-      drupal_set_message(t('There is not enough memory available to PHP to change this theme\'s color scheme. You need at least %size more. Check the <a href="@url">PHP documentation</a> for more information.', array('%size' => format_size($usage + $required - $limit), '@url' => 'http://www.php.net/manual/ini.core.php#ini.sect.resource-limits')), 'error');
+    $memory_limit = ini_get('memory_limit');
+    $size = parse_size($memory_limit);
+    if (!drupal_check_memory_limit($usage + $required, $memory_limit)) {
+      drupal_set_message(t('There is not enough memory available to PHP to change this theme\'s color scheme. You need at least %size more. Check the <a href="@url">PHP documentation</a> for more information.', array('%size' => format_size($usage + $required - $size), '@url' => 'http://www.php.net/manual/ini.core.php#ini.sect.resource-limits')), 'error');
       return;
     }
   }
diff --git a/modules/comment/comment.admin.inc b/modules/comment/comment.admin.inc
index 4f3d350..43b53e2 100644
--- a/modules/comment/comment.admin.inc
+++ b/modules/comment/comment.admin.inc
@@ -98,13 +98,14 @@ function comment_admin_overview($form, &$form_state, $arg) {
     // Remove the first node title from the node_titles array and attach to
     // the comment.
     $comment->node_title = array_shift($node_titles);
+    $comment_body = field_get_items('comment', $comment, 'comment_body');
     $options[$comment->cid] = array(
       'subject' => array(
         'data' => array(
           '#type' => 'link',
           '#title' => $comment->subject,
           '#href' => 'comment/' . $comment->cid,
-          '#options' => array('attributes' => array('title' => truncate_utf8($comment->comment_body[LANGUAGE_NONE][0]['value'], 128)), 'fragment' => 'comment-' . $comment->cid),
+          '#options' => array('attributes' => array('title' => truncate_utf8($comment_body[0]['value'], 128)), 'fragment' => 'comment-' . $comment->cid),
         ),
       ),
       'author' => theme('username', array('account' => $comment)),
diff --git a/modules/comment/comment.module b/modules/comment/comment.module
index 4241538..a83069f 100644
--- a/modules/comment/comment.module
+++ b/modules/comment/comment.module
@@ -152,7 +152,7 @@ function comment_node_type_load($name) {
 }
 
 /**
- * Entity URI callback.
+ * Implements callback_entity_info_uri().
  */
 function comment_uri($comment) {
   return array(
@@ -2041,7 +2041,8 @@ function comment_form($form, &$form_state, $comment) {
 
   // Attach fields.
   $comment->node_type = 'comment_node_' . $node->type;
-  field_attach_form('comment', $comment, $form, $form_state);
+  $langcode = entity_language('comment', $comment);
+  field_attach_form('comment', $comment, $form, $form_state, $langcode);
 
   return $form;
 }
@@ -2066,7 +2067,8 @@ function comment_preview($comment) {
   $node = node_load($comment->nid);
 
   if (!form_get_errors()) {
-    $comment->format = $comment->comment_body[LANGUAGE_NONE][0]['format'];
+    $comment_body = field_get_items('comment', $comment, 'comment_body');
+    $comment->format = $comment_body[0]['format'];
     // Attach the user and time information.
     if (!empty($comment->name)) {
       $account = user_load_by_name($comment->name);
@@ -2190,7 +2192,9 @@ function comment_submit($comment) {
     // 1) Filter it into HTML
     // 2) Strip out all HTML tags
     // 3) Convert entities back to plain-text.
-    $comment_body = $comment->comment_body[LANGUAGE_NONE][0];
+    $field = field_info_field('comment_body');
+    $langcode = field_is_translatable('comment', $field) ? entity_language('comment', $comment) : LANGUAGE_NONE;
+    $comment_body = $comment->comment_body[$langcode][0];
     if (isset($comment_body['format'])) {
       $comment_text = check_markup($comment_body['value'], $comment_body['format']);
     }
@@ -2284,8 +2288,16 @@ function template_preprocess_comment(&$variables) {
   $variables['comment']   = $comment;
   $variables['node']      = $node;
   $variables['author']    = theme('username', array('account' => $comment));
+
   $variables['created']   = format_date($comment->created);
-  $variables['changed']   = format_date($comment->changed);
+
+  // Avoid calling format_date() twice on the same timestamp.
+  if ($comment->changed == $comment->created) {
+    $variables['changed'] = $variables['created'];
+  }
+  else {
+    $variables['changed'] = format_date($comment->changed);
+  }
 
   $variables['new']       = !empty($comment->new) ? t('new') : '';
   $variables['picture']   = theme_get_setting('toggle_comment_user_picture') ? theme('user_picture', array('account' => $comment)) : '';
diff --git a/modules/contact/contact.test b/modules/contact/contact.test
index 48c8bb0..6693b57 100644
--- a/modules/contact/contact.test
+++ b/modules/contact/contact.test
@@ -36,7 +36,7 @@ class ContactSitewideTestCase extends DrupalWebTestCase {
     $edit = array();
     $edit['contact_default_status'] = TRUE;
     $this->drupalPost('admin/config/people/accounts', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Setting successfully saved.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Setting successfully saved.');
 
     // Delete old categories to ensure that new categories are used.
     $this->deleteCategories();
@@ -56,21 +56,21 @@ class ContactSitewideTestCase extends DrupalWebTestCase {
     $invalid_recipients = array('invalid', 'invalid@', 'invalid@site.', '@site.', '@site.com');
     foreach ($invalid_recipients as $invalid_recipient) {
       $this->addCategory($this->randomName(16), $invalid_recipient, '', FALSE);
-      $this->assertRaw(t('%recipient is an invalid e-mail address.', array('%recipient' => $invalid_recipient)), t('Caught invalid recipient (' . $invalid_recipient . ').'));
+      $this->assertRaw(t('%recipient is an invalid e-mail address.', array('%recipient' => $invalid_recipient)), format_string('Caught invalid recipient (@invalid_recipient).', array('@invalid_recipient' => $invalid_recipient)));
     }
 
     // Test validation of empty category and recipients fields.
     $this->addCategory($category = '', '', '', TRUE);
-    $this->assertText(t('Category field is required.'), t('Caught empty category field'));
-    $this->assertText(t('Recipients field is required.'), t('Caught empty recipients field.'));
+    $this->assertText(t('Category field is required.'), 'Caught empty category field');
+    $this->assertText(t('Recipients field is required.'), 'Caught empty recipients field.');
 
     // Create first valid category.
     $recipients = array('simpletest@example.com', 'simpletest2@example.com', 'simpletest3@example.com');
     $this->addCategory($category = $this->randomName(16), implode(',', array($recipients[0])), '', TRUE);
-    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), t('Category successfully saved.'));
+    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), 'Category successfully saved.');
 
     // Make sure the newly created category is included in the list of categories.
-    $this->assertNoUniqueText($category, t('New category included in categories list.'));
+    $this->assertNoUniqueText($category, 'New category included in categories list.');
 
     // Test update contact form category.
     $categories = $this->getCategories();
@@ -80,80 +80,80 @@ class ContactSitewideTestCase extends DrupalWebTestCase {
     $this->assertEqual($category_array['recipients'], $recipients_str);
     $this->assertEqual($category_array['reply'], $reply);
     $this->assertFalse($category_array['selected']);
-    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), t('Category successfully saved.'));
+    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), 'Category successfully saved.');
 
     // Ensure that the contact form is shown without a category selection input.
     user_role_grant_permissions(DRUPAL_ANONYMOUS_RID, array('access site-wide contact form'));
     $this->drupalLogout();
     $this->drupalGet('contact');
-    $this->assertText(t('Your e-mail address'), t('Contact form is shown when there is one category.'));
-    $this->assertNoText(t('Category'), t('When there is only one category, the category selection element is hidden.'));
+    $this->assertText(t('Your e-mail address'), 'Contact form is shown when there is one category.');
+    $this->assertNoText(t('Category'), 'When there is only one category, the category selection element is hidden.');
     $this->drupalLogin($admin_user);
 
     // Add more categories.
     $this->addCategory($category = $this->randomName(16), implode(',', array($recipients[0], $recipients[1])), '', FALSE);
-    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), t('Category successfully saved.'));
+    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), 'Category successfully saved.');
 
     $this->addCategory($category = $this->randomName(16), implode(',', array($recipients[0], $recipients[1], $recipients[2])), '', FALSE);
-    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), t('Category successfully saved.'));
+    $this->assertRaw(t('Category %category has been saved.', array('%category' => $category)), 'Category successfully saved.');
 
     // Try adding a category that already exists.
     $this->addCategory($category, '', '', FALSE);
-    $this->assertNoRaw(t('Category %category has been saved.', array('%category' => $category)), t('Category not saved.'));
-    $this->assertRaw(t('A contact form with category %category already exists.', array('%category' => $category)), t('Duplicate category error found.'));
+    $this->assertNoRaw(t('Category %category has been saved.', array('%category' => $category)), 'Category not saved.');
+    $this->assertRaw(t('A contact form with category %category already exists.', array('%category' => $category)), 'Duplicate category error found.');
 
     // Clear flood table in preparation for flood test and allow other checks to complete.
     db_delete('flood')->execute();
     $num_records_after = db_query("SELECT COUNT(*) FROM {flood}")->fetchField();
-    $this->assertIdentical($num_records_after, '0', t('Flood table emptied.'));
+    $this->assertIdentical($num_records_after, '0', 'Flood table emptied.');
     $this->drupalLogout();
 
     // Check to see that anonymous user cannot see contact page without permission.
     user_role_revoke_permissions(DRUPAL_ANONYMOUS_RID, array('access site-wide contact form'));
     $this->drupalGet('contact');
-    $this->assertResponse(403, t('Access denied to anonymous user without permission.'));
+    $this->assertResponse(403, 'Access denied to anonymous user without permission.');
 
     // Give anonymous user permission and see that page is viewable.
     user_role_grant_permissions(DRUPAL_ANONYMOUS_RID, array('access site-wide contact form'));
     $this->drupalGet('contact');
-    $this->assertResponse(200, t('Access granted to anonymous user with permission.'));
+    $this->assertResponse(200, 'Access granted to anonymous user with permission.');
 
     // Submit contact form with invalid values.
     $this->submitContact('', $recipients[0], $this->randomName(16), $categories[0], $this->randomName(64));
-    $this->assertText(t('Your name field is required.'), t('Name required.'));
+    $this->assertText(t('Your name field is required.'), 'Name required.');
 
     $this->submitContact($this->randomName(16), '', $this->randomName(16), $categories[0], $this->randomName(64));
-    $this->assertText(t('Your e-mail address field is required.'), t('E-mail required.'));
+    $this->assertText(t('Your e-mail address field is required.'), 'E-mail required.');
 
     $this->submitContact($this->randomName(16), $invalid_recipients[0], $this->randomName(16), $categories[0], $this->randomName(64));
-    $this->assertText(t('You must enter a valid e-mail address.'), t('Valid e-mail required.'));
+    $this->assertText(t('You must enter a valid e-mail address.'), 'Valid e-mail required.');
 
     $this->submitContact($this->randomName(16), $recipients[0], '', $categories[0], $this->randomName(64));
-    $this->assertText(t('Subject field is required.'), t('Subject required.'));
+    $this->assertText(t('Subject field is required.'), 'Subject required.');
 
     $this->submitContact($this->randomName(16), $recipients[0], $this->randomName(16), $categories[0], '');
-    $this->assertText(t('Message field is required.'), t('Message required.'));
+    $this->assertText(t('Message field is required.'), 'Message required.');
 
     // Test contact form with no default category selected.
     db_update('contact')
       ->fields(array('selected' => 0))
       ->execute();
     $this->drupalGet('contact');
-    $this->assertRaw(t('- Please choose -'), t('Without selected categories the visitor is asked to chose a category.'));
+    $this->assertRaw(t('- Please choose -'), 'Without selected categories the visitor is asked to chose a category.');
 
     // Submit contact form with invalid category id (cid 0).
     $this->submitContact($this->randomName(16), $recipients[0], $this->randomName(16), 0, '');
-    $this->assertText(t('You must select a valid category.'), t('Valid category required.'));
+    $this->assertText(t('You must select a valid category.'), 'Valid category required.');
 
     // Submit contact form with correct values and check flood interval.
     for ($i = 0; $i < $flood_limit; $i++) {
       $this->submitContact($this->randomName(16), $recipients[0], $this->randomName(16), $categories[0], $this->randomName(64));
-      $this->assertText(t('Your message has been sent.'), t('Message sent.'));
+      $this->assertText(t('Your message has been sent.'), 'Message sent.');
     }
     // Submit contact form one over limit.
     $this->drupalGet('contact');
-    $this->assertResponse(403, t('Access denied to anonymous user after reaching message treshold.'));
-    $this->assertRaw(t('You cannot send more than %number messages in @interval. Try again later.', array('%number' => variable_get('contact_threshold_limit', 3), '@interval' => format_interval(600))), t('Message threshold reached.'));
+    $this->assertResponse(403, 'Access denied to anonymous user after reaching message treshold.');
+    $this->assertRaw(t('You cannot send more than %number messages in @interval. Try again later.', array('%number' => variable_get('contact_threshold_limit', 3), '@interval' => format_interval(600))), 'Message threshold reached.');
 
     // Delete created categories.
     $this->drupalLogin($admin_user);
@@ -182,8 +182,8 @@ class ContactSitewideTestCase extends DrupalWebTestCase {
 
     // We are testing the auto-reply, so there should be one e-mail going to the sender.
     $captured_emails = $this->drupalGetMails(array('id' => 'contact_page_autoreply', 'to' => $email, 'from' => 'foo@example.com'));
-    $this->assertEqual(count($captured_emails), 1, t('Auto-reply e-mail was sent to the sender for category "foo".'), t('Contact'));
-    $this->assertEqual($captured_emails[0]['body'], drupal_html_to_text($foo_autoreply), t('Auto-reply e-mail body is correct for category "foo".'), t('Contact'));
+    $this->assertEqual(count($captured_emails), 1, 'Auto-reply e-mail was sent to the sender for category "foo".', 'Contact');
+    $this->assertEqual($captured_emails[0]['body'], drupal_html_to_text($foo_autoreply), 'Auto-reply e-mail body is correct for category "foo".', 'Contact');
 
     // Test the auto-reply for category 'bar'.
     $email = $this->randomName(32) . '@example.com';
@@ -191,14 +191,14 @@ class ContactSitewideTestCase extends DrupalWebTestCase {
 
     // Auto-reply for category 'bar' should result in one auto-reply e-mail to the sender.
     $captured_emails = $this->drupalGetMails(array('id' => 'contact_page_autoreply', 'to' => $email, 'from' => 'bar@example.com'));
-    $this->assertEqual(count($captured_emails), 1, t('Auto-reply e-mail was sent to the sender for category "bar".'), t('Contact'));
-    $this->assertEqual($captured_emails[0]['body'], drupal_html_to_text($bar_autoreply), t('Auto-reply e-mail body is correct for category "bar".'), t('Contact'));
+    $this->assertEqual(count($captured_emails), 1, 'Auto-reply e-mail was sent to the sender for category "bar".', 'Contact');
+    $this->assertEqual($captured_emails[0]['body'], drupal_html_to_text($bar_autoreply), 'Auto-reply e-mail body is correct for category "bar".', 'Contact');
 
     // Verify that no auto-reply is sent when the auto-reply field is left blank.
     $email = $this->randomName(32) . '@example.com';
     $this->submitContact($this->randomName(16), $email, $this->randomString(64), 4, $this->randomString(128));
     $captured_emails = $this->drupalGetMails(array('id' => 'contact_page_autoreply', 'to' => $email, 'from' => 'no_autoreply@example.com'));
-    $this->assertEqual(count($captured_emails), 0, t('No auto-reply e-mail was sent to the sender for category "no-autoreply".'), t('Contact'));
+    $this->assertEqual(count($captured_emails), 0, 'No auto-reply e-mail was sent to the sender for category "no-autoreply".', 'Contact');
   }
 
   /**
@@ -279,7 +279,7 @@ class ContactSitewideTestCase extends DrupalWebTestCase {
     foreach ($categories as $category) {
       $category_name = db_query("SELECT category FROM {contact} WHERE cid = :cid", array(':cid' => $category))->fetchField();
       $this->drupalPost('admin/structure/contact/delete/' . $category, array(), t('Delete'));
-      $this->assertRaw(t('Category %category has been deleted.', array('%category' => $category_name)), t('Category deleted successfully.'));
+      $this->assertRaw(t('Category %category has been deleted.', array('%category' => $category_name)), 'Category deleted successfully.');
     }
   }
 
@@ -355,7 +355,7 @@ class ContactPersonalTestCase extends DrupalWebTestCase {
     $this->drupalLogin($this->admin_user);
     $edit = array('contact_default_status' => FALSE);
     $this->drupalPost('admin/config/people/accounts', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Setting successfully saved.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Setting successfully saved.');
     $this->drupalLogout();
 
     // Re-create our contacted user with personal contact forms disabled by
diff --git a/modules/contextual/contextual.css b/modules/contextual/contextual.css
index 3829328..93a1796 100644
--- a/modules/contextual/contextual.css
+++ b/modules/contextual/contextual.css
@@ -77,7 +77,7 @@ div.contextual-links-wrapper ul.contextual-links {
   -webkit-border-top-left-radius: 4px; /* LTR */
   border-radius: 4px 0 4px 4px; /* LTR */
 }
-.contextual-links-region:hover a.contextual-links-trigger,
+a.contextual-links-trigger-active,
 div.contextual-links-active a.contextual-links-trigger,
 div.contextual-links-active ul.contextual-links {
   display: block;
diff --git a/modules/contextual/contextual.js b/modules/contextual/contextual.js
index ebe5091..4339780 100644
--- a/modules/contextual/contextual.js
+++ b/modules/contextual/contextual.js
@@ -30,6 +30,10 @@ Drupal.behaviors.contextualLinks = {
       );
       // Hide the contextual links when user clicks a link or rolls out of the .contextual-links-region.
       $region.bind('mouseleave click', Drupal.contextualLinks.mouseleave);
+      $region.hover(
+        function() { $trigger.addClass('contextual-links-trigger-active'); },
+        function() { $trigger.removeClass('contextual-links-trigger-active'); }
+      );
       // Prepend the trigger.
       $wrapper.prepend($trigger);
     });
diff --git a/modules/dashboard/dashboard.js b/modules/dashboard/dashboard.js
index 83ffc1f..62f13a4 100644
--- a/modules/dashboard/dashboard.js
+++ b/modules/dashboard/dashboard.js
@@ -9,7 +9,7 @@
  * Implements Drupal.behaviors for the Dashboard module.
  */
 Drupal.behaviors.dashboard = {
-    attach: function (context, settings) {
+  attach: function (context, settings) {
     $('#dashboard', context).once(function () {
       $(this).prepend('<div class="customize clearfix"><ul class="action-links"><li><a href="#">' + Drupal.t('Customize dashboard') + '</a></li></ul><div class="canvas"></div></div>');
       $('.customize .action-links a', this).click(Drupal.behaviors.dashboard.enterCustomizeMode);
diff --git a/modules/dblog/dblog-rtl.css b/modules/dblog/dblog-rtl.css
index 282fe97..0fab8d0 100644
--- a/modules/dblog/dblog-rtl.css
+++ b/modules/dblog/dblog-rtl.css
@@ -1,3 +1,7 @@
+/**
+ * @file
+ * Right-to-Left styling for the Database Logging module.
+ */
 
 .form-item-type,
 .form-item-severity {
diff --git a/modules/dblog/dblog.admin.inc b/modules/dblog/dblog.admin.inc
index 0655e75..7c1c0e2 100644
--- a/modules/dblog/dblog.admin.inc
+++ b/modules/dblog/dblog.admin.inc
@@ -2,14 +2,19 @@
 
 /**
  * @file
- * Administrative page callbacks for the dblog module.
+ * Administrative page callbacks for the Database Logging module.
  */
 
 /**
- * Menu callback; displays a listing of log messages.
+ * Page callback: Displays a listing of database log messages.
  *
- * Messages are truncated at 56 chars. Full-length message could be viewed at
- * the message details page.
+ * Messages are truncated at 56 chars. Full-length messages can be viewed on the
+ * message details page.
+ *
+ * @see dblog_clear_log_form()
+ * @see dblog_event()
+ * @see dblog_filter_form()
+ * @see dblog_menu()
  *
  * @ingroup logging_severity_levels
  */
@@ -81,12 +86,18 @@ function dblog_overview() {
 }
 
 /**
- * Menu callback; generic function to display a page of the most frequent events.
+ * Page callback: Shows the most frequent log messages of a given event type.
+ *
+ * Messages are not truncated on this page because events detailed herein do not
+ * have links to a detailed view.
+ *
+ * @param string $type
+ *   Type of database log events to display (e.g., 'search').
  *
- * Messages are not truncated because events from this page have no detail view.
+ * @return array
+ *   A build array in the format expected by drupal_render().
  *
- * @param $type
- *   type of dblog events to display.
+ * @see dblog_menu()
  */
 function dblog_top($type) {
 
@@ -127,7 +138,16 @@ function dblog_top($type) {
 }
 
 /**
- * Menu callback; displays details about a log message.
+ * Page callback: Displays details about a specific database log message.
+ *
+ * @param int $id
+ *   Unique ID of the database log message.
+ *
+ * @return array|string
+ *   If the ID is located in the Database Logging table, a build array in the
+ *   format expected by drupal_render(); otherwise, an empty string.
+ *
+ * @see dblog_menu()
  */
 function dblog_event($id) {
   $severity = watchdog_severity_levels();
@@ -184,7 +204,10 @@ function dblog_event($id) {
 }
 
 /**
- * Build query for dblog administration filters based on session.
+ * Builds a query for database log administration filters based on session.
+ *
+ * @return array
+ *   An associative array with keys 'where' and 'args'.
  */
 function dblog_build_filter_query() {
   if (empty($_SESSION['dblog_overview_filter'])) {
@@ -213,9 +236,16 @@ function dblog_build_filter_query() {
   );
 }
 
-
 /**
- * List dblog administration filters that can be applied.
+ * Creates a list of database log administration filters that can be applied.
+ *
+ * @return array
+ *   Associative array of filters. The top-level keys are used as the form
+ *   element names for the filters, and the values are arrays with the following
+ *   elements:
+ *   - title: Title of the filter.
+ *   - where: The filter condition.
+ *   - options: Array of options for the select list for the filter.
  */
 function dblog_filters() {
   $filters = array();
@@ -244,7 +274,7 @@ function dblog_filters() {
 /**
  * Returns HTML for a log message.
  *
- * @param $variables
+ * @param array $variables
  *   An associative array containing:
  *   - event: An object with at least the message and variables properties.
  *   - link: (optional) Format message as link, event->wid is required.
@@ -274,11 +304,13 @@ function theme_dblog_message($variables) {
 }
 
 /**
- * Return form for dblog administration filters.
+ * Form constructor for the database logging filter form.
  *
- * @ingroup forms
- * @see dblog_filter_form_submit()
  * @see dblog_filter_form_validate()
+ * @see dblog_filter_form_submit()
+ * @see dblog_overview()
+ *
+ * @ingroup forms
  */
 function dblog_filter_form($form) {
   $filters = dblog_filters();
@@ -316,12 +348,13 @@ function dblog_filter_form($form) {
       '#value' => t('Reset')
     );
   }
-
   return $form;
 }
 
 /**
- * Validate result from dblog administration filter form.
+ * Form validation handler for dblog_filter_form().
+ *
+ * @see dblog_filter_form_submit()
  */
 function dblog_filter_form_validate($form, &$form_state) {
   if ($form_state['values']['op'] == t('Filter') && empty($form_state['values']['type']) && empty($form_state['values']['severity'])) {
@@ -330,7 +363,9 @@ function dblog_filter_form_validate($form, &$form_state) {
 }
 
 /**
- * Process result from dblog administration filter form.
+ * Form submission handler for dblog_filter_form().
+ *
+ * @see dblog_filter_form_validate()
  */
 function dblog_filter_form_submit($form, &$form_state) {
   $op = $form_state['values']['op'];
@@ -351,10 +386,10 @@ function dblog_filter_form_submit($form, &$form_state) {
 }
 
 /**
- * Return form for dblog clear button.
+ * Form constructor for the form that clears out the log.
  *
- * @ingroup forms
  * @see dblog_clear_log_submit()
+ * @ingroup forms
  */
 function dblog_clear_log_form($form) {
   $form['dblog_clear'] = array(
@@ -374,7 +409,7 @@ function dblog_clear_log_form($form) {
 }
 
 /**
- * Submit callback: clear database with log messages.
+ * Form submission handler for dblog_clear_log_form().
  */
 function dblog_clear_log_submit() {
   $_SESSION['dblog_overview_filter'] = array();
diff --git a/modules/dblog/dblog.css b/modules/dblog/dblog.css
index 88f4ba0..b127886 100644
--- a/modules/dblog/dblog.css
+++ b/modules/dblog/dblog.css
@@ -1,3 +1,8 @@
+/**
+ * @file
+ * Admin styles for the Database Logging module.
+ */
+
 .form-item-type,
 .form-item-severity {
   float: left; /* LTR */
diff --git a/modules/dblog/dblog.install b/modules/dblog/dblog.install
index 1eedcb0..abfd9a2 100644
--- a/modules/dblog/dblog.install
+++ b/modules/dblog/dblog.install
@@ -85,6 +85,7 @@ function dblog_schema() {
     'indexes' => array(
       'type' => array('type'),
       'uid' => array('uid'),
+      'severity' => array('severity'),
     ),
   );
 
@@ -140,3 +141,19 @@ function dblog_update_7001() {
 /**
  * @} End of "addtogroup updates-6.x-to-7.x".
  */
+
+/**
+ * @addtogroup updates-7.x-extra
+ * @{
+ */
+
+/**
+ * Add an index to the severity column in the watchdog database table.
+ */
+function dblog_update_7002() {
+  db_add_index('watchdog', 'severity', array('severity'));
+}
+
+/**
+ * @} End of "addtogroup updates-7.x-extra".
+ */
diff --git a/modules/dblog/dblog.module b/modules/dblog/dblog.module
index d831548..9183eed 100644
--- a/modules/dblog/dblog.module
+++ b/modules/dblog/dblog.module
@@ -4,9 +4,9 @@
  * @file
  * System monitoring and logging for administrators.
  *
- * The dblog module monitors your site and keeps a list of
- * recorded events containing usage and performance data, errors,
- * warnings, and similar operational information.
+ * The Database Logging module monitors your site and keeps a list of recorded
+ * events containing usage and performance data, errors, warnings, and similar
+ * operational information.
  *
  * @see watchdog()
  */
@@ -96,7 +96,7 @@ function dblog_init() {
 /**
  * Implements hook_cron().
  *
- * Remove expired log messages.
+ * Controls the size of the log table, paring it to 'dblog_row_limit' messages.
  */
 function dblog_cron() {
   // Cleanup the watchdog table.
@@ -121,6 +121,12 @@ function dblog_cron() {
   }
 }
 
+/**
+ * Gathers a list of uniquely defined database log message types.
+ *
+ * @return array
+ *   List of uniquely defined database log message types.
+ */
 function _dblog_get_message_types() {
   $types = array();
 
@@ -135,7 +141,7 @@ function _dblog_get_message_types() {
 /**
  * Implements hook_watchdog().
  *
- * Note some values may be truncated for database column size restrictions.
+ * Note: Some values may be truncated to meet database column size restrictions.
  */
 function dblog_watchdog(array $log_entry) {
   Database::getConnection('default', 'default')->insert('watchdog')
@@ -155,7 +161,7 @@ function dblog_watchdog(array $log_entry) {
 }
 
 /**
- * Implements hook_form_FORM_ID_alter().
+ * Implements hook_form_FORM_ID_alter() for system_logging_settings().
  */
 function dblog_form_system_logging_settings_alter(&$form, $form_state) {
   $form['dblog_row_limit'] = array(
diff --git a/modules/dblog/dblog.test b/modules/dblog/dblog.test
index ad01e97..f1d1034 100644
--- a/modules/dblog/dblog.test
+++ b/modules/dblog/dblog.test
@@ -5,8 +5,23 @@
  * Tests for dblog.module.
  */
 
+/**
+ * Tests logging messages to the database.
+ */
 class DBLogTestCase extends DrupalWebTestCase {
+
+  /**
+   * A user with some relevent administrative permissions.
+   *
+   * @var object
+   */
   protected $big_user;
+
+  /**
+   * A user without any permissions.
+   *
+   * @var object
+   */
   protected $any_user;
 
   public static function getInfo() {
@@ -28,7 +43,11 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Login users, create dblog events, and test dblog functionality through the admin and user interfaces.
+   * Tests Database Logging module functionality through interfaces.
+   *
+   * First logs in users, then creates database log events, and finally tests
+   * Database Logging module functionality through both the admin and user
+   * interfaces.
    */
   function testDBLog() {
     // Login the admin user.
@@ -46,12 +65,13 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Verify setting of the dblog row limit.
+   * Verifies setting of the database log row limit.
    *
-   * @param integer $count Log row limit.
+   * @param int $row_limit
+   *   The row limit.
    */
   private function verifyRowLimit($row_limit) {
-    // Change the dblog row limit.
+    // Change the database log row limit.
     $edit = array();
     $edit['dblog_row_limit'] = $row_limit;
     $this->drupalPost('admin/config/development/logging', $edit, t('Save configuration'));
@@ -59,40 +79,42 @@ class DBLogTestCase extends DrupalWebTestCase {
 
     // Check row limit variable.
     $current_limit = variable_get('dblog_row_limit', 1000);
-    $this->assertTrue($current_limit == $row_limit, t('[Cache] Row limit variable of @count equals row limit of @limit', array('@count' => $current_limit, '@limit' => $row_limit)));
+    $this->assertTrue($current_limit == $row_limit, format_string('[Cache] Row limit variable of @count equals row limit of @limit', array('@count' => $current_limit, '@limit' => $row_limit)));
     // Verify dblog row limit equals specified row limit.
     $current_limit = unserialize(db_query("SELECT value FROM {variable} WHERE name = :dblog_limit", array(':dblog_limit' => 'dblog_row_limit'))->fetchField());
-    $this->assertTrue($current_limit == $row_limit, t('[Variable table] Row limit variable of @count equals row limit of @limit', array('@count' => $current_limit, '@limit' => $row_limit)));
+    $this->assertTrue($current_limit == $row_limit, format_string('[Variable table] Row limit variable of @count equals row limit of @limit', array('@count' => $current_limit, '@limit' => $row_limit)));
   }
 
   /**
-   * Verify cron applies the dblog row limit.
+   * Verifies that cron correctly applies the database log row limit.
    *
-   * @param integer $count Log row limit.
+   * @param int $row_limit
+   *   The row limit.
    */
   private function verifyCron($row_limit) {
     // Generate additional log entries.
     $this->generateLogEntries($row_limit + 10);
-    // Verify dblog row count exceeds row limit.
+    // Verify that the database log row count exceeds the row limit.
     $count = db_query('SELECT COUNT(wid) FROM {watchdog}')->fetchField();
-    $this->assertTrue($count > $row_limit, t('Dblog row count of @count exceeds row limit of @limit', array('@count' => $count, '@limit' => $row_limit)));
+    $this->assertTrue($count > $row_limit, format_string('Dblog row count of @count exceeds row limit of @limit', array('@count' => $count, '@limit' => $row_limit)));
 
-    // Run cron job.
+    // Run a cron job.
     $this->cronRun();
-    // Verify dblog row count equals row limit plus one because cron adds a record after it runs.
+    // Verify that the database log row count equals the row limit plus one
+    // because cron adds a record after it runs.
     $count = db_query('SELECT COUNT(wid) FROM {watchdog}')->fetchField();
-    $this->assertTrue($count == $row_limit + 1, t('Dblog row count of @count equals row limit of @limit plus one', array('@count' => $count, '@limit' => $row_limit)));
+    $this->assertTrue($count == $row_limit + 1, format_string('Dblog row count of @count equals row limit of @limit plus one', array('@count' => $count, '@limit' => $row_limit)));
   }
 
   /**
-   * Generate dblog entries.
+   * Generates a number of random database log events.
    *
-   * @param integer $count
-   *   Number of log entries to generate.
-   * @param $type
-   *   The type of watchdog entry.
-   * @param $severity
-   *   The severity of the watchdog entry.
+   * @param int $count
+   *   Number of watchdog entries to generate.
+   * @param string $type
+   *   (optional) The type of watchdog entry. Defaults to 'custom'.
+   * @param int $severity
+   *   (optional) The severity of the watchdog entry. Defaults to WATCHDOG_NOTICE.
    */
   private function generateLogEntries($count, $type = 'custom', $severity = WATCHDOG_NOTICE) {
     global $base_root;
@@ -119,51 +141,52 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Verify the logged in user has the desired access to the various dblog nodes.
+   * Confirms that database log reports are displayed at the correct paths.
    *
-   * @param integer $response HTTP response code.
+   * @param int $response
+   *   (optional) HTTP response code. Defaults to 200.
    */
   private function verifyReports($response = 200) {
     $quote = '&#039;';
 
-    // View dblog help node.
+    // View the database log help page.
     $this->drupalGet('admin/help/dblog');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Database logging'), t('DBLog help was displayed'));
+      $this->assertText(t('Database logging'), 'DBLog help was displayed');
     }
 
-    // View dblog report node.
+    // View the database log report page.
     $this->drupalGet('admin/reports/dblog');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Recent log messages'), t('DBLog report was displayed'));
+      $this->assertText(t('Recent log messages'), 'DBLog report was displayed');
     }
 
-    // View dblog page-not-found report node.
+    // View the database log page-not-found report page.
     $this->drupalGet('admin/reports/page-not-found');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Top ' . $quote . 'page not found' . $quote . ' errors'), t('DBLog page-not-found report was displayed'));
+      $this->assertText(t('Top ' . $quote . 'page not found' . $quote . ' errors'), 'DBLog page-not-found report was displayed');
     }
 
-    // View dblog access-denied report node.
+    // View the database log access-denied report page.
     $this->drupalGet('admin/reports/access-denied');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Top ' . $quote . 'access denied' . $quote . ' errors'), t('DBLog access-denied report was displayed'));
+      $this->assertText(t('Top ' . $quote . 'access denied' . $quote . ' errors'), 'DBLog access-denied report was displayed');
     }
 
-    // View dblog event node.
+    // View the database log event page.
     $this->drupalGet('admin/reports/event/1');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Details'), t('DBLog event node was displayed'));
+      $this->assertText(t('Details'), 'DBLog event node was displayed');
     }
   }
 
   /**
-   * Verify events.
+   * Generates and then verifies various types of events.
    */
   private function verifyEvents() {
     // Invoke events.
@@ -179,14 +202,14 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Generate and verify user events.
-   *
+   * Generates and then verifies some user events.
    */
   private function doUser() {
     // Set user variables.
     $name = $this->randomName();
     $pass = user_password();
-    // Add user using form to generate add user event (which is not triggered by drupalCreateUser).
+    // Add a user using the form to generate an add user event (which is not
+    // triggered by drupalCreateUser).
     $edit = array();
     $edit['name'] = $name;
     $edit['mail'] = $name . '@example.com';
@@ -195,44 +218,46 @@ class DBLogTestCase extends DrupalWebTestCase {
     $edit['status'] = 1;
     $this->drupalPost('admin/people/create', $edit, t('Create new account'));
     $this->assertResponse(200);
-    // Retrieve user object.
+    // Retrieve the user object.
     $user = user_load_by_name($name);
-    $this->assertTrue($user != NULL, t('User @name was loaded', array('@name' => $name)));
-    $user->pass_raw = $pass; // Needed by drupalLogin.
+    $this->assertTrue($user != NULL, format_string('User @name was loaded', array('@name' => $name)));
+    // pass_raw property is needed by drupalLogin.
+    $user->pass_raw = $pass;
     // Login user.
     $this->drupalLogin($user);
     // Logout user.
     $this->drupalLogout();
-    // Fetch row ids in watchdog that relate to the user.
+    // Fetch the row IDs in watchdog that relate to the user.
     $result = db_query('SELECT wid FROM {watchdog} WHERE uid = :uid', array(':uid' => $user->uid));
     foreach ($result as $row) {
       $ids[] = $row->wid;
     }
     $count_before = (isset($ids)) ? count($ids) : 0;
-    $this->assertTrue($count_before > 0, t('DBLog contains @count records for @name', array('@count' => $count_before, '@name' => $user->name)));
+    $this->assertTrue($count_before > 0, format_string('DBLog contains @count records for @name', array('@count' => $count_before, '@name' => $user->name)));
 
     // Login the admin user.
     $this->drupalLogin($this->big_user);
-    // Delete user.
+    // Delete the user created at the start of this test.
     // We need to POST here to invoke batch_process() in the internal browser.
     $this->drupalPost('user/' . $user->uid . '/cancel', array('user_cancel_method' => 'user_cancel_reassign'), t('Cancel account'));
 
-    // View the dblog report.
+    // View the database log report.
     $this->drupalGet('admin/reports/dblog');
     $this->assertResponse(200);
 
-    // Verify events were recorded.
+    // Verify that the expected events were recorded.
     // Add user.
-    // Default display includes name and email address; if too long then email is replaced by three periods.
-    $this->assertLogMessage(t('New user: %name (%email).', array('%name' => $name, '%email' => $user->mail)), t('DBLog event was recorded: [add user]'));
+    // Default display includes name and email address; if too long, the email
+    // address is replaced by three periods.
+    $this->assertLogMessage(t('New user: %name (%email).', array('%name' => $name, '%email' => $user->mail)), 'DBLog event was recorded: [add user]');
     // Login user.
-    $this->assertLogMessage(t('Session opened for %name.', array('%name' => $name)), t('DBLog event was recorded: [login user]'));
+    $this->assertLogMessage(t('Session opened for %name.', array('%name' => $name)), 'DBLog event was recorded: [login user]');
     // Logout user.
-    $this->assertLogMessage(t('Session closed for %name.', array('%name' => $name)), t('DBLog event was recorded: [logout user]'));
+    $this->assertLogMessage(t('Session closed for %name.', array('%name' => $name)), 'DBLog event was recorded: [logout user]');
     // Delete user.
     $message = t('Deleted user: %name %email.', array('%name' => $name, '%email' => '<' . $user->mail . '>'));
     $message_text = truncate_utf8(filter_xss($message, array()), 56, TRUE, TRUE);
-    // Verify full message on details page.
+    // Verify that the full message displays on the details page.
     $link = FALSE;
     if ($links = $this->xpath('//a[text()="' . html_entity_decode($message_text) . '"]')) {
       // Found link with the message text.
@@ -243,27 +268,28 @@ class DBLogTestCase extends DrupalWebTestCase {
           $link = drupal_substr($value, strpos($value, 'admin/reports/event/'));
           $this->drupalGet($link);
           // Check for full message text on the details page.
-          $this->assertRaw($message, t('DBLog event details was found: [delete user]'));
+          $this->assertRaw($message, 'DBLog event details was found: [delete user]');
           break;
         }
       }
     }
-    $this->assertTrue($link, t('DBLog event was recorded: [delete user]'));
+    $this->assertTrue($link, 'DBLog event was recorded: [delete user]');
     // Visit random URL (to generate page not found event).
     $not_found_url = $this->randomName(60);
     $this->drupalGet($not_found_url);
     $this->assertResponse(404);
-    // View dblog page-not-found report page.
+    // View the database log page-not-found report page.
     $this->drupalGet('admin/reports/page-not-found');
     $this->assertResponse(200);
     // Check that full-length URL displayed.
-    $this->assertText($not_found_url, t('DBLog event was recorded: [page not found]'));
+    $this->assertText($not_found_url, 'DBLog event was recorded: [page not found]');
   }
 
   /**
-   * Generate and verify node events.
+   * Generates and then verifies some node events.
    *
-   * @param string $type Content type.
+   * @param string $type
+   *   A node type (e.g., 'article', 'page' or 'poll').
    */
   private function doNode($type) {
     // Create user.
@@ -272,61 +298,65 @@ class DBLogTestCase extends DrupalWebTestCase {
     // Login user.
     $this->drupalLogin($user);
 
-    // Create node using form to generate add content event (which is not triggered by drupalCreateNode).
+    // Create a node using the form in order to generate an add content event
+    // (which is not triggered by drupalCreateNode).
     $edit = $this->getContent($type);
     $langcode = LANGUAGE_NONE;
     $title = $edit["title"];
     $this->drupalPost('node/add/' . $type, $edit, t('Save'));
     $this->assertResponse(200);
-    // Retrieve node object.
+    // Retrieve the node object.
     $node = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($node != NULL, t('Node @title was loaded', array('@title' => $title)));
-    // Edit node.
+    $this->assertTrue($node != NULL, format_string('Node @title was loaded', array('@title' => $title)));
+    // Edit the node.
     $edit = $this->getContentUpdate($type);
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
     $this->assertResponse(200);
-    // Delete node.
+    // Delete the node.
     $this->drupalPost('node/' . $node->nid . '/delete', array(), t('Delete'));
     $this->assertResponse(200);
-    // View node (to generate page not found event).
+    // View the node (to generate page not found event).
     $this->drupalGet('node/' . $node->nid);
     $this->assertResponse(404);
-    // View the dblog report (to generate access denied event).
+    // View the database log report (to generate access denied event).
     $this->drupalGet('admin/reports/dblog');
     $this->assertResponse(403);
 
     // Login the admin user.
     $this->drupalLogin($this->big_user);
-    // View the dblog report.
+    // View the database log report.
     $this->drupalGet('admin/reports/dblog');
     $this->assertResponse(200);
 
-    // Verify events were recorded.
-    // Content added.
-    $this->assertLogMessage(t('@type: added %title.', array('@type' => $type, '%title' => $title)), t('DBLog event was recorded: [content added]'));
-    // Content updated.
-    $this->assertLogMessage(t('@type: updated %title.', array('@type' => $type, '%title' => $title)), t('DBLog event was recorded: [content updated]'));
-    // Content deleted.
-    $this->assertLogMessage(t('@type: deleted %title.', array('@type' => $type, '%title' => $title)), t('DBLog event was recorded: [content deleted]'));
+    // Verify that node events were recorded.
+    // Was node content added?
+    $this->assertLogMessage(t('@type: added %title.', array('@type' => $type, '%title' => $title)), 'DBLog event was recorded: [content added]');
+    // Was node content updated?
+    $this->assertLogMessage(t('@type: updated %title.', array('@type' => $type, '%title' => $title)), 'DBLog event was recorded: [content updated]');
+    // Was node content deleted?
+    $this->assertLogMessage(t('@type: deleted %title.', array('@type' => $type, '%title' => $title)), 'DBLog event was recorded: [content deleted]');
 
-    // View dblog access-denied report node.
+    // View the database log access-denied report page.
     $this->drupalGet('admin/reports/access-denied');
     $this->assertResponse(200);
-    // Access denied.
-    $this->assertText(t('admin/reports/dblog'), t('DBLog event was recorded: [access denied]'));
+    // Verify that the 'access denied' event was recorded.
+    $this->assertText(t('admin/reports/dblog'), 'DBLog event was recorded: [access denied]');
 
-    // View dblog page-not-found report node.
+    // View the database log page-not-found report page.
     $this->drupalGet('admin/reports/page-not-found');
     $this->assertResponse(200);
-    // Page not found.
-    $this->assertText(t('node/@nid', array('@nid' => $node->nid)), t('DBLog event was recorded: [page not found]'));
+    // Verify that the 'page not found' event was recorded.
+    $this->assertText(t('node/@nid', array('@nid' => $node->nid)), 'DBLog event was recorded: [page not found]');
   }
 
   /**
-   * Create content based on content type.
+   * Creates random content based on node content type.
    *
-   * @param string $type Content type.
-   * @return array Content.
+   * @param string $type
+   *   Node content type (e.g., 'article').
+   *
+   * @return array
+   *   Random content needed by various node types.
    */
   private function getContent($type) {
     $langcode = LANGUAGE_NONE;
@@ -350,10 +380,13 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create content update based on content type.
+   * Creates random content as an update based on node content type.
+   *
+   * @param string $type
+   *   Node content type (e.g., 'article').
    *
-   * @param string $type Content type.
-   * @return array Content.
+   * @return array
+   *   Random content needed by various node types.
    */
   private function getContentUpdate($type) {
     switch ($type) {
@@ -375,11 +408,14 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Login an admin user, create dblog event, and test clearing dblog functionality through the admin interface.
+   * Tests the addition and clearing of log events through the admin interface.
+   *
+   * Logs in the admin user, creates a database log event, and tests the
+   * functionality of clearing the database log through the admin interface.
    */
   protected function testDBLogAddAndClear() {
     global $base_root;
-    // Get a count of how many watchdog entries there are.
+    // Get a count of how many watchdog entries already exist.
     $count = db_query('SELECT COUNT(*) FROM {watchdog}')->fetchField();
     $log = array(
       'type'        => 'custom',
@@ -396,27 +432,27 @@ class DBLogTestCase extends DrupalWebTestCase {
     );
     // Add a watchdog entry.
     dblog_watchdog($log);
-    // Make sure the table count has actually incremented.
-    $this->assertEqual($count + 1, db_query('SELECT COUNT(*) FROM {watchdog}')->fetchField(), t('dblog_watchdog() added an entry to the dblog :count', array(':count' => $count)));
+    // Make sure the table count has actually been incremented.
+    $this->assertEqual($count + 1, db_query('SELECT COUNT(*) FROM {watchdog}')->fetchField(), format_string('dblog_watchdog() added an entry to the dblog :count', array(':count' => $count)));
     // Login the admin user.
     $this->drupalLogin($this->big_user);
-    // Now post to clear the db table.
+    // Post in order to clear the database table.
     $this->drupalPost('admin/reports/dblog', array(), t('Clear log messages'));
-    // Count rows in watchdog that previously related to the deleted user.
+    // Count the rows in watchdog that previously related to the deleted user.
     $count = db_query('SELECT COUNT(*) FROM {watchdog}')->fetchField();
-    $this->assertEqual($count, 0, t('DBLog contains :count records after a clear.', array(':count' => $count)));
+    $this->assertEqual($count, 0, format_string('DBLog contains :count records after a clear.', array(':count' => $count)));
   }
 
   /**
-   * Test the dblog filter on admin/reports/dblog.
+   * Tests the database log filter functionality at admin/reports/dblog.
    */
   protected function testFilter() {
     $this->drupalLogin($this->big_user);
 
-    // Clear log to ensure that only generated entries are found.
+    // Clear the log to ensure that only generated entries will be found.
     db_delete('watchdog')->execute();
 
-    // Generate watchdog entries.
+    // Generate 9 random watchdog entries.
     $type_names = array();
     $types = array();
     for ($i = 0; $i < 3; $i++) {
@@ -432,10 +468,10 @@ class DBLogTestCase extends DrupalWebTestCase {
       }
     }
 
-    // View the dblog.
+    // View the database log page.
     $this->drupalGet('admin/reports/dblog');
 
-    // Confirm all the entries are displayed.
+    // Confirm that all the entries are displayed.
     $count = $this->getTypeCount($types);
     foreach ($types as $key => $type) {
       $this->assertEqual($count[$key], $type['count'], 'Count matched');
@@ -461,8 +497,8 @@ class DBLogTestCase extends DrupalWebTestCase {
       $this->assertEqual(array_sum($count), $type_count, 'Count matched');
     }
 
-    // Set filter to match each of the three type attributes and confirm the
-    // number of entries displayed.
+    // Set the filter to match each of the two filter-type attributes and
+    // confirm the correct number of entries are displayed.
     foreach ($types as $key => $type) {
       $edit = array(
         'type[]' => array($type['type']),
@@ -476,14 +512,18 @@ class DBLogTestCase extends DrupalWebTestCase {
 
     // Clear all logs and make sure the confirmation message is found.
     $this->drupalPost('admin/reports/dblog', array(), t('Clear log messages'));
-    $this->assertText(t('Database log cleared.'), t('Confirmation message found'));
+    $this->assertText(t('Database log cleared.'), 'Confirmation message found');
   }
 
   /**
-   * Get the log entry information form the page.
+   * Gets the database log event information from the browser page.
    *
-   * @return
-   *   List of entries and their information.
+   * @return array
+   *   List of log events where each event is an array with following keys:
+   *   - severity: (int) A database log severity constant.
+   *   - type: (string) The type of database log event.
+   *   - message: (string) The message for this database log event.
+   *   - user: (string) The user associated with this database log event.
    */
   protected function getLogEntries() {
     $entries = array();
@@ -502,11 +542,12 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Get the count of entries per type.
+   * Gets the count of database log entries by database log event type.
    *
-   * @param $types
+   * @param array $types
    *   The type information to compare against.
-   * @return
+   *
+   * @return array
    *   The count of each type keyed by the key of the $types array.
    */
   protected function getTypeCount(array $types) {
@@ -524,11 +565,12 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Get the watchdog severity constant corresponding to the CSS class.
+   * Gets the watchdog severity constant corresponding to the CSS class.
    *
-   * @param $class
+   * @param string $class
    *   CSS class attribute.
-   * @return
+   *
+   * @return int|null
    *   The watchdog severity constant or NULL if not found.
    *
    * @ingroup logging_severity_levels
@@ -557,11 +599,12 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Extract the text contained by the element.
+   * Extracts the text contained by the XHTML element.
    *
-   * @param $element
+   * @param SimpleXMLElement $element
    *   Element to extract text from.
-   * @return
+   *
+   * @return string
    *   Extracted text.
    */
   protected function asText(SimpleXMLElement $element) {
@@ -572,21 +615,22 @@ class DBLogTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Assert messages appear on the log overview screen.
+   * Confirms that a log message appears on the database log overview screen.
    *
-   * This function should be used only for admin/reports/dblog page, because it
-   * check for the message link text truncated to 56 characters. Other dblog
-   * pages have no detail links so contains a full message text.
+   * This function should only be used for the admin/reports/dblog page, because
+   * it checks for the message link text truncated to 56 characters. Other log
+   * pages have no detail links so they contain the full message text.
    *
-   * @param $log_message
-   *   The message to check.
-   * @param $message
+   * @param string $log_message
+   *   The database log message to check.
+   * @param string $message
    *   The message to pass to simpletest.
    */
   protected function assertLogMessage($log_message, $message) {
     $message_text = truncate_utf8(filter_xss($log_message, array()), 56, TRUE, TRUE);
-    // After filter_xss() HTML entities should be converted to their characters
-    // because assertLink() uses this string in xpath() to query DOM.
+    // After filter_xss(), HTML entities should be converted to their character
+    // equivalents because assertLink() uses this string in xpath() to query the
+    // Document Object Model (DOM).
     $this->assertLink(html_entity_decode($message_text), 0, $message);
   }
 }
diff --git a/modules/field/field.api.php b/modules/field/field.api.php
index 5f64117..463da55 100644
--- a/modules/field/field.api.php
+++ b/modules/field/field.api.php
@@ -23,14 +23,20 @@
  * @see hook_field_extra_fields_alter()
  *
  * @return
- *   A nested array of 'pseudo-field' components. Each list is nested within
- *   the following keys: entity type, bundle name, context (either 'form' or
+ *   A nested array of 'pseudo-field' elements. Each list is nested within the
+ *   following keys: entity type, bundle name, context (either 'form' or
  *   'display'). The keys are the name of the elements as appearing in the
  *   renderable array (either the entity form or the displayed entity). The
  *   value is an associative array:
- *   - label: The human readable name of the component.
- *   - description: A short description of the component contents.
+ *   - label: The human readable name of the element.
+ *   - description: A short description of the element contents.
  *   - weight: The default weight of the element.
+ *   - edit: (optional) String containing markup (normally a link) used as the
+ *     element's 'edit' operation in the administration interface. Only for
+ *     'form' context.
+ *   - delete: (optional) String containing markup (normally a link) used as the
+ *     element's 'delete' operation in the administration interface. Only for
+ *     'form' context.
  */
 function hook_field_extra_fields() {
   $extra['node']['poll'] = array(
@@ -873,7 +879,7 @@ function hook_field_widget_form(&$form, &$form_state, $field, $instance, $langco
     '#type' => $instance['widget']['type'],
     '#default_value' => isset($items[$delta]) ? $items[$delta] : '',
   );
-  return $element;
+  return array('value' => $element);
 }
 
 /**
@@ -1735,11 +1741,14 @@ function hook_field_storage_details_alter(&$details, $field) {
  *     loaded.
  */
 function hook_field_storage_load($entity_type, $entities, $age, $fields, $options) {
-  $field_info = field_info_field_by_ids();
   $load_current = $age == FIELD_LOAD_CURRENT;
 
   foreach ($fields as $field_id => $ids) {
-    $field = $field_info[$field_id];
+    // By the time this hook runs, the relevant field definitions have been
+    // populated and cached in FieldInfo, so calling field_info_field_by_id()
+    // on each field individually is more efficient than loading all fields in
+    // memory upfront with field_info_field_by_ids().
+    $field = field_info_field_by_id($field_id);
     $field_name = $field['field_name'];
     $table = $load_current ? _field_sql_storage_tablename($field) : _field_sql_storage_revision_tablename($field);
 
@@ -2505,7 +2514,7 @@ function hook_field_delete_field($field) {
  *
  * @param $instance
  *   The instance as it is post-update.
- * @param $prior_$instance
+ * @param $prior_instance
  *   The instance as it was pre-update.
  */
 function hook_field_update_instance($instance, $prior_instance) {
diff --git a/modules/field/field.attach.inc b/modules/field/field.attach.inc
index 868d7bd..30a12d0 100644
--- a/modules/field/field.attach.inc
+++ b/modules/field/field.attach.inc
@@ -283,7 +283,6 @@ function _field_invoke_multiple($op, $entity_type, $entities, &$a = NULL, &$b =
     'language' => NULL,
   );
   $options += $default_options;
-  $field_info = field_info_field_by_ids();
 
   $fields = array();
   $grouped_instances = array();
@@ -307,7 +306,7 @@ function _field_invoke_multiple($op, $entity_type, $entities, &$a = NULL, &$b =
     foreach ($instances as $instance) {
       $field_id = $instance['field_id'];
       $field_name = $instance['field_name'];
-      $field = $field_info[$field_id];
+      $field = field_info_field_by_id($field_id);
       $function = $options['default'] ? 'field_default_' . $op : $field['module'] . '_field_' . $op;
       if (function_exists($function)) {
         // Add the field to the list of fields to invoke the hook on.
@@ -555,16 +554,23 @@ function _field_invoke_get_instances($entity_type, $bundle, $options) {
  * @param $langcode
  *   The language the field values are going to be entered, if no language
  *   is provided the default site language will be used.
+ * @param array $options
+ *   An associative array of additional options. See _field_invoke() for
+ *   details.
  *
  * @see field_form_get_state()
  * @see field_form_set_state()
  */
-function field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode = NULL) {
+function field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode = NULL, $options = array()) {
+  // Validate $options since this is a new parameter added after Drupal 7 was
+  // released.
+  $options = is_array($options) ? $options : array();
+
   // Set #parents to 'top-level' by default.
   $form += array('#parents' => array());
 
   // If no language is provided use the default site language.
-  $options = array('language' => field_valid_language($langcode));
+  $options['language'] = field_valid_language($langcode);
   $form += (array) _field_invoke_default('form', $entity_type, $entity, $form, $form_state, $options);
 
   // Add custom weight handling.
@@ -614,7 +620,6 @@ function field_attach_form($entity_type, $entity, &$form, &$form_state, $langcod
  *     non-deleted fields are operated on.
  */
 function field_attach_load($entity_type, $entities, $age = FIELD_LOAD_CURRENT, $options = array()) {
-  $field_info = field_info_field_by_ids();
   $load_current = $age == FIELD_LOAD_CURRENT;
 
   // Merge default options.
@@ -692,7 +697,7 @@ function field_attach_load($entity_type, $entities, $age = FIELD_LOAD_CURRENT, $
         }
         // Collect the storage backend if the field has not been loaded yet.
         if (!isset($skip_fields[$field_id])) {
-          $field = $field_info[$field_id];
+          $field = field_info_field_by_id($field_id);
           $storages[$field['storage']['type']][$field_id][] = $load_current ? $id : $vid;
         }
       }
@@ -709,7 +714,7 @@ function field_attach_load($entity_type, $entities, $age = FIELD_LOAD_CURRENT, $
     _field_invoke_multiple('load', $entity_type, $queried_entities, $age, $null, $options);
 
     // Invoke hook_field_attach_load(): let other modules act on loading the
-    // entitiy.
+    // entity.
     module_invoke_all('field_attach_load', $entity_type, $queried_entities, $age, $options);
 
     // Build cache data.
@@ -769,13 +774,21 @@ function field_attach_load_revision($entity_type, $entities, $options = array())
  *   If validation errors are found, a FieldValidationException is thrown. The
  *   'errors' property contains the array of errors, keyed by field name,
  *   language and delta.
+ * @param array $options
+ *   An associative array of additional options. See _field_invoke() for
+ *   details.
  */
-function field_attach_validate($entity_type, $entity) {
+function field_attach_validate($entity_type, $entity, $options = array()) {
+  // Validate $options since this is a new parameter added after Drupal 7 was
+  // released.
+  $options = is_array($options) ? $options : array();
+
   $errors = array();
   // Check generic, field-type-agnostic errors first.
-  _field_invoke_default('validate', $entity_type, $entity, $errors);
+  $null = NULL;
+  _field_invoke_default('validate', $entity_type, $entity, $errors, $null, $options);
   // Check field-type specific errors.
-  _field_invoke('validate', $entity_type, $entity, $errors);
+  _field_invoke('validate', $entity_type, $entity, $errors, $null, $options);
 
   // Let other modules validate the entity.
   // Avoid module_invoke_all() to let $errors be taken by reference.
@@ -817,14 +830,21 @@ function field_attach_validate($entity_type, $entity) {
  *   full form structure, or a sub-element of a larger form.
  * @param $form_state
  *   An associative array containing the current state of the form.
+ * @param array $options
+ *   An associative array of additional options. See _field_invoke() for
+ *   details.
  */
-function field_attach_form_validate($entity_type, $entity, $form, &$form_state) {
+function field_attach_form_validate($entity_type, $entity, $form, &$form_state, $options = array()) {
+  // Validate $options since this is a new parameter added after Drupal 7 was
+  // released.
+  $options = is_array($options) ? $options : array();
+
   // Extract field values from submitted values.
   _field_invoke_default('extract_form_values', $entity_type, $entity, $form, $form_state);
 
   // Perform field_level validation.
   try {
-    field_attach_validate($entity_type, $entity);
+    field_attach_validate($entity_type, $entity, $options);
   }
   catch (FieldValidationException $e) {
     // Pass field-level validation errors back to widgets for accurate error
@@ -836,7 +856,7 @@ function field_attach_form_validate($entity_type, $entity, $form, &$form_state)
         field_form_set_state($form['#parents'], $field_name, $langcode, $form_state, $field_state);
       }
     }
-    _field_invoke_default('form_errors', $entity_type, $entity, $form, $form_state);
+    _field_invoke_default('form_errors', $entity_type, $entity, $form, $form_state, $options);
   }
 }
 
@@ -857,12 +877,19 @@ function field_attach_form_validate($entity_type, $entity, $form, &$form_state)
  *   full form structure, or a sub-element of a larger form.
  * @param $form_state
  *   An associative array containing the current state of the form.
+ * @param array $options
+ *   An associative array of additional options. See _field_invoke() for
+ *   details.
  */
-function field_attach_submit($entity_type, $entity, $form, &$form_state) {
+function field_attach_submit($entity_type, $entity, $form, &$form_state, $options = array()) {
+  // Validate $options since this is a new parameter added after Drupal 7 was
+  // released.
+  $options = is_array($options) ? $options : array();
+
   // Extract field values from submitted values.
-  _field_invoke_default('extract_form_values', $entity_type, $entity, $form, $form_state);
+  _field_invoke_default('extract_form_values', $entity_type, $entity, $form, $form_state, $options);
 
-  _field_invoke_default('submit', $entity_type, $entity, $form, $form_state);
+  _field_invoke_default('submit', $entity_type, $entity, $form, $form_state, $options);
 
   // Let other modules act on submitting the entity.
   // Avoid module_invoke_all() to let $form_state be taken by reference.
@@ -1093,9 +1120,16 @@ function field_attach_delete_revision($entity_type, $entity) {
  * @param $langcode
  *   (Optional) The language the field values are to be shown in. If no language
  *   is provided the current language is used.
+ * @param array $options
+ *   An associative array of additional options. See _field_invoke() for
+ *   details.
  */
-function field_attach_prepare_view($entity_type, $entities, $view_mode, $langcode = NULL) {
-  $options = array('language' => array());
+function field_attach_prepare_view($entity_type, $entities, $view_mode, $langcode = NULL, $options = array()) {
+  // Validate $options since this is a new parameter added after Drupal 7 was
+  // released.
+  $options = is_array($options) ? $options : array();
+
+  $options['language'] = array();
 
   // To ensure hooks are only run once per entity, only process items without
   // the _field_view_prepared flag.
@@ -1167,14 +1201,21 @@ function field_attach_prepare_view($entity_type, $entities, $view_mode, $langcod
  * @param $langcode
  *   The language the field values are to be shown in. If no language is
  *   provided the current language is used.
+ * @param array $options
+ *   An associative array of additional options. See _field_invoke() for
+ *   details.
  * @return
  *   A renderable array for the field values.
  */
-function field_attach_view($entity_type, $entity, $view_mode, $langcode = NULL) {
+function field_attach_view($entity_type, $entity, $view_mode, $langcode = NULL, $options = array()) {
+  // Validate $options since this is a new parameter added after Drupal 7 was
+  // released.
+  $options = is_array($options) ? $options : array();
+
   // Determine the actual language to display for each field, given the
   // languages available in the field data.
   $display_language = field_language($entity_type, $entity, NULL, $langcode);
-  $options = array('language' => $display_language);
+  $options['language'] = $display_language;
 
   // Invoke field_default_view().
   $null = NULL;
diff --git a/modules/field/field.crud.inc b/modules/field/field.crud.inc
index f9c96c9..83863d6 100644
--- a/modules/field/field.crud.inc
+++ b/modules/field/field.crud.inc
@@ -244,9 +244,11 @@ function field_update_field($field) {
   // $prior_field may no longer be right.
   module_load_install($field['module']);
   $schema = (array) module_invoke($field['module'], 'field_schema', $field);
-  $schema += array('columns' => array(), 'indexes' => array());
+  $schema += array('columns' => array(), 'indexes' => array(), 'foreign keys' => array());
   // 'columns' are hardcoded in the field type.
   $field['columns'] = $schema['columns'];
+  // 'foreign keys' are hardcoded in the field type.
+  $field['foreign keys'] = $schema['foreign keys'];
   // 'indexes' can be both hardcoded in the field type, and specified in the
   // incoming $field definition.
   $field += array(
@@ -319,7 +321,11 @@ function field_read_field($field_name, $include_additional = array()) {
  * Reads in fields that match an array of conditions.
  *
  * @param array $params
- *   An array of conditions to match against.
+ *   An array of conditions to match against. Keys are columns from the
+ *   'field_config' table, values are conditions to match. Additionally,
+ *   conditions on the 'entity_type' and 'bundle' columns from the
+ *   'field_config_instance' table are supported (select fields having an
+ *   instance on a given bundle).
  * @param array $include_additional
  *   The default behavior of this function is to not return fields that
  *   are inactive or have been deleted. Setting
@@ -337,8 +343,21 @@ function field_read_fields($params = array(), $include_additional = array()) {
 
   // Turn the conditions into a query.
   foreach ($params as $key => $value) {
+    // Allow filtering on the 'entity_type' and 'bundle' columns of the
+    // field_config_instance table.
+    if ($key == 'entity_type' || $key == 'bundle') {
+      if (empty($fci_join)) {
+        $fci_join = $query->join('field_config_instance', 'fci', 'fc.id = fci.field_id');
+      }
+      $key = 'fci.' . $key;
+    }
+    else {
+      $key = 'fc.' . $key;
+    }
+
     $query->condition($key, $value);
   }
+
   if (!isset($include_additional['include_inactive']) || !$include_additional['include_inactive']) {
     $query
       ->condition('fc.active', 1)
@@ -505,17 +524,30 @@ function field_create_instance($instance) {
  * Updates an instance of a field.
  *
  * @param $instance
- *   An associative array representing an instance structure. The required
- *   keys and values are:
+ *   An associative array representing an instance structure. The following
+ *   required array elements specify which field instance is being updated:
  *   - entity_type: The type of the entity the field is attached to.
  *   - bundle: The bundle this field belongs to.
  *   - field_name: The name of an existing field.
- *   Read-only_id properties are assigned automatically. Any other
- *   properties specified in $instance overwrite the existing values for
- *   the instance.
+ *   The other array elements represent properties of the instance, and all
+ *   properties must be specified or their default values will be used (except
+ *   internal-use properties, which are assigned automatically). To avoid
+ *   losing the previously stored properties of the instance when making a
+ *   change, first load the instance with field_info_instance(), then override
+ *   the values you want to override, and finally save using this function.
+ *   Example:
+ *   @code
+ *   // Fetch an instance info array.
+ *   $instance_info = field_info_instance($entity_type, $field_name, $bundle_name);
+ *   // Change a single property in the instance definition.
+ *   $instance_info['definition']['required'] = TRUE;
+ *   // Write the changed definition back.
+ *   field_update_instance($instance_info['definition']);
+ *   @endcode
  *
  * @throws FieldException
  *
+ * @see field_info_instance()
  * @see field_create_instance()
  */
 function field_update_instance($instance) {
diff --git a/modules/field/field.info b/modules/field/field.info
index f8a331a..fcdca88 100644
--- a/modules/field/field.info
+++ b/modules/field/field.info
@@ -5,6 +5,7 @@ version = VERSION
 core = 7.x
 files[] = field.module
 files[] = field.attach.inc
+files[] = field.info.class.inc
 files[] = tests/field.test
 dependencies[] = field_sql_storage
 required = TRUE
diff --git a/modules/field/field.info.class.inc b/modules/field/field.info.class.inc
new file mode 100644
index 0000000..3b89898
--- /dev/null
+++ b/modules/field/field.info.class.inc
@@ -0,0 +1,668 @@
+<?php
+
+/*
+ * @file
+ * Definition of the FieldInfo class.
+ */
+
+/**
+ * Provides field and instance definitions for the current runtime environment.
+ *
+ * A FieldInfo object is created and statically persisted through the request
+ * by the _field_info_field_cache() function. The object properties act as a
+ * "static cache" of fields and instances definitions.
+ *
+ * The preferred way to access definitions is through the getBundleInstances()
+ * method, which keeps cache entries per bundle, storing both fields and
+ * instances for a given bundle. Fields used in multiple bundles are duplicated
+ * in several cache entries, and are merged into a single list in the memory
+ * cache. Cache entries are loaded for bundles as a whole, optimizing memory
+ * and CPU usage for the most common pattern of iterating over all instances of
+ * a bundle rather than accessing a single instance.
+ *
+ * The getFields() and getInstances() methods, which return all existing field
+ * and instance definitions, are kept mainly for backwards compatibility, and
+ * should be avoided when possible, since they load and persist in memory a
+ * potentially large array of information. In many cases, the lightweight
+ * getFieldMap() method should be preferred.
+ */
+class FieldInfo {
+
+  /**
+   * Lightweight map of fields across entity types and bundles.
+   *
+   * @var array
+   */
+  protected $fieldMap;
+
+  /**
+   * List of $field structures keyed by ID. Includes deleted fields.
+   *
+   * @var array
+   */
+  protected $fieldsById = array();
+
+  /**
+   * Mapping of field names to the ID of the corresponding non-deleted field.
+   *
+   * @var array
+   */
+  protected $fieldIdsByName = array();
+
+  /**
+   * Whether $fieldsById contains all field definitions or a subset.
+   *
+   * @var bool
+   */
+  protected $loadedAllFields = FALSE;
+
+  /**
+   * Separately tracks requested field names or IDs that do not exist.
+   *
+   * @var array
+   */
+  protected $unknownFields = array();
+
+  /**
+   * Instance definitions by bundle.
+   *
+   * @var array
+   */
+  protected $bundleInstances = array();
+
+  /**
+   * Whether $bundleInstances contains all instances definitions or a subset.
+   *
+   * @var bool
+   */
+  protected $loadedAllInstances = FALSE;
+
+  /**
+   * Separately tracks requested bundles that are empty (or do not exist).
+   *
+   * @var array
+   */
+  protected $emptyBundles = array();
+
+  /**
+   * Extra fields by bundle.
+   *
+   * @var array
+   */
+  protected $bundleExtraFields = array();
+
+  /**
+   * Clears the "static" and persistent caches.
+   */
+  public function flush() {
+    $this->fieldMap = NULL;
+
+    $this->fieldsById = array();
+    $this->fieldIdsByName = array();
+    $this->loadedAllFields = FALSE;
+    $this->unknownFields = array();
+
+    $this->bundleInstances = array();
+    $this->loadedAllInstances = FALSE;
+    $this->emptyBundles = array();
+
+    $this->bundleExtraFields = array();
+
+    cache_clear_all('field_info:', 'cache_field', TRUE);
+  }
+
+  /**
+   * Collects a lightweight map of fields across bundles.
+   *
+   * @return
+   *   An array keyed by field name. Each value is an array with two entries:
+   *   - type: The field type.
+   *   - bundles: The bundles in which the field appears, as an array with
+   *     entity types as keys and the array of bundle names as values.
+   */
+  public function getFieldMap() {
+    // Read from the "static" cache.
+    if ($this->fieldMap !== NULL) {
+      return $this->fieldMap;
+    }
+
+    // Read from persistent cache.
+    if ($cached = cache_get('field_info:field_map', 'cache_field')) {
+      $map = $cached->data;
+
+      // Save in "static" cache.
+      $this->fieldMap = $map;
+
+      return $map;
+    }
+
+    $map = array();
+
+    $query = db_query('SELECT fc.type, fci.field_name, fci.entity_type, fci.bundle FROM {field_config_instance} fci INNER JOIN {field_config} fc ON fc.id = fci.field_id WHERE fc.active = 1 AND fc.storage_active = 1 AND fc.deleted = 0 AND fci.deleted = 0');
+    foreach ($query as $row) {
+      $map[$row->field_name]['bundles'][$row->entity_type][] = $row->bundle;
+      $map[$row->field_name]['type'] = $row->type;
+    }
+
+    // Save in "static" and persistent caches.
+    $this->fieldMap = $map;
+    cache_set('field_info:field_map', $map, 'cache_field');
+
+    return $map;
+  }
+
+  /**
+   * Returns all active fields, including deleted ones.
+   *
+   * @return
+   *   An array of field definitions, keyed by field ID.
+   */
+  public function getFields() {
+    // Read from the "static" cache.
+    if ($this->loadedAllFields) {
+      return $this->fieldsById;
+    }
+
+    // Read from persistent cache.
+    if ($cached = cache_get('field_info:fields', 'cache_field')) {
+      $this->fieldsById = $cached->data;
+    }
+    else {
+      // Collect and prepare fields.
+      foreach (field_read_fields(array(), array('include_deleted' => TRUE)) as $field) {
+        $this->fieldsById[$field['id']] = $this->prepareField($field);
+      }
+
+      // Store in persistent cache.
+      cache_set('field_info:fields', $this->fieldsById, 'cache_field');
+    }
+
+    // Fill the name/ID map.
+    foreach ($this->fieldsById as $field) {
+      if (!$field['deleted']) {
+        $this->fieldIdsByName[$field['field_name']] = $field['id'];
+      }
+    }
+
+    $this->loadedAllFields = TRUE;
+
+    return $this->fieldsById;
+  }
+
+  /**
+   * Retrieves all active, non-deleted instances definitions.
+   *
+   * @param $entity_type
+   *   (optional) The entity type.
+   *
+   * @return
+   *   If $entity_type is not set, all instances keyed by entity type and bundle
+   *   name. If $entity_type is set, all instances for that entity type, keyed
+   *   by bundle name.
+   */
+  public function getInstances($entity_type = NULL) {
+    // If the full list is not present in "static" cache yet.
+    if (!$this->loadedAllInstances) {
+
+      // Read from persistent cache.
+      if ($cached = cache_get('field_info:instances', 'cache_field')) {
+        $this->bundleInstances = $cached->data;
+      }
+      else {
+        // Collect and prepare instances.
+
+        // We also need to populate the static field cache, since it will not
+        // be set by subsequent getBundleInstances() calls.
+        $this->getFields();
+
+        // Initialize empty arrays for all existing entity types and bundles.
+        // This is not strictly needed, but is done to preserve the behavior of
+        // field_info_instances() before http://drupal.org/node/1915646.
+        foreach (field_info_bundles() as $existing_entity_type => $bundles) {
+          foreach ($bundles as $bundle => $bundle_info) {
+            $this->bundleInstances[$existing_entity_type][$bundle] = array();
+          }
+        }
+
+        foreach (field_read_instances() as $instance) {
+          $field = $this->getField($instance['field_name']);
+          $instance = $this->prepareInstance($instance, $field['type']);
+          $this->bundleInstances[$instance['entity_type']][$instance['bundle']][$instance['field_name']] = $instance;
+        }
+
+        // Store in persistent cache.
+        cache_set('field_info:instances', $this->bundleInstances, 'cache_field');
+      }
+
+      $this->loadedAllInstances = TRUE;
+    }
+
+    if (isset($entity_type)) {
+      return isset($this->bundleInstances[$entity_type]) ? $this->bundleInstances[$entity_type] : array();
+    }
+    else {
+      return $this->bundleInstances;
+    }
+  }
+
+  /**
+   * Returns a field definition from a field name.
+   *
+   * This method only retrieves active, non-deleted fields.
+   *
+   * @param $field_name
+   *   The field name.
+   *
+   * @return
+   *   The field definition, or NULL if no field was found.
+   */
+  public function getField($field_name) {
+    // Read from the "static" cache.
+    if (isset($this->fieldIdsByName[$field_name])) {
+      $field_id = $this->fieldIdsByName[$field_name];
+      return $this->fieldsById[$field_id];
+    }
+    if (isset($this->unknownFields[$field_name])) {
+      return;
+    }
+
+    // Do not check the (large) persistent cache, but read the definition.
+
+    // Cache miss: read from definition.
+    if ($field = field_read_field($field_name)) {
+      $field = $this->prepareField($field);
+
+      // Save in the "static" cache.
+      $this->fieldsById[$field['id']] = $field;
+      $this->fieldIdsByName[$field['field_name']] = $field['id'];
+
+      return $field;
+    }
+    else {
+      $this->unknownFields[$field_name] = TRUE;
+    }
+  }
+
+  /**
+   * Returns a field definition from a field ID.
+   *
+   * This method only retrieves active fields, deleted or not.
+   *
+   * @param $field_id
+   *   The field ID.
+   *
+   * @return
+   *   The field definition, or NULL if no field was found.
+   */
+  public function getFieldById($field_id) {
+    // Read from the "static" cache.
+    if (isset($this->fieldsById[$field_id])) {
+      return $this->fieldsById[$field_id];
+    }
+    if (isset($this->unknownFields[$field_id])) {
+      return;
+    }
+
+    // No persistent cache, fields are only persistently cached as part of a
+    // bundle.
+
+    // Cache miss: read from definition.
+    if ($fields = field_read_fields(array('id' => $field_id), array('include_deleted' => TRUE))) {
+      $field = current($fields);
+      $field = $this->prepareField($field);
+
+      // Store in the static cache.
+      $this->fieldsById[$field['id']] = $field;
+      if (!$field['deleted']) {
+        $this->fieldIdsByName[$field['field_name']] = $field['id'];
+      }
+
+      return $field;
+    }
+    else {
+      $this->unknownFields[$field_id] = TRUE;
+    }
+  }
+
+  /**
+   * Retrieves the instances for a bundle.
+   *
+   * The function also populates the corresponding field definitions in the
+   * "static" cache.
+   *
+   * @param $entity_type
+   *   The entity type.
+   * @param $bundle
+   *   The bundle name.
+   *
+   * @return
+   *   The array of instance definitions, keyed by field name.
+   */
+  public function getBundleInstances($entity_type, $bundle) {
+    // Read from the "static" cache.
+    if (isset($this->bundleInstances[$entity_type][$bundle])) {
+      return $this->bundleInstances[$entity_type][$bundle];
+    }
+    if (isset($this->emptyBundles[$entity_type][$bundle])) {
+      return array();
+    }
+
+    // Read from the persistent cache.
+    if ($cached = cache_get("field_info:bundle:$entity_type:$bundle", 'cache_field')) {
+      $info = $cached->data;
+
+      // Extract the field definitions and save them in the "static" cache.
+      foreach ($info['fields'] as $field) {
+        if (!isset($this->fieldsById[$field['id']])) {
+          $this->fieldsById[$field['id']] = $field;
+          if (!$field['deleted']) {
+            $this->fieldIdsByName[$field['field_name']] = $field['id'];
+          }
+        }
+      }
+      unset($info['fields']);
+
+      // Store the instance definitions in the "static" cache'. Empty (or
+      // non-existent) bundles are stored separately, so that they do not
+      // pollute the global list returned by getInstances().
+      if ($info['instances']) {
+        $this->bundleInstances[$entity_type][$bundle] = $info['instances'];
+      }
+      else {
+        $this->emptyBundles[$entity_type][$bundle] = TRUE;
+      }
+
+      return $info['instances'];
+    }
+
+    // Cache miss: collect from the definitions.
+
+    $instances = array();
+
+    // Collect the fields in the bundle.
+    $params = array('entity_type' => $entity_type, 'bundle' => $bundle);
+    $fields = field_read_fields($params);
+
+    // This iterates on non-deleted instances, so deleted fields are kept out of
+    // the persistent caches.
+    foreach (field_read_instances($params) as $instance) {
+      $field = $fields[$instance['field_name']];
+
+      $instance = $this->prepareInstance($instance, $field['type']);
+      $instances[$field['field_name']] = $instance;
+
+      // If the field is not in our global "static" list yet, add it.
+      if (!isset($this->fieldsById[$field['id']])) {
+        $field = $this->prepareField($field);
+
+        $this->fieldsById[$field['id']] = $field;
+        $this->fieldIdsByName[$field['field_name']] = $field['id'];
+      }
+    }
+
+    // Store in the 'static' cache'. Empty (or non-existent) bundles are stored
+    // separately, so that they do not pollute the global list returned by
+    // getInstances().
+    if ($instances) {
+      $this->bundleInstances[$entity_type][$bundle] = $instances;
+    }
+    else {
+      $this->emptyBundles[$entity_type][$bundle] = TRUE;
+    }
+
+    // The persistent cache additionally contains the definitions of the fields
+    // involved in the bundle.
+    $cache = array(
+      'instances' => $instances,
+      'fields' => array()
+    );
+    foreach ($instances as $instance) {
+      $cache['fields'][] = $this->fieldsById[$instance['field_id']];
+    }
+    cache_set("field_info:bundle:$entity_type:$bundle", $cache, 'cache_field');
+
+    return $instances;
+  }
+
+  /**
+   * Retrieves the "extra fields" for a bundle.
+   *
+   * @param $entity_type
+   *   The entity type.
+   * @param $bundle
+   *   The bundle name.
+   *
+   * @return
+   *   The array of extra fields.
+   */
+  public function getBundleExtraFields($entity_type, $bundle) {
+    // Read from the "static" cache.
+    if (isset($this->bundleExtraFields[$entity_type][$bundle])) {
+      return $this->bundleExtraFields[$entity_type][$bundle];
+    }
+
+    // Read from the persistent cache.
+    if ($cached = cache_get("field_info:bundle_extra:$entity_type:$bundle", 'cache_field')) {
+      $this->bundleExtraFields[$entity_type][$bundle] = $cached->data;
+      return $this->bundleExtraFields[$entity_type][$bundle];
+    }
+
+    // Cache miss: read from hook_field_extra_fields(). Note: given the current
+    // shape of the hook, we have no other way than collecting extra fields on
+    // all bundles.
+    $info = array();
+    $extra = module_invoke_all('field_extra_fields');
+    drupal_alter('field_extra_fields', $extra);
+    // Merge in saved settings.
+    if (isset($extra[$entity_type][$bundle])) {
+      $info = $this->prepareExtraFields($extra[$entity_type][$bundle], $entity_type, $bundle);
+    }
+
+    // Store in the 'static' and persistent caches.
+    $this->bundleExtraFields[$entity_type][$bundle] = $info;
+    cache_set("field_info:bundle_extra:$entity_type:$bundle", $info, 'cache_field');
+
+    return $this->bundleExtraFields[$entity_type][$bundle];
+  }
+
+  /**
+   * Prepares a field definition for the current run-time context.
+   *
+   * @param $field
+   *   The raw field structure as read from the database.
+   *
+   * @return
+   *   The field definition completed for the current runtime context.
+   */
+  public function prepareField($field) {
+    // Make sure all expected field settings are present.
+    $field['settings'] += field_info_field_settings($field['type']);
+    $field['storage']['settings'] += field_info_storage_settings($field['storage']['type']);
+
+    // Add storage details.
+    $details = (array) module_invoke($field['storage']['module'], 'field_storage_details', $field);
+    drupal_alter('field_storage_details', $details, $field);
+    $field['storage']['details'] = $details;
+
+    // Populate the list of bundles using the field.
+    $field['bundles'] = array();
+    if (!$field['deleted']) {
+      $map = $this->getFieldMap();
+      if (isset($map[$field['field_name']])) {
+        $field['bundles'] = $map[$field['field_name']]['bundles'];
+      }
+    }
+
+    return $field;
+  }
+
+  /**
+   * Prepares an instance definition for the current run-time context.
+   *
+   * @param $instance
+   *   The raw instance structure as read from the database.
+   * @param $field_type
+   *   The field type.
+   *
+   * @return
+   *   The field instance array completed for the current runtime context.
+   */
+  public function prepareInstance($instance, $field_type) {
+    // Make sure all expected instance settings are present.
+    $instance['settings'] += field_info_instance_settings($field_type);
+
+    // Set a default value for the instance.
+    if (field_behaviors_widget('default value', $instance) == FIELD_BEHAVIOR_DEFAULT && !isset($instance['default_value'])) {
+      $instance['default_value'] = NULL;
+    }
+
+    // Prepare widget settings.
+    $instance['widget'] = $this->prepareInstanceWidget($instance['widget'], $field_type);
+
+    // Prepare display settings.
+    foreach ($instance['display'] as $view_mode => $display) {
+      $instance['display'][$view_mode] = $this->prepareInstanceDisplay($display, $field_type);
+    }
+
+    // Fall back to 'hidden' for view modes configured to use custom display
+    // settings, and for which the instance has no explicit settings.
+    $entity_info = entity_get_info($instance['entity_type']);
+    $view_modes = array_merge(array('default'), array_keys($entity_info['view modes']));
+    $view_mode_settings = field_view_mode_settings($instance['entity_type'], $instance['bundle']);
+    foreach ($view_modes as $view_mode) {
+      if ($view_mode == 'default' || !empty($view_mode_settings[$view_mode]['custom_settings'])) {
+        if (!isset($instance['display'][$view_mode])) {
+          $instance['display'][$view_mode] = array(
+            'type' => 'hidden',
+            'label' => 'above',
+            'settings' => array(),
+            'weight' => 0,
+          );
+        }
+      }
+    }
+
+    return $instance;
+  }
+
+  /**
+   * Prepares widget properties for the current run-time context.
+   *
+   * @param $widget
+   *   Widget specifications as found in $instance['widget'].
+   * @param $field_type
+   *   The field type.
+   *
+   * @return
+   *   The widget properties completed for the current runtime context.
+   */
+  public function prepareInstanceWidget($widget, $field_type) {
+    $field_type_info = field_info_field_types($field_type);
+
+    // Fill in default values.
+    $widget += array(
+      'type' => $field_type_info['default_widget'],
+      'settings' => array(),
+      'weight' => 0,
+    );
+
+    $widget_type_info = field_info_widget_types($widget['type']);
+    // Fall back to default formatter if formatter type is not available.
+    if (!$widget_type_info) {
+      $widget['type'] = $field_type_info['default_widget'];
+      $widget_type_info = field_info_widget_types($widget['type']);
+    }
+    $widget['module'] = $widget_type_info['module'];
+    // Fill in default settings for the widget.
+    $widget['settings'] += field_info_widget_settings($widget['type']);
+
+    return $widget;
+  }
+
+  /**
+   * Adapts display specifications to the current run-time context.
+   *
+   * @param $display
+   *   Display specifications as found in $instance['display']['a_view_mode'].
+   * @param $field_type
+   *   The field type.
+   *
+   * @return
+   *   The display properties completed for the current runtime context.
+   */
+  public function prepareInstanceDisplay($display, $field_type) {
+    $field_type_info = field_info_field_types($field_type);
+
+    // Fill in default values.
+    $display += array(
+      'label' => 'above',
+      'type' => $field_type_info['default_formatter'],
+      'settings' => array(),
+      'weight' => 0,
+    );
+    if ($display['type'] != 'hidden') {
+      $formatter_type_info = field_info_formatter_types($display['type']);
+      // Fall back to default formatter if formatter type is not available.
+      if (!$formatter_type_info) {
+        $display['type'] = $field_type_info['default_formatter'];
+        $formatter_type_info = field_info_formatter_types($display['type']);
+      }
+      $display['module'] = $formatter_type_info['module'];
+      // Fill in default settings for the formatter.
+      $display['settings'] += field_info_formatter_settings($display['type']);
+    }
+
+    return $display;
+  }
+
+  /**
+   * Prepares 'extra fields' for the current run-time context.
+   *
+   * @param $extra_fields
+   *   The array of extra fields, as collected in hook_field_extra_fields().
+   * @param $entity_type
+   *   The entity type.
+   * @param $bundle
+   *   The bundle name.
+   *
+   * @return
+   *   The list of extra fields completed for the current runtime context.
+   */
+  public function prepareExtraFields($extra_fields, $entity_type, $bundle) {
+    $entity_type_info = entity_get_info($entity_type);
+    $bundle_settings = field_bundle_settings($entity_type, $bundle);
+    $extra_fields += array('form' => array(), 'display' => array());
+
+    $result = array();
+    // Extra fields in forms.
+    foreach ($extra_fields['form'] as $name => $field_data) {
+      $settings = isset($bundle_settings['extra_fields']['form'][$name]) ? $bundle_settings['extra_fields']['form'][$name] : array();
+      if (isset($settings['weight'])) {
+        $field_data['weight'] = $settings['weight'];
+      }
+      $result['form'][$name] = $field_data;
+    }
+
+    // Extra fields in displayed entities.
+    $data = $extra_fields['display'];
+    foreach ($extra_fields['display'] as $name => $field_data) {
+      $settings = isset($bundle_settings['extra_fields']['display'][$name]) ? $bundle_settings['extra_fields']['display'][$name] : array();
+      $view_modes = array_merge(array('default'), array_keys($entity_type_info['view modes']));
+      foreach ($view_modes as $view_mode) {
+        if (isset($settings[$view_mode])) {
+          $field_data['display'][$view_mode] = $settings[$view_mode];
+        }
+        else {
+          $field_data['display'][$view_mode] = array(
+            'weight' => $field_data['weight'],
+            'visible' => TRUE,
+          );
+        }
+      }
+      unset($field_data['weight']);
+      $result['display'][$name] = $field_data;
+    }
+
+    return $result;
+  }
+}
diff --git a/modules/field/field.info.inc b/modules/field/field.info.inc
index 9e7ab93..02b3c9c 100644
--- a/modules/field/field.info.inc
+++ b/modules/field/field.info.inc
@@ -6,6 +6,32 @@
  */
 
 /**
+ * Retrieves the FieldInfo object for the current request.
+ *
+ * @return FieldInfo
+ *   An instance of the FieldInfo class.
+ */
+function _field_info_field_cache() {
+  // Use the advanced drupal_static() pattern, since this is called very often.
+  static $drupal_static_fast;
+
+  if (!isset($drupal_static_fast)) {
+    $drupal_static_fast['field_info_field_cache'] = &drupal_static(__FUNCTION__);
+  }
+  $field_info = &$drupal_static_fast['field_info_field_cache'];
+
+  if (!isset($field_info)) {
+    // @todo The registry should save the need for an explicit include, but not
+    // a couple upgrade tests (DisabledNodeTypeTestCase,
+    // FilterFormatUpgradePathTestCase...) break in a strange way without it.
+    include_once dirname(__FILE__) . '/field.info.class.inc';
+    $field_info = new FieldInfo();
+  }
+
+  return $field_info;
+}
+
+/**
  * @defgroup field_info Field Info API
  * @{
  * Obtain information about Field API configuration.
@@ -34,7 +60,50 @@ function field_info_cache_clear() {
   entity_info_cache_clear();
 
   _field_info_collate_types(TRUE);
-  _field_info_collate_fields(TRUE);
+  _field_info_field_cache()->flush();
+}
+
+/**
+ * Collates all information on existing fields and instances.
+ *
+ * Deprecated. This function is kept to ensure backwards compatibility, but has
+ * a serious performance impact, and should be absolutely avoided.
+ * See http://drupal.org/node/1915646.
+ *
+ * Use the regular field_info_*() API functions to access the information, or
+ * field_info_cache_clear() to clear the cached data.
+ */
+function _field_info_collate_fields($reset = FALSE) {
+  if ($reset) {
+    _field_info_field_cache()->flush();
+    return;
+  }
+
+  $cache = _field_info_field_cache();
+
+  // Collect fields, and build the array of IDs keyed by field_name.
+  $fields = $cache->getFields();
+  $field_ids = array();
+  foreach ($fields as $id => $field) {
+    if (!$field['deleted']) {
+      $field_ids[$field['field_name']] = $id;
+    }
+  }
+
+  // Collect extra fields for all entity types.
+  $extra_fields = array();
+  foreach (field_info_bundles() as $entity_type => $bundles) {
+    foreach ($bundles as $bundle => $info) {
+      $extra_fields[$entity_type][$bundle] = $cache->getBundleExtraFields($entity_type, $bundle);
+    }
+  }
+
+  return array(
+    'fields' => $fields,
+    'field_ids' => $field_ids,
+    'instances' => $cache->getInstances(),
+    'extra_fields' => $extra_fields,
+  );
 }
 
 /**
@@ -162,281 +231,68 @@ function _field_info_collate_types($reset = FALSE) {
 }
 
 /**
- * Collates all information on existing fields and instances.
- *
- * @param $reset
- *   If TRUE, clear the cache. The information will be rebuilt from the
- *   database next time it is needed. Defaults to FALSE.
- *
- * @return
- *   If $reset is TRUE, nothing.
- *   If $reset is FALSE, an array containing the following elements:
- *   - fields: Array of existing fields, keyed by field ID. This element
- *     lists deleted and non-deleted fields, but not inactive ones.
- *     Each field has an additional element, 'bundles', which is an array
- *     of all non-deleted instances of that field.
- *   - field_ids: Array of field IDs, keyed by field name. This element
- *     only lists non-deleted, active fields.
- *   - instances: Array of existing instances, keyed by entity type, bundle
- *     name and field name. This element only lists non-deleted instances
- *     whose field is active.
- */
-function _field_info_collate_fields($reset = FALSE) {
-  static $info;
-
-  if ($reset) {
-    $info = NULL;
-    cache_clear_all('field_info_fields', 'cache_field');
-    return;
-  }
-
-  if (!isset($info)) {
-    if ($cached = cache_get('field_info_fields', 'cache_field')) {
-      $info = $cached->data;
-    }
-    else {
-      $definitions = array(
-        'field_ids' => field_read_fields(array(), array('include_deleted' => 1)),
-        'instances' => field_read_instances(),
-      );
-
-      // Populate 'fields' with all fields, keyed by ID.
-      $info['fields'] = array();
-      foreach ($definitions['field_ids'] as $key => $field) {
-        $info['fields'][$key] = $definitions['field_ids'][$key] = _field_info_prepare_field($field);
-      }
-
-      // Build an array of field IDs for non-deleted fields, keyed by name.
-      $info['field_ids'] = array();
-      foreach ($info['fields'] as $key => $field) {
-        if (!$field['deleted']) {
-          $info['field_ids'][$field['field_name']] = $key;
-        }
-      }
-
-      // Populate 'instances'. Only non-deleted instances are considered.
-      $info['instances'] = array();
-      foreach (field_info_bundles() as $entity_type => $bundles) {
-        foreach ($bundles as $bundle => $bundle_info) {
-          $info['instances'][$entity_type][$bundle] = array();
-        }
-      }
-      foreach ($definitions['instances'] as $instance) {
-        $field = $info['fields'][$instance['field_id']];
-        $instance = _field_info_prepare_instance($instance, $field);
-        $info['instances'][$instance['entity_type']][$instance['bundle']][$instance['field_name']] = $instance;
-        // Enrich field definitions with the list of bundles where they have
-        // instances. NOTE: Deleted fields in $info['field_ids'] are not
-        // enriched because all of their instances are deleted, too, and
-        // are thus not in $definitions['instances'].
-        $info['fields'][$instance['field_id']]['bundles'][$instance['entity_type']][] = $instance['bundle'];
-      }
-
-      // Populate 'extra_fields'.
-      $extra = module_invoke_all('field_extra_fields');
-      drupal_alter('field_extra_fields', $extra);
-      // Merge in saved settings.
-      foreach ($extra as $entity_type => $bundles) {
-        foreach ($bundles as $bundle => $extra_fields) {
-          $extra_fields = _field_info_prepare_extra_fields($extra_fields, $entity_type, $bundle);
-          $info['extra_fields'][$entity_type][$bundle] = $extra_fields;
-        }
-      }
-
-      cache_set('field_info_fields', $info, 'cache_field');
-    }
-  }
-
-  return $info;
-}
-
-/**
  * Prepares a field definition for the current run-time context.
  *
- * Since the field was last saved or updated, new field settings can be
- * expected.
+ * The functionality has moved to the FieldInfo class. This function is kept as
+ * a backwards-compatibility layer. See http://drupal.org/node/1915646.
  *
- * @param $field
- *   The raw field structure as read from the database.
+ * @see FieldInfo::prepareField()
  */
 function _field_info_prepare_field($field) {
-  // Make sure all expected field settings are present.
-  $field['settings'] += field_info_field_settings($field['type']);
-  $field['storage']['settings'] += field_info_storage_settings($field['storage']['type']);
-
-  // Add storage details.
-  $details = (array) module_invoke($field['storage']['module'], 'field_storage_details', $field);
-  drupal_alter('field_storage_details', $details, $field, $instance);
-  $field['storage']['details'] = $details;
-
-  // Initialize the 'bundles' list.
-  $field['bundles'] = array();
-
-  return $field;
+  $cache = _field_info_field_cache();
+  return $cache->prepareField($field);
 }
 
 /**
  * Prepares an instance definition for the current run-time context.
  *
- * Since the instance was last saved or updated, a number of things might have
- * changed: widgets or formatters disabled, new settings expected, new view
- * modes added...
+ * The functionality has moved to the FieldInfo class. This function is kept as
+ * a backwards-compatibility layer. See http://drupal.org/node/1915646.
  *
- * @param $instance
- *   The raw instance structure as read from the database.
- * @param $field
- *   The field structure for the instance.
- *
- * @return
- *   Field instance array.
+ * @see FieldInfo::prepareInstance()
  */
 function _field_info_prepare_instance($instance, $field) {
-  // Make sure all expected instance settings are present.
-  $instance['settings'] += field_info_instance_settings($field['type']);
-
-  // Set a default value for the instance.
-  if (field_behaviors_widget('default value', $instance) == FIELD_BEHAVIOR_DEFAULT && !isset($instance['default_value'])) {
-    $instance['default_value'] = NULL;
-  }
-
-  $instance['widget'] = _field_info_prepare_instance_widget($field, $instance['widget']);
-
-  foreach ($instance['display'] as $view_mode => $display) {
-    $instance['display'][$view_mode] = _field_info_prepare_instance_display($field, $display);
-  }
-
-  // Fallback to 'hidden' for view modes configured to use custom display
-  // settings, and for which the instance has no explicit settings.
-  $entity_info = entity_get_info($instance['entity_type']);
-  $view_modes = array_merge(array('default'), array_keys($entity_info['view modes']));
-  $view_mode_settings = field_view_mode_settings($instance['entity_type'], $instance['bundle']);
-  foreach ($view_modes as $view_mode) {
-    if ($view_mode == 'default' || !empty($view_mode_settings[$view_mode]['custom_settings'])) {
-      if (!isset($instance['display'][$view_mode])) {
-        $instance['display'][$view_mode] = array(
-          'type' => 'hidden',
-          'label' => 'above',
-          'settings' => array(),
-          'weight' => 0,
-        );
-      }
-    }
-  }
-
-  return $instance;
+  $cache = _field_info_field_cache();
+  return $cache->prepareInstance($instance, $field['type']);
 }
 
 /**
  * Adapts display specifications to the current run-time context.
  *
- * @param $field
- *   The field structure for the instance.
- * @param $display
- *   Display specifications as found in
- *   $instance['display']['some_view_mode'].
+ * The functionality has moved to the FieldInfo class. This function is kept as
+ * a backwards-compatibility layer. See http://drupal.org/node/1915646.
+ *
+ * @see FieldInfo::prepareInstanceDisplay()
  */
 function _field_info_prepare_instance_display($field, $display) {
-  $field_type = field_info_field_types($field['type']);
-
-  // Fill in default values.
-  $display += array(
-    'label' => 'above',
-    'type' => $field_type['default_formatter'],
-    'settings' => array(),
-    'weight' => 0,
-  );
-  if ($display['type'] != 'hidden') {
-    $formatter_type = field_info_formatter_types($display['type']);
-    // Fallback to default formatter if formatter type is not available.
-    if (!$formatter_type) {
-      $display['type'] = $field_type['default_formatter'];
-      $formatter_type = field_info_formatter_types($display['type']);
-    }
-    $display['module'] = $formatter_type['module'];
-    // Fill in default settings for the formatter.
-    $display['settings'] += field_info_formatter_settings($display['type']);
-  }
-
-  return $display;
+  $cache = _field_info_field_cache();
+  return $cache->prepareInstanceDisplay($display, $field['type']);
 }
 
 /**
  * Prepares widget specifications for the current run-time context.
  *
- * @param $field
- *   The field structure for the instance.
- * @param $widget
- *   Widget specifications as found in $instance['widget'].
+ * The functionality has moved to the FieldInfo class. This function is kept as
+ * a backwards-compatibility layer. See http://drupal.org/node/1915646.
+ *
+ * @see FieldInfo::prepareInstanceWidget()
  */
 function _field_info_prepare_instance_widget($field, $widget) {
-  $field_type = field_info_field_types($field['type']);
-
-  // Fill in default values.
-  $widget += array(
-    'type' => $field_type['default_widget'],
-    'settings' => array(),
-    'weight' => 0,
-  );
-
-  $widget_type = field_info_widget_types($widget['type']);
-  // Fallback to default formatter if formatter type is not available.
-  if (!$widget_type) {
-    $widget['type'] = $field_type['default_widget'];
-    $widget_type = field_info_widget_types($widget['type']);
-  }
-  $widget['module'] = $widget_type['module'];
-  // Fill in default settings for the widget.
-  $widget['settings'] += field_info_widget_settings($widget['type']);
-
-  return $widget;
+  $cache = _field_info_field_cache();
+  return $cache->prepareInstanceWidget($widget, $field['type']);
 }
 
 /**
  * Prepares 'extra fields' for the current run-time context.
  *
- * @param $extra_fields
- *   The array of extra fields, as collected in hook_field_extra_fields().
- * @param $entity_type
- *   The entity type.
- * @param $bundle
- *   The bundle name.
+ * The functionality has moved to the FieldInfo class. This function is kept as
+ * a backwards-compatibility layer. See http://drupal.org/node/1915646.
+ *
+ * @see FieldInfo::prepareExtraFields()
  */
 function _field_info_prepare_extra_fields($extra_fields, $entity_type, $bundle) {
-  $entity_type_info = entity_get_info($entity_type);
-  $bundle_settings = field_bundle_settings($entity_type, $bundle);
-  $extra_fields += array('form' => array(), 'display' => array());
-
-  $result = array();
-  // Extra fields in forms.
-  foreach ($extra_fields['form'] as $name => $field_data) {
-    $settings = isset($bundle_settings['extra_fields']['form'][$name]) ? $bundle_settings['extra_fields']['form'][$name] : array();
-    if (isset($settings['weight'])) {
-      $field_data['weight'] = $settings['weight'];
-    }
-    $result['form'][$name] = $field_data;
-  }
-
-  // Extra fields in displayed entities.
-  $data = $extra_fields['display'];
-  foreach ($extra_fields['display'] as $name => $field_data) {
-    $settings = isset($bundle_settings['extra_fields']['display'][$name]) ? $bundle_settings['extra_fields']['display'][$name] : array();
-    $view_modes = array_merge(array('default'), array_keys($entity_type_info['view modes']));
-    foreach ($view_modes as $view_mode) {
-      if (isset($settings[$view_mode])) {
-        $field_data['display'][$view_mode] = $settings[$view_mode];
-      }
-      else {
-        $field_data['display'][$view_mode] = array(
-          'weight' => $field_data['weight'],
-          'visible' => TRUE,
-        );
-      }
-    }
-    unset($field_data['weight']);
-    $result['display'][$name] = $field_data;
-  }
-
-  return $result;
+  $cache = _field_info_field_cache();
+  return $cache->prepareExtraFields($extra_fields, $entity_type, $bundle);
 }
 
 /**
@@ -584,21 +440,61 @@ function field_info_bundles($entity_type = NULL) {
 }
 
 /**
+ * Returns a lightweight map of fields across bundles.
+ *
+ * The function only returns active, non deleted fields.
+ *
+ * @return
+ *   An array keyed by field name. Each value is an array with two entries:
+ *   - type: The field type.
+ *   - bundles: The bundles in which the field appears, as an array with entity
+ *     types as keys and the array of bundle names as values.
+ * Example:
+ * @code
+ * array(
+ *   'body' => array(
+ *     'bundles' => array(
+ *       'node' => array('page', 'article'),
+ *     ),
+ *     'type' => 'text_with_summary',
+ *   ),
+ * );
+ * @endcode
+ */
+function field_info_field_map() {
+  $cache = _field_info_field_cache();
+  return $cache->getFieldMap();
+}
+
+/**
  * Returns all field definitions.
  *
+ * Use of this function should be avoided when possible, since it loads and
+ * statically caches a potentially large array of information. Use
+ * field_info_field_map() instead.
+ *
+ * When iterating over the fields present in a given bundle after a call to
+ * field_info_instances($entity_type, $bundle), it is recommended to use
+ * field_info_field() on each individual field instead.
+ *
  * @return
  *   An array of field definitions, keyed by field name. Each field has an
  *   additional property, 'bundles', which is an array of all the bundles to
  *   which this field belongs keyed by entity type.
+ *
+ * @see field_info_field_map()
  */
 function field_info_fields() {
+  $cache = _field_info_field_cache();
+  $info = $cache->getFields();
+
   $fields = array();
-  $info = _field_info_collate_fields();
-  foreach ($info['fields'] as $key => $field) {
+  foreach ($info as $key => $field) {
     if (!$field['deleted']) {
       $fields[$field['field_name']] = $field;
     }
   }
+
   return $fields;
 }
 
@@ -620,10 +516,8 @@ function field_info_fields() {
  * @see field_info_field_by_id()
  */
 function field_info_field($field_name) {
-  $info = _field_info_collate_fields();
-  if (isset($info['field_ids'][$field_name])) {
-    return $info['fields'][$info['field_ids'][$field_name]];
-  }
+  $cache = _field_info_field_cache();
+  return $cache->getField($field_name);
 }
 
 /**
@@ -641,17 +535,19 @@ function field_info_field($field_name) {
  * @see field_info_field()
  */
 function field_info_field_by_id($field_id) {
-  $info = _field_info_collate_fields();
-  if (isset($info['fields'][$field_id])) {
-    return $info['fields'][$field_id];
-  }
+  $cache = _field_info_field_cache();
+  return $cache->getFieldById($field_id);
 }
 
 /**
  * Returns the same data as field_info_field_by_id() for every field.
  *
- * This function is typically used when handling all fields of some entities
- * to avoid thousands of calls to field_info_field_by_id().
+ * Use of this function should be avoided when possible, since it loads and
+ * statically caches a potentially large array of information.
+ *
+ * When iterating over the fields present in a given bundle after a call to
+ * field_info_instances($entity_type, $bundle), it is recommended to use
+ * field_info_field() on each individual field instead.
  *
  * @return
  *   An array, each key is a field ID and the values are field arrays as
@@ -662,41 +558,57 @@ function field_info_field_by_id($field_id) {
  * @see field_info_field_by_id()
  */
 function field_info_field_by_ids() {
-  $info = _field_info_collate_fields();
-  return $info['fields'];
+  $cache = _field_info_field_cache();
+  return $cache->getFields();
 }
 
 /**
  * Retrieves information about field instances.
  *
+ * Use of this function to retrieve instances across separate bundles (i.e.
+ * when the $bundle parameter is NULL) should be avoided when possible, since
+ * it loads and statically caches a potentially large array of information. Use
+ * field_info_field_map() instead.
+ *
+ * When retrieving the instances of a specific bundle (i.e. when both
+ * $entity_type and $bundle_name are provided), the function also populates a
+ * static cache with the corresponding field definitions, allowing fast
+ * retrieval of field_info_field() later in the request.
+ *
  * @param $entity_type
- *   The entity type for which to return instances.
+ *   (optional) The entity type for which to return instances.
  * @param $bundle_name
- *   The bundle name for which to return instances.
+ *   (optional) The bundle name for which to return instances. If $entity_type
+ *   is NULL, the $bundle_name parameter is ignored.
  *
  * @return
  *   If $entity_type is not set, return all instances keyed by entity type and
  *   bundle name. If $entity_type is set, return all instances for that entity
  *   type, keyed by bundle name. If $entity_type and $bundle_name are set, return
  *   all instances for that bundle.
+ *
+ * @see field_info_field_map()
  */
 function field_info_instances($entity_type = NULL, $bundle_name = NULL) {
-  $info = _field_info_collate_fields();
+  $cache = _field_info_field_cache();
 
-  if (isset($entity_type) && isset($bundle_name)) {
-    return isset($info['instances'][$entity_type][$bundle_name]) ? $info['instances'][$entity_type][$bundle_name] : array();
+  if (!isset($entity_type)) {
+    return $cache->getInstances();
   }
-  elseif (isset($entity_type)) {
-    return isset($info['instances'][$entity_type]) ? $info['instances'][$entity_type] : array();
-  }
-  else {
-    return $info['instances'];
+  if (!isset($bundle_name)) {
+    return $cache->getInstances($entity_type);
   }
+
+  return $cache->getBundleInstances($entity_type, $bundle_name);
 }
 
 /**
  * Returns an array of instance data for a specific field and bundle.
  *
+ * The function populates a static cache with all fields and instances used in
+ * the bundle, allowing fast retrieval of field_info_field() or
+ * field_info_instance() later in the request.
+ *
  * @param $entity_type
  *   The entity type for the instance.
  * @param $field_name
@@ -709,9 +621,10 @@ function field_info_instances($entity_type = NULL, $bundle_name = NULL) {
  *   NULL if the instance does not exist.
  */
 function field_info_instance($entity_type, $field_name, $bundle_name) {
-  $info = _field_info_collate_fields();
-  if (isset($info['instances'][$entity_type][$bundle_name][$field_name])) {
-    return $info['instances'][$entity_type][$bundle_name][$field_name];
+  $cache = _field_info_field_cache();
+  $info = $cache->getBundleInstances($entity_type, $bundle_name);
+  if (isset($info[$field_name])) {
+    return $info[$field_name];
   }
 }
 
@@ -769,11 +682,10 @@ function field_info_instance($entity_type, $field_name, $bundle_name) {
  *   The array of pseudo-field elements in the bundle.
  */
 function field_info_extra_fields($entity_type, $bundle, $context) {
-  $info = _field_info_collate_fields();
-  if (isset($info['extra_fields'][$entity_type][$bundle][$context])) {
-    return $info['extra_fields'][$entity_type][$bundle][$context];
-  }
-  return array();
+  $cache = _field_info_field_cache();
+  $info = $cache->getBundleExtraFields($entity_type, $bundle);
+
+  return isset($info[$context]) ? $info[$context] : array();
 }
 
 /**
diff --git a/modules/field/field.install b/modules/field/field.install
index 34d2807..c5c5005 100644
--- a/modules/field/field.install
+++ b/modules/field/field.install
@@ -128,7 +128,7 @@ function field_schema() {
         'not null' => TRUE,
         'default' => ''
       ),
-      'entity_type'       => array(
+      'entity_type' => array(
         'type' => 'varchar',
         'length' => 32,
         'not null' => TRUE,
@@ -460,5 +460,12 @@ function field_update_7002() {
 }
 
 /**
+ * Add the FieldInfo class to the class registry.
+ */
+function field_update_7003() {
+  // Empty update to force a rebuild of the registry.
+}
+
+/**
  * @} End of "addtogroup updates-7.x-extra".
  */
diff --git a/modules/field/field.module b/modules/field/field.module
index b6cf05c..4331cdf 100644
--- a/modules/field/field.module
+++ b/modules/field/field.module
@@ -873,7 +873,8 @@ function field_view_field($entity_type, $entity, $field_name, $display = array()
   if ($field = field_info_field($field_name)) {
     if (is_array($display)) {
       // When using custom display settings, fill in default values.
-      $display = _field_info_prepare_instance_display($field, $display);
+      $cache = _field_info_field_cache();
+      $display = $cache->prepareInstanceDisplay($display, $field["type"]);
     }
 
     // Hook invocations are done through the _field_invoke() functions in
@@ -1197,7 +1198,7 @@ function _element_validate_integer($element, &$form_state) {
  * Use element_validate_integer_positive() instead.
  *
  * @deprecated
- * @see element_validate_number_positive()
+ * @see element_validate_integer_positive()
  */
 function _element_validate_integer_positive($element, &$form_state) {
   element_validate_integer_positive($element, $form_state);
diff --git a/modules/field/modules/field_sql_storage/field_sql_storage.module b/modules/field/modules/field_sql_storage/field_sql_storage.module
index a756194..93f2077 100644
--- a/modules/field/modules/field_sql_storage/field_sql_storage.module
+++ b/modules/field/modules/field_sql_storage/field_sql_storage.module
@@ -188,7 +188,7 @@ function _field_sql_storage_schema($field) {
   foreach ($field['foreign keys'] as $specifier => $specification) {
     $real_name = _field_sql_storage_indexname($field['field_name'], $specifier);
     $current['foreign keys'][$real_name]['table'] = $specification['table'];
-    foreach ($specification['columns'] as $column => $referenced) {
+    foreach ($specification['columns'] as $column_name => $referenced) {
       $sql_storage_column = _field_sql_storage_columnname($field['field_name'], $column_name);
       $current['foreign keys'][$real_name]['columns'][$sql_storage_column] = $referenced;
     }
@@ -324,11 +324,14 @@ function field_sql_storage_field_storage_delete_field($field) {
  * Implements hook_field_storage_load().
  */
 function field_sql_storage_field_storage_load($entity_type, $entities, $age, $fields, $options) {
-  $field_info = field_info_field_by_ids();
   $load_current = $age == FIELD_LOAD_CURRENT;
 
   foreach ($fields as $field_id => $ids) {
-    $field = $field_info[$field_id];
+    // By the time this hook runs, the relevant field definitions have been
+    // populated and cached in FieldInfo, so calling field_info_field_by_id()
+    // on each field individually is more efficient than loading all fields in
+    // memory upfront with field_info_field_by_ids().
+    $field = field_info_field_by_id($field_id);
     $field_name = $field['field_name'];
     $table = $load_current ? _field_sql_storage_tablename($field) : _field_sql_storage_revision_tablename($field);
 
diff --git a/modules/field/modules/field_sql_storage/field_sql_storage.test b/modules/field/modules/field_sql_storage/field_sql_storage.test
index 773de3d..12c54ba 100644
--- a/modules/field/modules/field_sql_storage/field_sql_storage.test
+++ b/modules/field/modules/field_sql_storage/field_sql_storage.test
@@ -126,7 +126,7 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
     $rows = db_select($this->table, 't')->fields('t')->execute()->fetchAllAssoc('delta', PDO::FETCH_ASSOC);
     foreach ($values as $delta => $value) {
       if ($delta < $this->field['cardinality']) {
-        $this->assertEqual($rows[$delta][$this->field_name . '_value'], $value['value'], t("Value $delta is inserted correctly"));
+        $this->assertEqual($rows[$delta][$this->field_name . '_value'], $value['value'], format_string("Value %delta is inserted correctly", array('%delta' => $delta)));
       }
       else {
         $this->assertFalse(array_key_exists($delta, $rows), "No extraneous value gets inserted.");
@@ -145,7 +145,7 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
     $rows = db_select($this->table, 't')->fields('t')->execute()->fetchAllAssoc('delta', PDO::FETCH_ASSOC);
     foreach ($values as $delta => $value) {
       if ($delta < $this->field['cardinality']) {
-        $this->assertEqual($rows[$delta][$this->field_name . '_value'], $value['value'], t("Value $delta is updated correctly"));
+        $this->assertEqual($rows[$delta][$this->field_name . '_value'], $value['value'], format_string("Value %delta is updated correctly", array('%delta' => $delta)));
       }
       else {
         $this->assertFalse(array_key_exists($delta, $rows), "No extraneous value gets updated.");
@@ -175,7 +175,7 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
     $rows = db_select($this->table, 't')->fields('t')->execute()->fetchAllAssoc('delta', PDO::FETCH_ASSOC);
     foreach ($values as $delta => $value) {
       if ($delta < $this->field['cardinality']) {
-        $this->assertEqual($rows[$delta][$this->field_name . '_value'], $value['value'], t("Update with no field_name entry leaves value $delta untouched"));
+        $this->assertEqual($rows[$delta][$this->field_name . '_value'], $value['value'], format_string("Update with no field_name entry leaves value %delta untouched", array('%delta' => $delta)));
       }
     }
 
@@ -183,7 +183,7 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
     $entity->{$this->field_name} = NULL;
     field_attach_update($entity_type, $entity);
     $rows = db_select($this->table, 't')->fields('t')->execute()->fetchAllAssoc('delta', PDO::FETCH_ASSOC);
-    $this->assertEqual(count($rows), 0, t("Update with an empty field_name entry empties the field."));
+    $this->assertEqual(count($rows), 0, "Update with an empty field_name entry empties the field.");
   }
 
   /**
@@ -326,7 +326,7 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
 
     // Ensure that the field tables are still there.
     foreach (_field_sql_storage_schema($prior_field) as $table_name => $table_info) {
-      $this->assertTrue(db_table_exists($table_name), t('Table %table exists.', array('%table' => $table_name)));
+      $this->assertTrue(db_table_exists($table_name), format_string('Table %table exists.', array('%table' => $table_name)));
     }
   }
 
@@ -345,8 +345,8 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
 
     // Verify the indexes we will create do not exist yet.
     foreach ($tables as $table) {
-      $this->assertFalse(Database::getConnection()->schema()->indexExists($table, 'value'), t("No index named value exists in $table"));
-      $this->assertFalse(Database::getConnection()->schema()->indexExists($table, 'value_format'), t("No index named value_format exists in $table"));
+      $this->assertFalse(Database::getConnection()->schema()->indexExists($table, 'value'), format_string("No index named value exists in %table", array('%table' => $table)));
+      $this->assertFalse(Database::getConnection()->schema()->indexExists($table, 'value_format'), format_string("No index named value_format exists in %table", array('%table' => $table)));
     }
 
     // Add data so the table cannot be dropped.
@@ -358,21 +358,21 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
     $field = array('field_name' => $field_name, 'indexes' => array('value' => array('value')));
     field_update_field($field);
     foreach ($tables as $table) {
-      $this->assertTrue(Database::getConnection()->schema()->indexExists($table, "{$field_name}_value"), t("Index on value created in $table"));
+      $this->assertTrue(Database::getConnection()->schema()->indexExists($table, "{$field_name}_value"), format_string("Index on value created in %table", array('%table' => $table)));
     }
 
     // Add a different index, removing the existing custom one.
     $field = array('field_name' => $field_name, 'indexes' => array('value_format' => array('value', 'format')));
     field_update_field($field);
     foreach ($tables as $table) {
-      $this->assertTrue(Database::getConnection()->schema()->indexExists($table, "{$field_name}_value_format"), t("Index on value_format created in $table"));
-      $this->assertFalse(Database::getConnection()->schema()->indexExists($table, "{$field_name}_value"), t("Index on value removed in $table"));
+      $this->assertTrue(Database::getConnection()->schema()->indexExists($table, "{$field_name}_value_format"), format_string("Index on value_format created in %table", array('%table' => $table)));
+      $this->assertFalse(Database::getConnection()->schema()->indexExists($table, "{$field_name}_value"), format_string("Index on value removed in %table", array('%table' => $table)));
     }
 
     // Verify that the tables were not dropped.
     $entity = field_test_create_stub_entity(0, 0, $instance['bundle']);
     field_attach_load('test_entity', array(0 => $entity));
-    $this->assertEqual($entity->{$field_name}[LANGUAGE_NONE][0]['value'], 'field data', t("Index changes performed without dropping the tables"));
+    $this->assertEqual($entity->{$field_name}[LANGUAGE_NONE][0]['value'], 'field data', "Index changes performed without dropping the tables");
   }
 
   /**
@@ -387,19 +387,19 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
     $instance = field_info_instance($this->instance['entity_type'], $this->instance['field_name'], $this->instance['bundle']);
 
     // The storage details are indexed by a storage engine type.
-    $this->assertTrue(array_key_exists('sql', $field['storage']['details']), t('The storage type is SQL.'));
+    $this->assertTrue(array_key_exists('sql', $field['storage']['details']), 'The storage type is SQL.');
 
     // The SQL details are indexed by table name.
     $details = $field['storage']['details']['sql'];
-    $this->assertTrue(array_key_exists($current, $details[FIELD_LOAD_CURRENT]), t('Table name is available in the instance array.'));
-    $this->assertTrue(array_key_exists($revision, $details[FIELD_LOAD_REVISION]), t('Revision table name is available in the instance array.'));
+    $this->assertTrue(array_key_exists($current, $details[FIELD_LOAD_CURRENT]), 'Table name is available in the instance array.');
+    $this->assertTrue(array_key_exists($revision, $details[FIELD_LOAD_REVISION]), 'Revision table name is available in the instance array.');
 
     // Test current and revision storage details together because the columns
     // are the same.
     foreach ((array) $this->field['columns'] as $column_name => $attributes) {
       $storage_column_name = _field_sql_storage_columnname($this->field['field_name'], $column_name);
-      $this->assertEqual($details[FIELD_LOAD_CURRENT][$current][$column_name], $storage_column_name, t('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => $current)));
-      $this->assertEqual($details[FIELD_LOAD_REVISION][$revision][$column_name], $storage_column_name, t('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => $revision)));
+      $this->assertEqual($details[FIELD_LOAD_CURRENT][$current][$column_name], $storage_column_name, format_string('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => $current)));
+      $this->assertEqual($details[FIELD_LOAD_REVISION][$revision][$column_name], $storage_column_name, format_string('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => $revision)));
     }
   }
 
@@ -407,21 +407,35 @@ class FieldSqlStorageTestCase extends DrupalWebTestCase {
    * Test foreign key support.
    */
   function testFieldSqlStorageForeignKeys() {
-    // Create a decimal field.
+    // Create a 'shape' field, with a configurable foreign key (see
+    // field_test_field_schema()).
     $field_name = 'testfield';
-    $field = array('field_name' => $field_name, 'type' => 'text');
-    $field = field_create_field($field);
-    // Retrieve the field and instance with field_info and verify the foreign
-    // keys are in place.
+    $foreign_key_name = 'shape';
+    $field = array('field_name' => $field_name, 'type' => 'shape', 'settings' => array('foreign_key_name' => $foreign_key_name));
+    field_create_field($field);
+
+    // Retrieve the field definition and check that the foreign key is in place.
     $field = field_info_field($field_name);
-    $this->assertEqual($field['foreign keys']['format']['table'], 'filter_format', t('Foreign key table name preserved through CRUD'));
-    $this->assertEqual($field['foreign keys']['format']['columns']['format'], 'format', t('Foreign key column name preserved through CRUD'));
+    $this->assertEqual($field['foreign keys'][$foreign_key_name]['table'], $foreign_key_name, 'Foreign key table name preserved through CRUD');
+    $this->assertEqual($field['foreign keys'][$foreign_key_name]['columns'][$foreign_key_name], 'id', 'Foreign key column name preserved through CRUD');
+
+    // Update the field settings, it should update the foreign key definition
+    // too.
+    $foreign_key_name = 'color';
+    $field['settings']['foreign_key_name'] = $foreign_key_name;
+    field_update_field($field);
+
+    // Retrieve the field definition and check that the foreign key is in place.
+    $field = field_info_field($field_name);
+    $this->assertEqual($field['foreign keys'][$foreign_key_name]['table'], $foreign_key_name, 'Foreign key table name modified after update');
+    $this->assertEqual($field['foreign keys'][$foreign_key_name]['columns'][$foreign_key_name], 'id', 'Foreign key column name modified after update');
+
     // Now grab the SQL schema and verify that too.
-    $schema = drupal_get_schema(_field_sql_storage_tablename($field));
-    $this->assertEqual(count($schema['foreign keys']), 1, t("There is 1 foreign key in the schema"));
+    $schema = drupal_get_schema(_field_sql_storage_tablename($field), TRUE);
+    $this->assertEqual(count($schema['foreign keys']), 1, 'There is 1 foreign key in the schema');
     $foreign_key = reset($schema['foreign keys']);
-    $filter_column = _field_sql_storage_columnname($field['field_name'], 'format');
-    $this->assertEqual($foreign_key['table'], 'filter_format', t('Foreign key table name preserved in the schema'));
-    $this->assertEqual($foreign_key['columns'][$filter_column], 'format', t('Foreign key column name preserved in the schema'));
+    $foreign_key_column = _field_sql_storage_columnname($field['field_name'], $foreign_key_name);
+    $this->assertEqual($foreign_key['table'], $foreign_key_name, 'Foreign key table name preserved in the schema');
+    $this->assertEqual($foreign_key['columns'][$foreign_key_column], 'id', 'Foreign key column name preserved in the schema');
   }
 }
diff --git a/modules/field/modules/list/tests/list.test b/modules/field/modules/list/tests/list.test
index 7a0f46c..84de7e8 100644
--- a/modules/field/modules/list/tests/list.test
+++ b/modules/field/modules/list/tests/list.test
@@ -51,9 +51,9 @@ class ListFieldTestCase extends FieldTestCase {
     // All three options appear.
     $entity = field_test_create_stub_entity();
     $form = drupal_get_form('field_test_entity_form', $entity);
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][1]), t('Option 1 exists'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][2]), t('Option 2 exists'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][3]), t('Option 3 exists'));
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][1]), 'Option 1 exists');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][2]), 'Option 2 exists');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][3]), 'Option 3 exists');
 
     // Use one of the values in an actual entity, and check that this value
     // cannot be removed from the list.
@@ -77,19 +77,19 @@ class ListFieldTestCase extends FieldTestCase {
     field_update_field($this->field);
     $entity = field_test_create_stub_entity();
     $form = drupal_get_form('field_test_entity_form', $entity);
-    $this->assertTrue(empty($form[$this->field_name][$langcode][1]), t('Option 1 does not exist'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][2]), t('Option 2 exists'));
-    $this->assertTrue(empty($form[$this->field_name][$langcode][3]), t('Option 3 does not exist'));
+    $this->assertTrue(empty($form[$this->field_name][$langcode][1]), 'Option 1 does not exist');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][2]), 'Option 2 exists');
+    $this->assertTrue(empty($form[$this->field_name][$langcode][3]), 'Option 3 does not exist');
 
     // Completely new options appear.
     $this->field['settings']['allowed_values'] = array(10 => 'Update', 20 => 'Twenty');
     field_update_field($this->field);
     $form = drupal_get_form('field_test_entity_form', $entity);
-    $this->assertTrue(empty($form[$this->field_name][$langcode][1]), t('Option 1 does not exist'));
-    $this->assertTrue(empty($form[$this->field_name][$langcode][2]), t('Option 2 does not exist'));
-    $this->assertTrue(empty($form[$this->field_name][$langcode][3]), t('Option 3 does not exist'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][10]), t('Option 10 exists'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][20]), t('Option 20 exists'));
+    $this->assertTrue(empty($form[$this->field_name][$langcode][1]), 'Option 1 does not exist');
+    $this->assertTrue(empty($form[$this->field_name][$langcode][2]), 'Option 2 does not exist');
+    $this->assertTrue(empty($form[$this->field_name][$langcode][3]), 'Option 3 does not exist');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][10]), 'Option 10 exists');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][20]), 'Option 20 exists');
 
     // Options are reset when a new field with the same name is created.
     field_delete_field($this->field_name);
@@ -107,9 +107,9 @@ class ListFieldTestCase extends FieldTestCase {
     $this->instance = field_create_instance($this->instance);
     $entity = field_test_create_stub_entity();
     $form = drupal_get_form('field_test_entity_form', $entity);
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][1]), t('Option 1 exists'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][2]), t('Option 2 exists'));
-    $this->assertTrue(!empty($form[$this->field_name][$langcode][3]), t('Option 3 exists'));
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][1]), 'Option 1 exists');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][2]), 'Option 2 exists');
+    $this->assertTrue(!empty($form[$this->field_name][$langcode][3]), 'Option 3 exists');
   }
 }
 
@@ -233,20 +233,20 @@ class ListFieldUITestCase extends FieldTestCase {
     // Flat list of textual values.
     $string = "Zero\nOne";
     $array = array('0' => 'Zero', '1' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Unkeyed lists are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Unkeyed lists are accepted.');
     // Explicit integer keys.
     $string = "0|Zero\n2|Two";
     $array = array('0' => 'Zero', '2' => 'Two');
-    $this->assertAllowedValuesInput($string, $array, t('Integer keys are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Integer keys are accepted.');
     // Check that values can be added and removed.
     $string = "0|Zero\n1|One";
     $array = array('0' => 'Zero', '1' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Values can be added and removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values can be added and removed.');
     // Non-integer keys.
-    $this->assertAllowedValuesInput("1.1|One", 'keys must be integers', t('Non integer keys are rejected.'));
-    $this->assertAllowedValuesInput("abc|abc", 'keys must be integers', t('Non integer keys are rejected.'));
+    $this->assertAllowedValuesInput("1.1|One", 'keys must be integers', 'Non integer keys are rejected.');
+    $this->assertAllowedValuesInput("abc|abc", 'keys must be integers', 'Non integer keys are rejected.');
     // Mixed list of keyed and unkeyed values.
-    $this->assertAllowedValuesInput("Zero\n1|One", 'invalid input', t('Mixed lists are rejected.'));
+    $this->assertAllowedValuesInput("Zero\n1|One", 'invalid input', 'Mixed lists are rejected.');
 
     // Create a node with actual data for the field.
     $settings = array(
@@ -256,22 +256,22 @@ class ListFieldUITestCase extends FieldTestCase {
     $node = $this->drupalCreateNode($settings);
 
     // Check that a flat list of values is rejected once the field has data.
-    $this->assertAllowedValuesInput( "Zero\nOne", 'invalid input', t('Unkeyed lists are rejected once the field has data.'));
+    $this->assertAllowedValuesInput( "Zero\nOne", 'invalid input', 'Unkeyed lists are rejected once the field has data.');
 
     // Check that values can be added but values in use cannot be removed.
     $string = "0|Zero\n1|One\n2|Two";
     $array = array('0' => 'Zero', '1' => 'One', '2' => 'Two');
-    $this->assertAllowedValuesInput($string, $array, t('Values can be added.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values can be added.');
     $string = "0|Zero\n1|One";
     $array = array('0' => 'Zero', '1' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Values not in use can be removed.'));
-    $this->assertAllowedValuesInput("0|Zero", 'some values are being removed while currently in use', t('Values in use cannot be removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values not in use can be removed.');
+    $this->assertAllowedValuesInput("0|Zero", 'some values are being removed while currently in use', 'Values in use cannot be removed.');
 
     // Delete the node, remove the value.
     node_delete($node->nid);
     $string = "0|Zero";
     $array = array('0' => 'Zero');
-    $this->assertAllowedValuesInput($string, $array, t('Values not in use can be removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values not in use can be removed.');
   }
 
   /**
@@ -284,19 +284,19 @@ class ListFieldUITestCase extends FieldTestCase {
     // Flat list of textual values.
     $string = "Zero\nOne";
     $array = array('0' => 'Zero', '1' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Unkeyed lists are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Unkeyed lists are accepted.');
     // Explicit numeric keys.
     $string = "0|Zero\n.5|Point five";
     $array = array('0' => 'Zero', '0.5' => 'Point five');
-    $this->assertAllowedValuesInput($string, $array, t('Integer keys are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Integer keys are accepted.');
     // Check that values can be added and removed.
     $string = "0|Zero\n.5|Point five\n1.0|One";
     $array = array('0' => 'Zero', '0.5' => 'Point five', '1' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Values can be added and removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values can be added and removed.');
     // Non-numeric keys.
-    $this->assertAllowedValuesInput("abc|abc\n", 'each key must be a valid integer or decimal', t('Non numeric keys are rejected.'));
+    $this->assertAllowedValuesInput("abc|abc\n", 'each key must be a valid integer or decimal', 'Non numeric keys are rejected.');
     // Mixed list of keyed and unkeyed values.
-    $this->assertAllowedValuesInput("Zero\n1|One\n", 'invalid input', t('Mixed lists are rejected.'));
+    $this->assertAllowedValuesInput("Zero\n1|One\n", 'invalid input', 'Mixed lists are rejected.');
 
     // Create a node with actual data for the field.
     $settings = array(
@@ -306,22 +306,22 @@ class ListFieldUITestCase extends FieldTestCase {
     $node = $this->drupalCreateNode($settings);
 
     // Check that a flat list of values is rejected once the field has data.
-    $this->assertAllowedValuesInput("Zero\nOne", 'invalid input', t('Unkeyed lists are rejected once the field has data.'));
+    $this->assertAllowedValuesInput("Zero\nOne", 'invalid input', 'Unkeyed lists are rejected once the field has data.');
 
     // Check that values can be added but values in use cannot be removed.
     $string = "0|Zero\n.5|Point five\n2|Two";
     $array = array('0' => 'Zero', '0.5' => 'Point five', '2' => 'Two');
-    $this->assertAllowedValuesInput($string, $array, t('Values can be added.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values can be added.');
     $string = "0|Zero\n.5|Point five";
     $array = array('0' => 'Zero', '0.5' => 'Point five');
-    $this->assertAllowedValuesInput($string, $array, t('Values not in use can be removed.'));
-    $this->assertAllowedValuesInput("0|Zero", 'some values are being removed while currently in use', t('Values in use cannot be removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values not in use can be removed.');
+    $this->assertAllowedValuesInput("0|Zero", 'some values are being removed while currently in use', 'Values in use cannot be removed.');
 
     // Delete the node, remove the value.
     node_delete($node->nid);
     $string = "0|Zero";
     $array = array('0' => 'Zero');
-    $this->assertAllowedValuesInput($string, $array, t('Values not in use can be removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values not in use can be removed.');
   }
 
   /**
@@ -334,21 +334,21 @@ class ListFieldUITestCase extends FieldTestCase {
     // Flat list of textual values.
     $string = "Zero\nOne";
     $array = array('Zero' => 'Zero', 'One' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Unkeyed lists are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Unkeyed lists are accepted.');
     // Explicit keys.
     $string = "zero|Zero\none|One";
     $array = array('zero' => 'Zero', 'one' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Explicit keys are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Explicit keys are accepted.');
     // Check that values can be added and removed.
     $string = "zero|Zero\ntwo|Two";
     $array = array('zero' => 'Zero', 'two' => 'Two');
-    $this->assertAllowedValuesInput($string, $array, t('Values can be added and removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values can be added and removed.');
     // Mixed list of keyed and unkeyed values.
     $string = "zero|Zero\nOne\n";
     $array = array('zero' => 'Zero', 'One' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Mixed lists are accepted.'));
+    $this->assertAllowedValuesInput($string, $array, 'Mixed lists are accepted.');
     // Overly long keys.
-    $this->assertAllowedValuesInput("zero|Zero\n" . $this->randomName(256) . "|One", 'each key must be a string at most 255 characters long', t('Overly long keys are rejected.'));
+    $this->assertAllowedValuesInput("zero|Zero\n" . $this->randomName(256) . "|One", 'each key must be a string at most 255 characters long', 'Overly long keys are rejected.');
 
     // Create a node with actual data for the field.
     $settings = array(
@@ -361,22 +361,22 @@ class ListFieldUITestCase extends FieldTestCase {
     // data.
     $string = "Zero\nOne";
     $array = array('Zero' => 'Zero', 'One' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Unkeyed lists are still accepted once the field has data.'));
+    $this->assertAllowedValuesInput($string, $array, 'Unkeyed lists are still accepted once the field has data.');
 
     // Check that values can be added but values in use cannot be removed.
     $string = "Zero\nOne\nTwo";
     $array = array('Zero' => 'Zero', 'One' => 'One', 'Two' => 'Two');
-    $this->assertAllowedValuesInput($string, $array, t('Values can be added.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values can be added.');
     $string = "Zero\nOne";
     $array = array('Zero' => 'Zero', 'One' => 'One');
-    $this->assertAllowedValuesInput($string, $array, t('Values not in use can be removed.'));
-    $this->assertAllowedValuesInput("Zero", 'some values are being removed while currently in use', t('Values in use cannot be removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values not in use can be removed.');
+    $this->assertAllowedValuesInput("Zero", 'some values are being removed while currently in use', 'Values in use cannot be removed.');
 
     // Delete the node, remove the value.
     node_delete($node->nid);
     $string = "Zero";
     $array = array('Zero' => 'Zero');
-    $this->assertAllowedValuesInput($string, $array, t('Values not in use can be removed.'));
+    $this->assertAllowedValuesInput($string, $array, 'Values not in use can be removed.');
   }
 
   /**
@@ -395,15 +395,15 @@ class ListFieldUITestCase extends FieldTestCase {
       'off' => $off,
     );
     $this->drupalPost($this->admin_path, $edit, t('Save settings'));
-    $this->assertText("Saved field_list_boolean configuration.", t("The 'On' and 'Off' form fields work for boolean fields."));
+    $this->assertText("Saved field_list_boolean configuration.", "The 'On' and 'Off' form fields work for boolean fields.");
     // Test the allowed_values on the field settings form.
     $this->drupalGet($this->admin_path);
-    $this->assertFieldByName('on', $on, t("The 'On' value is stored correctly."));
-    $this->assertFieldByName('off', $off, t("The 'Off' value is stored correctly."));
+    $this->assertFieldByName('on', $on, "The 'On' value is stored correctly.");
+    $this->assertFieldByName('off', $off, "The 'Off' value is stored correctly.");
     $field = field_info_field($this->field_name);
-    $this->assertEqual($field['settings']['allowed_values'], $allowed_values, t('The allowed value is correct'));
-    $this->assertFalse(isset($field['settings']['on']), t('The on value is not saved into settings'));
-    $this->assertFalse(isset($field['settings']['off']), t('The off value is not saved into settings'));
+    $this->assertEqual($field['settings']['allowed_values'], $allowed_values, 'The allowed value is correct');
+    $this->assertFalse(isset($field['settings']['on']), 'The on value is not saved into settings');
+    $this->assertFalse(isset($field['settings']['off']), 'The off value is not saved into settings');
   }
 
   /**
diff --git a/modules/field/modules/number/number.test b/modules/field/modules/number/number.test
index e5e7e8c..88029cd 100644
--- a/modules/field/modules/number/number.test
+++ b/modules/field/modules/number/number.test
@@ -58,7 +58,7 @@ class NumberFieldTestCase extends DrupalWebTestCase {
     // Display creation form.
     $this->drupalGet('test-entity/add/test-bundle');
     $langcode = LANGUAGE_NONE;
-    $this->assertFieldByName("{$this->field['field_name']}[$langcode][0][value]", '', t('Widget is displayed'));
+    $this->assertFieldByName("{$this->field['field_name']}[$langcode][0][value]", '', 'Widget is displayed');
 
     // Submit a signed decimal value within the allowed precision and scale.
     $value = '-1234.5678';
@@ -68,8 +68,8 @@ class NumberFieldTestCase extends DrupalWebTestCase {
     $this->drupalPost(NULL, $edit, t('Save'));
     preg_match('|test-entity/manage/(\d+)/edit|', $this->url, $match);
     $id = $match[1];
-    $this->assertRaw(t('test_entity @id has been created.', array('@id' => $id)), t('Entity was created'));
-    $this->assertRaw(round($value, 2), t('Value is displayed.'));
+    $this->assertRaw(t('test_entity @id has been created.', array('@id' => $id)), 'Entity was created');
+    $this->assertRaw(round($value, 2), 'Value is displayed.');
 
     // Try to create entries with more than one decimal separator; assert fail.
     $wrong_entries = array(
@@ -89,7 +89,7 @@ class NumberFieldTestCase extends DrupalWebTestCase {
       $this->assertText(
         t('There should only be one decimal separator (@separator)',
           array('@separator' => $this->field['settings']['decimal_separator'])),
-        t('Correctly failed to save decimal value with more than one decimal point.')
+        'Correctly failed to save decimal value with more than one decimal point.'
       );
     }
 
diff --git a/modules/field/modules/options/options.test b/modules/field/modules/options/options.test
index 69d6116..44b3caf 100644
--- a/modules/field/modules/options/options.test
+++ b/modules/field/modules/options/options.test
@@ -1,7 +1,7 @@
 <?php
 
 /**
- * @file 
+ * @file
  * Tests for options.module.
  */
 
@@ -85,7 +85,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $this->assertNoFieldChecked("edit-card-1-$langcode-0");
     $this->assertNoFieldChecked("edit-card-1-$langcode-1");
     $this->assertNoFieldChecked("edit-card-1-$langcode-2");
-    $this->assertRaw('Some dangerous &amp; unescaped <strong>markup</strong>', t('Option text was properly filtered.'));
+    $this->assertRaw('Some dangerous &amp; unescaped <strong>markup</strong>', 'Option text was properly filtered.');
 
     // Select first option.
     $edit = array("card_1[$langcode]" => 0);
@@ -139,7 +139,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $this->assertNoFieldChecked("edit-card-2-$langcode-0");
     $this->assertNoFieldChecked("edit-card-2-$langcode-1");
     $this->assertNoFieldChecked("edit-card-2-$langcode-2");
-    $this->assertRaw('Some dangerous &amp; unescaped <strong>markup</strong>', t('Option text was properly filtered.'));
+    $this->assertRaw('Some dangerous &amp; unescaped <strong>markup</strong>', 'Option text was properly filtered.');
 
     // Submit form: select first and third options.
     $edit = array(
@@ -178,7 +178,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
       "card_2[$langcode][2]" => TRUE,
     );
     $this->drupalPost(NULL, $edit, t('Save'));
-    $this->assertText('this field cannot hold more than 2 values', t('Validation error was displayed.'));
+    $this->assertText('this field cannot hold more than 2 values', 'Validation error was displayed.');
 
     // Submit form: uncheck all options.
     $edit = array(
@@ -225,19 +225,19 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     // Display form.
     $this->drupalGet('test-entity/manage/' . $entity->ftid . '/edit');
     // A required field without any value has a "none" option.
-    $this->assertTrue($this->xpath('//select[@id=:id]//option[@value="_none" and text()=:label]', array(':id' => 'edit-card-1-' . $langcode, ':label' => t('- Select a value -'))), t('A required select list has a "Select a value" choice.'));
+    $this->assertTrue($this->xpath('//select[@id=:id]//option[@value="_none" and text()=:label]', array(':id' => 'edit-card-1-' . $langcode, ':label' => t('- Select a value -'))), 'A required select list has a "Select a value" choice.');
 
     // With no field data, nothing is selected.
     $this->assertNoOptionSelected("edit-card-1-$langcode", '_none');
     $this->assertNoOptionSelected("edit-card-1-$langcode", 0);
     $this->assertNoOptionSelected("edit-card-1-$langcode", 1);
     $this->assertNoOptionSelected("edit-card-1-$langcode", 2);
-    $this->assertRaw('Some dangerous &amp; unescaped markup', t('Option text was properly filtered.'));
+    $this->assertRaw('Some dangerous &amp; unescaped markup', 'Option text was properly filtered.');
 
     // Submit form: select invalid 'none' option.
     $edit = array("card_1[$langcode]" => '_none');
     $this->drupalPost(NULL, $edit, t('Save'));
-    $this->assertRaw(t('!title field is required.', array('!title' => $instance['field_name'])), t('Cannot save a required field when selecting "none" from the select list.'));
+    $this->assertRaw(t('!title field is required.', array('!title' => $instance['field_name'])), 'Cannot save a required field when selecting "none" from the select list.');
 
     // Submit form: select first option.
     $edit = array("card_1[$langcode]" => 0);
@@ -247,7 +247,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     // Display form: check that the right options are selected.
     $this->drupalGet('test-entity/manage/' . $entity->ftid . '/edit');
     // A required field with a value has no 'none' option.
-    $this->assertFalse($this->xpath('//select[@id=:id]//option[@value="_none"]', array(':id' => 'edit-card-1-' . $langcode)), t('A required select list with an actual value has no "none" choice.'));
+    $this->assertFalse($this->xpath('//select[@id=:id]//option[@value="_none"]', array(':id' => 'edit-card-1-' . $langcode)), 'A required select list with an actual value has no "none" choice.');
     $this->assertOptionSelected("edit-card-1-$langcode", 0);
     $this->assertNoOptionSelected("edit-card-1-$langcode", 1);
     $this->assertNoOptionSelected("edit-card-1-$langcode", 2);
@@ -259,7 +259,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     // Display form.
     $this->drupalGet('test-entity/manage/' . $entity->ftid . '/edit');
     // A non-required field has a 'none' option.
-    $this->assertTrue($this->xpath('//select[@id=:id]//option[@value="_none" and text()=:label]', array(':id' => 'edit-card-1-' . $langcode, ':label' => t('- None -'))), t('A non-required select list has a "None" choice.'));
+    $this->assertTrue($this->xpath('//select[@id=:id]//option[@value="_none" and text()=:label]', array(':id' => 'edit-card-1-' . $langcode, ':label' => t('- None -'))), 'A non-required select list has a "None" choice.');
     // Submit form: Unselect the option.
     $edit = array("card_1[$langcode]" => '_none');
     $this->drupalPost('test-entity/manage/' . $entity->ftid . '/edit', $edit, t('Save'));
@@ -276,8 +276,8 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $this->assertNoOptionSelected("edit-card-1-$langcode", 0);
     $this->assertNoOptionSelected("edit-card-1-$langcode", 1);
     $this->assertNoOptionSelected("edit-card-1-$langcode", 2);
-    $this->assertRaw('Some dangerous &amp; unescaped markup', t('Option text was properly filtered.'));
-    $this->assertRaw('Group 1', t('Option groups are displayed.'));
+    $this->assertRaw('Some dangerous &amp; unescaped markup', 'Option text was properly filtered.');
+    $this->assertRaw('Group 1', 'Option groups are displayed.');
 
     // Submit form: select first option.
     $edit = array("card_1[$langcode]" => 0);
@@ -323,7 +323,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $this->assertNoOptionSelected("edit-card-2-$langcode", 0);
     $this->assertNoOptionSelected("edit-card-2-$langcode", 1);
     $this->assertNoOptionSelected("edit-card-2-$langcode", 2);
-    $this->assertRaw('Some dangerous &amp; unescaped markup', t('Option text was properly filtered.'));
+    $this->assertRaw('Some dangerous &amp; unescaped markup', 'Option text was properly filtered.');
 
     // Submit form: select first and third options.
     $edit = array("card_2[$langcode][]" => array(0 => 0, 2 => 2));
@@ -350,7 +350,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     // Submit form: select the three options while the field accepts only 2.
     $edit = array("card_2[$langcode][]" => array(0 => 0, 1 => 1, 2 => 2));
     $this->drupalPost(NULL, $edit, t('Save'));
-    $this->assertText('this field cannot hold more than 2 values', t('Validation error was displayed.'));
+    $this->assertText('this field cannot hold more than 2 values', 'Validation error was displayed.');
 
     // Submit form: uncheck all options.
     $edit = array("card_2[$langcode][]" => array());
@@ -374,7 +374,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $instance['required'] = TRUE;
     field_update_instance($instance);
     $this->drupalGet('test-entity/manage/' . $entity->ftid . '/edit');
-    $this->assertFalse($this->xpath('//select[@id=:id]//option[@value=""]', array(':id' => 'edit-card-2-' . $langcode)), t('A required select list does not have an empty key.'));
+    $this->assertFalse($this->xpath('//select[@id=:id]//option[@value=""]', array(':id' => 'edit-card-2-' . $langcode)), 'A required select list does not have an empty key.');
 
     // We do not have to test that a required select list with one option is
     // auto-selected because the browser does it for us.
@@ -393,8 +393,8 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $this->assertNoOptionSelected("edit-card-2-$langcode", 0);
     $this->assertNoOptionSelected("edit-card-2-$langcode", 1);
     $this->assertNoOptionSelected("edit-card-2-$langcode", 2);
-    $this->assertRaw('Some dangerous &amp; unescaped markup', t('Option text was properly filtered.'));
-    $this->assertRaw('Group 1', t('Option groups are displayed.'));
+    $this->assertRaw('Some dangerous &amp; unescaped markup', 'Option text was properly filtered.');
+    $this->assertRaw('Group 1', 'Option groups are displayed.');
 
     // Submit form: select first option.
     $edit = array("card_2[$langcode][]" => array(0 => 0));
@@ -438,7 +438,7 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     // Display form: with no field data, option is unchecked.
     $this->drupalGet('test-entity/manage/' . $entity->ftid . '/edit');
     $this->assertNoFieldChecked("edit-bool-$langcode");
-    $this->assertRaw('Some dangerous &amp; unescaped <strong>markup</strong>', t('Option text was properly filtered.'));
+    $this->assertRaw('Some dangerous &amp; unescaped <strong>markup</strong>', 'Option text was properly filtered.');
 
     // Submit form: check the option.
     $edit = array("bool[$langcode]" => TRUE);
@@ -483,13 +483,13 @@ class OptionsWidgetsTestCase extends FieldTestCase {
 
     $this->assertText(
       'Use field label instead of the "On value" as label ',
-      t('Display setting checkbox available.')
+      'Display setting checkbox available.'
     );
 
     $this->assertFieldByXPath(
       '*//label[@for="edit-' . $this->bool['field_name'] . '-und" and text()="MyOnValue "]',
       TRUE,
-      t('Default case shows "On value"')
+      'Default case shows "On value"'
     );
 
     // Enable setting
@@ -502,16 +502,16 @@ class OptionsWidgetsTestCase extends FieldTestCase {
     $this->drupalGet($fieldEditUrl);
     $this->assertText(
       'Use field label instead of the "On value" as label ',
-      t('Display setting checkbox is available')
+      'Display setting checkbox is available'
     );
     $this->assertFieldChecked(
       'edit-instance-widget-settings-display-label',
-      t('Display settings checkbox checked')
+      'Display settings checkbox checked'
     );
     $this->assertFieldByXPath(
       '*//label[@for="edit-' . $this->bool['field_name'] . '-und" and text()="' . $this->bool['field_name'] . ' "]',
       TRUE,
-      t('Display label changes label of the checkbox')
+      'Display label changes label of the checkbox'
     );
   }
 }
diff --git a/modules/field/modules/text/text.test b/modules/field/modules/text/text.test
index 5936937..2f14738 100644
--- a/modules/field/modules/text/text.test
+++ b/modules/field/modules/text/text.test
@@ -110,8 +110,8 @@ class TextFieldTestCase extends DrupalWebTestCase {
 
     // Display creation form.
     $this->drupalGet('test-entity/add/test-bundle');
-    $this->assertFieldByName("{$this->field_name}[$langcode][0][value]", '', t('Widget is displayed'));
-    $this->assertNoFieldByName("{$this->field_name}[$langcode][0][format]", '1', t('Format selector is not displayed'));
+    $this->assertFieldByName("{$this->field_name}[$langcode][0][value]", '', 'Widget is displayed');
+    $this->assertNoFieldByName("{$this->field_name}[$langcode][0][format]", '1', 'Format selector is not displayed');
 
     // Submit with some value.
     $value = $this->randomName();
@@ -121,7 +121,7 @@ class TextFieldTestCase extends DrupalWebTestCase {
     $this->drupalPost(NULL, $edit, t('Save'));
     preg_match('|test-entity/manage/(\d+)/edit|', $this->url, $match);
     $id = $match[1];
-    $this->assertRaw(t('test_entity @id has been created.', array('@id' => $id)), t('Entity was created'));
+    $this->assertRaw(t('test_entity @id has been created.', array('@id' => $id)), 'Entity was created');
 
     // Display the entity.
     $entity = field_test_entity_test_load($id);
@@ -179,8 +179,8 @@ class TextFieldTestCase extends DrupalWebTestCase {
     // Display the creation form. Since the user only has access to one format,
     // no format selector will be displayed.
     $this->drupalGet('test-entity/add/test-bundle');
-    $this->assertFieldByName("{$this->field_name}[$langcode][0][value]", '', t('Widget is displayed'));
-    $this->assertNoFieldByName("{$this->field_name}[$langcode][0][format]", '', t('Format selector is not displayed'));
+    $this->assertFieldByName("{$this->field_name}[$langcode][0][value]", '', 'Widget is displayed');
+    $this->assertNoFieldByName("{$this->field_name}[$langcode][0][format]", '', 'Format selector is not displayed');
 
     // Submit with data that should be filtered.
     $value = '<em>' . $this->randomName() . '</em>';
@@ -190,14 +190,14 @@ class TextFieldTestCase extends DrupalWebTestCase {
     $this->drupalPost(NULL, $edit, t('Save'));
     preg_match('|test-entity/manage/(\d+)/edit|', $this->url, $match);
     $id = $match[1];
-    $this->assertRaw(t('test_entity @id has been created.', array('@id' => $id)), t('Entity was created'));
+    $this->assertRaw(t('test_entity @id has been created.', array('@id' => $id)), 'Entity was created');
 
     // Display the entity.
     $entity = field_test_entity_test_load($id);
     $entity->content = field_attach_view($entity_type, $entity, 'full');
     $this->content = drupal_render($entity->content);
-    $this->assertNoRaw($value, t('HTML tags are not displayed.'));
-    $this->assertRaw(check_plain($value), t('Escaped HTML is displayed correctly.'));
+    $this->assertNoRaw($value, 'HTML tags are not displayed.');
+    $this->assertRaw(check_plain($value), 'Escaped HTML is displayed correctly.');
 
     // Create a new text format that does not escape HTML, and grant the user
     // access to it.
@@ -219,21 +219,21 @@ class TextFieldTestCase extends DrupalWebTestCase {
     // Display edition form.
     // We should now have a 'text format' selector.
     $this->drupalGet('test-entity/manage/' . $id . '/edit');
-    $this->assertFieldByName("{$this->field_name}[$langcode][0][value]", NULL, t('Widget is displayed'));
-    $this->assertFieldByName("{$this->field_name}[$langcode][0][format]", NULL, t('Format selector is displayed'));
+    $this->assertFieldByName("{$this->field_name}[$langcode][0][value]", NULL, 'Widget is displayed');
+    $this->assertFieldByName("{$this->field_name}[$langcode][0][format]", NULL, 'Format selector is displayed');
 
     // Edit and change the text format to the new one that was created.
     $edit = array(
       "{$this->field_name}[$langcode][0][format]" => $format_id,
     );
     $this->drupalPost(NULL, $edit, t('Save'));
-    $this->assertRaw(t('test_entity @id has been updated.', array('@id' => $id)), t('Entity was updated'));
+    $this->assertRaw(t('test_entity @id has been updated.', array('@id' => $id)), 'Entity was updated');
 
     // Display the entity.
     $entity = field_test_entity_test_load($id);
     $entity->content = field_attach_view($entity_type, $entity, 'full');
     $this->content = drupal_render($entity->content);
-    $this->assertRaw($value, t('Value is displayed unfiltered'));
+    $this->assertRaw($value, 'Value is displayed unfiltered');
   }
 }
 
@@ -383,7 +383,7 @@ class TextSummaryTestCase extends DrupalWebTestCase {
    */
   function callTextSummary($text, $expected, $format = NULL, $size = NULL) {
     $summary = text_summary($text, $format, $size);
-    $this->assertIdentical($summary, $expected, t('Generated summary "@summary" matches expected "@expected".', array('@summary' => $summary, '@expected' => $expected)));
+    $this->assertIdentical($summary, $expected, format_string('Generated summary "@summary" matches expected "@expected".', array('@summary' => $summary, '@expected' => $expected)));
   }
 
   /**
@@ -401,7 +401,7 @@ class TextSummaryTestCase extends DrupalWebTestCase {
     $this->drupalPost('node/add/article', $edit, t('Save'));
     $node = $this->drupalGetNodeByTitle($edit['title']);
 
-    $this->assertIdentical($node->body['und'][0]['summary'], $summary, t('Article with with summary and no body has been submitted.'));
+    $this->assertIdentical($node->body['und'][0]['summary'], $summary, 'Article with with summary and no body has been submitted.');
   }
 }
 
@@ -436,7 +436,7 @@ class TextTranslationTestCase extends DrupalWebTestCase {
     // Set "Article" content type to use multilingual support with translation.
     $edit = array('language_content_type' => 2);
     $this->drupalPost('admin/structure/types/manage/article', $edit, t('Save content type'));
-    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Article')), t('Article content type has been updated.'));
+    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Article')), 'Article content type has been updated.');
   }
 
   /**
@@ -464,7 +464,7 @@ class TextTranslationTestCase extends DrupalWebTestCase {
     $node = $this->drupalGetNodeByTitle($edit['title']);
     $this->drupalGet("node/$node->nid/translate");
     $this->clickLink(t('add translation'));
-    $this->assertFieldByXPath("//textarea[@name='body[$langcode][0][value]']", $body, t('The textfield widget is populated.'));
+    $this->assertFieldByXPath("//textarea[@name='body[$langcode][0][value]']", $body, 'The textfield widget is populated.');
   }
 
   /**
@@ -476,7 +476,7 @@ class TextTranslationTestCase extends DrupalWebTestCase {
     $edit = array('field[cardinality]' => -1);
     $this->drupalPost('admin/structure/types/manage/article/fields/body', $edit, t('Save settings'));
     $this->drupalGet('node/add/article');
-    $this->assertFieldByXPath("//input[@name='body_add_more']", t('Add another item'), t('Body field cardinality set to multiple.'));
+    $this->assertFieldByXPath("//input[@name='body_add_more']", t('Add another item'), 'Body field cardinality set to multiple.');
 
     $body = array(
       $this->randomName(),
@@ -501,7 +501,7 @@ class TextTranslationTestCase extends DrupalWebTestCase {
         "body[$langcode][$delta][format]" => array_shift($formats),
       );
       $this->drupalPost('node/1/edit', $edit, t('Save'));
-      $this->assertText($body[$delta], t('The body field with delta @delta has been saved.', array('@delta' => $delta)));
+      $this->assertText($body[$delta], format_string('The body field with delta @delta has been saved.', array('@delta' => $delta)));
     }
 
     // Login as translator.
@@ -511,7 +511,7 @@ class TextTranslationTestCase extends DrupalWebTestCase {
     $node = $this->drupalGetNodeByTitle($title);
     $this->drupalGet("node/$node->nid/translate");
     $this->clickLink(t('add translation'));
-    $this->assertNoText($body[0], t('The body field with delta @delta is hidden.', array('@delta' => 0)));
-    $this->assertText($body[1], t('The body field with delta @delta is shown.', array('@delta' => 1)));
+    $this->assertNoText($body[0], format_string('The body field with delta @delta is hidden.', array('@delta' => 0)));
+    $this->assertText($body[1], format_string('The body field with delta @delta is shown.', array('@delta' => 1)));
   }
 }
diff --git a/modules/field/tests/field.test b/modules/field/tests/field.test
index 8004178..1e59315 100644
--- a/modules/field/tests/field.test
+++ b/modules/field/tests/field.test
@@ -64,9 +64,9 @@ class FieldTestCase extends DrupalWebTestCase {
     $e = clone $entity;
     field_attach_load('test_entity', array($e->ftid => $e));
     $values = isset($e->{$field_name}[$langcode]) ? $e->{$field_name}[$langcode] : array();
-    $this->assertEqual(count($values), count($expected_values), t('Expected number of values were saved.'));
+    $this->assertEqual(count($values), count($expected_values), 'Expected number of values were saved.');
     foreach ($expected_values as $key => $value) {
-      $this->assertEqual($values[$key][$column], $value, t('Value @value was saved correctly.', array('@value' => $value)));
+      $this->assertEqual($values[$key][$column], $value, format_string('Value @value was saved correctly.', array('@value' => $value)));
     }
   }
 }
@@ -85,12 +85,28 @@ class FieldAttachTestCase extends FieldTestCase {
     }
     parent::setUp($modules);
 
-    $this->field_name = drupal_strtolower($this->randomName() . '_field_name');
-    $this->field = array('field_name' => $this->field_name, 'type' => 'test_field', 'cardinality' => 4);
-    $this->field = field_create_field($this->field);
-    $this->field_id = $this->field['id'];
-    $this->instance = array(
-      'field_name' => $this->field_name,
+    $this->createFieldWithInstance();
+  }
+
+  /**
+   * Create a field and an instance of it.
+   *
+   * @param string $suffix
+   *   (optional) A string that should only contain characters that are valid in
+   *   PHP variable names as well.
+   */
+  function createFieldWithInstance($suffix = '') {
+    $field_name = 'field_name' . $suffix;
+    $field = 'field' . $suffix;
+    $field_id = 'field_id' . $suffix;
+    $instance = 'instance' . $suffix;
+
+    $this->$field_name = drupal_strtolower($this->randomName() . '_field_name' . $suffix);
+    $this->$field = array('field_name' => $this->$field_name, 'type' => 'test_field', 'cardinality' => 4);
+    $this->$field = field_create_field($this->$field);
+    $this->$field_id = $this->{$field}['id'];
+    $this->$instance = array(
+      'field_name' => $this->$field_name,
       'entity_type' => 'test_entity',
       'bundle' => 'test_bundle',
       'label' => $this->randomName() . '_label',
@@ -107,7 +123,7 @@ class FieldAttachTestCase extends FieldTestCase {
         )
       )
     );
-    field_create_instance($this->instance);
+    field_create_instance($this->$instance);
   }
 }
 
@@ -166,12 +182,12 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
     $entity = field_test_create_stub_entity(0, 0, $this->instance['bundle']);
     field_attach_load($entity_type, array(0 => $entity));
     // Number of values per field loaded equals the field cardinality.
-    $this->assertEqual(count($entity->{$this->field_name}[$langcode]), $this->field['cardinality'], t('Current revision: expected number of values'));
+    $this->assertEqual(count($entity->{$this->field_name}[$langcode]), $this->field['cardinality'], 'Current revision: expected number of values');
     for ($delta = 0; $delta < $this->field['cardinality']; $delta++) {
       // The field value loaded matches the one inserted or updated.
-      $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['value'] , $values[$current_revision][$delta]['value'], t('Current revision: expected value %delta was found.', array('%delta' => $delta)));
+      $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['value'] , $values[$current_revision][$delta]['value'], format_string('Current revision: expected value %delta was found.', array('%delta' => $delta)));
       // The value added in hook_field_load() is found.
-      $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['additional_key'], 'additional_value', t('Current revision: extra information for value %delta was found', array('%delta' => $delta)));
+      $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['additional_key'], 'additional_value', format_string('Current revision: extra information for value %delta was found', array('%delta' => $delta)));
     }
 
     // Confirm each revision loads the correct data.
@@ -179,12 +195,12 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
       $entity = field_test_create_stub_entity(0, $revision_id, $this->instance['bundle']);
       field_attach_load_revision($entity_type, array(0 => $entity));
       // Number of values per field loaded equals the field cardinality.
-      $this->assertEqual(count($entity->{$this->field_name}[$langcode]), $this->field['cardinality'], t('Revision %revision_id: expected number of values.', array('%revision_id' => $revision_id)));
+      $this->assertEqual(count($entity->{$this->field_name}[$langcode]), $this->field['cardinality'], format_string('Revision %revision_id: expected number of values.', array('%revision_id' => $revision_id)));
       for ($delta = 0; $delta < $this->field['cardinality']; $delta++) {
         // The field value loaded matches the one inserted or updated.
-        $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['value'], $values[$revision_id][$delta]['value'], t('Revision %revision_id: expected value %delta was found.', array('%revision_id' => $revision_id, '%delta' => $delta)));
+        $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['value'], $values[$revision_id][$delta]['value'], format_string('Revision %revision_id: expected value %delta was found.', array('%revision_id' => $revision_id, '%delta' => $delta)));
         // The value added in hook_field_load() is found.
-        $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['additional_key'], 'additional_value', t('Revision %revision_id: extra information for value %delta was found', array('%revision_id' => $revision_id, '%delta' => $delta)));
+        $this->assertEqual($entity->{$this->field_name}[$langcode][$delta]['additional_key'], 'additional_value', format_string('Revision %revision_id: extra information for value %delta was found', array('%revision_id' => $revision_id, '%delta' => $delta)));
       }
     }
   }
@@ -250,19 +266,19 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
       $instances = field_info_instances($entity_type, $bundles[$index]);
       foreach ($instances as $field_name => $instance) {
         // The field value loaded matches the one inserted.
-        $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], $values[$index][$field_name], t('Entity %index: expected value was found.', array('%index' => $index)));
+        $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], $values[$index][$field_name], format_string('Entity %index: expected value was found.', array('%index' => $index)));
         // The value added in hook_field_load() is found.
-        $this->assertEqual($entity->{$field_name}[$langcode][0]['additional_key'], 'additional_value', t('Entity %index: extra information was found', array('%index' => $index)));
+        $this->assertEqual($entity->{$field_name}[$langcode][0]['additional_key'], 'additional_value', format_string('Entity %index: extra information was found', array('%index' => $index)));
       }
     }
 
     // Check that the single-field load option works.
     $entity = field_test_create_stub_entity(1, 1, $bundles[1]);
     field_attach_load($entity_type, array(1 => $entity), FIELD_LOAD_CURRENT, array('field_id' => $field_ids[1]));
-    $this->assertEqual($entity->{$field_names[1]}[$langcode][0]['value'], $values[1][$field_names[1]], t('Entity %index: expected value was found.', array('%index' => 1)));
-    $this->assertEqual($entity->{$field_names[1]}[$langcode][0]['additional_key'], 'additional_value', t('Entity %index: extra information was found', array('%index' => 1)));
-    $this->assert(!isset($entity->{$field_names[2]}), t('Entity %index: field %field_name is not loaded.', array('%index' => 2, '%field_name' => $field_names[2])));
-    $this->assert(!isset($entity->{$field_names[3]}), t('Entity %index: field %field_name is not loaded.', array('%index' => 3, '%field_name' => $field_names[3])));
+    $this->assertEqual($entity->{$field_names[1]}[$langcode][0]['value'], $values[1][$field_names[1]], format_string('Entity %index: expected value was found.', array('%index' => 1)));
+    $this->assertEqual($entity->{$field_names[1]}[$langcode][0]['additional_key'], 'additional_value', format_string('Entity %index: extra information was found', array('%index' => 1)));
+    $this->assert(!isset($entity->{$field_names[2]}), format_string('Entity %index: field %field_name is not loaded.', array('%index' => 2, '%field_name' => $field_names[2])));
+    $this->assert(!isset($entity->{$field_names[3]}), format_string('Entity %index: field %field_name is not loaded.', array('%index' => 3, '%field_name' => $field_names[3])));
   }
 
   /**
@@ -312,7 +328,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
     foreach ($fields as $field) {
-      $this->assertEqual($values[$field['field_name']], $entity->{$field['field_name']}[$langcode], t('%storage storage: expected values were found.', array('%storage' => $field['storage']['type'])));
+      $this->assertEqual($values[$field['field_name']], $entity->{$field['field_name']}[$langcode], format_string('%storage storage: expected values were found.', array('%storage' => $field['storage']['type'])));
     }
   }
 
@@ -341,20 +357,20 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
     $instance = field_info_instance($instance['entity_type'], $instance['field_name'], $instance['bundle']);
 
     // The storage details are indexed by a storage engine type.
-    $this->assertTrue(array_key_exists('drupal_variables', $field['storage']['details']), t('The storage type is Drupal variables.'));
+    $this->assertTrue(array_key_exists('drupal_variables', $field['storage']['details']), 'The storage type is Drupal variables.');
 
     $details = $field['storage']['details']['drupal_variables'];
 
     // The field_test storage details are indexed by variable name. The details
     // are altered, so moon and mars are correct for this test.
-    $this->assertTrue(array_key_exists('moon', $details[FIELD_LOAD_CURRENT]), t('Moon is available in the instance array.'));
-    $this->assertTrue(array_key_exists('mars', $details[FIELD_LOAD_REVISION]), t('Mars is available in the instance array.'));
+    $this->assertTrue(array_key_exists('moon', $details[FIELD_LOAD_CURRENT]), 'Moon is available in the instance array.');
+    $this->assertTrue(array_key_exists('mars', $details[FIELD_LOAD_REVISION]), 'Mars is available in the instance array.');
 
     // Test current and revision storage details together because the columns
     // are the same.
     foreach ((array) $field['columns'] as $column_name => $attributes) {
-      $this->assertEqual($details[FIELD_LOAD_CURRENT]['moon'][$column_name], $column_name, t('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => 'moon[FIELD_LOAD_CURRENT]')));
-      $this->assertEqual($details[FIELD_LOAD_REVISION]['mars'][$column_name], $column_name, t('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => 'mars[FIELD_LOAD_REVISION]')));
+      $this->assertEqual($details[FIELD_LOAD_CURRENT]['moon'][$column_name], $column_name, format_string('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => 'moon[FIELD_LOAD_CURRENT]')));
+      $this->assertEqual($details[FIELD_LOAD_REVISION]['mars'][$column_name], $column_name, format_string('Column name %value matches the definition in %bin.', array('%value' => $column_name, '%bin' => 'mars[FIELD_LOAD_REVISION]')));
     }
   }
 
@@ -372,7 +388,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertTrue(empty($entity->{$this->field_name}), t('Insert: missing field results in no value saved'));
+    $this->assertTrue(empty($entity->{$this->field_name}), 'Insert: missing field results in no value saved');
 
     // Insert: Field is NULL.
     field_cache_clear();
@@ -382,7 +398,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertTrue(empty($entity->{$this->field_name}), t('Insert: NULL field results in no value saved'));
+    $this->assertTrue(empty($entity->{$this->field_name}), 'Insert: NULL field results in no value saved');
 
     // Add some real data.
     field_cache_clear();
@@ -393,7 +409,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, t('Field data saved'));
+    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, 'Field data saved');
 
     // Update: Field is missing. Data should survive.
     field_cache_clear();
@@ -402,7 +418,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, t('Update: missing field leaves existing values in place'));
+    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, 'Update: missing field leaves existing values in place');
 
     // Update: Field is NULL. Data should be wiped.
     field_cache_clear();
@@ -412,7 +428,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertTrue(empty($entity->{$this->field_name}), t('Update: NULL field removes existing values'));
+    $this->assertTrue(empty($entity->{$this->field_name}), 'Update: NULL field removes existing values');
 
     // Re-add some data.
     field_cache_clear();
@@ -423,7 +439,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, t('Field data saved'));
+    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, 'Field data saved');
 
     // Update: Field is empty array. Data should be wiped.
     field_cache_clear();
@@ -433,7 +449,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertTrue(empty($entity->{$this->field_name}), t('Update: empty array removes existing values'));
+    $this->assertTrue(empty($entity->{$this->field_name}), 'Update: empty array removes existing values');
   }
 
   /**
@@ -455,7 +471,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
 
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertTrue(empty($entity->{$this->field_name}[$langcode]), t('Insert: NULL field results in no value saved'));
+    $this->assertTrue(empty($entity->{$this->field_name}[$langcode]), 'Insert: NULL field results in no value saved');
 
     // Insert: Field is missing.
     field_cache_clear();
@@ -465,7 +481,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
     $values = field_test_default_value($entity_type, $entity, $this->field, $this->instance);
-    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, t('Insert: missing field results in default value saved'));
+    $this->assertEqual($entity->{$this->field_name}[$langcode], $values, 'Insert: missing field results in default value saved');
   }
 
   /**
@@ -520,7 +536,7 @@ class FieldAttachStorageTestCase extends FieldAttachTestCase {
     }
     $read = field_test_create_stub_entity(0, 2, $this->instance['bundle']);
     field_attach_load($entity_type, array(0 => $read));
-    $this->assertIdentical($read->{$this->field_name}, array(), t('The test entity current revision is deleted.'));
+    $this->assertIdentical($read->{$this->field_name}, array(), 'The test entity current revision is deleted.');
   }
 
   /**
@@ -641,13 +657,18 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
    * Test field_attach_view() and field_attach_prepare_view().
    */
   function testFieldAttachView() {
+    $this->createFieldWithInstance('_2');
+
     $entity_type = 'test_entity';
     $entity_init = field_test_create_stub_entity();
     $langcode = LANGUAGE_NONE;
+    $options = array('field_name' => $this->field_name_2);
 
     // Populate values to be displayed.
     $values = $this->_generateTestFieldValues($this->field['cardinality']);
     $entity_init->{$this->field_name}[$langcode] = $values;
+    $values_2 = $this->_generateTestFieldValues($this->field_2['cardinality']);
+    $entity_init->{$this->field_name_2}[$langcode] = $values_2;
 
     // Simple formatter, label displayed.
     $entity = clone($entity_init);
@@ -662,15 +683,47 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
       ),
     );
     field_update_instance($this->instance);
+    $formatter_setting_2 = $this->randomName();
+    $this->instance_2['display'] = array(
+      'full' => array(
+        'label' => 'above',
+        'type' => 'field_test_default',
+        'settings' => array(
+          'test_formatter_setting' => $formatter_setting_2,
+        )
+      ),
+    );
+    field_update_instance($this->instance_2);
+    // View all fields.
     field_attach_prepare_view($entity_type, array($entity->ftid => $entity), 'full');
     $entity->content = field_attach_view($entity_type, $entity, 'full');
     $output = drupal_render($entity->content);
     $this->content = $output;
-    $this->assertRaw($this->instance['label'], "Label is displayed.");
+    $this->assertRaw($this->instance['label'], "First field's label is displayed.");
     foreach ($values as $delta => $value) {
       $this->content = $output;
       $this->assertRaw("$formatter_setting|{$value['value']}", "Value $delta is displayed, formatter settings are applied.");
     }
+    $this->assertRaw($this->instance_2['label'], "Second field's label is displayed.");
+    foreach ($values_2 as $delta => $value) {
+      $this->content = $output;
+      $this->assertRaw("$formatter_setting_2|{$value['value']}", "Value $delta is displayed, formatter settings are applied.");
+    }
+    // View single field (the second field).
+    field_attach_prepare_view($entity_type, array($entity->ftid => $entity), 'full', $langcode, $options);
+    $entity->content = field_attach_view($entity_type, $entity, 'full', $langcode, $options);
+    $output = drupal_render($entity->content);
+    $this->content = $output;
+    $this->assertNoRaw($this->instance['label'], "First field's label is not displayed.");
+    foreach ($values as $delta => $value) {
+      $this->content = $output;
+      $this->assertNoRaw("$formatter_setting|{$value['value']}", "Value $delta is displayed, formatter settings are applied.");
+    }
+    $this->assertRaw($this->instance_2['label'], "Second field's label is displayed.");
+    foreach ($values_2 as $delta => $value) {
+      $this->content = $output;
+      $this->assertRaw("$formatter_setting_2|{$value['value']}", "Value $delta is displayed, formatter settings are applied.");
+    }
 
     // Label hidden.
     $entity = clone($entity_init);
@@ -697,7 +750,7 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
     $this->content = $output;
     $this->assertNoRaw($this->instance['label'], "Hidden field: label is not displayed.");
     foreach ($values as $delta => $value) {
-      $this->assertNoRaw($value['value'], "Hidden field: value $delta is not displayed.");
+      $this->assertNoRaw("$formatter_setting|{$value['value']}", "Hidden field: value $delta is not displayed.");
     }
 
     // Multiple formatter.
@@ -759,7 +812,7 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
         break;
       }
     }
-    $this->assertTrue($result, t('Variable $@field_name correctly populated.', array('@field_name' => $this->field_name)));
+    $this->assertTrue($result, format_string('Variable $@field_name correctly populated.', array('@field_name' => $this->field_name)));
   }
 
   /**
@@ -825,18 +878,18 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
     $cid = "field:$entity_type:{$entity_init->ftid}";
 
     // Check that no initial cache entry is present.
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Non-cached: no initial cache entry'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Non-cached: no initial cache entry');
 
     // Save, and check that no cache entry is present.
     $entity = clone($entity_init);
     $entity->{$this->field_name}[$langcode] = $values;
     field_attach_insert($entity_type, $entity);
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Non-cached: no cache entry on insert'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Non-cached: no cache entry on insert');
 
     // Load, and check that no cache entry is present.
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Non-cached: no cache entry on load'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Non-cached: no cache entry on load');
 
 
     // Cacheable entity type.
@@ -847,38 +900,38 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
     field_create_instance($instance);
 
     // Check that no initial cache entry is present.
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Cached: no initial cache entry'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Cached: no initial cache entry');
 
     // Save, and check that no cache entry is present.
     $entity = clone($entity_init);
     $entity->{$this->field_name}[$langcode] = $values;
     field_attach_insert($entity_type, $entity);
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Cached: no cache entry on insert'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Cached: no cache entry on insert');
 
     // Load a single field, and check that no cache entry is present.
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity), FIELD_LOAD_CURRENT, array('field_id' => $this->field_id));
     $cache = cache_get($cid, 'cache_field');
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Cached: no cache entry on loading a single field'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Cached: no cache entry on loading a single field');
 
     // Load, and check that a cache entry is present with the expected values.
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
     $cache = cache_get($cid, 'cache_field');
-    $this->assertEqual($cache->data[$this->field_name][$langcode], $values, t('Cached: correct cache entry on load'));
+    $this->assertEqual($cache->data[$this->field_name][$langcode], $values, 'Cached: correct cache entry on load');
 
     // Update with different values, and check that the cache entry is wiped.
     $values = $this->_generateTestFieldValues($this->field['cardinality']);
     $entity = clone($entity_init);
     $entity->{$this->field_name}[$langcode] = $values;
     field_attach_update($entity_type, $entity);
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Cached: no cache entry on update'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Cached: no cache entry on update');
 
     // Load, and check that a cache entry is present with the expected values.
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
     $cache = cache_get($cid, 'cache_field');
-    $this->assertEqual($cache->data[$this->field_name][$langcode], $values, t('Cached: correct cache entry on load'));
+    $this->assertEqual($cache->data[$this->field_name][$langcode], $values, 'Cached: correct cache entry on load');
 
     // Create a new revision, and check that the cache entry is wiped.
     $entity_init = field_test_create_stub_entity(1, 2, $this->instance['bundle']);
@@ -887,17 +940,17 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
     $entity->{$this->field_name}[$langcode] = $values;
     field_attach_update($entity_type, $entity);
     $cache = cache_get($cid, 'cache_field');
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Cached: no cache entry on new revision creation'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Cached: no cache entry on new revision creation');
 
     // Load, and check that a cache entry is present with the expected values.
     $entity = clone($entity_init);
     field_attach_load($entity_type, array($entity->ftid => $entity));
     $cache = cache_get($cid, 'cache_field');
-    $this->assertEqual($cache->data[$this->field_name][$langcode], $values, t('Cached: correct cache entry on load'));
+    $this->assertEqual($cache->data[$this->field_name][$langcode], $values, 'Cached: correct cache entry on load');
 
     // Delete, and check that the cache entry is wiped.
     field_attach_delete($entity_type, $entity);
-    $this->assertFalse(cache_get($cid, 'cache_field'), t('Cached: no cache entry after delete'));
+    $this->assertFalse(cache_get($cid, 'cache_field'), 'Cached: no cache entry after delete');
   }
 
   /**
@@ -907,11 +960,13 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
    * hook_field_validate.
    */
   function testFieldAttachValidate() {
+    $this->createFieldWithInstance('_2');
+
     $entity_type = 'test_entity';
     $entity = field_test_create_stub_entity(0, 0, $this->instance['bundle']);
     $langcode = LANGUAGE_NONE;
 
-    // Set up values to generate errors
+    // Set up all but one values of the first field to generate errors.
     $values = array();
     for ($delta = 0; $delta < $this->field['cardinality']; $delta++) {
       $values[$delta]['value'] = -1;
@@ -920,6 +975,14 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
     $values[1]['value'] = 1;
     $entity->{$this->field_name}[$langcode] = $values;
 
+    // Set up all values of the second field to generate errors.
+    $values_2 = array();
+    for ($delta = 0; $delta < $this->field_2['cardinality']; $delta++) {
+      $values_2[$delta]['value'] = -1;
+    }
+    $entity->{$this->field_name_2}[$langcode] = $values_2;
+
+    // Validate all fields.
     try {
       field_attach_validate($entity_type, $entity);
     }
@@ -929,26 +992,57 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
 
     foreach ($values as $delta => $value) {
       if ($value['value'] != 1) {
-        $this->assertIdentical($errors[$this->field_name][$langcode][$delta][0]['error'], 'field_test_invalid', "Error set on value $delta");
-        $this->assertEqual(count($errors[$this->field_name][$langcode][$delta]), 1, "Only one error set on value $delta");
+        $this->assertIdentical($errors[$this->field_name][$langcode][$delta][0]['error'], 'field_test_invalid', "Error set on first field's value $delta");
+        $this->assertEqual(count($errors[$this->field_name][$langcode][$delta]), 1, "Only one error set on first field's value $delta");
         unset($errors[$this->field_name][$langcode][$delta]);
       }
       else {
-        $this->assertFalse(isset($errors[$this->field_name][$langcode][$delta]), "No error set on value $delta");
+        $this->assertFalse(isset($errors[$this->field_name][$langcode][$delta]), "No error set on first field's value $delta");
       }
     }
-    $this->assertEqual(count($errors[$this->field_name][$langcode]), 0, 'No extraneous errors set');
+    foreach ($values_2 as $delta => $value) {
+      $this->assertIdentical($errors[$this->field_name_2][$langcode][$delta][0]['error'], 'field_test_invalid', "Error set on second field's value $delta");
+      $this->assertEqual(count($errors[$this->field_name_2][$langcode][$delta]), 1, "Only one error set on second field's value $delta");
+      unset($errors[$this->field_name_2][$langcode][$delta]);
+    }
+    $this->assertEqual(count($errors[$this->field_name][$langcode]), 0, 'No extraneous errors set for first field');
+    $this->assertEqual(count($errors[$this->field_name_2][$langcode]), 0, 'No extraneous errors set for second field');
+
+    // Validate a single field.
+    $options = array('field_name' => $this->field_name_2);
+    try {
+      field_attach_validate($entity_type, $entity, $options);
+    }
+    catch (FieldValidationException $e) {
+      $errors = $e->errors;
+    }
+
+    foreach ($values_2 as $delta => $value) {
+      $this->assertIdentical($errors[$this->field_name_2][$langcode][$delta][0]['error'], 'field_test_invalid', "Error set on second field's value $delta");
+      $this->assertEqual(count($errors[$this->field_name_2][$langcode][$delta]), 1, "Only one error set on second field's value $delta");
+      unset($errors[$this->field_name_2][$langcode][$delta]);
+    }
+    $this->assertFalse(isset($errors[$this->field_name]), 'No validation errors are set for the first field, despite it having errors');
+    $this->assertEqual(count($errors[$this->field_name_2][$langcode]), 0, 'No extraneous errors set for second field');
 
     // Check that cardinality is validated.
-    $entity->{$this->field_name}[$langcode] = $this->_generateTestFieldValues($this->field['cardinality'] + 1);
+    $entity->{$this->field_name_2}[$langcode] = $this->_generateTestFieldValues($this->field_2['cardinality'] + 1);
+    // When validating all fields.
     try {
       field_attach_validate($entity_type, $entity);
     }
     catch (FieldValidationException $e) {
       $errors = $e->errors;
     }
-    $this->assertEqual($errors[$this->field_name][$langcode][0][0]['error'], 'field_cardinality', t('Cardinality validation failed.'));
-
+    $this->assertEqual($errors[$this->field_name_2][$langcode][0][0]['error'], 'field_cardinality', 'Cardinality validation failed.');
+    // When validating a single field (the second field).
+    try {
+      field_attach_validate($entity_type, $entity, $options);
+    }
+    catch (FieldValidationException $e) {
+      $errors = $e->errors;
+    }
+    $this->assertEqual($errors[$this->field_name_2][$langcode][0][0]['error'], 'field_cardinality', 'Cardinality validation failed.');
   }
 
   /**
@@ -958,34 +1052,59 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
    * widgets show up.
    */
   function testFieldAttachForm() {
+    $this->createFieldWithInstance('_2');
+
     $entity_type = 'test_entity';
     $entity = field_test_create_stub_entity(0, 0, $this->instance['bundle']);
+    $langcode = LANGUAGE_NONE;
 
+    // When generating form for all fields.
     $form = array();
     $form_state = form_state_defaults();
     field_attach_form($entity_type, $entity, $form, $form_state);
 
-    $langcode = LANGUAGE_NONE;
-    $this->assertEqual($form[$this->field_name][$langcode]['#title'], $this->instance['label'], "Form title is {$this->instance['label']}");
+    $this->assertEqual($form[$this->field_name][$langcode]['#title'], $this->instance['label'], "First field's form title is {$this->instance['label']}");
+    $this->assertEqual($form[$this->field_name_2][$langcode]['#title'], $this->instance_2['label'], "Second field's form title is {$this->instance_2['label']}");
     for ($delta = 0; $delta < $this->field['cardinality']; $delta++) {
       // field_test_widget uses 'textfield'
-      $this->assertEqual($form[$this->field_name][$langcode][$delta]['value']['#type'], 'textfield', "Form delta $delta widget is textfield");
-    }
+        $this->assertEqual($form[$this->field_name][$langcode][$delta]['value']['#type'], 'textfield', "First field's form delta $delta widget is textfield");
+      }
+      for ($delta = 0; $delta < $this->field_2['cardinality']; $delta++) {
+        // field_test_widget uses 'textfield'
+        $this->assertEqual($form[$this->field_name_2][$langcode][$delta]['value']['#type'], 'textfield', "Second field's form delta $delta widget is textfield");
+      }
+
+      // When generating form for a single field (the second field).
+      $options = array('field_name' => $this->field_name_2);
+      $form = array();
+      $form_state = form_state_defaults();
+      field_attach_form($entity_type, $entity, $form, $form_state, NULL, $options);
+
+      $this->assertFalse(isset($form[$this->field_name]), 'The first field does not exist in the form');
+      $this->assertEqual($form[$this->field_name_2][$langcode]['#title'], $this->instance_2['label'], "Second field's form title is {$this->instance_2['label']}");
+      for ($delta = 0; $delta < $this->field_2['cardinality']; $delta++) {
+        // field_test_widget uses 'textfield'
+        $this->assertEqual($form[$this->field_name_2][$langcode][$delta]['value']['#type'], 'textfield', "Second field's form delta $delta widget is textfield");
+      }
   }
 
   /**
    * Test field_attach_submit().
    */
   function testFieldAttachSubmit() {
+    $this->createFieldWithInstance('_2');
+
     $entity_type = 'test_entity';
-    $entity = field_test_create_stub_entity(0, 0, $this->instance['bundle']);
+    $entity_init = field_test_create_stub_entity(0, 0, $this->instance['bundle']);
+    $langcode = LANGUAGE_NONE;
 
-    // Build the form.
+    // Build the form for all fields.
     $form = array();
     $form_state = form_state_defaults();
-    field_attach_form($entity_type, $entity, $form, $form_state);
+    field_attach_form($entity_type, $entity_init, $form, $form_state);
 
     // Simulate incoming values.
+    // First field.
     $values = array();
     $weights = array();
     for ($delta = 0; $delta < $this->field['cardinality']; $delta++) {
@@ -999,22 +1118,59 @@ class FieldAttachOtherTestCase extends FieldAttachTestCase {
     }
     // Leave an empty value. 'field_test' fields are empty if empty().
     $values[1]['value'] = 0;
-
-    $langcode = LANGUAGE_NONE;
+    // Second field.
+    $values_2 = array();
+    $weights_2 = array();
+    for ($delta = 0; $delta < $this->field_2['cardinality']; $delta++) {
+      $values_2[$delta]['value'] = mt_rand(1, 127);
+      // Assign random weight.
+      do {
+        $weight = mt_rand(0, $this->field_2['cardinality']);
+      } while (in_array($weight, $weights_2));
+      $weights_2[$delta] = $weight;
+      $values_2[$delta]['_weight'] = $weight;
+    }
+    // Leave an empty value. 'field_test' fields are empty if empty().
+    $values_2[1]['value'] = 0;
     // Pretend the form has been built.
     drupal_prepare_form('field_test_entity_form', $form, $form_state);
     drupal_process_form('field_test_entity_form', $form, $form_state);
     $form_state['values'][$this->field_name][$langcode] = $values;
+    $form_state['values'][$this->field_name_2][$langcode] = $values_2;
+
+    // Call field_attach_submit() for all fields.
+    $entity = clone($entity_init);
     field_attach_submit($entity_type, $entity, $form, $form_state);
 
     asort($weights);
+    asort($weights_2);
     $expected_values = array();
+    $expected_values_2 = array();
     foreach ($weights as $key => $value) {
       if ($key != 1) {
         $expected_values[] = array('value' => $values[$key]['value']);
       }
     }
     $this->assertIdentical($entity->{$this->field_name}[$langcode], $expected_values, 'Submit filters empty values');
+    foreach ($weights_2 as $key => $value) {
+      if ($key != 1) {
+        $expected_values_2[] = array('value' => $values_2[$key]['value']);
+      }
+    }
+    $this->assertIdentical($entity->{$this->field_name_2}[$langcode], $expected_values_2, 'Submit filters empty values');
+
+    // Call field_attach_submit() for a single field (the second field).
+    $options = array('field_name' => $this->field_name_2);
+    $entity = clone($entity_init);
+    field_attach_submit($entity_type, $entity, $form, $form_state, $options);
+    $expected_values_2 = array();
+    foreach ($weights_2 as $key => $value) {
+      if ($key != 1) {
+        $expected_values_2[] = array('value' => $values_2[$key]['value']);
+      }
+    }
+    $this->assertFalse(isset($entity->{$this->field_name}), 'The first field does not exist in the entity object');
+    $this->assertIdentical($entity->{$this->field_name_2}[$langcode], $expected_values_2, 'Submit filters empty values');
   }
 }
 
@@ -1046,42 +1202,42 @@ class FieldInfoTestCase extends FieldTestCase {
     $info = field_info_field_types();
     foreach ($field_test_info as $t_key => $field_type) {
       foreach ($field_type as $key => $val) {
-        $this->assertEqual($info[$t_key][$key], $val, t("Field type $t_key key $key is $val"));
+        $this->assertEqual($info[$t_key][$key], $val, format_string('Field type %t_key key %key is %value', array('%t_key' => $t_key, '%key' => $key, '%value' => print_r($val, TRUE))));
       }
-      $this->assertEqual($info[$t_key]['module'], 'field_test',  t("Field type field_test module appears"));
+      $this->assertEqual($info[$t_key]['module'], 'field_test',  "Field type field_test module appears");
     }
 
     $formatter_info = field_test_field_formatter_info();
     $info = field_info_formatter_types();
     foreach ($formatter_info as $f_key => $formatter) {
       foreach ($formatter as $key => $val) {
-        $this->assertEqual($info[$f_key][$key], $val, t("Formatter type $f_key key $key is $val"));
+        $this->assertEqual($info[$f_key][$key], $val, format_string('Formatter type %f_key key %key is %value', array('%f_key' => $f_key, '%key' => $key, '%value' => print_r($val, TRUE))));
       }
-      $this->assertEqual($info[$f_key]['module'], 'field_test',  t("Formatter type field_test module appears"));
+      $this->assertEqual($info[$f_key]['module'], 'field_test',  "Formatter type field_test module appears");
     }
 
     $widget_info = field_test_field_widget_info();
     $info = field_info_widget_types();
     foreach ($widget_info as $w_key => $widget) {
       foreach ($widget as $key => $val) {
-        $this->assertEqual($info[$w_key][$key], $val, t("Widget type $w_key key $key is $val"));
+        $this->assertEqual($info[$w_key][$key], $val, format_string('Widget type %w_key key %key is %value', array('%w_key' => $w_key, '%key' => $key, '%value' => print_r($val, TRUE))));
       }
-      $this->assertEqual($info[$w_key]['module'], 'field_test',  t("Widget type field_test module appears"));
+      $this->assertEqual($info[$w_key]['module'], 'field_test',  "Widget type field_test module appears");
     }
 
     $storage_info = field_test_field_storage_info();
     $info = field_info_storage_types();
     foreach ($storage_info as $s_key => $storage) {
       foreach ($storage as $key => $val) {
-        $this->assertEqual($info[$s_key][$key], $val, t("Storage type $s_key key $key is $val"));
+        $this->assertEqual($info[$s_key][$key], $val, format_string('Storage type %s_key key %key is %value', array('%s_key' => $s_key, '%key' => $key, '%value' => print_r($val, TRUE))));
       }
-      $this->assertEqual($info[$s_key]['module'], 'field_test',  t("Storage type field_test module appears"));
+      $this->assertEqual($info[$s_key]['module'], 'field_test',  "Storage type field_test module appears");
     }
 
     // Verify that no unexpected instances exist.
     $instances = field_info_instances('test_entity');
     $expected = array('test_bundle' => array());
-    $this->assertIdentical($instances, $expected, "field_info_instances('test_entity') returns " . var_export($expected, TRUE) . '.');
+    $this->assertIdentical($instances, $expected, format_string("field_info_instances('test_entity') returns %expected.", array('%expected' => var_export($expected, TRUE))));
     $instances = field_info_instances('test_entity', 'test_bundle');
     $this->assertIdentical($instances, array(), "field_info_instances('test_entity', 'test_bundle') returns an empty array.");
 
@@ -1093,16 +1249,16 @@ class FieldInfoTestCase extends FieldTestCase {
     );
     field_create_field($field);
     $fields = field_info_fields();
-    $this->assertEqual(count($fields), count($core_fields) + 1, t('One new field exists'));
-    $this->assertEqual($fields[$field['field_name']]['field_name'], $field['field_name'], t('info fields contains field name'));
-    $this->assertEqual($fields[$field['field_name']]['type'], $field['type'], t('info fields contains field type'));
-    $this->assertEqual($fields[$field['field_name']]['module'], 'field_test', t('info fields contains field module'));
+    $this->assertEqual(count($fields), count($core_fields) + 1, 'One new field exists');
+    $this->assertEqual($fields[$field['field_name']]['field_name'], $field['field_name'], 'info fields contains field name');
+    $this->assertEqual($fields[$field['field_name']]['type'], $field['type'], 'info fields contains field type');
+    $this->assertEqual($fields[$field['field_name']]['module'], 'field_test', 'info fields contains field module');
     $settings = array('test_field_setting' => 'dummy test string');
     foreach ($settings as $key => $val) {
-      $this->assertEqual($fields[$field['field_name']]['settings'][$key], $val, t("Field setting $key has correct default value $val"));
+      $this->assertEqual($fields[$field['field_name']]['settings'][$key], $val, format_string('Field setting %key has correct default value %value', array('%key' => $key, '%value' => $val)));
     }
-    $this->assertEqual($fields[$field['field_name']]['cardinality'], 1, t('info fields contains cardinality 1'));
-    $this->assertEqual($fields[$field['field_name']]['active'], 1, t('info fields contains active 1'));
+    $this->assertEqual($fields[$field['field_name']]['cardinality'], 1, 'info fields contains cardinality 1');
+    $this->assertEqual($fields[$field['field_name']]['active'], 1, 'info fields contains active 1');
 
     // Create an instance, verify that it shows up
     $instance = array(
@@ -1124,7 +1280,7 @@ class FieldInfoTestCase extends FieldTestCase {
     $this->assertEqual(count($instances), 1, format_string('One instance shows up in info when attached to a bundle on a @label.', array(
       '@label' => $info['label']
     )));
-    $this->assertTrue($instance < $instances[$instance['field_name']], t('Instance appears in info correctly'));
+    $this->assertTrue($instance < $instances[$instance['field_name']], 'Instance appears in info correctly');
 
     // Test a valid entity type but an invalid bundle.
     $instances = field_info_instances('test_entity', 'invalid_bundle');
@@ -1141,9 +1297,19 @@ class FieldInfoTestCase extends FieldTestCase {
     // Test with an entity type that has no bundles.
     $instances = field_info_instances('user');
     $expected = array('user' => array());
-    $this->assertIdentical($instances, $expected, "field_info_instances('user') returns " . var_export($expected, TRUE) . '.');
+    $this->assertIdentical($instances, $expected, format_string("field_info_instances('user') returns %expected.", array('%expected' => var_export($expected, TRUE))));
     $instances = field_info_instances('user', 'user');
     $this->assertIdentical($instances, array(), "field_info_instances('user', 'user') returns an empty array.");
+
+    // Test that querying for invalid entity types does not add entries in the
+    // list returned by field_info_instances().
+    field_info_cache_clear();
+    field_info_instances('invalid_entity', 'invalid_bundle');
+    // Simulate new request by clearing static caches.
+    drupal_static_reset();
+    field_info_instances('invalid_entity', 'invalid_bundle');
+    $instances = field_info_instances();
+    $this->assertFalse(isset($instances['invalid_entity']), 'field_info_instances() does not contain entries for the invalid entity type that was queried before');
   }
 
   /**
@@ -1174,7 +1340,7 @@ class FieldInfoTestCase extends FieldTestCase {
 
     // Check that all expected settings are in place.
     $field_type = field_info_field_types($field_definition['type']);
-    $this->assertIdentical($field['settings'], $field_type['settings'], t('All expected default field settings are present.'));
+    $this->assertIdentical($field['settings'], $field_type['settings'], 'All expected default field settings are present.');
   }
 
   /**
@@ -1216,18 +1382,18 @@ class FieldInfoTestCase extends FieldTestCase {
 
     // Check that all expected instance settings are in place.
     $field_type = field_info_field_types($field_definition['type']);
-    $this->assertIdentical($instance['settings'], $field_type['instance_settings'] , t('All expected instance settings are present.'));
+    $this->assertIdentical($instance['settings'], $field_type['instance_settings'] , 'All expected instance settings are present.');
 
     // Check that the default widget is used and expected settings are in place.
-    $this->assertIdentical($instance['widget']['type'], $field_type['default_widget'], t('Unavailable widget replaced with default widget.'));
+    $this->assertIdentical($instance['widget']['type'], $field_type['default_widget'], 'Unavailable widget replaced with default widget.');
     $widget_type = field_info_widget_types($instance['widget']['type']);
-    $this->assertIdentical($instance['widget']['settings'], $widget_type['settings'] , t('All expected widget settings are present.'));
+    $this->assertIdentical($instance['widget']['settings'], $widget_type['settings'] , 'All expected widget settings are present.');
 
     // Check that display settings are set for the 'default' mode.
     $display = $instance['display']['default'];
-    $this->assertIdentical($display['type'], $field_type['default_formatter'], t("Formatter is set for the 'default' view mode"));
+    $this->assertIdentical($display['type'], $field_type['default_formatter'], "Formatter is set for the 'default' view mode");
     $formatter_type = field_info_formatter_types($display['type']);
-    $this->assertIdentical($display['settings'], $formatter_type['settings'] , t("Formatter settings are set for the 'default' view mode"));
+    $this->assertIdentical($display['settings'], $formatter_type['settings'] , "Formatter settings are set for the 'default' view mode");
   }
 
   /**
@@ -1250,7 +1416,81 @@ class FieldInfoTestCase extends FieldTestCase {
 
     // Disable coment module. This clears field_info cache.
     module_disable(array('comment'));
-    $this->assertNull(field_info_instance('comment', 'field', 'comment_node_article'), t('No instances are returned on disabled entity types.'));
+    $this->assertNull(field_info_instance('comment', 'field', 'comment_node_article'), 'No instances are returned on disabled entity types.');
+  }
+
+  /**
+   * Test field_info_field_map().
+   */
+  function testFieldMap() {
+    // We will overlook fields created by the 'standard' install profile.
+    $exclude = field_info_field_map();
+
+    // Create a new bundle for 'test_entity' entity type.
+    field_test_create_bundle('test_bundle_2');
+
+    // Create a couple fields.
+    $fields  = array(
+      array(
+        'field_name' => 'field_1',
+        'type' => 'test_field',
+      ),
+      array(
+        'field_name' => 'field_2',
+        'type' => 'hidden_test_field',
+      ),
+    );
+    foreach ($fields as $field) {
+      field_create_field($field);
+    }
+
+    // Create a couple instances.
+    $instances = array(
+      array(
+        'field_name' => 'field_1',
+        'entity_type' => 'test_entity',
+        'bundle' => 'test_bundle',
+      ),
+      array(
+        'field_name' => 'field_1',
+        'entity_type' => 'test_entity',
+        'bundle' => 'test_bundle_2',
+      ),
+      array(
+        'field_name' => 'field_2',
+        'entity_type' => 'test_entity',
+        'bundle' => 'test_bundle',
+      ),
+      array(
+        'field_name' => 'field_2',
+        'entity_type' => 'test_cacheable_entity',
+        'bundle' => 'test_bundle',
+      ),
+    );
+    foreach ($instances as $instance) {
+      field_create_instance($instance);
+    }
+
+    $expected = array(
+      'field_1' => array(
+        'type' => 'test_field',
+        'bundles' => array(
+          'test_entity' => array('test_bundle', 'test_bundle_2'),
+        ),
+      ),
+      'field_2' => array(
+        'type' => 'hidden_test_field',
+        'bundles' => array(
+          'test_entity' => array('test_bundle'),
+          'test_cacheable_entity' => array('test_bundle'),
+        ),
+      ),
+    );
+
+    // Check that the field map is correct.
+    $map = field_info_field_map();
+    $map = array_diff_key($map, $exclude);
+    $this->assertEqual($map, $expected);
   }
 
   /**
@@ -1263,20 +1503,45 @@ class FieldInfoTestCase extends FieldTestCase {
       $info[$name]['instance_settings']['user_register_form'] = FALSE;
     }
     foreach ($info as $type => $data) {
-      $this->assertIdentical(field_info_field_settings($type), $data['settings'], "field_info_field_settings returns {$type}'s field settings");
-      $this->assertIdentical(field_info_instance_settings($type), $data['instance_settings'], "field_info_field_settings returns {$type}'s field instance settings");
+      $this->assertIdentical(field_info_field_settings($type), $data['settings'], format_string("field_info_field_settings returns %type's field settings", array('%type' => $type)));
+      $this->assertIdentical(field_info_instance_settings($type), $data['instance_settings'], format_string("field_info_field_settings returns %type's field instance settings", array('%type' => $type)));
     }
 
     $info = field_test_field_widget_info();
     foreach ($info as $type => $data) {
-      $this->assertIdentical(field_info_widget_settings($type), $data['settings'], "field_info_widget_settings returns {$type}'s widget settings");
+      $this->assertIdentical(field_info_widget_settings($type), $data['settings'], format_string("field_info_widget_settings returns %type's widget settings", array('%type' => $type)));
     }
 
     $info = field_test_field_formatter_info();
     foreach ($info as $type => $data) {
-      $this->assertIdentical(field_info_formatter_settings($type), $data['settings'], "field_info_formatter_settings returns {$type}'s formatter settings");
+      $this->assertIdentical(field_info_formatter_settings($type), $data['settings'], format_string("field_info_formatter_settings returns %type's formatter settings", array('%type' => $type)));
     }
   }
+
+  /**
+   * Tests that the field info cache can be built correctly.
+   */
+  function testFieldInfoCache() {
+    // Create a test field and ensure it's in the array returned by
+    // field_info_fields().
+    $field_name = drupal_strtolower($this->randomName());
+    $field = array(
+      'field_name' => $field_name,
+      'type' => 'test_field',
+    );
+    field_create_field($field);
+    $fields = field_info_fields();
+    $this->assertTrue(isset($fields[$field_name]), 'The test field is initially found in the array returned by field_info_fields().');
+
+    // Now rebuild the field info cache, and set a variable which will cause
+    // the cache to be cleared while it's being rebuilt; see
+    // field_test_entity_info(). Ensure the test field is still in the returned
+    // array.
+    field_info_cache_clear();
+    variable_set('field_test_clear_info_cache_in_hook_entity_info', TRUE);
+    $fields = field_info_fields();
+    $this->assertTrue(isset($fields[$field_name]), 'The test field is found in the array returned by field_info_fields() even if its cache is cleared while being rebuilt.');
+  }
 }
 
 class FieldFormTestCase extends FieldTestCase {
@@ -1600,7 +1865,7 @@ class FieldFormTestCase extends FieldTestCase {
 
     // Display creation form.
     $this->drupalGet('test-entity/add/test-bundle');
-    $this->assertFieldByName("{$this->field_name}[$langcode]", '', t('Widget is displayed.'));
+    $this->assertFieldByName("{$this->field_name}[$langcode]", '', 'Widget is displayed.');
 
     // Create entity with three values.
     $edit = array("{$this->field_name}[$langcode]" => '1, 2, 3');
@@ -1614,12 +1879,12 @@ class FieldFormTestCase extends FieldTestCase {
 
     // Display the form, check that the values are correctly filled in.
     $this->drupalGet('test-entity/manage/' . $id . '/edit');
-    $this->assertFieldByName("{$this->field_name}[$langcode]", '1, 2, 3', t('Widget is displayed.'));
+    $this->assertFieldByName("{$this->field_name}[$langcode]", '1, 2, 3', 'Widget is displayed.');
 
     // Submit the form with more values than the field accepts.
     $edit = array("{$this->field_name}[$langcode]" => '1, 2, 3, 4, 5');
     $this->drupalPost(NULL, $edit, t('Save'));
-    $this->assertRaw('this field cannot hold more than 4 values', t('Form validation failed.'));
+    $this->assertRaw('this field cannot hold more than 4 values', 'Form validation failed.');
     // Check that the field values were not submitted.
     $this->assertFieldValues($entity_init, $this->field_name, $langcode, array(1, 2, 3));
   }
@@ -1667,7 +1932,7 @@ class FieldFormTestCase extends FieldTestCase {
 
     // Display creation form.
     $this->drupalGet('test-entity/add/test-bundle');
-    $this->assertNoFieldByName("{$field_name_no_access}[$langcode][0][value]", '', t('Widget is not displayed if field access is denied.'));
+    $this->assertNoFieldByName("{$field_name_no_access}[$langcode][0][value]", '', 'Widget is not displayed if field access is denied.');
 
     // Create entity.
     $edit = array("{$field_name}[$langcode][0][value]" => 1);
@@ -1677,8 +1942,8 @@ class FieldFormTestCase extends FieldTestCase {
 
     // Check that the default value was saved.
     $entity = field_test_entity_test_load($id);
-    $this->assertEqual($entity->{$field_name_no_access}[$langcode][0]['value'], 99, t('Default value was saved for the field with no edit access.'));
-    $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], 1, t('Entered value vas saved for the field with edit access.'));
+    $this->assertEqual($entity->{$field_name_no_access}[$langcode][0]['value'], 99, 'Default value was saved for the field with no edit access.');
+    $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], 1, 'Entered value vas saved for the field with edit access.');
 
     // Create a new revision.
     $edit = array("{$field_name}[$langcode][0][value]" => 2, 'revision' => TRUE);
@@ -1686,13 +1951,13 @@ class FieldFormTestCase extends FieldTestCase {
 
     // Check that the new revision has the expected values.
     $entity = field_test_entity_test_load($id);
-    $this->assertEqual($entity->{$field_name_no_access}[$langcode][0]['value'], 99, t('New revision has the expected value for the field with no edit access.'));
-    $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], 2, t('New revision has the expected value for the field with edit access.'));
+    $this->assertEqual($entity->{$field_name_no_access}[$langcode][0]['value'], 99, 'New revision has the expected value for the field with no edit access.');
+    $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], 2, 'New revision has the expected value for the field with edit access.');
 
     // Check that the revision is also saved in the revisions table.
     $entity = field_test_entity_test_load($id, $entity->ftvid);
-    $this->assertEqual($entity->{$field_name_no_access}[$langcode][0]['value'], 99, t('New revision has the expected value for the field with no edit access.'));
-    $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], 2, t('New revision has the expected value for the field with edit access.'));
+    $this->assertEqual($entity->{$field_name_no_access}[$langcode][0]['value'], 99, 'New revision has the expected value for the field with no edit access.');
+    $this->assertEqual($entity->{$field_name}[$langcode][0]['value'], 2, 'New revision has the expected value for the field with edit access.');
   }
 
   /**
@@ -1724,10 +1989,10 @@ class FieldFormTestCase extends FieldTestCase {
 
     // Display the 'combined form'.
     $this->drupalGet('test-entity/nested/1/2');
-    $this->assertFieldByName('field_single[und][0][value]', 0, t('Entity 1: field_single value appears correctly is the form.'));
-    $this->assertFieldByName('field_unlimited[und][0][value]', 1, t('Entity 1: field_unlimited value 0 appears correctly is the form.'));
-    $this->assertFieldByName('entity_2[field_single][und][0][value]', 10, t('Entity 2: field_single value appears correctly is the form.'));
-    $this->assertFieldByName('entity_2[field_unlimited][und][0][value]', 11, t('Entity 2: field_unlimited value 0 appears correctly is the form.'));
+    $this->assertFieldByName('field_single[und][0][value]', 0, 'Entity 1: field_single value appears correctly is the form.');
+    $this->assertFieldByName('field_unlimited[und][0][value]', 1, 'Entity 1: field_unlimited value 0 appears correctly is the form.');
+    $this->assertFieldByName('entity_2[field_single][und][0][value]', 10, 'Entity 2: field_single value appears correctly is the form.');
+    $this->assertFieldByName('entity_2[field_unlimited][und][0][value]', 11, 'Entity 2: field_unlimited value 0 appears correctly is the form.');
 
     // Submit the form and check that the entities are updated accordingly.
     $edit = array(
@@ -1753,16 +2018,16 @@ class FieldFormTestCase extends FieldTestCase {
       'field_unlimited[und][1][value]' => -1,
     );
     $this->drupalPost('test-entity/nested/1/2', $edit, t('Save'));
-    $this->assertRaw(t('%label does not accept the value -1', array('%label' => 'Unlimited field')), t('Entity 1: the field validation error was reported.'));
+    $this->assertRaw(t('%label does not accept the value -1', array('%label' => 'Unlimited field')), 'Entity 1: the field validation error was reported.');
     $error_field = $this->xpath('//input[@id=:id and contains(@class, "error")]', array(':id' => 'edit-field-unlimited-und-1-value'));
-    $this->assertTrue($error_field, t('Entity 1: the error was flagged on the correct element.'));
+    $this->assertTrue($error_field, 'Entity 1: the error was flagged on the correct element.');
     $edit = array(
       'entity_2[field_unlimited][und][1][value]' => -1,
     );
     $this->drupalPost('test-entity/nested/1/2', $edit, t('Save'));
-    $this->assertRaw(t('%label does not accept the value -1', array('%label' => 'Unlimited field')), t('Entity 2: the field validation error was reported.'));
+    $this->assertRaw(t('%label does not accept the value -1', array('%label' => 'Unlimited field')), 'Entity 2: the field validation error was reported.');
     $error_field = $this->xpath('//input[@id=:id and contains(@class, "error")]', array(':id' => 'edit-entity-2-field-unlimited-und-1-value'));
-    $this->assertTrue($error_field, t('Entity 2: the error was flagged on the correct element.'));
+    $this->assertTrue($error_field, 'Entity 2: the error was flagged on the correct element.');
 
     // Test that reordering works on both entities.
     $edit = array(
@@ -1782,10 +2047,10 @@ class FieldFormTestCase extends FieldTestCase {
     // 'Add more' button in the first entity:
     $this->drupalGet('test-entity/nested/1/2');
     $this->drupalPostAJAX(NULL, array(), 'field_unlimited_add_more');
-    $this->assertFieldByName('field_unlimited[und][0][value]', 3, t('Entity 1: field_unlimited value 0 appears correctly is the form.'));
-    $this->assertFieldByName('field_unlimited[und][1][value]', 2, t('Entity 1: field_unlimited value 1 appears correctly is the form.'));
-    $this->assertFieldByName('field_unlimited[und][2][value]', '', t('Entity 1: field_unlimited value 2 appears correctly is the form.'));
-    $this->assertFieldByName('field_unlimited[und][3][value]', '', t('Entity 1: an empty widget was added for field_unlimited value 3.'));
+    $this->assertFieldByName('field_unlimited[und][0][value]', 3, 'Entity 1: field_unlimited value 0 appears correctly is the form.');
+    $this->assertFieldByName('field_unlimited[und][1][value]', 2, 'Entity 1: field_unlimited value 1 appears correctly is the form.');
+    $this->assertFieldByName('field_unlimited[und][2][value]', '', 'Entity 1: field_unlimited value 2 appears correctly is the form.');
+    $this->assertFieldByName('field_unlimited[und][3][value]', '', 'Entity 1: an empty widget was added for field_unlimited value 3.');
     // 'Add more' button in the first entity (changing field values):
     $edit = array(
       'entity_2[field_unlimited][und][0][value]' => 13,
@@ -1793,10 +2058,10 @@ class FieldFormTestCase extends FieldTestCase {
       'entity_2[field_unlimited][und][2][value]' => 15,
     );
     $this->drupalPostAJAX(NULL, $edit, 'entity_2_field_unlimited_add_more');
-    $this->assertFieldByName('entity_2[field_unlimited][und][0][value]', 13, t('Entity 2: field_unlimited value 0 appears correctly is the form.'));
-    $this->assertFieldByName('entity_2[field_unlimited][und][1][value]', 14, t('Entity 2: field_unlimited value 1 appears correctly is the form.'));
-    $this->assertFieldByName('entity_2[field_unlimited][und][2][value]', 15, t('Entity 2: field_unlimited value 2 appears correctly is the form.'));
-    $this->assertFieldByName('entity_2[field_unlimited][und][3][value]', '', t('Entity 2: an empty widget was added for field_unlimited value 3.'));
+    $this->assertFieldByName('entity_2[field_unlimited][und][0][value]', 13, 'Entity 2: field_unlimited value 0 appears correctly is the form.');
+    $this->assertFieldByName('entity_2[field_unlimited][und][1][value]', 14, 'Entity 2: field_unlimited value 1 appears correctly is the form.');
+    $this->assertFieldByName('entity_2[field_unlimited][und][2][value]', 15, 'Entity 2: field_unlimited value 2 appears correctly is the form.');
+    $this->assertFieldByName('entity_2[field_unlimited][und][3][value]', '', 'Entity 2: an empty widget was added for field_unlimited value 3.');
     // Save the form and check values are saved correclty.
     $this->drupalPost(NULL, array(), t('Save'));
     field_cache_clear();
@@ -1867,9 +2132,9 @@ class FieldDisplayAPITestCase extends FieldTestCase {
     $this->drupalSetContent(drupal_render($output));
     $settings = field_info_formatter_settings('field_test_default');
     $setting = $settings['test_formatter_setting'];
-    $this->assertText($this->label, t('Label was displayed.'));
+    $this->assertText($this->label, 'Label was displayed.');
     foreach ($this->values as $delta => $value) {
-      $this->assertText($setting . '|' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // Check that explicit display settings are used.
@@ -1884,13 +2149,13 @@ class FieldDisplayAPITestCase extends FieldTestCase {
     $output = field_view_field('test_entity', $this->entity, $this->field_name, $display);
     $this->drupalSetContent(drupal_render($output));
     $setting = $display['settings']['test_formatter_setting_multiple'];
-    $this->assertNoText($this->label, t('Label was not displayed.'));
-    $this->assertText('field_test_field_attach_view_alter', t('Alter fired, display passed.'));
+    $this->assertNoText($this->label, 'Label was not displayed.');
+    $this->assertText('field_test_field_attach_view_alter', 'Alter fired, display passed.');
     $array = array();
     foreach ($this->values as $delta => $value) {
       $array[] = $delta . ':' . $value['value'];
     }
-    $this->assertText($setting . '|' . implode('|', $array), t('Values were displayed with expected setting.'));
+    $this->assertText($setting . '|' . implode('|', $array), 'Values were displayed with expected setting.');
 
     // Check the prepare_view steps are invoked.
     $display = array(
@@ -1904,10 +2169,10 @@ class FieldDisplayAPITestCase extends FieldTestCase {
     $view = drupal_render($output);
     $this->drupalSetContent($view);
     $setting = $display['settings']['test_formatter_setting_additional'];
-    $this->assertNoText($this->label, t('Label was not displayed.'));
-    $this->assertNoText('field_test_field_attach_view_alter', t('Alter not fired.'));
+    $this->assertNoText($this->label, 'Label was not displayed.');
+    $this->assertNoText('field_test_field_attach_view_alter', 'Alter not fired.');
     foreach ($this->values as $delta => $value) {
-      $this->assertText($setting . '|' . $value['value'] . '|' . ($value['value'] + 1), t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'] . '|' . ($value['value'] + 1), format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // View mode: check that display settings specified in the instance are
@@ -1915,9 +2180,9 @@ class FieldDisplayAPITestCase extends FieldTestCase {
     $output = field_view_field('test_entity', $this->entity, $this->field_name, 'teaser');
     $this->drupalSetContent(drupal_render($output));
     $setting = $this->instance['display']['teaser']['settings']['test_formatter_setting'];
-    $this->assertText($this->label, t('Label was displayed.'));
+    $this->assertText($this->label, 'Label was displayed.');
     foreach ($this->values as $delta => $value) {
-      $this->assertText($setting . '|' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // Unknown view mode: check that display settings for 'default' view mode
@@ -1925,9 +2190,9 @@ class FieldDisplayAPITestCase extends FieldTestCase {
     $output = field_view_field('test_entity', $this->entity, $this->field_name, 'unknown_view_mode');
     $this->drupalSetContent(drupal_render($output));
     $setting = $this->instance['display']['default']['settings']['test_formatter_setting'];
-    $this->assertText($this->label, t('Label was displayed.'));
+    $this->assertText($this->label, 'Label was displayed.');
     foreach ($this->values as $delta => $value) {
-      $this->assertText($setting . '|' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
   }
 
@@ -1942,7 +2207,7 @@ class FieldDisplayAPITestCase extends FieldTestCase {
       $item = $this->entity->{$this->field_name}[LANGUAGE_NONE][$delta];
       $output = field_view_value('test_entity', $this->entity, $this->field_name, $item);
       $this->drupalSetContent(drupal_render($output));
-      $this->assertText($setting . '|' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // Check that explicit display settings are used.
@@ -1958,7 +2223,7 @@ class FieldDisplayAPITestCase extends FieldTestCase {
       $item = $this->entity->{$this->field_name}[LANGUAGE_NONE][$delta];
       $output = field_view_value('test_entity', $this->entity, $this->field_name, $item, $display);
       $this->drupalSetContent(drupal_render($output));
-      $this->assertText($setting . '|0:' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|0:' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // Check that prepare_view steps are invoked.
@@ -1974,7 +2239,7 @@ class FieldDisplayAPITestCase extends FieldTestCase {
       $item = $this->entity->{$this->field_name}[LANGUAGE_NONE][$delta];
       $output = field_view_value('test_entity', $this->entity, $this->field_name, $item, $display);
       $this->drupalSetContent(drupal_render($output));
-      $this->assertText($setting . '|' . $value['value'] . '|' . ($value['value'] + 1), t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'] . '|' . ($value['value'] + 1), format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // View mode: check that display settings specified in the instance are
@@ -1984,7 +2249,7 @@ class FieldDisplayAPITestCase extends FieldTestCase {
       $item = $this->entity->{$this->field_name}[LANGUAGE_NONE][$delta];
       $output = field_view_value('test_entity', $this->entity, $this->field_name, $item, 'teaser');
       $this->drupalSetContent(drupal_render($output));
-      $this->assertText($setting . '|' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
 
     // Unknown view mode: check that display settings for 'default' view mode
@@ -1994,7 +2259,7 @@ class FieldDisplayAPITestCase extends FieldTestCase {
       $item = $this->entity->{$this->field_name}[LANGUAGE_NONE][$delta];
       $output = field_view_value('test_entity', $this->entity, $this->field_name, $item, 'unknown_view_mode');
       $this->drupalSetContent(drupal_render($output));
-      $this->assertText($setting . '|' . $value['value'], t('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
+      $this->assertText($setting . '|' . $value['value'], format_string('Value @delta was displayed with expected setting.', array('@delta' => $delta)));
     }
   }
 }
@@ -2037,18 +2302,18 @@ class FieldCrudTestCase extends FieldTestCase {
     $record['data'] = unserialize($record['data']);
 
     // Ensure that basic properties are preserved.
-    $this->assertEqual($record['field_name'], $field_definition['field_name'], t('The field name is properly saved.'));
-    $this->assertEqual($record['type'], $field_definition['type'], t('The field type is properly saved.'));
+    $this->assertEqual($record['field_name'], $field_definition['field_name'], 'The field name is properly saved.');
+    $this->assertEqual($record['type'], $field_definition['type'], 'The field type is properly saved.');
 
     // Ensure that cardinality defaults to 1.
-    $this->assertEqual($record['cardinality'], 1, t('Cardinality defaults to 1.'));
+    $this->assertEqual($record['cardinality'], 1, 'Cardinality defaults to 1.');
 
     // Ensure that default settings are present.
     $field_type = field_info_field_types($field_definition['type']);
-    $this->assertIdentical($record['data']['settings'], $field_type['settings'], t('Default field settings have been written.'));
+    $this->assertIdentical($record['data']['settings'], $field_type['settings'], 'Default field settings have been written.');
 
     // Ensure that default storage was set.
-    $this->assertEqual($record['storage_type'], variable_get('field_storage_default'), t('The field type is properly saved.'));
+    $this->assertEqual($record['storage_type'], variable_get('field_storage_default'), 'The field type is properly saved.');
 
     // Guarantee that the name is unique.
     try {
@@ -2175,7 +2440,42 @@ class FieldCrudTestCase extends FieldTestCase {
 
     // Read the field back.
     $field = field_read_field($field_definition['field_name']);
-    $this->assertTrue($field_definition < $field, t('The field was properly read.'));
+    $this->assertTrue($field_definition < $field, 'The field was properly read.');
+  }
+
+  /**
+   * Tests reading field definitions.
+   */
+  function testReadFields() {
+    $field_definition = array(
+      'field_name' => 'field_1',
+      'type' => 'test_field',
+    );
+    field_create_field($field_definition);
+
+    // Check that 'single column' criteria works.
+    $fields = field_read_fields(array('field_name' => $field_definition['field_name']));
+    $this->assertTrue(count($fields) == 1 && isset($fields[$field_definition['field_name']]), 'The field was properly read.');
+
+    // Check that 'multi column' criteria works.
+    $fields = field_read_fields(array('field_name' => $field_definition['field_name'], 'type' => $field_definition['type']));
+    $this->assertTrue(count($fields) == 1 && isset($fields[$field_definition['field_name']]), 'The field was properly read.');
+    $fields = field_read_fields(array('field_name' => $field_definition['field_name'], 'type' => 'foo'));
+    $this->assertTrue(empty($fields), 'No field was found.');
+
+    // Create an instance of the field.
+    $instance_definition = array(
+      'field_name' => $field_definition['field_name'],
+      'entity_type' => 'test_entity',
+      'bundle' => 'test_bundle',
+    );
+    field_create_instance($instance_definition);
+
+    // Check that criteria spanning over the field_config_instance table work.
+    $fields = field_read_fields(array('entity_type' => $instance_definition['entity_type'], 'bundle' => $instance_definition['bundle']));
+    $this->assertTrue(count($fields) == 1 && isset($fields[$field_definition['field_name']]), 'The field was properly read.');
+    $fields = field_read_fields(array('entity_type' => $instance_definition['entity_type'], 'field_name' => $instance_definition['field_name']));
+    $this->assertTrue(count($fields) == 1 && isset($fields[$field_definition['field_name']]), 'The field was properly read.');
   }
 
   /**
@@ -2190,7 +2490,7 @@ class FieldCrudTestCase extends FieldTestCase {
     field_create_field($field_definition);
     $field = field_read_field($field_definition['field_name']);
     $expected_indexes = array('value' => array('value'));
-    $this->assertEqual($field['indexes'], $expected_indexes, t('Field type indexes saved by default'));
+    $this->assertEqual($field['indexes'], $expected_indexes, 'Field type indexes saved by default');
 
     // Check that indexes specified by the field definition override the field
     // type indexes.
@@ -2204,7 +2504,7 @@ class FieldCrudTestCase extends FieldTestCase {
     field_create_field($field_definition);
     $field = field_read_field($field_definition['field_name']);
     $expected_indexes = array('value' => array());
-    $this->assertEqual($field['indexes'], $expected_indexes, t('Field definition indexes override field type indexes'));
+    $this->assertEqual($field['indexes'], $expected_indexes, 'Field definition indexes override field type indexes');
 
     // Check that indexes specified by the field definition add to the field
     // type indexes.
@@ -2218,7 +2518,7 @@ class FieldCrudTestCase extends FieldTestCase {
     field_create_field($field_definition);
     $field = field_read_field($field_definition['field_name']);
     $expected_indexes = array('value' => array('value'), 'value_2' => array('value'));
-    $this->assertEqual($field['indexes'], $expected_indexes, t('Field definition indexes are merged with field type indexes'));
+    $this->assertEqual($field['indexes'], $expected_indexes, 'Field definition indexes are merged with field type indexes');
   }
 
   /**
@@ -2249,41 +2549,41 @@ class FieldCrudTestCase extends FieldTestCase {
 
     // Test that the first field is not deleted, and then delete it.
     $field = field_read_field($this->field['field_name'], array('include_deleted' => TRUE));
-    $this->assertTrue(!empty($field) && empty($field['deleted']), t('A new field is not marked for deletion.'));
+    $this->assertTrue(!empty($field) && empty($field['deleted']), 'A new field is not marked for deletion.');
     field_delete_field($this->field['field_name']);
 
     // Make sure that the field is marked as deleted when it is specifically
     // loaded.
     $field = field_read_field($this->field['field_name'], array('include_deleted' => TRUE));
-    $this->assertTrue(!empty($field['deleted']), t('A deleted field is marked for deletion.'));
+    $this->assertTrue(!empty($field['deleted']), 'A deleted field is marked for deletion.');
 
     // Make sure that this field's instance is marked as deleted when it is
     // specifically loaded.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle'], array('include_deleted' => TRUE));
-    $this->assertTrue(!empty($instance['deleted']), t('An instance for a deleted field is marked for deletion.'));
+    $this->assertTrue(!empty($instance['deleted']), 'An instance for a deleted field is marked for deletion.');
 
     // Try to load the field normally and make sure it does not show up.
     $field = field_read_field($this->field['field_name']);
-    $this->assertTrue(empty($field), t('A deleted field is not loaded by default.'));
+    $this->assertTrue(empty($field), 'A deleted field is not loaded by default.');
 
     // Try to load the instance normally and make sure it does not show up.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertTrue(empty($instance), t('An instance for a deleted field is not loaded by default.'));
+    $this->assertTrue(empty($instance), 'An instance for a deleted field is not loaded by default.');
 
     // Make sure the other field (and its field instance) are not deleted.
     $another_field = field_read_field($this->another_field['field_name']);
-    $this->assertTrue(!empty($another_field) && empty($another_field['deleted']), t('A non-deleted field is not marked for deletion.'));
+    $this->assertTrue(!empty($another_field) && empty($another_field['deleted']), 'A non-deleted field is not marked for deletion.');
     $another_instance = field_read_instance('test_entity', $this->another_instance_definition['field_name'], $this->another_instance_definition['bundle']);
-    $this->assertTrue(!empty($another_instance) && empty($another_instance['deleted']), t('An instance of a non-deleted field is not marked for deletion.'));
+    $this->assertTrue(!empty($another_instance) && empty($another_instance['deleted']), 'An instance of a non-deleted field is not marked for deletion.');
 
     // Try to create a new field the same name as a deleted field and
     // write data into it.
     field_create_field($this->field);
     field_create_instance($this->instance_definition);
     $field = field_read_field($this->field['field_name']);
-    $this->assertTrue(!empty($field) && empty($field['deleted']), t('A new field with a previously used name is created.'));
+    $this->assertTrue(!empty($field) && empty($field['deleted']), 'A new field with a previously used name is created.');
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertTrue(!empty($instance) && empty($instance['deleted']), t('A new instance for a previously used field name is created.'));
+    $this->assertTrue(!empty($instance) && empty($instance['deleted']), 'A new instance for a previously used field name is created.');
 
     // Save an entity with data for the field
     $entity = field_test_create_stub_entity(0, 0, $instance['bundle']);
@@ -2436,18 +2736,18 @@ class FieldCrudTestCase extends FieldTestCase {
 
     // Read the field.
     $field = field_read_field($field_name);
-    $this->assertTrue($field_definition <= $field, t('The field was properly read.'));
+    $this->assertTrue($field_definition <= $field, 'The field was properly read.');
 
     module_disable($modules, FALSE);
 
     $fields = field_read_fields(array('field_name' => $field_name), array('include_inactive' => TRUE));
-    $this->assertTrue(isset($fields[$field_name]) && $field_definition < $field, t('The field is properly read when explicitly fetching inactive fields.'));
+    $this->assertTrue(isset($fields[$field_name]) && $field_definition < $field, 'The field is properly read when explicitly fetching inactive fields.');
 
     // Re-enable modules one by one, and check that the field is still inactive
     // while some modules remain disabled.
     while ($modules) {
       $field = field_read_field($field_name);
-      $this->assertTrue(empty($field), t('%modules disabled. The field is marked inactive.', array('%modules' => implode(', ', $modules))));
+      $this->assertTrue(empty($field), format_string('%modules disabled. The field is marked inactive.', array('%modules' => implode(', ', $modules))));
 
       $module = array_shift($modules);
       module_enable(array($module), FALSE);
@@ -2456,7 +2756,7 @@ class FieldCrudTestCase extends FieldTestCase {
     // Check that the field is active again after all modules have been
     // enabled.
     $field = field_read_field($field_name);
-    $this->assertTrue($field_definition <= $field, t('The field was was marked active.'));
+    $this->assertTrue($field_definition <= $field, 'The field was was marked active.');
   }
 }
 
@@ -2508,17 +2808,17 @@ class FieldInstanceCrudTestCase extends FieldTestCase {
     $formatter_type = field_info_formatter_types($field_type['default_formatter']);
 
     // Check that default values are set.
-    $this->assertIdentical($record['data']['required'], FALSE, t('Required defaults to false.'));
-    $this->assertIdentical($record['data']['label'], $this->instance_definition['field_name'], t('Label defaults to field name.'));
-    $this->assertIdentical($record['data']['description'], '', t('Description defaults to empty string.'));
-    $this->assertIdentical($record['data']['widget']['type'], $field_type['default_widget'], t('Default widget has been written.'));
-    $this->assertTrue(isset($record['data']['display']['default']), t('Display for "full" view_mode has been written.'));
-    $this->assertIdentical($record['data']['display']['default']['type'], $field_type['default_formatter'], t('Default formatter for "full" view_mode has been written.'));
+    $this->assertIdentical($record['data']['required'], FALSE, 'Required defaults to false.');
+    $this->assertIdentical($record['data']['label'], $this->instance_definition['field_name'], 'Label defaults to field name.');
+    $this->assertIdentical($record['data']['description'], '', 'Description defaults to empty string.');
+    $this->assertIdentical($record['data']['widget']['type'], $field_type['default_widget'], 'Default widget has been written.');
+    $this->assertTrue(isset($record['data']['display']['default']), 'Display for "full" view_mode has been written.');
+    $this->assertIdentical($record['data']['display']['default']['type'], $field_type['default_formatter'], 'Default formatter for "full" view_mode has been written.');
 
     // Check that default settings are set.
-    $this->assertIdentical($record['data']['settings'], $field_type['instance_settings'] , t('Default instance settings have been written.'));
-    $this->assertIdentical($record['data']['widget']['settings'], $widget_type['settings'] , t('Default widget settings have been written.'));
-    $this->assertIdentical($record['data']['display']['default']['settings'], $formatter_type['settings'], t('Default formatter settings for "full" view_mode have been written.'));
+    $this->assertIdentical($record['data']['settings'], $field_type['instance_settings'] , 'Default instance settings have been written.');
+    $this->assertIdentical($record['data']['widget']['settings'], $widget_type['settings'] , 'Default widget settings have been written.');
+    $this->assertIdentical($record['data']['display']['default']['settings'], $formatter_type['settings'], 'Default formatter settings for "full" view_mode have been written.');
 
     // Guarantee that the field/bundle combination is unique.
     try {
@@ -2583,7 +2883,7 @@ class FieldInstanceCrudTestCase extends FieldTestCase {
 
     // Read the instance back.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertTrue($this->instance_definition < $instance, t('The field was properly read.'));
+    $this->assertTrue($this->instance_definition < $instance, 'The field was properly read.');
   }
 
   /**
@@ -2606,13 +2906,13 @@ class FieldInstanceCrudTestCase extends FieldTestCase {
     field_update_instance($instance);
 
     $instance_new = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertEqual($instance['required'], $instance_new['required'], t('"required" change is saved'));
-    $this->assertEqual($instance['label'], $instance_new['label'], t('"label" change is saved'));
-    $this->assertEqual($instance['description'], $instance_new['description'], t('"description" change is saved'));
-    $this->assertEqual($instance['widget']['settings']['test_widget_setting'], $instance_new['widget']['settings']['test_widget_setting'], t('Widget setting change is saved'));
-    $this->assertEqual($instance['widget']['weight'], $instance_new['widget']['weight'], t('Widget weight change is saved'));
-    $this->assertEqual($instance['display']['default']['settings']['test_formatter_setting'], $instance_new['display']['default']['settings']['test_formatter_setting'], t('Formatter setting change is saved'));
-    $this->assertEqual($instance['display']['default']['weight'], $instance_new['display']['default']['weight'], t('Widget weight change is saved'));
+    $this->assertEqual($instance['required'], $instance_new['required'], '"required" change is saved');
+    $this->assertEqual($instance['label'], $instance_new['label'], '"label" change is saved');
+    $this->assertEqual($instance['description'], $instance_new['description'], '"description" change is saved');
+    $this->assertEqual($instance['widget']['settings']['test_widget_setting'], $instance_new['widget']['settings']['test_widget_setting'], 'Widget setting change is saved');
+    $this->assertEqual($instance['widget']['weight'], $instance_new['widget']['weight'], 'Widget weight change is saved');
+    $this->assertEqual($instance['display']['default']['settings']['test_formatter_setting'], $instance_new['display']['default']['settings']['test_formatter_setting'], 'Formatter setting change is saved');
+    $this->assertEqual($instance['display']['default']['weight'], $instance_new['display']['default']['weight'], 'Widget weight change is saved');
 
     // Check that changing widget and formatter types updates the default settings.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
@@ -2621,13 +2921,13 @@ class FieldInstanceCrudTestCase extends FieldTestCase {
     field_update_instance($instance);
 
     $instance_new = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertEqual($instance['widget']['type'], $instance_new['widget']['type'] , t('Widget type change is saved.'));
+    $this->assertEqual($instance['widget']['type'], $instance_new['widget']['type'] , 'Widget type change is saved.');
     $settings = field_info_widget_settings($instance_new['widget']['type']);
-    $this->assertIdentical($settings, array_intersect_key($instance_new['widget']['settings'], $settings) , t('Widget type change updates default settings.'));
-    $this->assertEqual($instance['display']['default']['type'], $instance_new['display']['default']['type'] , t('Formatter type change is saved.'));
+    $this->assertIdentical($settings, array_intersect_key($instance_new['widget']['settings'], $settings) , 'Widget type change updates default settings.');
+    $this->assertEqual($instance['display']['default']['type'], $instance_new['display']['default']['type'] , 'Formatter type change is saved.');
     $info = field_info_formatter_types($instance_new['display']['default']['type']);
     $settings = $info['settings'];
-    $this->assertIdentical($settings, array_intersect_key($instance_new['display']['default']['settings'], $settings) , t('Changing formatter type updates default settings.'));
+    $this->assertIdentical($settings, array_intersect_key($instance_new['display']['default']['settings'], $settings) , 'Changing formatter type updates default settings.');
 
     // Check that adding a new view mode is saved and gets default settings.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
@@ -2635,11 +2935,11 @@ class FieldInstanceCrudTestCase extends FieldTestCase {
     field_update_instance($instance);
 
     $instance_new = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertTrue(isset($instance_new['display']['teaser']), t('Display for the new view_mode has been written.'));
-    $this->assertIdentical($instance_new['display']['teaser']['type'], $field_type['default_formatter'], t('Default formatter for the new view_mode has been written.'));
+    $this->assertTrue(isset($instance_new['display']['teaser']), 'Display for the new view_mode has been written.');
+    $this->assertIdentical($instance_new['display']['teaser']['type'], $field_type['default_formatter'], 'Default formatter for the new view_mode has been written.');
     $info = field_info_formatter_types($instance_new['display']['teaser']['type']);
     $settings = $info['settings'];
-    $this->assertIdentical($settings, $instance_new['display']['teaser']['settings'] , t('Default formatter settings for the new view_mode have been written.'));
+    $this->assertIdentical($settings, $instance_new['display']['teaser']['settings'] , 'Default formatter settings for the new view_mode have been written.');
 
     // TODO: test failures.
   }
@@ -2661,26 +2961,26 @@ class FieldInstanceCrudTestCase extends FieldTestCase {
 
     // Test that the first instance is not deleted, and then delete it.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle'], array('include_deleted' => TRUE));
-    $this->assertTrue(!empty($instance) && empty($instance['deleted']), t('A new field instance is not marked for deletion.'));
+    $this->assertTrue(!empty($instance) && empty($instance['deleted']), 'A new field instance is not marked for deletion.');
     field_delete_instance($instance);
 
     // Make sure the instance is marked as deleted when the instance is
     // specifically loaded.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle'], array('include_deleted' => TRUE));
-    $this->assertTrue(!empty($instance['deleted']), t('A deleted field instance is marked for deletion.'));
+    $this->assertTrue(!empty($instance['deleted']), 'A deleted field instance is marked for deletion.');
 
     // Try to load the instance normally and make sure it does not show up.
     $instance = field_read_instance('test_entity', $this->instance_definition['field_name'], $this->instance_definition['bundle']);
-    $this->assertTrue(empty($instance), t('A deleted field instance is not loaded by default.'));
+    $this->assertTrue(empty($instance), 'A deleted field instance is not loaded by default.');
 
     // Make sure the other field instance is not deleted.
     $another_instance = field_read_instance('test_entity', $this->another_instance_definition['field_name'], $this->another_instance_definition['bundle']);
-    $this->assertTrue(!empty($another_instance) && empty($another_instance['deleted']), t('A non-deleted field instance is not marked for deletion.'));
+    $this->assertTrue(!empty($another_instance) && empty($another_instance['deleted']), 'A non-deleted field instance is not marked for deletion.');
 
     // Make sure the field is deleted when its last instance is deleted.
     field_delete_instance($another_instance);
     $field = field_read_field($another_instance['field_name'], array('include_deleted' => TRUE));
-    $this->assertTrue(!empty($field['deleted']), t('A deleted field is marked for deletion after all its instances have been marked for deletion.'));
+    $this->assertTrue(!empty($field['deleted']), 'A deleted field is marked for deletion after all its instances have been marked for deletion.');
   }
 }
 
@@ -2747,17 +3047,17 @@ class FieldTranslationsTestCase extends FieldTestCase {
     $available_languages = field_available_languages($this->entity_type, $this->field);
     foreach ($available_languages as $delta => $langcode) {
       if ($langcode != 'xx' && $langcode != 'en') {
-        $this->assertTrue(in_array($langcode, $enabled_languages), t('%language is an enabled language.', array('%language' => $langcode)));
+        $this->assertTrue(in_array($langcode, $enabled_languages), format_string('%language is an enabled language.', array('%language' => $langcode)));
       }
     }
-    $this->assertTrue(in_array('xx', $available_languages), t('%language was made available.', array('%language' => 'xx')));
-    $this->assertFalse(in_array('en', $available_languages), t('%language was made unavailable.', array('%language' => 'en')));
+    $this->assertTrue(in_array('xx', $available_languages), format_string('%language was made available.', array('%language' => 'xx')));
+    $this->assertFalse(in_array('en', $available_languages), format_string('%language was made unavailable.', array('%language' => 'en')));
 
     // Test field_available_languages() behavior for untranslatable fields.
     $this->field['translatable'] = FALSE;
     field_update_field($this->field);
     $available_languages = field_available_languages($this->entity_type, $this->field);
-    $this->assertTrue(count($available_languages) == 1 && $available_languages[0] === LANGUAGE_NONE, t('For untranslatable fields only LANGUAGE_NONE is available.'));
+    $this->assertTrue(count($available_languages) == 1 && $available_languages[0] === LANGUAGE_NONE, 'For untranslatable fields only LANGUAGE_NONE is available.');
   }
 
   /**
@@ -2792,10 +3092,10 @@ class FieldTranslationsTestCase extends FieldTestCase {
       $hash = hash('sha256', serialize(array($entity_type, $entity, $this->field_name, $langcode, $values[$langcode])));
       // Check whether the parameters passed to _field_invoke() were correctly
       // forwarded to the callback function.
-      $this->assertEqual($hash, $result, t('The result for %language is correctly stored.', array('%language' => $langcode)));
+      $this->assertEqual($hash, $result, format_string('The result for %language is correctly stored.', array('%language' => $langcode)));
     }
 
-    $this->assertEqual(count($results), count($available_languages), t('No unavailable language has been processed.'));
+    $this->assertEqual(count($results), count($available_languages), 'No unavailable language has been processed.');
   }
 
   /**
@@ -2856,17 +3156,17 @@ class FieldTranslationsTestCase extends FieldTestCase {
           $hash = hash('sha256', serialize(array($entity_type, $entities[$id], $this->field_name, $langcode, $values[$id][$langcode])));
           // Check whether the parameters passed to _field_invoke_multiple()
           // were correctly forwarded to the callback function.
-          $this->assertEqual($hash, $result, t('The result for entity %id/%language is correctly stored.', array('%id' => $id, '%language' => $langcode)));
+          $this->assertEqual($hash, $result, format_string('The result for entity %id/%language is correctly stored.', array('%id' => $id, '%language' => $langcode)));
         }
       }
-      $this->assertEqual(count($results), count($available_languages), t('No unavailable language has been processed for entity %id.', array('%id' => $id)));
+      $this->assertEqual(count($results), count($available_languages), format_string('No unavailable language has been processed for entity %id.', array('%id' => $id)));
     }
 
     $null = NULL;
     $grouped_results = _field_invoke_multiple('test_op_multiple', $entity_type, $entities, $null, $null, $options);
     foreach ($grouped_results as $id => $results) {
       foreach ($results as $langcode => $result) {
-        $this->assertTrue(isset($options['language'][$id]), t('The result language %language for entity %id was correctly suggested (display language: %display_language).', array('%id' => $id, '%language' => $langcode, '%display_language' => $display_language)));
+        $this->assertTrue(isset($options['language'][$id]), format_string('The result language %language for entity %id was correctly suggested (display language: %display_language).', array('%id' => $id, '%language' => $langcode, '%display_language' => $display_language)));
       }
     }
   }
@@ -2878,7 +3178,7 @@ class FieldTranslationsTestCase extends FieldTestCase {
     // Enable field translations for nodes.
     field_test_entity_info_translatable('node', TRUE);
     $entity_info = entity_get_info('node');
-    $this->assertTrue(count($entity_info['translation']), t('Nodes are translatable.'));
+    $this->assertTrue(count($entity_info['translation']), 'Nodes are translatable.');
 
     // Prepare the field translations.
     field_test_entity_info_translatable('test_entity', TRUE);
@@ -2887,7 +3187,7 @@ class FieldTranslationsTestCase extends FieldTestCase {
     $entity = field_test_create_stub_entity($eid, $evid, $this->instance['bundle']);
     $field_translations = array();
     $available_languages = field_available_languages($entity_type, $this->field);
-    $this->assertTrue(count($available_languages) > 1, t('Field is translatable.'));
+    $this->assertTrue(count($available_languages) > 1, 'Field is translatable.');
     foreach ($available_languages as $langcode) {
       $field_translations[$langcode] = $this->_generateTestFieldValues($this->field['cardinality']);
     }
@@ -2904,7 +3204,7 @@ class FieldTranslationsTestCase extends FieldTestCase {
       foreach ($items as $delta => $item) {
         $result = $result && $item['value'] == $entity->{$this->field_name}[$langcode][$delta]['value'];
       }
-      $this->assertTrue($result, t('%language translation correctly handled.', array('%language' => $langcode)));
+      $this->assertTrue($result, format_string('%language translation correctly handled.', array('%language' => $langcode)));
     }
   }
 
@@ -2960,7 +3260,7 @@ class FieldTranslationsTestCase extends FieldTestCase {
     $display_language = field_language($entity_type, $entity, NULL, $requested_language);
     foreach ($instances as $instance) {
       $field_name = $instance['field_name'];
-      $this->assertTrue($display_language[$field_name] == LANGUAGE_NONE, t('The display language for field %field_name is %language.', array('%field_name' => $field_name, '%language' => LANGUAGE_NONE)));
+      $this->assertTrue($display_language[$field_name] == LANGUAGE_NONE, format_string('The display language for field %field_name is %language.', array('%field_name' => $field_name, '%language' => LANGUAGE_NONE)));
     }
 
     // Test multiple-fields display languages for translatable entities.
@@ -2974,20 +3274,20 @@ class FieldTranslationsTestCase extends FieldTestCase {
       // As the requested language was not assinged to any field, if the
       // returned language is defined for the current field, core fallback rules
       // were successfully applied.
-      $this->assertTrue(isset($entity->{$field_name}[$langcode]) && $langcode != $requested_language, t('The display language for the field %field_name is %language.', array('%field_name' => $field_name, '%language' => $langcode)));
+      $this->assertTrue(isset($entity->{$field_name}[$langcode]) && $langcode != $requested_language, format_string('The display language for the field %field_name is %language.', array('%field_name' => $field_name, '%language' => $langcode)));
     }
 
     // Test single-field display language.
     drupal_static_reset('field_language');
     $langcode = field_language($entity_type, $entity, $this->field_name, $requested_language);
-    $this->assertTrue(isset($entity->{$this->field_name}[$langcode]) && $langcode != $requested_language, t('The display language for the (single) field %field_name is %language.', array('%field_name' => $field_name, '%language' => $langcode)));
+    $this->assertTrue(isset($entity->{$this->field_name}[$langcode]) && $langcode != $requested_language, format_string('The display language for the (single) field %field_name is %language.', array('%field_name' => $field_name, '%language' => $langcode)));
 
     // Test field_language() basic behavior without language fallback.
     variable_set('field_test_language_fallback', FALSE);
     $entity->{$this->field_name}[$requested_language] = mt_rand(1, 127);
     drupal_static_reset('field_language');
     $display_language = field_language($entity_type, $entity, $this->field_name, $requested_language);
-    $this->assertEqual($display_language, $requested_language, t('Display language behave correctly when language fallback is disabled'));
+    $this->assertEqual($display_language, $requested_language, 'Display language behave correctly when language fallback is disabled');
   }
 
   /**
@@ -3031,7 +3331,7 @@ class FieldTranslationsTestCase extends FieldTestCase {
     $entity = field_test_entity_test_load($eid, $evid);
     foreach ($available_languages as $langcode => $value) {
       $passed = isset($entity->{$field_name}[$langcode]) && $entity->{$field_name}[$langcode][0]['value'] == $value + 1;
-      $this->assertTrue($passed, t('The @language translation for revision @revision was correctly stored', array('@language' => $langcode, '@revision' => $entity->ftvid)));
+      $this->assertTrue($passed, format_string('The @language translation for revision @revision was correctly stored', array('@language' => $langcode, '@revision' => $entity->ftvid)));
     }
   }
 }
diff --git a/modules/field/tests/field_test.entity.inc b/modules/field/tests/field_test.entity.inc
index 95af3ee..c6686eb 100644
--- a/modules/field/tests/field_test.entity.inc
+++ b/modules/field/tests/field_test.entity.inc
@@ -9,6 +9,12 @@
  * Implements hook_entity_info().
  */
 function field_test_entity_info() {
+  // If requested, clear the field cache while this hook is being called. See
+  // testFieldInfoCache().
+  if (variable_get('field_test_clear_info_cache_in_hook_entity_info', FALSE)) {
+    field_info_cache_clear();
+  }
+
   $bundles = variable_get('field_test_bundles', array('test_bundle' => array('label' => 'Test Bundle')));
   $test_entity_modes = array(
     'full' => array(
diff --git a/modules/field/tests/field_test.field.inc b/modules/field/tests/field_test.field.inc
index cc76a99..1cab773 100644
--- a/modules/field/tests/field_test.field.inc
+++ b/modules/field/tests/field_test.field.inc
@@ -28,7 +28,9 @@ function field_test_field_info() {
     'shape' => array(
       'label' => t('Shape'),
       'description' => t('Another dummy field type.'),
-      'settings' => array(),
+      'settings' => array(
+        'foreign_key_name' => 'shape',
+      ),
       'instance_settings' => array(),
       'default_widget' => 'test_field_widget',
       'default_formatter' => 'field_test_default',
diff --git a/modules/field/tests/field_test.install b/modules/field/tests/field_test.install
index 5957561..a224520 100644
--- a/modules/field/tests/field_test.install
+++ b/modules/field/tests/field_test.install
@@ -132,6 +132,18 @@ function field_test_field_schema($field) {
     );
   }
   else {
+    $foreign_keys = array();
+    // The 'foreign keys' key is not always used in tests.
+    if (!empty($field['settings']['foreign_key_name'])) {
+      $foreign_keys['foreign keys'] = array(
+      // This is a dummy foreign key definition, references a table that
+      // doesn't exist, but that's not a problem.
+      $field['settings']['foreign_key_name'] => array(
+        'table' => $field['settings']['foreign_key_name'],
+        'columns' => array($field['settings']['foreign_key_name'] => 'id'),
+        ),
+      );
+    }
     return array(
       'columns' => array(
         'shape' => array(
@@ -145,6 +157,6 @@ function field_test_field_schema($field) {
           'not null' => FALSE,
         ),
       ),
-    );
+    ) + $foreign_keys;
   }
 }
diff --git a/modules/field/tests/field_test.module b/modules/field/tests/field_test.module
index 37ea7b1..dc2023a 100644
--- a/modules/field/tests/field_test.module
+++ b/modules/field/tests/field_test.module
@@ -204,10 +204,7 @@ function field_test_dummy_field_storage_query(EntityFieldQuery $query) {
 }
 
 /**
- * Entity label callback.
- *
- * @param $entity
- *   The entity object.
+ * Implements callback_entity_info_label().
  *
  * @return
  *   The label of the entity prefixed with "label callback".
diff --git a/modules/field_ui/field_ui.admin.inc b/modules/field_ui/field_ui.admin.inc
index 44770ac..5c6f529 100644
--- a/modules/field_ui/field_ui.admin.inc
+++ b/modules/field_ui/field_ui.admin.inc
@@ -1534,7 +1534,7 @@ function field_ui_existing_field_options($entity_type, $bundle) {
           // - locked fields,
           // - fields already in the current bundle,
           // - fields that cannot be added to the entity type,
-          // - fields that that shoud not be added via user interface.
+          // - fields that should not be added via user interface.
 
           if (empty($field['locked'])
             && !field_info_instance($entity_type, $field['field_name'], $bundle)
@@ -1544,7 +1544,7 @@ function field_ui_existing_field_options($entity_type, $bundle) {
               'type' => $field['type'],
               'type_label' => $field_types[$field['type']]['label'],
               'field' => $field['field_name'],
-              'label' => t($instance['label']),
+              'label' => $instance['label'],
               'widget_type' => $instance['widget']['type'],
             );
           }
@@ -1558,8 +1558,8 @@ function field_ui_existing_field_options($entity_type, $bundle) {
 /**
  * Form constructor for the field settings edit page.
  *
- * @see field_ui_settings_form_submit()
- * @ingroups forms
+ * @see field_ui_field_settings_form_submit()
+ * @ingroup forms
  */
 function field_ui_field_settings_form($form, &$form_state, $instance) {
   $bundle = $instance['bundle'];
diff --git a/modules/field_ui/field_ui.module b/modules/field_ui/field_ui.module
index 93cbccc..5f8bc45 100644
--- a/modules/field_ui/field_ui.module
+++ b/modules/field_ui/field_ui.module
@@ -332,23 +332,30 @@ function _field_ui_bundle_admin_path($entity_type, $bundle_name) {
  * Identifies inactive fields within a bundle.
  */
 function field_ui_inactive_instances($entity_type, $bundle_name = NULL) {
-  if (!empty($bundle_name)) {
-    $inactive = array($bundle_name => array());
-    $params = array('bundle' => $bundle_name);
+  $params = array('entity_type' => $entity_type);
+
+  if (empty($bundle_name)) {
+    $active = field_info_instances($entity_type);
+    $inactive = array();
   }
   else {
-    $inactive = array();
-    $params = array();
+    // Restrict to the specified bundle. For consistency with the case where
+    // $bundle_name is NULL, the $active and  $inactive arrays are keyed by
+    // bundle name first.
+    $params['bundle'] = $bundle_name;
+    $active = array($bundle_name => field_info_instances($entity_type, $bundle_name));
+    $inactive = array($bundle_name => array());
   }
-  $params['entity_type'] = $entity_type;
 
-  $active_instances = field_info_instances($entity_type);
+  // Iterate on existing definitions, and spot those that do not appear in the
+  // $active list collected earlier.
   $all_instances = field_read_instances($params, array('include_inactive' => TRUE));
   foreach ($all_instances as $instance) {
-    if (!isset($active_instances[$instance['bundle']][$instance['field_name']])) {
+    if (!isset($active[$instance['bundle']][$instance['field_name']])) {
       $inactive[$instance['bundle']][$instance['field_name']] = $instance;
     }
   }
+
   if (!empty($bundle_name)) {
     return $inactive[$bundle_name];
   }
diff --git a/modules/field_ui/field_ui.test b/modules/field_ui/field_ui.test
index d0a822a..21767d6 100644
--- a/modules/field_ui/field_ui.test
+++ b/modules/field_ui/field_ui.test
@@ -59,18 +59,18 @@ class FieldUITestCase extends DrupalWebTestCase {
 
     // First step : 'Add new field' on the 'Manage fields' page.
     $this->drupalPost("$bundle_path/fields",  $initial_edit, t('Save'));
-    $this->assertRaw(t('These settings apply to the %label field everywhere it is used.', array('%label' => $label)), t('Field settings page was displayed.'));
+    $this->assertRaw(t('These settings apply to the %label field everywhere it is used.', array('%label' => $label)), 'Field settings page was displayed.');
 
     // Second step : 'Field settings' form.
     $this->drupalPost(NULL, $field_edit, t('Save field settings'));
-    $this->assertRaw(t('Updated field %label field settings.', array('%label' => $label)), t('Redirected to instance and widget settings page.'));
+    $this->assertRaw(t('Updated field %label field settings.', array('%label' => $label)), 'Redirected to instance and widget settings page.');
 
     // Third step : 'Instance settings' form.
     $this->drupalPost(NULL, $instance_edit, t('Save settings'));
-    $this->assertRaw(t('Saved %label configuration.', array('%label' => $label)), t('Redirected to "Manage fields" page.'));
+    $this->assertRaw(t('Saved %label configuration.', array('%label' => $label)), 'Redirected to "Manage fields" page.');
 
     // Check that the field appears in the overview form.
-    $this->assertFieldByXPath('//table[@id="field-overview"]//td[1]', $label, t('Field was created and appears in the overview page.'));
+    $this->assertFieldByXPath('//table[@id="field-overview"]//td[1]', $label, 'Field was created and appears in the overview page.');
   }
 
   /**
@@ -98,10 +98,10 @@ class FieldUITestCase extends DrupalWebTestCase {
 
     // Second step : 'Instance settings' form.
     $this->drupalPost(NULL, $instance_edit, t('Save settings'));
-    $this->assertRaw(t('Saved %label configuration.', array('%label' => $label)), t('Redirected to "Manage fields" page.'));
+    $this->assertRaw(t('Saved %label configuration.', array('%label' => $label)), 'Redirected to "Manage fields" page.');
 
     // Check that the field appears in the overview form.
-    $this->assertFieldByXPath('//table[@id="field-overview"]//td[1]', $label, t('Field was created and appears in the overview page.'));
+    $this->assertFieldByXPath('//table[@id="field-overview"]//td[1]', $label, 'Field was created and appears in the overview page.');
   }
 
   /**
@@ -119,14 +119,14 @@ class FieldUITestCase extends DrupalWebTestCase {
   function fieldUIDeleteField($bundle_path, $field_name, $label, $bundle_label) {
     // Display confirmation form.
     $this->drupalGet("$bundle_path/fields/$field_name/delete");
-    $this->assertRaw(t('Are you sure you want to delete the field %label', array('%label' => $label)), t('Delete confirmation was found.'));
+    $this->assertRaw(t('Are you sure you want to delete the field %label', array('%label' => $label)), 'Delete confirmation was found.');
 
     // Submit confirmation form.
     $this->drupalPost(NULL, array(), t('Delete'));
-    $this->assertRaw(t('The field %label has been deleted from the %type content type.', array('%label' => $label, '%type' => $bundle_label)), t('Delete message was found.'));
+    $this->assertRaw(t('The field %label has been deleted from the %type content type.', array('%label' => $label, '%type' => $bundle_label)), 'Delete message was found.');
 
     // Check that the field does not appear in the overview form.
-    $this->assertNoFieldByXPath('//table[@id="field-overview"]//span[@class="label-field"]', $label, t('Field does not appear in the overview page.'));
+    $this->assertNoFieldByXPath('//table[@id="field-overview"]//span[@class="label-field"]', $label, 'Field does not appear in the overview page.');
   }
 }
 
@@ -179,13 +179,13 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
     );
     foreach ($table_headers as $table_header) {
       // We check that the label appear in the table headings.
-      $this->assertRaw($table_header . '</th>', t('%table_header table header was found.', array('%table_header' => $table_header)));
+      $this->assertRaw($table_header . '</th>', format_string('%table_header table header was found.', array('%table_header' => $table_header)));
     }
 
     // "Add new field" and "Add existing field" aren't a table heading so just
     // test the text.
     foreach (array('Add new field', 'Add existing field') as $element) {
-      $this->assertText($element, t('"@element" was found.', array('@element' => $element)));
+      $this->assertText($element, format_string('"@element" was found.', array('@element' => $element)));
     }
   }
 
@@ -208,7 +208,7 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
     // should also appear in the 'taxonomy term' entity.
     $vocabulary = taxonomy_vocabulary_load(1);
     $this->drupalGet('admin/structure/taxonomy/' . $vocabulary->machine_name . '/fields');
-    $this->assertTrue($this->xpath('//select[@name="fields[_add_existing_field][field_name]"]//option[@value="' . $this->field_name . '"]'), t('Existing field was found in account settings.'));
+    $this->assertTrue($this->xpath('//select[@name="fields[_add_existing_field][field_name]"]//option[@value="' . $this->field_name . '"]'), 'Existing field was found in account settings.');
   }
 
   /**
@@ -231,7 +231,7 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
     $this->assertFieldSettings($this->type, $this->field_name, $string);
 
     // Assert redirection back to the "manage fields" page.
-    $this->assertText(t('Saved @label configuration.', array('@label' => $this->field_label)), t('Redirected to "Manage fields" page.'));
+    $this->assertText(t('Saved @label configuration.', array('@label' => $this->field_label)), 'Redirected to "Manage fields" page.');
   }
 
   /**
@@ -240,12 +240,12 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
   function addExistingField() {
     // Check "Add existing field" appears.
     $this->drupalGet('admin/structure/types/manage/page/fields');
-    $this->assertRaw(t('Add existing field'), t('"Add existing field" was found.'));
+    $this->assertRaw(t('Add existing field'), '"Add existing field" was found.');
 
     // Check that the list of options respects entity type restrictions on
     // fields. The 'comment' field is restricted to the 'comment' entity type
     // and should not appear in the list.
-    $this->assertFalse($this->xpath('//select[@id="edit-add-existing-field-field-name"]//option[@value="comment"]'), t('The list of options respects entity type restrictions.'));
+    $this->assertFalse($this->xpath('//select[@id="edit-add-existing-field-field-name"]//option[@value="comment"]'), 'The list of options respects entity type restrictions.');
 
     // Add a new field based on an existing field.
     $edit = array(
@@ -269,15 +269,15 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
    */
   function assertFieldSettings($bundle, $field_name, $string = 'dummy test string', $entity_type = 'node') {
     // Reset the fields info.
-    _field_info_collate_fields(TRUE);
+    field_info_cache_clear();
     // Assert field settings.
     $field = field_info_field($field_name);
-    $this->assertTrue($field['settings']['test_field_setting'] == $string, t('Field settings were found.'));
+    $this->assertTrue($field['settings']['test_field_setting'] == $string, 'Field settings were found.');
 
     // Assert instance and widget settings.
     $instance = field_info_instance($entity_type, $field_name, $bundle);
-    $this->assertTrue($instance['settings']['test_instance_setting'] == $string, t('Field instance settings were found.'));
-    $this->assertTrue($instance['widget']['settings']['test_widget_setting'] == $string, t('Field widget settings were found.'));
+    $this->assertTrue($instance['settings']['test_instance_setting'] == $string, 'Field instance settings were found.');
+    $this->assertTrue($instance['widget']['settings']['test_widget_setting'] == $string, 'Field widget settings were found.');
   }
 
   /**
@@ -303,31 +303,31 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
     $element_id = "edit-$field_name-$langcode-0-value";
     $element_name = "{$field_name}[$langcode][0][value]";
     $this->drupalGet($admin_path);
-    $this->assertFieldById($element_id, '', t('The default value widget was empty.'));
+    $this->assertFieldById($element_id, '', 'The default value widget was empty.');
 
     // Check that invalid default values are rejected.
     $edit = array($element_name => '-1');
     $this->drupalPost($admin_path, $edit, t('Save settings'));
-    $this->assertText("$field_name does not accept the value -1", t('Form vaildation failed.'));
+    $this->assertText("$field_name does not accept the value -1", 'Form vaildation failed.');
 
     // Check that the default value is saved.
     $edit = array($element_name => '1');
     $this->drupalPost($admin_path, $edit, t('Save settings'));
-    $this->assertText("Saved $field_name configuration", t('The form was successfully submitted.'));
+    $this->assertText("Saved $field_name configuration", 'The form was successfully submitted.');
     $instance = field_info_instance('node', $field_name, $this->type);
-    $this->assertEqual($instance['default_value'], array(array('value' => 1)), t('The default value was correctly saved.'));
+    $this->assertEqual($instance['default_value'], array(array('value' => 1)), 'The default value was correctly saved.');
 
     // Check that the default value shows up in the form
     $this->drupalGet($admin_path);
-    $this->assertFieldById($element_id, '1', t('The default value widget was displayed with the correct value.'));
+    $this->assertFieldById($element_id, '1', 'The default value widget was displayed with the correct value.');
 
     // Check that the default value can be emptied.
     $edit = array($element_name => '');
     $this->drupalPost(NULL, $edit, t('Save settings'));
-    $this->assertText("Saved $field_name configuration", t('The form was successfully submitted.'));
+    $this->assertText("Saved $field_name configuration", 'The form was successfully submitted.');
     field_info_cache_clear();
     $instance = field_info_instance('node', $field_name, $this->type);
-    $this->assertEqual($instance['default_value'], NULL, t('The default value was correctly saved.'));
+    $this->assertEqual($instance['default_value'], NULL, 'The default value was correctly saved.');
   }
 
   /**
@@ -360,21 +360,21 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
     $this->fieldUIDeleteField($bundle_path1, $this->field_name, $this->field_label, $this->type);
 
     // Reset the fields info.
-    _field_info_collate_fields(TRUE);
+    field_info_cache_clear();
     // Check that the field instance was deleted.
-    $this->assertNull(field_info_instance('node', $this->field_name, $this->type), t('Field instance was deleted.'));
+    $this->assertNull(field_info_instance('node', $this->field_name, $this->type), 'Field instance was deleted.');
     // Check that the field was not deleted
-    $this->assertNotNull(field_info_field($this->field_name), t('Field was not deleted.'));
+    $this->assertNotNull(field_info_field($this->field_name), 'Field was not deleted.');
 
     // Delete the second instance.
     $this->fieldUIDeleteField($bundle_path2, $this->field_name, $this->field_label, $type_name2);
 
     // Reset the fields info.
-    _field_info_collate_fields(TRUE);
+    field_info_cache_clear();
     // Check that the field instance was deleted.
-    $this->assertNull(field_info_instance('node', $this->field_name, $type_name2), t('Field instance was deleted.'));
+    $this->assertNull(field_info_instance('node', $this->field_name, $type_name2), 'Field instance was deleted.');
     // Check that the field was deleted too.
-    $this->assertNull(field_info_field($this->field_name), t('Field was deleted.'));
+    $this->assertNull(field_info_field($this->field_name), 'Field was deleted.');
   }
 
   /**
@@ -385,7 +385,7 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
 
     // Check that the field type is not available in the 'add new field' row.
     $this->drupalGet($bundle_path);
-    $this->assertFalse($this->xpath('//select[@id="edit-add-new-field-type"]//option[@value="hidden_test_field"]'), t("The 'add new field' select respects field types 'no_ui' property."));
+    $this->assertFalse($this->xpath('//select[@id="edit-add-new-field-type"]//option[@value="hidden_test_field"]'), "The 'add new field' select respects field types 'no_ui' property.");
 
     // Create a field and an instance programmatically.
     $field_name = 'hidden_test_field';
@@ -398,18 +398,18 @@ class FieldUIManageFieldsTestCase extends FieldUITestCase {
       'widget' => array('type' => 'test_field_widget'),
     );
     field_create_instance($instance);
-    $this->assertTrue(field_read_instance('node', $field_name, $this->type), t('An instance of the field %field was created programmatically.', array('%field' => $field_name)));
+    $this->assertTrue(field_read_instance('node', $field_name, $this->type), format_string('An instance of the field %field was created programmatically.', array('%field' => $field_name)));
 
     // Check that the newly added instance appears on the 'Manage Fields'
     // screen.
     $this->drupalGet($bundle_path);
-    $this->assertFieldByXPath('//table[@id="field-overview"]//td[1]', $instance['label'], t('Field was created and appears in the overview page.'));
+    $this->assertFieldByXPath('//table[@id="field-overview"]//td[1]', $instance['label'], 'Field was created and appears in the overview page.');
 
     // Check that the instance does not appear in the 'add existing field' row
     // on other bundles.
     $bundle_path = 'admin/structure/types/manage/article/fields/';
     $this->drupalGet($bundle_path);
-    $this->assertFalse($this->xpath('//select[@id="edit-add-existing-field-field-name"]//option[@value=:field_name]', array(':field_name' => $field_name)), t("The 'add existing field' select respects field types 'no_ui' property."));
+    $this->assertFalse($this->xpath('//select[@id="edit-add-existing-field-field-name"]//option[@value=:field_name]', array(':field_name' => $field_name)), "The 'add existing field' select respects field types 'no_ui' property.");
   }
 
   /**
@@ -488,8 +488,8 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
     // Display the "Manage display" screen and check that the expected formatter is
     // selected.
     $this->drupalGet($manage_display);
-    $this->assertFieldByName('fields[field_test][type]', $format, t('The expected formatter is selected.'));
-    $this->assertText("$setting_name: $setting_value", t('The expected summary is displayed.'));
+    $this->assertFieldByName('fields[field_test][type]', $format, 'The expected formatter is selected.');
+    $this->assertText("$setting_name: $setting_value", 'The expected summary is displayed.');
 
     // Change the formatter and check that the summary is updated.
     $edit = array('fields[field_test][type]' => 'field_test_multiple', 'refresh_rows' => 'field_test');
@@ -498,8 +498,8 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
     $default_settings = field_info_formatter_settings($format);
     $setting_name = key($default_settings);
     $setting_value = $default_settings[$setting_name];
-    $this->assertFieldByName('fields[field_test][type]', $format, t('The expected formatter is selected.'));
-    $this->assertText("$setting_name: $setting_value", t('The expected summary is displayed.'));
+    $this->assertFieldByName('fields[field_test][type]', $format, 'The expected formatter is selected.');
+    $this->assertText("$setting_name: $setting_value", 'The expected summary is displayed.');
 
     // Submit the form and check that the instance is updated.
     $this->drupalPost(NULL, array(), t('Save'));
@@ -507,8 +507,8 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
     $instance = field_info_instance('node', 'field_test', $this->type);
     $current_format = $instance['display']['default']['type'];
     $current_setting_value = $instance['display']['default']['settings'][$setting_name];
-    $this->assertEqual($current_format, $format, t('The formatter was updated.'));
-    $this->assertEqual($current_setting_value, $setting_value, t('The setting was updated.'));
+    $this->assertEqual($current_format, $format, 'The formatter was updated.');
+    $this->assertEqual($current_setting_value, $setting_value, 'The setting was updated.');
   }
 
   /**
@@ -540,8 +540,8 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
 
     // Check that the field is displayed with the default formatter in 'rss'
     // mode (uses 'default'), and hidden in 'teaser' mode (uses custom settings).
-    $this->assertNodeViewText($node, 'rss', $output['field_test_default'], t("The field is displayed as expected in view modes that use 'default' settings."));
-    $this->assertNodeViewNoText($node, 'teaser', $value, t("The field is hidden in view modes that use custom settings."));
+    $this->assertNodeViewText($node, 'rss', $output['field_test_default'], "The field is displayed as expected in view modes that use 'default' settings.");
+    $this->assertNodeViewNoText($node, 'teaser', $value, "The field is hidden in view modes that use custom settings.");
 
     // Change fomatter for 'default' mode, check that the field is displayed
     // accordingly in 'rss' mode.
@@ -549,14 +549,14 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
       'fields[field_test][type]' => 'field_test_with_prepare_view',
     );
     $this->drupalPost('admin/structure/types/manage/' . $this->hyphen_type . '/display', $edit, t('Save'));
-    $this->assertNodeViewText($node, 'rss', $output['field_test_with_prepare_view'], t("The field is displayed as expected in view modes that use 'default' settings."));
+    $this->assertNodeViewText($node, 'rss', $output['field_test_with_prepare_view'], "The field is displayed as expected in view modes that use 'default' settings.");
 
     // Specialize the 'rss' mode, check that the field is displayed the same.
     $edit = array(
       "view_modes_custom[rss]" => TRUE,
     );
     $this->drupalPost('admin/structure/types/manage/' . $this->hyphen_type . '/display', $edit, t('Save'));
-    $this->assertNodeViewText($node, 'rss', $output['field_test_with_prepare_view'], t("The field is displayed as expected in newly specialized 'rss' mode."));
+    $this->assertNodeViewText($node, 'rss', $output['field_test_with_prepare_view'], "The field is displayed as expected in newly specialized 'rss' mode.");
 
     // Set the field to 'hidden' in the view mode, check that the field is
     // hidden.
@@ -564,7 +564,7 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
       'fields[field_test][type]' => 'hidden',
     );
     $this->drupalPost('admin/structure/types/manage/' . $this->hyphen_type . '/display/rss', $edit, t('Save'));
-    $this->assertNodeViewNoText($node, 'rss', $value, t("The field is hidden in 'rss' mode."));
+    $this->assertNodeViewNoText($node, 'rss', $value, "The field is hidden in 'rss' mode.");
 
     // Set the view mode back to 'default', check that the field is displayed
     // accordingly.
@@ -572,7 +572,7 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
       "view_modes_custom[rss]" => FALSE,
     );
     $this->drupalPost('admin/structure/types/manage/' . $this->hyphen_type . '/display', $edit, t('Save'));
-    $this->assertNodeViewText($node, 'rss', $output['field_test_with_prepare_view'], t("The field is displayed as expected when 'rss' mode is set back to 'default' settings."));
+    $this->assertNodeViewText($node, 'rss', $output['field_test_with_prepare_view'], "The field is displayed as expected when 'rss' mode is set back to 'default' settings.");
 
     // Specialize the view mode again.
     $edit = array(
@@ -580,7 +580,7 @@ class FieldUIManageDisplayTestCase extends FieldUITestCase {
     );
     $this->drupalPost('admin/structure/types/manage/' . $this->hyphen_type . '/display', $edit, t('Save'));
     // Check that the previous settings for the view mode have been kept.
-    $this->assertNodeViewNoText($node, 'rss', $value, t("The previous settings are kept when 'rss' mode is specialized again."));
+    $this->assertNodeViewNoText($node, 'rss', $value, "The previous settings are kept when 'rss' mode is specialized again.");
   }
 
   /**
diff --git a/modules/file/file.field.inc b/modules/file/file.field.inc
index 1189704..319cd58 100644
--- a/modules/file/file.field.inc
+++ b/modules/file/file.field.inc
@@ -261,8 +261,16 @@ function file_field_update($entity_type, $entity, $field, $instance, $langcode,
     $current_fids[] = $item['fid'];
   }
 
-  // Compare the original field values with the ones that are being saved.
-  $original = $entity->original;
+  // Compare the original field values with the ones that are being saved. Use
+  // $entity->original to check this when possible, but if it isn't available,
+  // create a bare-bones entity and load its previous values instead.
+  if (isset($entity->original)) {
+    $original = $entity->original;
+  }
+  else {
+    $original = entity_create_stub_entity($entity_type, array($id, $vid, $bundle));
+    field_attach_load($entity_type, array($id => $original), FIELD_LOAD_CURRENT, array('field_id' => $field['id']));
+  }
   $original_fids = array();
   if (!empty($original->{$field['field_name']}[$langcode])) {
     foreach ($original->{$field['field_name']}[$langcode] as $original_item) {
diff --git a/modules/file/tests/file.test b/modules/file/tests/file.test
index 76708a3..69e711a 100644
--- a/modules/file/tests/file.test
+++ b/modules/file/tests/file.test
@@ -139,7 +139,7 @@ class FileFieldTestCase extends DrupalWebTestCase {
       // Save at least one revision to better simulate a real site.
       $this->drupalCreateNode(get_object_vars($node));
       $node = node_load($nid, NULL, TRUE);
-      $this->assertNotEqual($nid, $node->vid, t('Node revision exists.'));
+      $this->assertNotEqual($nid, $node->vid, 'Node revision exists.');
     }
 
     // Attach a file to the node.
@@ -180,7 +180,7 @@ class FileFieldTestCase extends DrupalWebTestCase {
    * Asserts that a file exists physically on disk.
    */
   function assertFileExists($file, $message = NULL) {
-    $message = isset($message) ? $message : t('File %file exists on the disk.', array('%file' => $file->uri));
+    $message = isset($message) ? $message : format_string('File %file exists on the disk.', array('%file' => $file->uri));
     $this->assertTrue(is_file($file->uri), $message);
   }
 
@@ -190,7 +190,7 @@ class FileFieldTestCase extends DrupalWebTestCase {
   function assertFileEntryExists($file, $message = NULL) {
     entity_get_controller('file')->resetCache();
     $db_file = file_load($file->fid);
-    $message = isset($message) ? $message : t('File %file exists in database at the correct path.', array('%file' => $file->uri));
+    $message = isset($message) ? $message : format_string('File %file exists in database at the correct path.', array('%file' => $file->uri));
     $this->assertEqual($db_file->uri, $file->uri, $message);
   }
 
@@ -198,7 +198,7 @@ class FileFieldTestCase extends DrupalWebTestCase {
    * Asserts that a file does not exist on disk.
    */
   function assertFileNotExists($file, $message = NULL) {
-    $message = isset($message) ? $message : t('File %file exists on the disk.', array('%file' => $file->uri));
+    $message = isset($message) ? $message : format_string('File %file exists on the disk.', array('%file' => $file->uri));
     $this->assertFalse(is_file($file->uri), $message);
   }
 
@@ -207,7 +207,7 @@ class FileFieldTestCase extends DrupalWebTestCase {
    */
   function assertFileEntryNotExists($file, $message) {
     entity_get_controller('file')->resetCache();
-    $message = isset($message) ? $message : t('File %file exists in database at the correct path.', array('%file' => $file->uri));
+    $message = isset($message) ? $message : format_string('File %file exists in database at the correct path.', array('%file' => $file->uri));
     $this->assertFalse(file_load($file->fid), $message);
   }
 
@@ -215,7 +215,7 @@ class FileFieldTestCase extends DrupalWebTestCase {
    * Asserts that a file's status is set to permanent in the database.
    */
   function assertFileIsPermanent($file, $message = NULL) {
-    $message = isset($message) ? $message : t('File %file is permanent.', array('%file' => $file->uri));
+    $message = isset($message) ? $message : format_string('File %file is permanent.', array('%file' => $file->uri));
     $this->assertTrue($file->status == FILE_STATUS_PERMANENT, $message);
   }
 }
@@ -253,19 +253,19 @@ class FileManagedFileElementTestCase extends FileFieldTestCase {
 
         // Submit without a file.
         $this->drupalPost($path, array(), t('Save'));
-        $this->assertRaw(t('The file id is %fid.', array('%fid' => 0)), t('Submitted without a file.'));
+        $this->assertRaw(t('The file id is %fid.', array('%fid' => 0)), 'Submitted without a file.');
 
         // Submit a new file, without using the Upload button.
         $last_fid_prior = $this->getLastFileId();
         $edit = array('files[' . $input_base_name . ']' => drupal_realpath($test_file->uri));
         $this->drupalPost($path, $edit, t('Save'));
         $last_fid = $this->getLastFileId();
-        $this->assertTrue($last_fid > $last_fid_prior, t('New file got saved.'));
-        $this->assertRaw(t('The file id is %fid.', array('%fid' => $last_fid)), t('Submit handler has correct file info.'));
+        $this->assertTrue($last_fid > $last_fid_prior, 'New file got saved.');
+        $this->assertRaw(t('The file id is %fid.', array('%fid' => $last_fid)), 'Submit handler has correct file info.');
 
         // Submit no new input, but with a default file.
         $this->drupalPost($path . '/' . $last_fid, array(), t('Save'));
-        $this->assertRaw(t('The file id is %fid.', array('%fid' => $last_fid)), t('Empty submission did not change an existing file.'));
+        $this->assertRaw(t('The file id is %fid.', array('%fid' => $last_fid)), 'Empty submission did not change an existing file.');
 
         // Now, test the Upload and Remove buttons, with and without Ajax.
         foreach (array(FALSE, TRUE) as $ajax) {
@@ -280,9 +280,9 @@ class FileManagedFileElementTestCase extends FileFieldTestCase {
             $this->drupalPost(NULL, $edit, t('Upload'));
           }
           $last_fid = $this->getLastFileId();
-          $this->assertTrue($last_fid > $last_fid_prior, t('New file got uploaded.'));
+          $this->assertTrue($last_fid > $last_fid_prior, 'New file got uploaded.');
           $this->drupalPost(NULL, array(), t('Save'));
-          $this->assertRaw(t('The file id is %fid.', array('%fid' => $last_fid)), t('Submit handler has correct file info.'));
+          $this->assertRaw(t('The file id is %fid.', array('%fid' => $last_fid)), 'Submit handler has correct file info.');
 
           // Remove, then Submit.
           $this->drupalGet($path . '/' . $last_fid);
@@ -293,7 +293,7 @@ class FileManagedFileElementTestCase extends FileFieldTestCase {
             $this->drupalPost(NULL, array(), t('Remove'));
           }
           $this->drupalPost(NULL, array(), t('Save'));
-          $this->assertRaw(t('The file id is %fid.', array('%fid' => 0)), t('Submission after file removal was successful.'));
+          $this->assertRaw(t('The file id is %fid.', array('%fid' => 0)), 'Submission after file removal was successful.');
 
           // Upload, then Remove, then Submit.
           $this->drupalGet($path);
@@ -307,7 +307,7 @@ class FileManagedFileElementTestCase extends FileFieldTestCase {
             $this->drupalPost(NULL, array(), t('Remove'));
           }
           $this->drupalPost(NULL, array(), t('Save'));
-          $this->assertRaw(t('The file id is %fid.', array('%fid' => 0)), t('Submission after file upload and removal was successful.'));
+          $this->assertRaw(t('The file id is %fid.', array('%fid' => 0)), 'Submission after file upload and removal was successful.');
         }
       }
     }
@@ -350,16 +350,16 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
       $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
       $node = node_load($nid, NULL, TRUE);
       $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-      $this->assertFileExists($node_file, t('New file saved to disk on node creation.'));
+      $this->assertFileExists($node_file, 'New file saved to disk on node creation.');
 
       // Ensure the file can be downloaded.
       $this->drupalGet(file_create_url($node_file->uri));
-      $this->assertResponse(200, t('Confirmed that the generated URL is correct by downloading the shipped file.'));
+      $this->assertResponse(200, 'Confirmed that the generated URL is correct by downloading the shipped file.');
 
       // Ensure the edit page has a remove button instead of an upload button.
       $this->drupalGet("node/$nid/edit");
-      $this->assertNoFieldByXPath('//input[@type="submit"]', t('Upload'), t('Node with file does not display the "Upload" button.'));
-      $this->assertFieldByXpath('//input[@type="submit"]', t('Remove'), t('Node with file displays the "Remove" button.'));
+      $this->assertNoFieldByXPath('//input[@type="submit"]', t('Upload'), 'Node with file does not display the "Upload" button.');
+      $this->assertFieldByXpath('//input[@type="submit"]', t('Remove'), 'Node with file displays the "Remove" button.');
 
       // "Click" the remove button (emulating either a nojs or js submission).
       switch ($type) {
@@ -373,13 +373,13 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
       }
 
       // Ensure the page now has an upload button instead of a remove button.
-      $this->assertNoFieldByXPath('//input[@type="submit"]', t('Remove'), t('After clicking the "Remove" button, it is no longer displayed.'));
-      $this->assertFieldByXpath('//input[@type="submit"]', t('Upload'), t('After clicking the "Remove" button, the "Upload" button is displayed.'));
+      $this->assertNoFieldByXPath('//input[@type="submit"]', t('Remove'), 'After clicking the "Remove" button, it is no longer displayed.');
+      $this->assertFieldByXpath('//input[@type="submit"]', t('Upload'), 'After clicking the "Remove" button, the "Upload" button is displayed.');
 
       // Save the node and ensure it does not have the file.
       $this->drupalPost(NULL, array(), t('Save'));
       $node = node_load($nid, NULL, TRUE);
-      $this->assertTrue(empty($node->{$field_name}[LANGUAGE_NONE][0]['fid']), t('File was successfully removed from the node.'));
+      $this->assertTrue(empty($node->{$field_name}[LANGUAGE_NONE][0]['fid']), 'File was successfully removed from the node.');
     }
   }
 
@@ -423,7 +423,7 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
           $this->drupalPost(NULL, $edit, t('Upload'));
         }
       }
-      $this->assertNoFieldByXpath('//input[@type="submit"]', t('Upload'), t('After uploading 3 files for each field, the "Upload" button is no longer displayed.'));
+      $this->assertNoFieldByXpath('//input[@type="submit"]', t('Upload'), 'After uploading 3 files for each field, the "Upload" button is no longer displayed.');
 
       $num_expected_remove_buttons = 6;
 
@@ -440,7 +440,7 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
           // Ensure we have the expected number of Remove buttons, and that they
           // are numbered sequentially.
           $buttons = $this->xpath('//input[@type="submit" and @value="Remove"]');
-          $this->assertTrue(is_array($buttons) && count($buttons) === $num_expected_remove_buttons, t('There are %n "Remove" buttons displayed (JSMode=%type).', array('%n' => $num_expected_remove_buttons, '%type' => $type)));
+          $this->assertTrue(is_array($buttons) && count($buttons) === $num_expected_remove_buttons, format_string('There are %n "Remove" buttons displayed (JSMode=%type).', array('%n' => $num_expected_remove_buttons, '%type' => $type)));
           foreach ($buttons as $i => $button) {
             $key = $i >= $remaining ? $i - $remaining : $i;
             $check_field_name = $field_name2;
@@ -482,17 +482,17 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
           // correct name.
           $upload_button_name = $current_field_name . '_' . LANGUAGE_NONE . '_' . $remaining . '_upload_button';
           $buttons = $this->xpath('//input[@type="submit" and @value="Upload" and @name=:name]', array(':name' => $upload_button_name));
-          $this->assertTrue(is_array($buttons) && count($buttons) == 1, t('The upload button is displayed with the correct name (JSMode=%type).', array('%type' => $type)));
+          $this->assertTrue(is_array($buttons) && count($buttons) == 1, format_string('The upload button is displayed with the correct name (JSMode=%type).', array('%type' => $type)));
 
           // Ensure only at most one button per field is displayed.
           $buttons = $this->xpath('//input[@type="submit" and @value="Upload"]');
           $expected = $current_field_name == $field_name ? 1 : 2;
-          $this->assertTrue(is_array($buttons) && count($buttons) == $expected, t('After removing a file, only one "Upload" button for each possible field is displayed (JSMode=%type).', array('%type' => $type)));
+          $this->assertTrue(is_array($buttons) && count($buttons) == $expected, format_string('After removing a file, only one "Upload" button for each possible field is displayed (JSMode=%type).', array('%type' => $type)));
         }
       }
 
       // Ensure the page now has no Remove buttons.
-      $this->assertNoFieldByXPath('//input[@type="submit"]', t('Remove'), t('After removing all files, there is no "Remove" button displayed (JSMode=%type).', array('%type' => $type)));
+      $this->assertNoFieldByXPath('//input[@type="submit"]', t('Remove'), format_string('After removing all files, there is no "Remove" button displayed (JSMode=%type).', array('%type' => $type)));
 
       // Save the node and ensure it does not have any files.
       $this->drupalPost(NULL, array('title' => $this->randomName()), t('Save'));
@@ -500,7 +500,7 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
       preg_match('/node\/([0-9]+)/', $this->getUrl(), $matches);
       $nid = $matches[1];
       $node = node_load($nid, NULL, TRUE);
-      $this->assertTrue(empty($node->{$field_name}[LANGUAGE_NONE][0]['fid']), t('Node was successfully saved without any files.'));
+      $this->assertTrue(empty($node->{$field_name}[LANGUAGE_NONE][0]['fid']), 'Node was successfully saved without any files.');
     }
   }
 
@@ -526,21 +526,21 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
     $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($node_file, t('New file saved to disk on node creation.'));
+    $this->assertFileExists($node_file, 'New file saved to disk on node creation.');
 
     // Ensure the private file is available to the user who uploaded it.
     $this->drupalGet(file_create_url($node_file->uri));
-    $this->assertResponse(200, t('Confirmed that the generated URL is correct by downloading the shipped file.'));
+    $this->assertResponse(200, 'Confirmed that the generated URL is correct by downloading the shipped file.');
 
     // Ensure we can't change 'uri_scheme' field settings while there are some
     // entities with uploaded files.
     $this->drupalGet("admin/structure/types/manage/$type_name/fields/$field_name");
-    $this->assertFieldByXpath('//input[@id="edit-field-settings-uri-scheme-public" and @disabled="disabled"]', 'public', t('Upload destination setting disabled.'));
+    $this->assertFieldByXpath('//input[@id="edit-field-settings-uri-scheme-public" and @disabled="disabled"]', 'public', 'Upload destination setting disabled.');
 
     // Delete node and confirm that setting could be changed.
     node_delete($nid);
     $this->drupalGet("admin/structure/types/manage/$type_name/fields/$field_name");
-    $this->assertFieldByXpath('//input[@id="edit-field-settings-uri-scheme-public" and not(@disabled)]', 'public', t('Upload destination setting enabled.'));
+    $this->assertFieldByXpath('//input[@id="edit-field-settings-uri-scheme-public" and not(@disabled)]', 'public', 'Upload destination setting enabled.');
   }
 
   /**
@@ -592,17 +592,17 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
 
     $comment = comment_load($cid);
     $comment_file = (object) $comment->{'field_' . $name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($comment_file, t('New file saved to disk on node creation.'));
+    $this->assertFileExists($comment_file, 'New file saved to disk on node creation.');
     // Test authenticated file download.
     $url = file_create_url($comment_file->uri);
-    $this->assertNotEqual($url, NULL, t('Confirmed that the URL is valid'));
+    $this->assertNotEqual($url, NULL, 'Confirmed that the URL is valid');
     $this->drupalGet(file_create_url($comment_file->uri));
-    $this->assertResponse(200, t('Confirmed that the generated URL is correct by downloading the shipped file.'));
+    $this->assertResponse(200, 'Confirmed that the generated URL is correct by downloading the shipped file.');
 
     // Test anonymous file download.
     $this->drupalLogout();
     $this->drupalGet(file_create_url($comment_file->uri));
-    $this->assertResponse(403, t('Confirmed that access is denied for the file without the needed permission.'));
+    $this->assertResponse(403, 'Confirmed that access is denied for the file without the needed permission.');
 
     // Unpublishes node.
     $this->drupalLogin($this->admin_user);
@@ -614,7 +614,7 @@ class FileFieldWidgetTestCase extends FileFieldTestCase {
     // Ensures normal user can no longer download the file.
     $this->drupalLogin($user);
     $this->drupalGet(file_create_url($comment_file->uri));
-    $this->assertResponse(403, t('Confirmed that access is denied for the file without the needed permission.'));
+    $this->assertResponse(403, 'Confirmed that access is denied for the file without the needed permission.');
   }
 
 }
@@ -661,25 +661,25 @@ class FileFieldRevisionTestCase extends FileFieldTestCase {
     $node = node_load($nid, NULL, TRUE);
     $node_file_r1 = (object) $node->{$field_name}[LANGUAGE_NONE][0];
     $node_vid_r1 = $node->vid;
-    $this->assertFileExists($node_file_r1, t('New file saved to disk on node creation.'));
-    $this->assertFileEntryExists($node_file_r1, t('File entry exists in database on node creation.'));
-    $this->assertFileIsPermanent($node_file_r1, t('File is permanent.'));
+    $this->assertFileExists($node_file_r1, 'New file saved to disk on node creation.');
+    $this->assertFileEntryExists($node_file_r1, 'File entry exists in database on node creation.');
+    $this->assertFileIsPermanent($node_file_r1, 'File is permanent.');
 
     // Upload another file to the same node in a new revision.
     $this->replaceNodeFile($test_file, $field_name, $nid);
     $node = node_load($nid, NULL, TRUE);
     $node_file_r2 = (object) $node->{$field_name}[LANGUAGE_NONE][0];
     $node_vid_r2 = $node->vid;
-    $this->assertFileExists($node_file_r2, t('Replacement file exists on disk after creating new revision.'));
-    $this->assertFileEntryExists($node_file_r2, t('Replacement file entry exists in database after creating new revision.'));
-    $this->assertFileIsPermanent($node_file_r2, t('Replacement file is permanent.'));
+    $this->assertFileExists($node_file_r2, 'Replacement file exists on disk after creating new revision.');
+    $this->assertFileEntryExists($node_file_r2, 'Replacement file entry exists in database after creating new revision.');
+    $this->assertFileIsPermanent($node_file_r2, 'Replacement file is permanent.');
 
     // Check that the original file is still in place on the first revision.
     $node = node_load($nid, $node_vid_r1, TRUE);
-    $this->assertEqual($node_file_r1, (object) $node->{$field_name}[LANGUAGE_NONE][0], t('Original file still in place after replacing file in new revision.'));
-    $this->assertFileExists($node_file_r1, t('Original file still in place after replacing file in new revision.'));
-    $this->assertFileEntryExists($node_file_r1, t('Original file entry still in place after replacing file in new revision'));
-    $this->assertFileIsPermanent($node_file_r1, t('Original file is still permanent.'));
+    $this->assertEqual($node_file_r1, (object) $node->{$field_name}[LANGUAGE_NONE][0], 'Original file still in place after replacing file in new revision.');
+    $this->assertFileExists($node_file_r1, 'Original file still in place after replacing file in new revision.');
+    $this->assertFileEntryExists($node_file_r1, 'Original file entry still in place after replacing file in new revision');
+    $this->assertFileIsPermanent($node_file_r1, 'Original file is still permanent.');
 
     // Save a new version of the node without any changes.
     // Check that the file is still the same as the previous revision.
@@ -687,23 +687,23 @@ class FileFieldRevisionTestCase extends FileFieldTestCase {
     $node = node_load($nid, NULL, TRUE);
     $node_file_r3 = (object) $node->{$field_name}[LANGUAGE_NONE][0];
     $node_vid_r3 = $node->vid;
-    $this->assertEqual($node_file_r2, $node_file_r3, t('Previous revision file still in place after creating a new revision without a new file.'));
-    $this->assertFileIsPermanent($node_file_r3, t('New revision file is permanent.'));
+    $this->assertEqual($node_file_r2, $node_file_r3, 'Previous revision file still in place after creating a new revision without a new file.');
+    $this->assertFileIsPermanent($node_file_r3, 'New revision file is permanent.');
 
     // Revert to the first revision and check that the original file is active.
     $this->drupalPost('node/' . $nid . '/revisions/' . $node_vid_r1 . '/revert', array(), t('Revert'));
     $node = node_load($nid, NULL, TRUE);
     $node_file_r4 = (object) $node->{$field_name}[LANGUAGE_NONE][0];
     $node_vid_r4 = $node->vid;
-    $this->assertEqual($node_file_r1, $node_file_r4, t('Original revision file still in place after reverting to the original revision.'));
-    $this->assertFileIsPermanent($node_file_r4, t('Original revision file still permanent after reverting to the original revision.'));
+    $this->assertEqual($node_file_r1, $node_file_r4, 'Original revision file still in place after reverting to the original revision.');
+    $this->assertFileIsPermanent($node_file_r4, 'Original revision file still permanent after reverting to the original revision.');
 
     // Delete the second revision and check that the file is kept (since it is
     // still being used by the third revision).
     $this->drupalPost('node/' . $nid . '/revisions/' . $node_vid_r2 . '/delete', array(), t('Delete'));
-    $this->assertFileExists($node_file_r3, t('Second file is still available after deleting second revision, since it is being used by the third revision.'));
-    $this->assertFileEntryExists($node_file_r3, t('Second file entry is still available after deleting second revision, since it is being used by the third revision.'));
-    $this->assertFileIsPermanent($node_file_r3, t('Second file entry is still permanent after deleting second revision, since it is being used by the third revision.'));
+    $this->assertFileExists($node_file_r3, 'Second file is still available after deleting second revision, since it is being used by the third revision.');
+    $this->assertFileEntryExists($node_file_r3, 'Second file entry is still available after deleting second revision, since it is being used by the third revision.');
+    $this->assertFileIsPermanent($node_file_r3, 'Second file entry is still permanent after deleting second revision, since it is being used by the third revision.');
 
     // Attach the second file to a user.
     $user = $this->drupalCreateUser();
@@ -714,9 +714,9 @@ class FileFieldRevisionTestCase extends FileFieldTestCase {
 
     // Delete the third revision and check that the file is not deleted yet.
     $this->drupalPost('node/' . $nid . '/revisions/' . $node_vid_r3 . '/delete', array(), t('Delete'));
-    $this->assertFileExists($node_file_r3, t('Second file is still available after deleting third revision, since it is being used by the user.'));
-    $this->assertFileEntryExists($node_file_r3, t('Second file entry is still available after deleting third revision, since it is being used by the user.'));
-    $this->assertFileIsPermanent($node_file_r3, t('Second file entry is still permanent after deleting third revision, since it is being used by the user.'));
+    $this->assertFileExists($node_file_r3, 'Second file is still available after deleting third revision, since it is being used by the user.');
+    $this->assertFileEntryExists($node_file_r3, 'Second file entry is still available after deleting third revision, since it is being used by the user.');
+    $this->assertFileIsPermanent($node_file_r3, 'Second file entry is still permanent after deleting third revision, since it is being used by the user.');
 
     // Delete the user and check that the file is also deleted.
     user_delete($user->uid);
@@ -724,13 +724,13 @@ class FileFieldRevisionTestCase extends FileFieldTestCase {
     // not be necessary here. The file really is deleted, but stream wrappers
     // doesn't seem to think so unless we clear the PHP file stat() cache.
     clearstatcache();
-    $this->assertFileNotExists($node_file_r3, t('Second file is now deleted after deleting third revision, since it is no longer being used by any other nodes.'));
-    $this->assertFileEntryNotExists($node_file_r3, t('Second file entry is now deleted after deleting third revision, since it is no longer being used by any other nodes.'));
+    $this->assertFileNotExists($node_file_r3, 'Second file is now deleted after deleting third revision, since it is no longer being used by any other nodes.');
+    $this->assertFileEntryNotExists($node_file_r3, 'Second file entry is now deleted after deleting third revision, since it is no longer being used by any other nodes.');
 
     // Delete the entire node and check that the original file is deleted.
     $this->drupalPost('node/' . $nid . '/delete', array(), t('Delete'));
-    $this->assertFileNotExists($node_file_r1, t('Original file is deleted after deleting the entire node with two revisions remaining.'));
-    $this->assertFileEntryNotExists($node_file_r1, t('Original file entry is deleted after deleting the entire node with two revisions remaining.'));
+    $this->assertFileNotExists($node_file_r1, 'Original file is deleted after deleting the entire node with two revisions remaining.');
+    $this->assertFileEntryNotExists($node_file_r1, 'Original file entry is deleted after deleting the entire node with two revisions remaining.');
   }
 }
 
@@ -774,7 +774,7 @@ class FileFieldDisplayTestCase extends FileFieldTestCase {
       );
       $this->drupalPost("admin/structure/types/manage/$type_name/display", $edit, t('Save'));
       $this->drupalGet('node/' . $node->nid);
-      $this->assertNoText($field_name, t('Field label is hidden when no file attached for formatter %formatter', array('%formatter' => $formatter)));
+      $this->assertNoText($field_name, format_string('Field label is hidden when no file attached for formatter %formatter', array('%formatter' => $formatter)));
     }
 
     $test_file = $this->getTestFile('text');
@@ -787,13 +787,13 @@ class FileFieldDisplayTestCase extends FileFieldTestCase {
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
     $default_output = theme('file_link', array('file' => $node_file));
-    $this->assertRaw($default_output, t('Default formatter displaying correctly on full node view.'));
+    $this->assertRaw($default_output, 'Default formatter displaying correctly on full node view.');
 
     // Turn the "display" option off and check that the file is no longer displayed.
     $edit = array($field_name . '[' . LANGUAGE_NONE . '][0][display]' => FALSE);
     $this->drupalPost('node/' . $nid . '/edit', $edit, t('Save'));
 
-    $this->assertNoRaw($default_output, t('Field is hidden when "display" option is unchecked.'));
+    $this->assertNoRaw($default_output, 'Field is hidden when "display" option is unchecked.');
 
   }
 }
@@ -829,17 +829,17 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
     $langcode = LANGUAGE_NONE;
     $edit = array("title" => $this->randomName());
     $this->drupalPost('node/add/' . $type_name, $edit, t('Save'));
-    $this->assertRaw(t('!title field is required.', array('!title' => $instance['label'])), t('Node save failed when required file field was empty.'));
+    $this->assertRaw(t('!title field is required.', array('!title' => $instance['label'])), 'Node save failed when required file field was empty.');
 
     // Create a new node with the uploaded file.
     $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
-    $this->assertTrue($nid !== FALSE, t('uploadNodeFile(@test_file, @field_name, @type_name) succeeded', array('@test_file' => $test_file->uri, '@field_name' => $field_name, '@type_name' => $type_name)));
+    $this->assertTrue($nid !== FALSE, format_string('uploadNodeFile(@test_file, @field_name, @type_name) succeeded', array('@test_file' => $test_file->uri, '@field_name' => $field_name, '@type_name' => $type_name)));
 
     $node = node_load($nid, NULL, TRUE);
 
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($node_file, t('File exists after uploading to the required field.'));
-    $this->assertFileEntryExists($node_file, t('File entry exists after uploading to the required field.'));
+    $this->assertFileExists($node_file, 'File exists after uploading to the required field.');
+    $this->assertFileEntryExists($node_file, 'File entry exists after uploading to the required field.');
 
     // Try again with a multiple value field.
     field_delete_field($field_name);
@@ -848,14 +848,14 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
     // Try to post a new node without uploading a file in the multivalue field.
     $edit = array('title' => $this->randomName());
     $this->drupalPost('node/add/' . $type_name, $edit, t('Save'));
-    $this->assertRaw(t('!title field is required.', array('!title' => $instance['label'])), t('Node save failed when required multiple value file field was empty.'));
+    $this->assertRaw(t('!title field is required.', array('!title' => $instance['label'])), 'Node save failed when required multiple value file field was empty.');
 
     // Create a new node with the uploaded file into the multivalue field.
     $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($node_file, t('File exists after uploading to the required multiple value field.'));
-    $this->assertFileEntryExists($node_file, t('File entry exists after uploading to the required multipel value field.'));
+    $this->assertFileExists($node_file, 'File exists after uploading to the required multiple value field.');
+    $this->assertFileEntryExists($node_file, 'File entry exists after uploading to the required multipel value field.');
 
     // Remove our file field.
     field_delete_field($field_name);
@@ -890,13 +890,13 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
       $nid = $this->uploadNodeFile($small_file, $field_name, $type_name);
       $node = node_load($nid, NULL, TRUE);
       $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-      $this->assertFileExists($node_file, t('File exists after uploading a file (%filesize) under the max limit (%maxsize).', array('%filesize' => format_size($small_file->filesize), '%maxsize' => $max_filesize)));
-      $this->assertFileEntryExists($node_file, t('File entry exists after uploading a file (%filesize) under the max limit (%maxsize).', array('%filesize' => format_size($small_file->filesize), '%maxsize' => $max_filesize)));
+      $this->assertFileExists($node_file, format_string('File exists after uploading a file (%filesize) under the max limit (%maxsize).', array('%filesize' => format_size($small_file->filesize), '%maxsize' => $max_filesize)));
+      $this->assertFileEntryExists($node_file, format_string('File entry exists after uploading a file (%filesize) under the max limit (%maxsize).', array('%filesize' => format_size($small_file->filesize), '%maxsize' => $max_filesize)));
 
       // Check that uploading the large file fails (1M limit).
       $nid = $this->uploadNodeFile($large_file, $field_name, $type_name);
       $error_message = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size($large_file->filesize), '%maxsize' => format_size($file_limit)));
-      $this->assertRaw($error_message, t('Node save failed when file (%filesize) exceeded the max upload size (%maxsize).', array('%filesize' => format_size($large_file->filesize), '%maxsize' => $max_filesize)));
+      $this->assertRaw($error_message, format_string('Node save failed when file (%filesize) exceeded the max upload size (%maxsize).', array('%filesize' => format_size($large_file->filesize), '%maxsize' => $max_filesize)));
     }
 
     // Turn off the max filesize.
@@ -906,8 +906,8 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
     $nid = $this->uploadNodeFile($large_file, $field_name, $type_name);
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($node_file, t('File exists after uploading a file (%filesize) with no max limit.', array('%filesize' => format_size($large_file->filesize))));
-    $this->assertFileEntryExists($node_file, t('File entry exists after uploading a file (%filesize) with no max limit.', array('%filesize' => format_size($large_file->filesize))));
+    $this->assertFileExists($node_file, format_string('File exists after uploading a file (%filesize) with no max limit.', array('%filesize' => format_size($large_file->filesize))));
+    $this->assertFileEntryExists($node_file, format_string('File entry exists after uploading a file (%filesize) with no max limit.', array('%filesize' => format_size($large_file->filesize))));
 
     // Remove our file field.
     field_delete_field($field_name);
@@ -933,8 +933,8 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
     $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($node_file, t('File exists after uploading a file with no extension checking.'));
-    $this->assertFileEntryExists($node_file, t('File entry exists after uploading a file with no extension checking.'));
+    $this->assertFileExists($node_file, 'File exists after uploading a file with no extension checking.');
+    $this->assertFileEntryExists($node_file, 'File entry exists after uploading a file with no extension checking.');
 
     // Enable extension checking for text files.
     $this->updateFileField($field_name, $type_name, array('file_extensions' => 'txt'));
@@ -942,7 +942,7 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
     // Check that the file with the wrong extension cannot be uploaded.
     $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
     $error_message = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => 'txt'));
-    $this->assertRaw($error_message, t('Node save failed when file uploaded with the wrong extension.'));
+    $this->assertRaw($error_message, 'Node save failed when file uploaded with the wrong extension.');
 
     // Enable extension checking for text and image files.
     $this->updateFileField($field_name, $type_name, array('file_extensions' => "txt $test_file_extension"));
@@ -951,8 +951,8 @@ class FileFieldValidateTestCase extends FileFieldTestCase {
     $nid = $this->uploadNodeFile($test_file, $field_name, $type_name);
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertFileExists($node_file, t('File exists after uploading a file with extension checking.'));
-    $this->assertFileEntryExists($node_file, t('File entry exists after uploading a file with extension checking.'));
+    $this->assertFileExists($node_file, 'File exists after uploading a file with extension checking.');
+    $this->assertFileEntryExists($node_file, 'File entry exists after uploading a file with extension checking.');
 
     // Remove our file field.
     field_delete_field($field_name);
@@ -986,7 +986,7 @@ class FileFieldPathTestCase extends FileFieldTestCase {
     // Check that the file was uploaded to the file root.
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertPathMatch('public://' . $test_file->filename, $node_file->uri, t('The file %file was uploaded to the correct path.', array('%file' => $node_file->uri)));
+    $this->assertPathMatch('public://' . $test_file->filename, $node_file->uri, format_string('The file %file was uploaded to the correct path.', array('%file' => $node_file->uri)));
 
     // Change the path to contain multiple subdirectories.
     $field = $this->updateFileField($field_name, $type_name, array('file_directory' => 'foo/bar/baz'));
@@ -997,7 +997,7 @@ class FileFieldPathTestCase extends FileFieldTestCase {
     // Check that the file was uploaded into the subdirectory.
     $node = node_load($nid, NULL, TRUE);
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
-    $this->assertPathMatch('public://foo/bar/baz/' . $test_file->filename, $node_file->uri, t('The file %file was uploaded to the correct path.', array('%file' => $node_file->uri)));
+    $this->assertPathMatch('public://foo/bar/baz/' . $test_file->filename, $node_file->uri, format_string('The file %file was uploaded to the correct path.', array('%file' => $node_file->uri)));
 
     // Check the path when used with tokens.
     // Change the path to contain multiple token directories.
@@ -1013,7 +1013,7 @@ class FileFieldPathTestCase extends FileFieldTestCase {
     // the user running the test case.
     $data = array('user' => $this->admin_user);
     $subdirectory = token_replace('[user:uid]/[user:name]', $data);
-    $this->assertPathMatch('public://' . $subdirectory . '/' . $test_file->filename, $node_file->uri, t('The file %file was uploaded to the correct path with token replacements.', array('%file' => $node_file->uri)));
+    $this->assertPathMatch('public://' . $subdirectory . '/' . $test_file->filename, $node_file->uri, format_string('The file %file was uploaded to the correct path with token replacements.', array('%file' => $node_file->uri)));
   }
 
   /**
@@ -1094,11 +1094,11 @@ class FileTokenReplaceTestCase extends FileFieldTestCase {
     $tests['[file:owner:uid]'] = $file->uid;
 
     // Test to make sure that we generated something for each token.
-    $this->assertFalse(in_array(0, array_map('strlen', $tests)), t('No empty tokens generated.'));
+    $this->assertFalse(in_array(0, array_map('strlen', $tests)), 'No empty tokens generated.');
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('file' => $file), array('language' => $language));
-      $this->assertEqual($output, $expected, t('Sanitized file token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Sanitized file token %token replaced.', array('%token' => $input)));
     }
 
     // Generate and test unsanitized tokens.
@@ -1109,7 +1109,7 @@ class FileTokenReplaceTestCase extends FileFieldTestCase {
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('file' => $file), array('language' => $language, 'sanitize' => FALSE));
-      $this->assertEqual($output, $expected, t('Unsanitized file token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Unsanitized file token %token replaced.', array('%token' => $input)));
     }
   }
 }
@@ -1154,10 +1154,10 @@ class FilePrivateTestCase extends FileFieldTestCase {
     $node_file = (object) $node->{$field_name}[LANGUAGE_NONE][0];
     // Ensure the file can be downloaded.
     $this->drupalGet(file_create_url($node_file->uri));
-    $this->assertResponse(200, t('Confirmed that the generated URL is correct by downloading the shipped file.'));
+    $this->assertResponse(200, 'Confirmed that the generated URL is correct by downloading the shipped file.');
     $this->drupalLogOut();
     $this->drupalGet(file_create_url($node_file->uri));
-    $this->assertResponse(403, t('Confirmed that access is denied for the file without the needed permission.'));
+    $this->assertResponse(403, 'Confirmed that access is denied for the file without the needed permission.');
 
     // Test with the field that should deny access through field access.
     $this->drupalLogin($this->admin_user);
@@ -1166,6 +1166,6 @@ class FilePrivateTestCase extends FileFieldTestCase {
     $node_file = (object) $node->{$no_access_field_name}[LANGUAGE_NONE][0];
     // Ensure the file cannot be downloaded.
     $this->drupalGet(file_create_url($node_file->uri));
-    $this->assertResponse(403, t('Confirmed that access is denied for the file without view field access permission.'));
+    $this->assertResponse(403, 'Confirmed that access is denied for the file without view field access permission.');
   }
 }
diff --git a/modules/filter/filter.admin.inc b/modules/filter/filter.admin.inc
index 5a21e6e..60284d9 100644
--- a/modules/filter/filter.admin.inc
+++ b/modules/filter/filter.admin.inc
@@ -2,13 +2,14 @@
 
 /**
  * @file
- * Admin page callbacks for the filter module.
+ * Administrative page callbacks for the Filter module.
  */
 
 /**
- * Menu callback; Displays a list of all text formats and allows them to be rearranged.
+ * Page callback: Form constructor for a form to list and reorder text formats.
  *
  * @ingroup forms
+ * @see filter_menu()
  * @see filter_admin_overview_submit()
  */
 function filter_admin_overview($form) {
@@ -45,6 +46,9 @@ function filter_admin_overview($form) {
   return $form;
 }
 
+/**
+ * Form submission handler for filter_admin_overview().
+ */
 function filter_admin_overview_submit($form, &$form_state) {
   foreach ($form_state['values']['formats'] as $id => $data) {
     if (is_array($data) && isset($data['weight'])) {
@@ -95,7 +99,26 @@ function theme_filter_admin_overview($variables) {
 }
 
 /**
- * Menu callback; Display a text format form.
+ * Page callback: Displays the text format add/edit form.
+ *
+ * @param object|null $format
+ *   (optional) An object representing a format, with the following properties:
+ *   - format: A machine-readable name representing the ID of the text format
+ *     to save. If this corresponds to an existing text format, that format
+ *     will be updated; otherwise, a new format will be created.
+ *   - name: The title of the text format.
+ *   - cache: (optional) An integer indicating whether the text format is
+ *     cacheable (1) or not (0). Defaults to 1.
+ *   - status: (optional) An integer indicating whether the text format is
+ *     enabled (1) or not (0). Defaults to 1.
+ *   - weight: (optional) The weight of the text format, which controls its
+ *     placement in text format lists. If omitted, the weight is set to 0.
+ *     Defaults to NULL.
+ *
+ * @return
+ *   A form array.
+ *
+ * @see filter_menu()
  */
 function filter_admin_format_page($format = NULL) {
   if (!isset($format->name)) {
@@ -109,11 +132,24 @@ function filter_admin_format_page($format = NULL) {
 }
 
 /**
- * Generate a text format form.
+ * Form constructor for the text format add/edit form.
+ *
+ * @param $format
+ *   A format object having the properties:
+ *   - format: A machine-readable name representing the ID of the text format to
+ *     save. If this corresponds to an existing text format, that format will be
+ *     updated; otherwise, a new format will be created.
+ *   - name: The title of the text format.
+ *   - cache: An integer indicating whether the text format is cacheable (1) or
+ *     not (0). Defaults to 1.
+ *   - status: (optional) An integer indicating whether the text format is
+ *     enabled (1) or not (0). Defaults to 1.
+ *   - weight: (optional) The weight of the text format, which controls its
+ *     placement in text format lists. If omitted, the weight is set to 0.
  *
- * @ingroup forms
  * @see filter_admin_format_form_validate()
  * @see filter_admin_format_form_submit()
+ * @ingroup forms
  */
 function filter_admin_format_form($form, &$form_state, $format) {
   $is_fallback = ($format->format == filter_fallback_format());
@@ -287,7 +323,9 @@ function theme_filter_admin_format_filter_order($variables) {
 }
 
 /**
- * Validate text format form submissions.
+ * Form validation handler for filter_admin_format_form().
+ *
+ * @see filter_admin_format_form_submit()
  */
 function filter_admin_format_form_validate($form, &$form_state) {
   $format_format = trim($form_state['values']['format']);
@@ -304,7 +342,9 @@ function filter_admin_format_form_validate($form, &$form_state) {
 }
 
 /**
- * Process text format form submissions.
+ * Form submission handler for filter_admin_format_form().
+ *
+ * @see filter_admin_format_form_validate()
  */
 function filter_admin_format_form_submit($form, &$form_state) {
   // Remove unnecessary values.
@@ -336,10 +376,14 @@ function filter_admin_format_form_submit($form, &$form_state) {
 }
 
 /**
- * Menu callback; confirm deletion of a format.
+ * Form constructor for the text format deletion confirmation form.
  *
- * @ingroup forms
+ * @param $format
+ *   An object representing a text format.
+ *
+ * @see filter_menu()
  * @see filter_admin_disable_submit()
+ * @ingroup forms
  */
 function filter_admin_disable($form, &$form_state, $format) {
   $form['#format'] = $format;
@@ -353,7 +397,7 @@ function filter_admin_disable($form, &$form_state, $format) {
 }
 
 /**
- * Process filter disable form submission.
+ * Form submission handler for filter_admin_disable().
  */
 function filter_admin_disable_submit($form, &$form_state) {
   $format = $form['#format'];
@@ -362,4 +406,3 @@ function filter_admin_disable_submit($form, &$form_state) {
 
   $form_state['redirect'] = 'admin/config/content/formats';
 }
-
diff --git a/modules/filter/filter.api.php b/modules/filter/filter.api.php
index 6675e4a..2901eb9 100644
--- a/modules/filter/filter.api.php
+++ b/modules/filter/filter.api.php
@@ -57,20 +57,20 @@
  *   - description: Additional administrative information about the filter's
  *     behavior, if needed for clarification.
  *   - settings callback: The name of a function that returns configuration form
- *     elements for the filter. See hook_filter_FILTER_settings() for details.
+ *     elements for the filter. See callback_filter_settings() for details.
  *   - default settings: An associative array containing default settings for
  *     the filter, to be applied when the filter has not been configured yet.
  *   - prepare callback: The name of a function that escapes the content before
- *     the actual filtering happens. See hook_filter_FILTER_prepare() for
+ *     the actual filtering happens. See callback_filter_prepare() for
  *     details.
  *   - process callback: (required) The name the function that performs the
- *     actual filtering. See hook_filter_FILTER_process() for details.
+ *     actual filtering. See callback_filter_process() for details.
  *   - cache (default TRUE): Specifies whether the filtered text can be cached.
  *     Note that setting this to FALSE makes the entire text format not
  *     cacheable, which may have an impact on the site's overall performance.
  *     See filter_format_allowcache() for details.
  *   - tips callback: The name of a function that returns end-user-facing filter
- *     usage guidelines for the filter. See hook_filter_FILTER_tips() for
+ *     usage guidelines for the filter. See callback_filter_tips() for
  *     details.
  *   - weight: A default weight for the filter in new text formats.
  *
@@ -122,11 +122,9 @@ function hook_filter_info_alter(&$info) {
  */
 
 /**
- * Settings callback for hook_filter_info().
+ * Provide a settings form for filter settings.
  *
- * Note: This is not really a hook. The function name is manually specified via
- * 'settings callback' in hook_filter_info(), with this recommended callback
- * name pattern. It is called from filter_admin_format_form().
+ * Callback for hook_filter_info().
  *
  * This callback function is used to provide a settings form for filter
  * settings, for filters that need settings on a per-text-format basis. This
@@ -158,8 +156,10 @@ function hook_filter_info_alter(&$info) {
  * @return
  *   An array of form elements defining settings for the filter. Array keys
  *   should match the array keys in $filter->settings and $defaults.
+ *
+ * @ingroup callbacks
  */
-function hook_filter_FILTER_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
+function callback_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
   $filter->settings += $defaults;
 
   $elements = array();
@@ -172,11 +172,9 @@ function hook_filter_FILTER_settings($form, &$form_state, $filter, $format, $def
 }
 
 /**
- * Prepare callback for hook_filter_info().
+ * Provide prepared text with special characters escaped.
  *
- * Note: This is not really a hook. The function name is manually specified via
- * 'prepare callback' in hook_filter_info(), with this recommended callback
- * name pattern. It is called from check_markup().
+ * Callback for hook_filter_info().
  *
  * See hook_filter_info() for a description of the filtering process. Filters
  * should not use the 'prepare callback' step for anything other than escaping,
@@ -199,19 +197,19 @@ function hook_filter_FILTER_settings($form, &$form_state, $filter, $format, $def
  *
  * @return
  *   The prepared, escaped text.
+ *
+ * @ingroup callbacks
  */
-function hook_filter_FILTER_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {
+function callback_filter_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {
   // Escape <code> and </code> tags.
   $text = preg_replace('|<code>(.+?)</code>|se', "[codefilter_code]$1[/codefilter_code]", $text);
   return $text;
 }
 
 /**
- * Process callback for hook_filter_info().
+ * Provide text filtered to conform to the supplied format.
  *
- * Note: This is not really a hook. The function name is manually specified via
- * 'process callback' in hook_filter_info(), with this recommended callback
- * name pattern. It is called from check_markup().
+ * Callback for hook_filter_info().
  *
  * See hook_filter_info() for a description of the filtering process. This step
  * is where the filter actually transforms the text.
@@ -232,19 +230,19 @@ function hook_filter_FILTER_prepare($text, $filter, $format, $langcode, $cache,
  *
  * @return
  *   The filtered text.
+ *
+ * @ingroup callbacks
  */
-function hook_filter_FILTER_process($text, $filter, $format, $langcode, $cache, $cache_id) {
+function callback_filter_process($text, $filter, $format, $langcode, $cache, $cache_id) {
   $text = preg_replace('|\[codefilter_code\](.+?)\[/codefilter_code\]|se', "<pre>$1</pre>", $text);
 
   return $text;
 }
 
 /**
- * Tips callback for hook_filter_info().
+ * Return help text for a filter.
  *
- * Note: This is not really a hook. The function name is manually specified via
- * 'tips callback' in hook_filter_info(), with this recommended callback
- * name pattern. It is called from _filter_tips().
+ * Callback for hook_filter_info().
  *
  * A filter's tips should be informative and to the point. Short tips are
  * preferably one-liners.
@@ -260,8 +258,10 @@ function hook_filter_FILTER_process($text, $filter, $format, $langcode, $cache,
  *
  * @return
  *   Translated text to display as a tip.
+ *
+ * @ingroup callbacks
  */
-function hook_filter_FILTER_tips($filter, $format, $long) {
+function callback_filter_tips($filter, $format, $long) {
  if ($long) {
     return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');
   }
diff --git a/modules/filter/filter.install b/modules/filter/filter.install
index 9d17eb5..71ba97b 100644
--- a/modules/filter/filter.install
+++ b/modules/filter/filter.install
@@ -2,7 +2,7 @@
 
 /**
  * @file
- * Install, update and uninstall functions for the filter module.
+ * Install, update, and uninstall functions for the Filter module.
  */
 
 /**
diff --git a/modules/filter/filter.module b/modules/filter/filter.module
index 7b451b7..2afe901 100644
--- a/modules/filter/filter.module
+++ b/modules/filter/filter.module
@@ -2,7 +2,7 @@
 
 /**
  * @file
- * Framework for handling filtering of content.
+ * Framework for handling the filtering of content.
  */
 
 /**
@@ -71,6 +71,7 @@ function filter_theme() {
  * Implements hook_element_info().
  *
  * @see filter_process_format()
+ * @see text_format_wrapper()
  */
 function filter_element_info() {
   $type['text_format'] = array(
@@ -132,13 +133,16 @@ function filter_menu() {
 }
 
 /**
- * Access callback for deleting text formats.
+ * Access callback: Checks access for disabling text formats.
  *
  * @param $format
  *   A text format object.
+ *
  * @return
  *   TRUE if the text format can be disabled by the current user, FALSE
  *   otherwise.
+ *
+ * @see filter_menu()
  */
 function _filter_disable_format_access($format) {
   // The fallback format can never be disabled.
@@ -146,7 +150,7 @@ function _filter_disable_format_access($format) {
 }
 
 /**
- * Load a text format object from the database.
+ * Loads a text format object from the database.
  *
  * @param $format_id
  *   The format ID.
@@ -164,29 +168,32 @@ function filter_format_load($format_id) {
 }
 
 /**
- * Save a text format object to the database.
+ * Saves a text format object to the database.
  *
  * @param $format
- *   A format object using the properties:
- *   - 'format': A machine-readable name representing the ID of the text format
+ *   A format object having the properties:
+ *   - format: A machine-readable name representing the ID of the text format
  *     to save. If this corresponds to an existing text format, that format
  *     will be updated; otherwise, a new format will be created.
- *   - 'name': The title of the text format.
- *   - 'status': (optional) An integer indicating whether the text format is
+ *   - name: The title of the text format.
+ *   - status: (optional) An integer indicating whether the text format is
  *     enabled (1) or not (0). Defaults to 1.
- *   - 'weight': (optional) The weight of the text format, which controls its
+ *   - weight: (optional) The weight of the text format, which controls its
  *     placement in text format lists. If omitted, the weight is set to 0.
- *   - 'filters': (optional) An associative, multi-dimensional array of filters
+ *   - filters: (optional) An associative, multi-dimensional array of filters
  *     assigned to the text format, keyed by the name of each filter and using
  *     the properties:
- *     - 'weight': (optional) The weight of the filter in the text format. If
+ *     - weight: (optional) The weight of the filter in the text format. If
  *       omitted, either the currently stored weight is retained (if there is
  *       one), or the filter is assigned a weight of 10, which will usually
  *       put it at the bottom of the list.
- *     - 'status': (optional) A boolean indicating whether the filter is
+ *     - status: (optional) A boolean indicating whether the filter is
  *       enabled in the text format. If omitted, the filter will be disabled.
- *     - 'settings': (optional) An array of configured settings for the filter.
+ *     - settings: (optional) An array of configured settings for the filter.
  *       See hook_filter_info() for details.
+ *
+ * @return
+ *   SAVED_NEW or SAVED_UPDATED.
  */
 function filter_format_save($format) {
   $format->name = trim($format->name);
@@ -271,7 +278,7 @@ function filter_format_save($format) {
 }
 
 /**
- * Disable a text format.
+ * Disables a text format.
  *
  * There is no core facility to re-enable a disabled format. It is not deleted
  * to keep information for contrib and to make sure the format ID is never
@@ -313,7 +320,15 @@ function filter_format_exists($format_id) {
 }
 
 /**
- * Display a text format form title.
+ * Displays a text format form title.
+ *
+ * @param object $format
+ *   A format object.
+ *
+ * @return string
+ *   The name of the format.
+ *
+ * @see filter_menu()
  */
 function filter_admin_format_title($format) {
   return $format->name;
@@ -350,6 +365,7 @@ function filter_permission() {
  *
  * @param $format
  *   An object representing a text format.
+ *
  * @return
  *   The machine-readable permission name, or FALSE if the provided text format
  *   is malformed or is the fallback format (which is available to all users).
@@ -380,11 +396,13 @@ function filter_modules_disabled($modules) {
 }
 
 /**
- * Retrieve a list of text formats, ordered by weight.
+ * Retrieves a list of text formats, ordered by weight.
  *
  * @param $account
  *   (optional) If provided, only those formats that are allowed for this user
- *   account will be returned. All formats will be returned otherwise.
+ *   account will be returned. All formats will be returned otherwise. Defaults
+ *   to NULL.
+ *
  * @return
  *   An array of text format objects, keyed by the format ID and ordered by
  *   weight.
@@ -427,7 +445,7 @@ function filter_formats($account = NULL) {
 }
 
 /**
- * Resets text format caches.
+ * Resets the text format caches.
  *
  * @see filter_formats()
  */
@@ -443,6 +461,7 @@ function filter_formats_reset() {
  *
  * @param $format
  *   An object representing the text format.
+ *
  * @return
  *   An array of role names, keyed by role ID.
  */
@@ -461,6 +480,7 @@ function filter_get_roles_by_format($format) {
  *
  * @param $rid
  *   The user role ID to retrieve text formats for.
+ *
  * @return
  *   An array of text format objects that are allowed for the role, keyed by
  *   the text format ID and ordered by weight.
@@ -494,7 +514,8 @@ function filter_get_formats_by_role($rid) {
  *
  * @param $account
  *   (optional) The user account to check. Defaults to the currently logged-in
- *   user.
+ *   user. Defaults to NULL.
+ *
  * @return
  *   The ID of the user's default text format.
  *
@@ -525,15 +546,18 @@ function filter_default_format($account = NULL) {
  * format is initialized to output plain text. Installation profiles and site
  * administrators have the freedom to configure it further.
  *
- * Note that the fallback format is completely distinct from the default
- * format, which differs per user and is simply the first format which that
- * user has access to. The default and fallback formats are only guaranteed to
- * be the same for users who do not have access to any other format; otherwise,
- * the fallback format's weight determines its placement with respect to the
- * user's other formats.
+ * Note that the fallback format is completely distinct from the default format,
+ * which differs per user and is simply the first format which that user has
+ * access to. The default and fallback formats are only guaranteed to be the
+ * same for users who do not have access to any other format; otherwise, the
+ * fallback format's weight determines its placement with respect to the user's
+ * other formats.
  *
- * Any modules implementing a format deletion functionality must not delete
- * this format.
+ * Any modules implementing a format deletion functionality must not delete this
+ * format.
+ *
+ * @return
+ *   The ID of the fallback text format.
  *
  * @see hook_filter_format_disable()
  * @see filter_default_format()
@@ -550,6 +574,9 @@ function filter_fallback_format() {
 
 /**
  * Returns the title of the fallback text format.
+ *
+ * @return string
+ *   The title of the fallback text format.
  */
 function filter_fallback_format_title() {
   $fallback_format = filter_format_load(filter_fallback_format());
@@ -557,7 +584,10 @@ function filter_fallback_format_title() {
 }
 
 /**
- * Return a list of all filters provided by modules.
+ * Returns a list of all filters provided by modules.
+ *
+ * @return array
+ *   An array of filter formats.
  */
 function filter_get_filters() {
   $filters = &drupal_static(__FUNCTION__, array());
@@ -588,14 +618,16 @@ function filter_get_filters() {
 }
 
 /**
- * Helper function for sorting the filter list by filter name.
+ * Sorts an array of filters by filter name.
+ *
+ * Callback for uasort() within filter_get_filters().
  */
 function _filter_list_cmp($a, $b) {
   return strcmp($a['title'], $b['title']);
 }
 
 /**
- * Check if text in a certain text format is allowed to be cached.
+ * Checks if the text in a certain text format is allowed to be cached.
  *
  * This function can be used to check whether the result of the filtering
  * process can be cached. A text format may allow caching depending on the
@@ -603,6 +635,7 @@ function _filter_list_cmp($a, $b) {
  *
  * @param $format_id
  *   The text format ID to check.
+ *
  * @return
  *   TRUE if the given text format allows caching, FALSE otherwise.
  */
@@ -619,6 +652,7 @@ function filter_format_allowcache($format_id) {
  *
  * @param $format
  *   The text format object to check.
+ *
  * @return
  *   TRUE if all the filters enabled in the given text format allow caching,
  *   FALSE otherwise.
@@ -640,7 +674,7 @@ function _filter_format_is_cacheable($format) {
 }
 
 /**
- * Retrieve a list of filters for a given text format.
+ * Retrieves a list of filters for a given text format.
  *
  * Note that this function returns all associated filters regardless of whether
  * they are enabled or disabled. All functions working with the filter
@@ -694,7 +728,7 @@ function filter_list_format($format_id) {
 }
 
 /**
- * Run all the enabled filters on a piece of text.
+ * Runs all the enabled filters on a piece of text.
  *
  * Note: Because filters can inject JavaScript or execute PHP code, security is
  * vital here. When a user supplies a text format, you should validate it using
@@ -705,16 +739,20 @@ function filter_list_format($format_id) {
  * @param $text
  *   The text to be filtered.
  * @param $format_id
- *   The format id of the text to be filtered. If no format is assigned, the
- *   fallback format will be used.
+ *   (optional) The format ID of the text to be filtered. If no format is
+ *   assigned, the fallback format will be used. Defaults to NULL.
  * @param $langcode
- *   Optional: the language code of the text to be filtered, e.g. 'en' for
+ *   (optional) The language code of the text to be filtered, e.g. 'en' for
  *   English. This allows filters to be language aware so language specific
- *   text replacement can be implemented.
+ *   text replacement can be implemented. Defaults to an empty string.
  * @param $cache
- *   Boolean whether to cache the filtered output in the {cache_filter} table.
- *   The caller may set this to FALSE when the output is already cached
- *   elsewhere to avoid duplicate cache lookups and storage.
+ *   (optional) A Boolean indicating whether to cache the filtered output in the
+ *   {cache_filter} table. The caller may set this to FALSE when the output is
+ *   already cached elsewhere to avoid duplicate cache lookups and storage.
+ *   Defaults to FALSE.
+ *
+ * @return
+ *   The filtered text.
  *
  * @ingroup sanitization
  */
@@ -784,8 +822,8 @@ function check_markup($text, $format_id = NULL, $langcode = '', $cache = FALSE)
  *   the text format id specified in #format or the user's default format by
  *   default, if NULL.
  *
- * The resulting value for the element will be an array holding the value and the
- * format.  For example, the value for the body element will be:
+ * The resulting value for the element will be an array holding the value and
+ * the format. For example, the value for the body element will be:
  * @code
  *   $form_state['values']['body']['value'] = 'foo';
  *   $form_state['values']['body']['format'] = 'foo';
@@ -795,7 +833,7 @@ function check_markup($text, $format_id = NULL, $langcode = '', $cache = FALSE)
  *   The form element to process. Properties used:
  *   - #base_type: The form element #type to use for the 'value' element.
  *     'textarea' by default.
- *   - #format: (optional) The text format id to preselect. If NULL or not set,
+ *   - #format: (optional) The text format ID to preselect. If NULL or not set,
  *     the default format for the current user will be used.
  *
  * @return
@@ -933,7 +971,7 @@ function filter_process_format($element) {
 }
 
 /**
- * #pre_render callback for #type 'text_format' to hide field value from prying eyes.
+ * Render API callback: Hides the field value of 'text_format' elements.
  *
  * To not break form processing and previews if a user does not have access to a
  * stored text format, the expanded form elements in filter_process_format() are
@@ -976,7 +1014,7 @@ function theme_text_format_wrapper($variables) {
  *   An object representing the text format.
  * @param $account
  *   (optional) The user account to check access for; if omitted, the currently
- *   logged-in user is used.
+ *   logged-in user is used. Defaults to NULL.
  *
  * @return
  *   Boolean TRUE if the user is allowed to access the given format.
@@ -998,7 +1036,20 @@ function filter_access($format, $account = NULL) {
 }
 
 /**
- * Helper function for fetching filter tips.
+ * Retrieves the filter tips.
+ *
+ * @param $format_id
+ *   The ID of the text format for which to retrieve tips, or -1 to return tips
+ *   for all formats accessible to the current user.
+ * @param $long
+ *   (optional) Boolean indicating whether the long form of tips should be
+ *   returned. Defaults to FALSE.
+ *
+ * @return
+ *   An associative array of filtering tips, keyed by filter name. Each
+ *   filtering tip is an associative array with elements:
+ *   - tip: Tip text.
+ *   - id: Filter ID.
  */
 function _filter_tips($format_id, $long = FALSE) {
   global $user;
@@ -1032,14 +1083,14 @@ function _filter_tips($format_id, $long = FALSE) {
 /**
  * Parses an HTML snippet and returns it as a DOM object.
  *
- * This function loads the body part of a partial (X)HTML document
- * and returns a full DOMDocument object that represents this document.
- * You can use filter_dom_serialize() to serialize this DOMDocument
- * back to a XHTML snippet.
+ * This function loads the body part of a partial (X)HTML document and returns
+ * a full DOMDocument object that represents this document. You can use
+ * filter_dom_serialize() to serialize this DOMDocument back to a XHTML
+ * snippet.
  *
  * @param $text
- *   The partial (X)HTML snippet to load. Invalid mark-up
- *   will be corrected on import.
+ *   The partial (X)HTML snippet to load. Invalid mark-up will be corrected on
+ *   import.
  * @return
  *   A DOMDocument that represents the loaded (X)HTML snippet.
  */
@@ -1054,15 +1105,14 @@ function filter_dom_load($text) {
 /**
  * Converts a DOM object back to an HTML snippet.
  *
- * The function serializes the body part of a DOMDocument
- * back to an XHTML snippet.
- *
- * The resulting XHTML snippet will be properly formatted
- * to be compatible with HTML user agents.
+ * The function serializes the body part of a DOMDocument back to an XHTML
+ * snippet. The resulting XHTML snippet will be properly formatted to be
+ * compatible with HTML user agents.
  *
  * @param $dom_document
  *   A DOMDocument object to serialize, only the tags below
  *   the first <body> node will be converted.
+ *
  * @return
  *   A valid (X)HTML snippet, as a string.
  */
@@ -1099,9 +1149,11 @@ function filter_dom_serialize($dom_document) {
  * @param $dom_element
  *   The element potentially containing a CDATA node.
  * @param $comment_start
- *   String to use as a comment start marker to escape the CDATA declaration.
+ *   (optional) A string to use as a comment start marker to escape the CDATA
+ *   declaration. Defaults to '//'.
  * @param $comment_end
- *   String to use as a comment end marker to escape the CDATA declaration.
+ *   (optional) A string to use as a comment end marker to escape the CDATA
+ *   declaration. Defaults to an empty string.
  */
 function filter_dom_serialize_escape_cdata_element($dom_document, $dom_element, $comment_start = '//', $comment_end = '') {
   foreach ($dom_element->childNodes as $node) {
@@ -1156,7 +1208,7 @@ function theme_filter_guidelines($variables) {
 /**
  * @defgroup standard_filters Standard filters
  * @{
- * Filters implemented by the filter.module.
+ * Filters implemented by the Filter module.
  */
 
 /**
@@ -1204,7 +1256,9 @@ function filter_filter_info() {
 }
 
 /**
- * Settings callback for the HTML filter.
+ * Implements callback_filter_settings().
+ *
+ * Filter settings callback for the HTML content filter.
  */
 function _filter_html_settings($form, &$form_state, $filter, $format, $defaults) {
   $filter->settings += $defaults;
@@ -1230,7 +1284,9 @@ function _filter_html_settings($form, &$form_state, $filter, $format, $defaults)
 }
 
 /**
- * HTML filter. Provides filtering of input into accepted HTML.
+ * Implements callback_filter_process().
+ *
+ * Provides filtering of input into accepted HTML.
  */
 function _filter_html($text, $filter) {
   $allowed_tags = preg_split('/\s+|<|>/', $filter->settings['allowed_html'], -1, PREG_SPLIT_NO_EMPTY);
@@ -1249,7 +1305,11 @@ function _filter_html($text, $filter) {
 }
 
 /**
- * Filter tips callback for HTML filter.
+ * Implements callback_filter_tips().
+ *
+ * Provides help for the HTML filter.
+ *
+ * @see filter_filter_info()
  */
 function _filter_html_tips($filter, $format, $long = FALSE) {
   global $base_url;
@@ -1347,7 +1407,11 @@ function _filter_html_tips($filter, $format, $long = FALSE) {
 }
 
 /**
- * Settings callback for URL filter.
+ * Implements callback_filter_settings().
+ *
+ * Provides settings for the URL filter.
+ *
+ * @see filter_filter_info()
  */
 function _filter_url_settings($form, &$form_state, $filter, $format, $defaults) {
   $filter->settings += $defaults;
@@ -1366,7 +1430,9 @@ function _filter_url_settings($form, &$form_state, $filter, $format, $defaults)
 }
 
 /**
- * URL filter. Automatically converts text into hyperlinks.
+ * Implements callback_filter_process().
+ *
+ * Converts text into hyperlinks automatically.
  *
  * This filter identifies and makes clickable three types of "links".
  * - URLs like http://example.com.
@@ -1395,7 +1461,7 @@ function _filter_url($text, $filter) {
   // we cannot cleanly differ between protocols here without hard-coding MAILTO,
   // so '//' is optional for all protocols.
   // @see filter_xss_bad_protocol()
-  $protocols = variable_get('filter_allowed_protocols', array('http', 'https', 'ftp', 'news', 'nntp', 'telnet', 'mailto', 'irc', 'ssh', 'sftp', 'webcal', 'rtsp'));
+  $protocols = variable_get('filter_allowed_protocols', array('ftp', 'http', 'https', 'irc', 'mailto', 'news', 'nntp', 'rtsp', 'sftp', 'ssh', 'tel', 'telnet', 'webcal'));
   $protocols = implode(':(?://)?|', $protocols) . ':(?://)?';
 
   // Prepare domain name pattern.
@@ -1489,7 +1555,9 @@ function _filter_url($text, $filter) {
 }
 
 /**
- * preg_replace callback to make links out of absolute URLs.
+ * Makes links out of absolute URLs.
+ *
+ * Callback for preg_replace_callback() within _filter_url().
  */
 function _filter_url_parse_full_links($match) {
   // The $i:th parenthesis in the regexp contains the URL.
@@ -1502,7 +1570,9 @@ function _filter_url_parse_full_links($match) {
 }
 
 /**
- * preg_replace callback to make links out of e-mail addresses.
+ * Makes links out of e-mail addresses.
+ *
+ * Callback for preg_replace_callback() within _filter_url().
  */
 function _filter_url_parse_email_links($match) {
   // The $i:th parenthesis in the regexp contains the URL.
@@ -1515,7 +1585,9 @@ function _filter_url_parse_email_links($match) {
 }
 
 /**
- * preg_replace callback to make links out of domain names starting with "www."
+ * Makes links out of domain names starting with "www."
+ *
+ * Callback for preg_replace_callback() within _filter_url().
  */
 function _filter_url_parse_partial_links($match) {
   // The $i:th parenthesis in the regexp contains the URL.
@@ -1528,14 +1600,17 @@ function _filter_url_parse_partial_links($match) {
 }
 
 /**
- * preg_replace callback to escape contents of HTML comments
+ * Escapes the contents of HTML comments.
+ *
+ * Callback for preg_replace_callback() within _filter_url().
  *
  * @param $match
  *   An array containing matches to replace from preg_replace_callback(),
  *   whereas $match[1] is expected to contain the content to be filtered.
  * @param $escape
- *   (optional) Boolean whether to escape (TRUE) or unescape comments (FALSE).
- *   Defaults to neither. If TRUE, statically cached $comments are reset.
+ *   (optional) A Boolean indicating whether to escape (TRUE) or unescape
+ *   comments (FALSE). Defaults to NULL, indicating neither. If TRUE, statically
+ *   cached $comments are reset.
  */
 function _filter_url_escape_comments($match, $escape = NULL) {
   static $mode, $comments = array();
@@ -1582,21 +1657,30 @@ function _filter_url_trim($text, $length = NULL) {
 }
 
 /**
- * Filter tips callback for URL filter.
+ * Implements callback_filter_tips().
+ *
+ * Provides help for the URL filter.
+ *
+ * @see filter_filter_info()
  */
 function _filter_url_tips($filter, $format, $long = FALSE) {
   return t('Web page addresses and e-mail addresses turn into links automatically.');
 }
 
 /**
- * Scan input and make sure that all HTML tags are properly closed and nested.
+ * Implements callback_filter_process().
+ *
+ * Scans the input and makes sure that HTML tags are properly closed.
  */
 function _filter_htmlcorrector($text) {
   return filter_dom_serialize(filter_dom_load($text));
 }
 
 /**
- * Convert line breaks into <p> and <br> in an intelligent fashion.
+ * Implements callback_filter_process().
+ *
+ * Converts line breaks into <p> and <br> in an intelligent fashion.
+ *
  * Based on: http://photomatt.net/scripts/autop
  */
 function _filter_autop($text) {
@@ -1662,7 +1746,11 @@ function _filter_autop($text) {
 }
 
 /**
- * Filter tips callback for auto-paragraph filter.
+ * Implements callback_filter_tips().
+ *
+ * Provides help for the auto-paragraph filter.
+ *
+ * @see filter_filter_info()
  */
 function _filter_autop_tips($filter, $format, $long = FALSE) {
   if ($long) {
@@ -1674,6 +1762,8 @@ function _filter_autop_tips($filter, $format, $long = FALSE) {
 }
 
 /**
+ * Implements callback_filter_process().
+ *
  * Escapes all HTML tags, so they will be visible instead of being effective.
  */
 function _filter_html_escape($text) {
@@ -1681,7 +1771,11 @@ function _filter_html_escape($text) {
 }
 
 /**
- * Filter tips callback for HTML escaping filter.
+ * Implements callback_filter_tips().
+ *
+ * Provides help for the HTML escaping filter.
+ *
+ * @see filter_filter_info()
  */
 function _filter_html_escape_tips($filter, $format, $long = FALSE) {
   return t('No HTML tags allowed.');
diff --git a/modules/filter/filter.pages.inc b/modules/filter/filter.pages.inc
index dbbbe4c..50f8117 100644
--- a/modules/filter/filter.pages.inc
+++ b/modules/filter/filter.pages.inc
@@ -2,12 +2,17 @@
 
 /**
  * @file
- * User page callbacks for the filter module.
+ * User page callbacks for the Filter module.
  */
 
-
 /**
- * Menu callback; show a page with long filter tips.
+ * Page callback: Displays a page with long filter tips.
+ *
+ * @return string
+ *   An HTML-formatted string.
+ *
+ * @see filter_menu()
+ * @see theme_filter_tips()
  */
 function filter_tips_long() {
   $format_id = arg(2);
@@ -20,13 +25,12 @@ function filter_tips_long() {
   return $output;
 }
 
-
 /**
  * Returns HTML for a set of filter tips.
  *
  * @param $variables
  *   An associative array containing:
- *   - tips: An array containing descriptions and a CSS id in the form of
+ *   - tips: An array containing descriptions and a CSS ID in the form of
  *     'module-name/filter-id' (only used when $long is TRUE) for each
  *     filter in one or more text formats. Example:
  *     @code
diff --git a/modules/filter/filter.test b/modules/filter/filter.test
index aa1693f..cc0295b 100644
--- a/modules/filter/filter.test
+++ b/modules/filter/filter.test
@@ -22,7 +22,7 @@ class FilterCRUDTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test CRUD operations for text formats and filters.
+   * Tests CRUD operations for text formats and filters.
    */
   function testTextFormatCRUD() {
     // Add a text format with minimum data only.
@@ -67,13 +67,13 @@ class FilterCRUDTestCase extends DrupalWebTestCase {
     filter_format_disable($format);
 
     $db_format = db_query("SELECT * FROM {filter_format} WHERE format = :format", array(':format' => $format->format))->fetchObject();
-    $this->assertFalse($db_format->status, t('Database: Disabled text format is marked as disabled.'));
+    $this->assertFalse($db_format->status, 'Database: Disabled text format is marked as disabled.');
     $formats = filter_formats();
-    $this->assertTrue(!isset($formats[$format->format]), t('filter_formats: Disabled text format no longer exists.'));
+    $this->assertTrue(!isset($formats[$format->format]), 'filter_formats: Disabled text format no longer exists.');
   }
 
   /**
-   * Verify that a text format is properly stored.
+   * Verifies that a text format is properly stored.
    */
   function verifyTextFormat($format) {
     $t_args = array('%format' => $format->name);
@@ -83,17 +83,17 @@ class FilterCRUDTestCase extends DrupalWebTestCase {
       ->condition('format', $format->format)
       ->execute()
       ->fetchObject();
-    $this->assertEqual($db_format->format, $format->format, t('Database: Proper format id for text format %format.', $t_args));
-    $this->assertEqual($db_format->name, $format->name, t('Database: Proper title for text format %format.', $t_args));
-    $this->assertEqual($db_format->cache, $format->cache, t('Database: Proper cache indicator for text format %format.', $t_args));
-    $this->assertEqual($db_format->weight, $format->weight, t('Database: Proper weight for text format %format.', $t_args));
+    $this->assertEqual($db_format->format, $format->format, format_string('Database: Proper format id for text format %format.', $t_args));
+    $this->assertEqual($db_format->name, $format->name, format_string('Database: Proper title for text format %format.', $t_args));
+    $this->assertEqual($db_format->cache, $format->cache, format_string('Database: Proper cache indicator for text format %format.', $t_args));
+    $this->assertEqual($db_format->weight, $format->weight, format_string('Database: Proper weight for text format %format.', $t_args));
 
     // Verify filter_format_load().
     $filter_format = filter_format_load($format->format);
-    $this->assertEqual($filter_format->format, $format->format, t('filter_format_load: Proper format id for text format %format.', $t_args));
-    $this->assertEqual($filter_format->name, $format->name, t('filter_format_load: Proper title for text format %format.', $t_args));
-    $this->assertEqual($filter_format->cache, $format->cache, t('filter_format_load: Proper cache indicator for text format %format.', $t_args));
-    $this->assertEqual($filter_format->weight, $format->weight, t('filter_format_load: Proper weight for text format %format.', $t_args));
+    $this->assertEqual($filter_format->format, $format->format, format_string('filter_format_load: Proper format id for text format %format.', $t_args));
+    $this->assertEqual($filter_format->name, $format->name, format_string('filter_format_load: Proper title for text format %format.', $t_args));
+    $this->assertEqual($filter_format->cache, $format->cache, format_string('filter_format_load: Proper cache indicator for text format %format.', $t_args));
+    $this->assertEqual($filter_format->weight, $format->weight, format_string('filter_format_load: Proper weight for text format %format.', $t_args));
 
     // Verify the 'cache' text format property according to enabled filters.
     $filter_info = filter_get_filters();
@@ -107,11 +107,11 @@ class FilterCRUDTestCase extends DrupalWebTestCase {
         break;
       }
     }
-    $this->assertEqual($filter_format->cache, $cacheable, t('Text format contains proper cache property.'));
+    $this->assertEqual($filter_format->cache, $cacheable, 'Text format contains proper cache property.');
   }
 
   /**
-   * Verify that filters are properly stored for a text format.
+   * Verifies that filters are properly stored for a text format.
    */
   function verifyFilters($format) {
     // Verify filter database records.
@@ -121,20 +121,20 @@ class FilterCRUDTestCase extends DrupalWebTestCase {
       $t_args = array('%format' => $format->name, '%filter' => $name);
 
       // Verify that filter status is properly stored.
-      $this->assertEqual($filter->status, $format_filters[$name]['status'], t('Database: Proper status for %filter in text format %format.', $t_args));
+      $this->assertEqual($filter->status, $format_filters[$name]['status'], format_string('Database: Proper status for %filter in text format %format.', $t_args));
 
       // Verify that filter settings were properly stored.
-      $this->assertEqual(unserialize($filter->settings), isset($format_filters[$name]['settings']) ? $format_filters[$name]['settings'] : array(), t('Database: Proper filter settings for %filter in text format %format.', $t_args));
+      $this->assertEqual(unserialize($filter->settings), isset($format_filters[$name]['settings']) ? $format_filters[$name]['settings'] : array(), format_string('Database: Proper filter settings for %filter in text format %format.', $t_args));
 
       // Verify that each filter has a module name assigned.
-      $this->assertTrue(!empty($filter->module), t('Database: Proper module name for %filter in text format %format.', $t_args));
+      $this->assertTrue(!empty($filter->module), format_string('Database: Proper module name for %filter in text format %format.', $t_args));
 
       // Remove the filter from the copy of saved $format to check whether all
       // filters have been processed later.
       unset($format_filters[$name]);
     }
     // Verify that all filters have been processed.
-    $this->assertTrue(empty($format_filters), t('Database contains values for all filters in the saved format.'));
+    $this->assertTrue(empty($format_filters), 'Database contains values for all filters in the saved format.');
 
     // Verify filter_list_format().
     $filters = filter_list_format($format->format);
@@ -143,23 +143,26 @@ class FilterCRUDTestCase extends DrupalWebTestCase {
       $t_args = array('%format' => $format->name, '%filter' => $name);
 
       // Verify that filter status is properly stored.
-      $this->assertEqual($filter->status, $format_filters[$name]['status'], t('filter_list_format: Proper status for %filter in text format %format.', $t_args));
+      $this->assertEqual($filter->status, $format_filters[$name]['status'], format_string('filter_list_format: Proper status for %filter in text format %format.', $t_args));
 
       // Verify that filter settings were properly stored.
-      $this->assertEqual($filter->settings, isset($format_filters[$name]['settings']) ? $format_filters[$name]['settings'] : array(), t('filter_list_format: Proper filter settings for %filter in text format %format.', $t_args));
+      $this->assertEqual($filter->settings, isset($format_filters[$name]['settings']) ? $format_filters[$name]['settings'] : array(), format_string('filter_list_format: Proper filter settings for %filter in text format %format.', $t_args));
 
       // Verify that each filter has a module name assigned.
-      $this->assertTrue(!empty($filter->module), t('filter_list_format: Proper module name for %filter in text format %format.', $t_args));
+      $this->assertTrue(!empty($filter->module), format_string('filter_list_format: Proper module name for %filter in text format %format.', $t_args));
 
       // Remove the filter from the copy of saved $format to check whether all
       // filters have been processed later.
       unset($format_filters[$name]);
     }
     // Verify that all filters have been processed.
-    $this->assertTrue(empty($format_filters), t('filter_list_format: Loaded filters contain values for all filters in the saved format.'));
+    $this->assertTrue(empty($format_filters), 'filter_list_format: Loaded filters contain values for all filters in the saved format.');
   }
 }
 
+/**
+ * Tests the administrative functionality of the Filter module.
+ */
 class FilterAdminTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -185,6 +188,9 @@ class FilterAdminTestCase extends DrupalWebTestCase {
     $this->drupalLogin($this->admin_user);
   }
 
+  /**
+   * Tests the format administration functionality.
+   */
   function testFormatAdmin() {
     // Add text format.
     $this->drupalGet('admin/config/content/formats');
@@ -199,14 +205,14 @@ class FilterAdminTestCase extends DrupalWebTestCase {
 
     // Verify default weight of the text format.
     $this->drupalGet('admin/config/content/formats');
-    $this->assertFieldByName("formats[$format_id][weight]", 0, t('Text format weight was saved.'));
+    $this->assertFieldByName("formats[$format_id][weight]", 0, 'Text format weight was saved.');
 
     // Change the weight of the text format.
     $edit = array(
       "formats[$format_id][weight]" => 5,
     );
     $this->drupalPost('admin/config/content/formats', $edit, t('Save changes'));
-    $this->assertFieldByName("formats[$format_id][weight]", 5, t('Text format weight was saved.'));
+    $this->assertFieldByName("formats[$format_id][weight]", 5, 'Text format weight was saved.');
 
     // Edit text format.
     $this->drupalGet('admin/config/content/formats');
@@ -216,7 +222,7 @@ class FilterAdminTestCase extends DrupalWebTestCase {
 
     // Verify that the custom weight of the text format has been retained.
     $this->drupalGet('admin/config/content/formats');
-    $this->assertFieldByName("formats[$format_id][weight]", 5, t('Text format weight was retained.'));
+    $this->assertFieldByName("formats[$format_id][weight]", 5, 'Text format weight was retained.');
 
     // Disable text format.
     $this->assertLinkByHref('admin/config/content/formats/' . $format_id . '/disable');
@@ -225,7 +231,7 @@ class FilterAdminTestCase extends DrupalWebTestCase {
 
     // Verify that disabled text format no longer exists.
     $this->drupalGet('admin/config/content/formats/' . $format_id);
-    $this->assertResponse(404, t('Disabled text format no longer exists.'));
+    $this->assertResponse(404, 'Disabled text format no longer exists.');
 
     // Attempt to create a format of the same machine name as the disabled
     // format but with a different human readable name.
@@ -249,7 +255,7 @@ class FilterAdminTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test filter administration functionality.
+   * Tests filter administration functionality.
    */
   function testFilterAdmin() {
     // URL filter.
@@ -262,44 +268,44 @@ class FilterAdminTestCase extends DrupalWebTestCase {
     $plain = 'plain_text';
 
     // Check that the fallback format exists and cannot be disabled.
-    $this->assertTrue($plain == filter_fallback_format(), t('The fallback format is set to plain text.'));
+    $this->assertTrue($plain == filter_fallback_format(), 'The fallback format is set to plain text.');
     $this->drupalGet('admin/config/content/formats');
-    $this->assertNoRaw('admin/config/content/formats/' . $plain . '/disable', t('Disable link for the fallback format not found.'));
+    $this->assertNoRaw('admin/config/content/formats/' . $plain . '/disable', 'Disable link for the fallback format not found.');
     $this->drupalGet('admin/config/content/formats/' . $plain . '/disable');
-    $this->assertResponse(403, t('The fallback format cannot be disabled.'));
+    $this->assertResponse(403, 'The fallback format cannot be disabled.');
 
     // Verify access permissions to Full HTML format.
-    $this->assertTrue(filter_access(filter_format_load($full), $this->admin_user), t('Admin user may use Full HTML.'));
-    $this->assertFalse(filter_access(filter_format_load($full), $this->web_user), t('Web user may not use Full HTML.'));
+    $this->assertTrue(filter_access(filter_format_load($full), $this->admin_user), 'Admin user may use Full HTML.');
+    $this->assertFalse(filter_access(filter_format_load($full), $this->web_user), 'Web user may not use Full HTML.');
 
     // Add an additional tag.
     $edit = array();
     $edit['filters[filter_html][settings][allowed_html]'] = '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd> <quote>';
     $this->drupalPost('admin/config/content/formats/' . $filtered, $edit, t('Save configuration'));
-    $this->assertFieldByName('filters[filter_html][settings][allowed_html]', $edit['filters[filter_html][settings][allowed_html]'], t('Allowed HTML tag added.'));
+    $this->assertFieldByName('filters[filter_html][settings][allowed_html]', $edit['filters[filter_html][settings][allowed_html]'], 'Allowed HTML tag added.');
 
     $result = db_query('SELECT * FROM {cache_filter}')->fetchObject();
-    $this->assertFalse($result, t('Cache cleared.'));
+    $this->assertFalse($result, 'Cache cleared.');
 
     $elements = $this->xpath('//select[@name=:first]/following::select[@name=:second]', array(
       ':first' => 'filters[' . $first_filter . '][weight]',
       ':second' => 'filters[' . $second_filter . '][weight]',
     ));
-    $this->assertTrue(!empty($elements), t('Order confirmed in admin interface.'));
+    $this->assertTrue(!empty($elements), 'Order confirmed in admin interface.');
 
     // Reorder filters.
     $edit = array();
     $edit['filters[' . $second_filter . '][weight]'] = 1;
     $edit['filters[' . $first_filter . '][weight]'] = 2;
     $this->drupalPost(NULL, $edit, t('Save configuration'));
-    $this->assertFieldByName('filters[' . $second_filter . '][weight]', 1, t('Order saved successfully.'));
-    $this->assertFieldByName('filters[' . $first_filter . '][weight]', 2, t('Order saved successfully.'));
+    $this->assertFieldByName('filters[' . $second_filter . '][weight]', 1, 'Order saved successfully.');
+    $this->assertFieldByName('filters[' . $first_filter . '][weight]', 2, 'Order saved successfully.');
 
     $elements = $this->xpath('//select[@name=:first]/following::select[@name=:second]', array(
       ':first' => 'filters[' . $second_filter . '][weight]',
       ':second' => 'filters[' . $first_filter . '][weight]',
     ));
-    $this->assertTrue(!empty($elements), t('Reorder confirmed in admin interface.'));
+    $this->assertTrue(!empty($elements), 'Reorder confirmed in admin interface.');
 
     $result = db_query('SELECT * FROM {filter} WHERE format = :format ORDER BY weight ASC', array(':format' => $filtered));
     $filters = array();
@@ -308,7 +314,7 @@ class FilterAdminTestCase extends DrupalWebTestCase {
         $filters[] = $filter;
       }
     }
-    $this->assertTrue(($filters[0]->name == $second_filter && $filters[1]->name == $first_filter), t('Order confirmed in database.'));
+    $this->assertTrue(($filters[0]->name == $second_filter && $filters[1]->name == $first_filter), 'Order confirmed in database.');
 
     // Add format.
     $edit = array();
@@ -318,19 +324,19 @@ class FilterAdminTestCase extends DrupalWebTestCase {
     $edit['filters[' . $second_filter . '][status]'] = TRUE;
     $edit['filters[' . $first_filter . '][status]'] = TRUE;
     $this->drupalPost('admin/config/content/formats/add', $edit, t('Save configuration'));
-    $this->assertRaw(t('Added text format %format.', array('%format' => $edit['name'])), t('New filter created.'));
+    $this->assertRaw(t('Added text format %format.', array('%format' => $edit['name'])), 'New filter created.');
 
     drupal_static_reset('filter_formats');
     $format = filter_format_load($edit['format']);
-    $this->assertNotNull($format, t('Format found in database.'));
+    $this->assertNotNull($format, 'Format found in database.');
 
-    $this->assertFieldByName('roles[' . DRUPAL_AUTHENTICATED_RID . ']', '', t('Role found.'));
-    $this->assertFieldByName('filters[' . $second_filter . '][status]', '', t('Line break filter found.'));
-    $this->assertFieldByName('filters[' . $first_filter . '][status]', '', t('Url filter found.'));
+    $this->assertFieldByName('roles[' . DRUPAL_AUTHENTICATED_RID . ']', '', 'Role found.');
+    $this->assertFieldByName('filters[' . $second_filter . '][status]', '', 'Line break filter found.');
+    $this->assertFieldByName('filters[' . $first_filter . '][status]', '', 'Url filter found.');
 
     // Disable new filter.
     $this->drupalPost('admin/config/content/formats/' . $format->format . '/disable', array(), t('Disable'));
-    $this->assertRaw(t('Disabled text format %format.', array('%format' => $edit['name'])), t('Format successfully disabled.'));
+    $this->assertRaw(t('Disabled text format %format.', array('%format' => $edit['name'])), 'Format successfully disabled.');
 
     // Allow authenticated users on full HTML.
     $format = filter_format_load($full);
@@ -338,14 +344,14 @@ class FilterAdminTestCase extends DrupalWebTestCase {
     $edit['roles[' . DRUPAL_ANONYMOUS_RID . ']'] = 0;
     $edit['roles[' . DRUPAL_AUTHENTICATED_RID . ']'] = 1;
     $this->drupalPost('admin/config/content/formats/' . $full, $edit, t('Save configuration'));
-    $this->assertRaw(t('The text format %format has been updated.', array('%format' => $format->name)), t('Full HTML format successfully updated.'));
+    $this->assertRaw(t('The text format %format has been updated.', array('%format' => $format->name)), 'Full HTML format successfully updated.');
 
     // Switch user.
     $this->drupalLogout();
     $this->drupalLogin($this->web_user);
 
     $this->drupalGet('node/add/page');
-    $this->assertRaw('<option value="' . $full . '">Full HTML</option>', t('Full HTML filter accessible.'));
+    $this->assertRaw('<option value="' . $full . '">Full HTML</option>', 'Full HTML filter accessible.');
 
     // Use filtered HTML and see if it removes tags that are not allowed.
     $body = '<em>' . $this->randomName() . '</em>';
@@ -358,20 +364,20 @@ class FilterAdminTestCase extends DrupalWebTestCase {
     $edit["body[$langcode][0][value]"] = $text;
     $edit["body[$langcode][0][format]"] = $filtered;
     $this->drupalPost('node/add/page', $edit, t('Save'));
-    $this->assertRaw(t('Basic page %title has been created.', array('%title' => $edit["title"])), t('Filtered node created.'));
+    $this->assertRaw(t('Basic page %title has been created.', array('%title' => $edit["title"])), 'Filtered node created.');
 
     $node = $this->drupalGetNodeByTitle($edit["title"]);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
 
     $this->drupalGet('node/' . $node->nid);
-    $this->assertRaw($body . $extra_text, t('Filter removed invalid tag.'));
+    $this->assertRaw($body . $extra_text, 'Filter removed invalid tag.');
 
     // Use plain text and see if it escapes all tags, whether allowed or not.
     $edit = array();
     $edit["body[$langcode][0][format]"] = $plain;
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText(check_plain($text), t('The "Plain text" text format escapes all HTML tags.'));
+    $this->assertText(check_plain($text), 'The "Plain text" text format escapes all HTML tags.');
 
     // Switch user.
     $this->drupalLogout();
@@ -382,22 +388,22 @@ class FilterAdminTestCase extends DrupalWebTestCase {
     $edit = array();
     $edit['filters[filter_html][settings][allowed_html]'] = '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>';
     $this->drupalPost('admin/config/content/formats/' . $filtered, $edit, t('Save configuration'));
-    $this->assertFieldByName('filters[filter_html][settings][allowed_html]', $edit['filters[filter_html][settings][allowed_html]'], t('Changes reverted.'));
+    $this->assertFieldByName('filters[filter_html][settings][allowed_html]', $edit['filters[filter_html][settings][allowed_html]'], 'Changes reverted.');
 
     // Full HTML.
     $edit = array();
     $edit['roles[' . DRUPAL_AUTHENTICATED_RID . ']'] = FALSE;
     $this->drupalPost('admin/config/content/formats/' . $full, $edit, t('Save configuration'));
-    $this->assertRaw(t('The text format %format has been updated.', array('%format' => $format->name)), t('Full HTML format successfully reverted.'));
-    $this->assertFieldByName('roles[' . DRUPAL_AUTHENTICATED_RID . ']', $edit['roles[' . DRUPAL_AUTHENTICATED_RID . ']'], t('Changes reverted.'));
+    $this->assertRaw(t('The text format %format has been updated.', array('%format' => $format->name)), 'Full HTML format successfully reverted.');
+    $this->assertFieldByName('roles[' . DRUPAL_AUTHENTICATED_RID . ']', $edit['roles[' . DRUPAL_AUTHENTICATED_RID . ']'], 'Changes reverted.');
 
     // Filter order.
     $edit = array();
     $edit['filters[' . $second_filter . '][weight]'] = 2;
     $edit['filters[' . $first_filter . '][weight]'] = 1;
     $this->drupalPost('admin/config/content/formats/' . $filtered, $edit, t('Save configuration'));
-    $this->assertFieldByName('filters[' . $second_filter . '][weight]', $edit['filters[' . $second_filter . '][weight]'], t('Changes reverted.'));
-    $this->assertFieldByName('filters[' . $first_filter . '][weight]', $edit['filters[' . $first_filter . '][weight]'], t('Changes reverted.'));
+    $this->assertFieldByName('filters[' . $second_filter . '][weight]', $edit['filters[' . $second_filter . '][weight]'], 'Changes reverted.');
+    $this->assertFieldByName('filters[' . $first_filter . '][weight]', $edit['filters[' . $first_filter . '][weight]'], 'Changes reverted.');
   }
 
   /**
@@ -413,11 +419,43 @@ class FilterAdminTestCase extends DrupalWebTestCase {
   }
 }
 
+/**
+ * Tests the filter format access functionality in the Filter module.
+ */
 class FilterFormatAccessTestCase extends DrupalWebTestCase {
+  /**
+   * A user with administrative permissions.
+   *
+   * @var object
+   */
   protected $admin_user;
+
+  /**
+   * A user with 'administer filters' permission.
+   *
+   * @var object
+   */
   protected $filter_admin_user;
+
+  /**
+   * A user with permission to create and edit own content.
+   *
+   * @var object
+   */
   protected $web_user;
+
+  /**
+   * An object representing an allowed text format.
+   *
+   * @var object
+   */
   protected $allowed_format;
+
+  /**
+   * An object representing a disallowed text format.
+   *
+   * @var object
+   */
   protected $disallowed_format;
 
   public static function getInfo() {
@@ -471,23 +509,26 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     ));
   }
 
+  /**
+   * Tests the Filter format access permissions functionality.
+   */
   function testFormatPermissions() {
     // Make sure that a regular user only has access to the text format they
     // were granted access to, as well to the fallback format.
-    $this->assertTrue(filter_access($this->allowed_format, $this->web_user), t('A regular user has access to a text format they were granted access to.'));
-    $this->assertFalse(filter_access($this->disallowed_format, $this->web_user), t('A regular user does not have access to a text format they were not granted access to.'));
-    $this->assertTrue(filter_access(filter_format_load(filter_fallback_format()), $this->web_user), t('A regular user has access to the fallback format.'));
+    $this->assertTrue(filter_access($this->allowed_format, $this->web_user), 'A regular user has access to a text format they were granted access to.');
+    $this->assertFalse(filter_access($this->disallowed_format, $this->web_user), 'A regular user does not have access to a text format they were not granted access to.');
+    $this->assertTrue(filter_access(filter_format_load(filter_fallback_format()), $this->web_user), 'A regular user has access to the fallback format.');
 
     // Perform similar checks as above, but now against the entire list of
     // available formats for this user.
-    $this->assertTrue(in_array($this->allowed_format->format, array_keys(filter_formats($this->web_user))), t('The allowed format appears in the list of available formats for a regular user.'));
-    $this->assertFalse(in_array($this->disallowed_format->format, array_keys(filter_formats($this->web_user))), t('The disallowed format does not appear in the list of available formats for a regular user.'));
-    $this->assertTrue(in_array(filter_fallback_format(), array_keys(filter_formats($this->web_user))), t('The fallback format appears in the list of available formats for a regular user.'));
+    $this->assertTrue(in_array($this->allowed_format->format, array_keys(filter_formats($this->web_user))), 'The allowed format appears in the list of available formats for a regular user.');
+    $this->assertFalse(in_array($this->disallowed_format->format, array_keys(filter_formats($this->web_user))), 'The disallowed format does not appear in the list of available formats for a regular user.');
+    $this->assertTrue(in_array(filter_fallback_format(), array_keys(filter_formats($this->web_user))), 'The fallback format appears in the list of available formats for a regular user.');
 
     // Make sure that a regular user only has permission to use the format
     // they were granted access to.
-    $this->assertTrue(user_access(filter_permission_name($this->allowed_format), $this->web_user), t('A regular user has permission to use the allowed text format.'));
-    $this->assertFalse(user_access(filter_permission_name($this->disallowed_format), $this->web_user), t('A regular user does not have permission to use the disallowed text format.'));
+    $this->assertTrue(user_access(filter_permission_name($this->allowed_format), $this->web_user), 'A regular user has permission to use the allowed text format.');
+    $this->assertFalse(user_access(filter_permission_name($this->disallowed_format), $this->web_user), 'A regular user does not have permission to use the disallowed text format.');
 
     // Make sure that the allowed format appears on the node form and that
     // the disallowed format does not.
@@ -502,11 +543,14 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     foreach ($elements as $element) {
       $options[(string) $element['value']] = $element;
     }
-    $this->assertTrue(isset($options[$this->allowed_format->format]), t('The allowed text format appears as an option when adding a new node.'));
-    $this->assertFalse(isset($options[$this->disallowed_format->format]), t('The disallowed text format does not appear as an option when adding a new node.'));
-    $this->assertTrue(isset($options[filter_fallback_format()]), t('The fallback format appears as an option when adding a new node.'));
+    $this->assertTrue(isset($options[$this->allowed_format->format]), 'The allowed text format appears as an option when adding a new node.');
+    $this->assertFalse(isset($options[$this->disallowed_format->format]), 'The disallowed text format does not appear as an option when adding a new node.');
+    $this->assertTrue(isset($options[filter_fallback_format()]), 'The fallback format appears as an option when adding a new node.');
   }
 
+  /**
+   * Tests if text format is available to a role.
+   */
   function testFormatRoles() {
     // Get the role ID assigned to the regular user; it must be the maximum.
     $rid = max(array_keys($this->web_user->roles));
@@ -514,27 +558,27 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     // Check that this role appears in the list of roles that have access to an
     // allowed text format, but does not appear in the list of roles that have
     // access to a disallowed text format.
-    $this->assertTrue(in_array($rid, array_keys(filter_get_roles_by_format($this->allowed_format))), t('A role which has access to a text format appears in the list of roles that have access to that format.'));
-    $this->assertFalse(in_array($rid, array_keys(filter_get_roles_by_format($this->disallowed_format))), t('A role which does not have access to a text format does not appear in the list of roles that have access to that format.'));
+    $this->assertTrue(in_array($rid, array_keys(filter_get_roles_by_format($this->allowed_format))), 'A role which has access to a text format appears in the list of roles that have access to that format.');
+    $this->assertFalse(in_array($rid, array_keys(filter_get_roles_by_format($this->disallowed_format))), 'A role which does not have access to a text format does not appear in the list of roles that have access to that format.');
 
     // Check that the correct text format appears in the list of formats
     // available to that role.
-    $this->assertTrue(in_array($this->allowed_format->format, array_keys(filter_get_formats_by_role($rid))), t('A text format which a role has access to appears in the list of formats available to that role.'));
-    $this->assertFalse(in_array($this->disallowed_format->format, array_keys(filter_get_formats_by_role($rid))), t('A text format which a role does not have access to does not appear in the list of formats available to that role.'));
+    $this->assertTrue(in_array($this->allowed_format->format, array_keys(filter_get_formats_by_role($rid))), 'A text format which a role has access to appears in the list of formats available to that role.');
+    $this->assertFalse(in_array($this->disallowed_format->format, array_keys(filter_get_formats_by_role($rid))), 'A text format which a role does not have access to does not appear in the list of formats available to that role.');
 
     // Check that the fallback format is always allowed.
-    $this->assertEqual(filter_get_roles_by_format(filter_format_load(filter_fallback_format())), user_roles(), t('All roles have access to the fallback format.'));
-    $this->assertTrue(in_array(filter_fallback_format(), array_keys(filter_get_formats_by_role($rid))), t('The fallback format appears in the list of allowed formats for any role.'));
+    $this->assertEqual(filter_get_roles_by_format(filter_format_load(filter_fallback_format())), user_roles(), 'All roles have access to the fallback format.');
+    $this->assertTrue(in_array(filter_fallback_format(), array_keys(filter_get_formats_by_role($rid))), 'The fallback format appears in the list of allowed formats for any role.');
   }
 
   /**
-   * Test editing a page using a disallowed text format.
+   * Tests editing a page using a disallowed text format.
    *
-   * Verifies that regular users and administrators are able to edit a page,
-   * but not allowed to change the fields which use an inaccessible text
-   * format. Also verifies that fields which use a text format that does not
-   * exist can be edited by administrators only, but that the administrator is
-   * forced to choose a new format before saving the page.
+   * Verifies that regular users and administrators are able to edit a page, but
+   * not allowed to change the fields which use an inaccessible text format.
+   * Also verifies that fields which use a text format that does not exist can
+   * be edited by administrators only, but that the administrator is forced to
+   * choose a new format before saving the page.
    */
   function testFormatWidgetPermissions() {
     $langcode = LANGUAGE_NONE;
@@ -557,19 +601,19 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     $this->clickLink(t('Edit'));
 
     // Verify that body field is read-only and contains replacement value.
-    $this->assertFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", t('This field has been disabled because you do not have sufficient permissions to edit it.'), t('Text format access denied message found.'));
+    $this->assertFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", t('This field has been disabled because you do not have sufficient permissions to edit it.'), 'Text format access denied message found.');
 
     // Verify that title can be changed, but preview displays original body.
     $new_edit = array();
     $new_edit['title'] = $this->randomName(8);
     $this->drupalPost(NULL, $new_edit, t('Preview'));
-    $this->assertText($edit[$body_value_key], t('Old body found in preview.'));
+    $this->assertText($edit[$body_value_key], 'Old body found in preview.');
 
     // Save and verify that only the title was changed.
     $this->drupalPost(NULL, $new_edit, t('Save'));
-    $this->assertNoText($edit['title'], t('Old title not found.'));
-    $this->assertText($new_edit['title'], t('New title found.'));
-    $this->assertText($edit[$body_value_key], t('Old body found.'));
+    $this->assertNoText($edit['title'], 'Old title not found.');
+    $this->assertText($new_edit['title'], 'New title found.');
+    $this->assertText($edit[$body_value_key], 'Old body found.');
 
     // Check that even an administrator with "administer filters" permission
     // cannot edit the body field if they do not have specific permission to
@@ -578,7 +622,7 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     // else.)
     $this->drupalLogin($this->filter_admin_user);
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", t('This field has been disabled because you do not have sufficient permissions to edit it.'), t('Text format access denied message found.'));
+    $this->assertFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", t('This field has been disabled because you do not have sufficient permissions to edit it.'), 'Text format access denied message found.');
 
     // Disable the text format used above.
     filter_format_disable($this->disallowed_format);
@@ -589,14 +633,14 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     // edit content that does not have an assigned format.
     $this->drupalLogin($this->web_user);
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", t('This field has been disabled because you do not have sufficient permissions to edit it.'), t('Text format access denied message found.'));
+    $this->assertFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", t('This field has been disabled because you do not have sufficient permissions to edit it.'), 'Text format access denied message found.');
 
     // Log back in as the filter administrator and verify that the body field
     // can be edited.
     $this->drupalLogin($this->filter_admin_user);
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertNoFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", NULL, t('Text format access denied message not found.'));
-    $this->assertFieldByXPath("//select[@name='$body_format_key']", NULL, t('Text format selector found.'));
+    $this->assertNoFieldByXPath("//textarea[@name='$body_value_key' and @disabled='disabled']", NULL, 'Text format access denied message not found.');
+    $this->assertFieldByXPath("//select[@name='$body_format_key']", NULL, 'Text format selector found.');
 
     // Verify that trying to save the node without selecting a new text format
     // produces an error message, and does not result in the node being saved.
@@ -604,17 +648,17 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     $new_title = $this->randomName(8);
     $edit = array('title' => $new_title);
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
-    $this->assertText(t('!name field is required.', array('!name' => t('Text format'))), t('Error message is displayed.'));
+    $this->assertText(t('!name field is required.', array('!name' => t('Text format'))), 'Error message is displayed.');
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText($old_title, t('Old title found.'));
-    $this->assertNoText($new_title, t('New title not found.'));
+    $this->assertText($old_title, 'Old title found.');
+    $this->assertNoText($new_title, 'New title not found.');
 
     // Now select a new text format and make sure the node can be saved.
     $edit[$body_format_key] = filter_fallback_format();
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
     $this->assertUrl('node/' . $node->nid);
-    $this->assertText($new_title, t('New title found.'));
-    $this->assertNoText($old_title, t('Old title not found.'));
+    $this->assertText($new_title, 'New title found.');
+    $this->assertNoText($old_title, 'Old title not found.');
 
     // Switch the text format to a new one, then disable that format and all
     // other formats on the site (leaving only the fallback format).
@@ -638,19 +682,19 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
     $new_title = $this->randomName(8);
     $edit = array('title' => $new_title);
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
-    $this->assertText(t('!name field is required.', array('!name' => t('Text format'))), t('Error message is displayed.'));
+    $this->assertText(t('!name field is required.', array('!name' => t('Text format'))), 'Error message is displayed.');
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText($old_title, t('Old title found.'));
-    $this->assertNoText($new_title, t('New title not found.'));
+    $this->assertText($old_title, 'Old title found.');
+    $this->assertNoText($new_title, 'New title not found.');
     $edit[$body_format_key] = filter_fallback_format();
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
     $this->assertUrl('node/' . $node->nid);
-    $this->assertText($new_title, t('New title found.'));
-    $this->assertNoText($old_title, t('Old title not found.'));
+    $this->assertText($new_title, 'New title found.');
+    $this->assertNoText($old_title, 'Old title not found.');
   }
 
   /**
-   * Rebuild text format and permission caches in the thread running the tests.
+   * Rebuilds text format and permission caches in the thread running the tests.
    */
   protected function resetFilterCaches() {
     filter_formats_reset();
@@ -658,6 +702,9 @@ class FilterFormatAccessTestCase extends DrupalWebTestCase {
   }
 }
 
+/**
+ * Tests the default filter functionality in the Filter module.
+ */
 class FilterDefaultFormatTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -667,6 +714,9 @@ class FilterDefaultFormatTestCase extends DrupalWebTestCase {
     );
   }
 
+  /**
+   * Tests if the default text format is accessible to users.
+   */
   function testDefaultTextFormats() {
     // Create two text formats, and two users. The first user has access to
     // both formats, but the second user only has access to the second one.
@@ -697,8 +747,8 @@ class FilterDefaultFormatTestCase extends DrupalWebTestCase {
 
     // Check that each user's default format is the lowest weighted format that
     // the user has access to.
-    $this->assertEqual(filter_default_format($first_user), $first_format->format, t("The first user's default format is the lowest weighted format that the user has access to."));
-    $this->assertEqual(filter_default_format($second_user), $second_format->format, t("The second user's default format is the lowest weighted format that the user has access to, and is different than the first user's."));
+    $this->assertEqual(filter_default_format($first_user), $first_format->format, "The first user's default format is the lowest weighted format that the user has access to.");
+    $this->assertEqual(filter_default_format($second_user), $second_format->format, "The second user's default format is the lowest weighted format that the user has access to, and is different than the first user's.");
 
     // Reorder the two formats, and check that both users now have the same
     // default.
@@ -706,11 +756,11 @@ class FilterDefaultFormatTestCase extends DrupalWebTestCase {
     $edit['formats[' . $second_format->format . '][weight]'] = $minimum_weight - 3;
     $this->drupalPost('admin/config/content/formats', $edit, t('Save changes'));
     $this->resetFilterCaches();
-    $this->assertEqual(filter_default_format($first_user), filter_default_format($second_user), t('After the formats are reordered, both users have the same default format.'));
+    $this->assertEqual(filter_default_format($first_user), filter_default_format($second_user), 'After the formats are reordered, both users have the same default format.');
   }
 
   /**
-   * Rebuild text format and permission caches in the thread running the tests.
+   * Rebuilds text format and permission caches in the thread running the tests.
    */
   protected function resetFilterCaches() {
     filter_formats_reset();
@@ -718,6 +768,9 @@ class FilterDefaultFormatTestCase extends DrupalWebTestCase {
   }
 }
 
+/**
+ * Tests the behavior of check_markup() when it is called without text format.
+ */
 class FilterNoFormatTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -727,6 +780,12 @@ class FilterNoFormatTestCase extends DrupalWebTestCase {
     );
   }
 
+  /**
+   * Tests text without format.
+   *
+   * Tests if text with no format is filtered the same way as text in the
+   * fallback format.
+   */
   function testCheckMarkupNoFormat() {
     // Create some text. Include some HTML and line breaks, so we get a good
     // test of the filtering that is applied to it.
@@ -734,7 +793,7 @@ class FilterNoFormatTestCase extends DrupalWebTestCase {
 
     // Make sure that when this text is run through check_markup() with no text
     // format, it is filtered as though it is in the fallback format.
-    $this->assertEqual(check_markup($text), check_markup($text, filter_fallback_format()), t('Text with no format is filtered the same as text in the fallback format.'));
+    $this->assertEqual(check_markup($text), check_markup($text, filter_fallback_format()), 'Text with no format is filtered the same as text in the fallback format.');
   }
 }
 
@@ -757,7 +816,10 @@ class FilterSecurityTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test that filtered content is emptied when an actively used filter module is disabled.
+   * Tests removal of filtered content when an active filter is disabled.
+   *
+   * Tests that filtered content is emptied when an actively used filter module
+   * is disabled.
    */
   function testDisableFilterModule() {
     // Create a new node.
@@ -765,7 +827,7 @@ class FilterSecurityTestCase extends DrupalWebTestCase {
     $body_raw = $node->body[LANGUAGE_NONE][0]['value'];
     $format_id = $node->body[LANGUAGE_NONE][0]['format'];
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText($body_raw, t('Node body found.'));
+    $this->assertText($body_raw, 'Node body found.');
 
     // Enable the filter_test_replace filter.
     $edit = array(
@@ -775,15 +837,15 @@ class FilterSecurityTestCase extends DrupalWebTestCase {
 
     // Verify that filter_test_replace filter replaced the content.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertNoText($body_raw, t('Node body not found.'));
-    $this->assertText('Filter: Testing filter', t('Testing filter output found.'));
+    $this->assertNoText($body_raw, 'Node body not found.');
+    $this->assertText('Filter: Testing filter', 'Testing filter output found.');
 
     // Disable the text format entirely.
     $this->drupalPost('admin/config/content/formats/' . $format_id . '/disable', array(), t('Disable'));
 
     // Verify that the content is empty, because the text format does not exist.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertNoText($body_raw, t('Node body not found.'));
+    $this->assertNoText($body_raw, 'Node body not found.');
   }
 }
 
@@ -800,7 +862,7 @@ class FilterUnitTestCase extends DrupalUnitTestCase {
   }
 
   /**
-   * Test the line break filter.
+   * Tests the line break filter.
    */
   function testLineBreakFilter() {
     // Setup dummy filter object.
@@ -870,7 +932,7 @@ class FilterUnitTestCase extends DrupalUnitTestCase {
     $limit = max(ini_get('pcre.backtrack_limit'), ini_get('pcre.recursion_limit'));
     $source = $this->randomName($limit);
     $result = _filter_autop($source);
-    $success = $this->assertEqual($result, '<p>' . $source . "</p>\n", t('Line break filter can process very long strings.'));
+    $success = $this->assertEqual($result, '<p>' . $source . "</p>\n", 'Line break filter can process very long strings.');
     if (!$success) {
       $this->verbose("\n" . $source . "\n<hr />\n" . $result);
     }
@@ -891,176 +953,176 @@ class FilterUnitTestCase extends DrupalUnitTestCase {
   function testFilterXSS() {
     // Tag stripping, different ways to work around removal of HTML tags.
     $f = filter_xss('<script>alert(0)</script>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping -- simple script without special characters.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping -- simple script without special characters.');
 
     $f = filter_xss('<script src="http://www.example.com" />');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping -- empty script with source.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping -- empty script with source.');
 
     $f = filter_xss('<ScRipt sRc=http://www.example.com/>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- varying case.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- varying case.');
 
     $f = filter_xss("<script\nsrc\n=\nhttp://www.example.com/\n>");
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- multiline tag.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- multiline tag.');
 
     $f = filter_xss('<script/a src=http://www.example.com/a.js></script>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- non whitespace character after tag name.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- non whitespace character after tag name.');
 
     $f = filter_xss('<script/src=http://www.example.com/a.js></script>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- no space between tag and attribute.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- no space between tag and attribute.');
 
     // Null between < and tag name works at least with IE6.
     $f = filter_xss("<\0scr\0ipt>alert(0)</script>");
-    $this->assertNoNormalized($f, 'ipt', t('HTML tag stripping evasion -- breaking HTML with nulls.'));
+    $this->assertNoNormalized($f, 'ipt', 'HTML tag stripping evasion -- breaking HTML with nulls.');
 
     $f = filter_xss("<scrscriptipt src=http://www.example.com/a.js>");
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- filter just removing "script".'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- filter just removing "script".');
 
     $f = filter_xss('<<script>alert(0);//<</script>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- double opening brackets.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- double opening brackets.');
 
     $f = filter_xss('<script src=http://www.example.com/a.js?<b>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- no closing tag.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- no closing tag.');
 
     // DRUPAL-SA-2008-047: This doesn't seem exploitable, but the filter should
     // work consistently.
     $f = filter_xss('<script>>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- double closing tag.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- double closing tag.');
 
     $f = filter_xss('<script src=//www.example.com/.a>');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- no scheme or ending slash.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- no scheme or ending slash.');
 
     $f = filter_xss('<script src=http://www.example.com/.a');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- no closing bracket.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- no closing bracket.');
 
     $f = filter_xss('<script src=http://www.example.com/ <');
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- opening instead of closing bracket.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- opening instead of closing bracket.');
 
     $f = filter_xss('<nosuchtag attribute="newScriptInjectionVector">');
-    $this->assertNoNormalized($f, 'nosuchtag', t('HTML tag stripping evasion -- unknown tag.'));
+    $this->assertNoNormalized($f, 'nosuchtag', 'HTML tag stripping evasion -- unknown tag.');
 
     $f = filter_xss('<?xml:namespace ns="urn:schemas-microsoft-com:time">');
-    $this->assertTrue(stripos($f, '<?xml') === FALSE, t('HTML tag stripping evasion -- starting with a question sign (processing instructions).'));
+    $this->assertTrue(stripos($f, '<?xml') === FALSE, 'HTML tag stripping evasion -- starting with a question sign (processing instructions).');
 
     $f = filter_xss('<t:set attributeName="innerHTML" to="&lt;script defer&gt;alert(0)&lt;/script&gt;">');
-    $this->assertNoNormalized($f, 't:set', t('HTML tag stripping evasion -- colon in the tag name (namespaces\' tricks).'));
+    $this->assertNoNormalized($f, 't:set', 'HTML tag stripping evasion -- colon in the tag name (namespaces\' tricks).');
 
     $f = filter_xss('<img """><script>alert(0)</script>', array('img'));
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- a malformed image tag.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- a malformed image tag.');
 
     $f = filter_xss('<blockquote><script>alert(0)</script></blockquote>', array('blockquote'));
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- script in a blockqoute.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- script in a blockqoute.');
 
     $f = filter_xss("<!--[if true]><script>alert(0)</script><![endif]-->");
-    $this->assertNoNormalized($f, 'script', t('HTML tag stripping evasion -- script within a comment.'));
+    $this->assertNoNormalized($f, 'script', 'HTML tag stripping evasion -- script within a comment.');
 
     // Dangerous attributes removal.
     $f = filter_xss('<p onmouseover="http://www.example.com/">', array('p'));
-    $this->assertNoNormalized($f, 'onmouseover', t('HTML filter attributes removal -- events, no evasion.'));
+    $this->assertNoNormalized($f, 'onmouseover', 'HTML filter attributes removal -- events, no evasion.');
 
     $f = filter_xss('<li style="list-style-image: url(javascript:alert(0))">', array('li'));
-    $this->assertNoNormalized($f, 'style', t('HTML filter attributes removal -- style, no evasion.'));
+    $this->assertNoNormalized($f, 'style', 'HTML filter attributes removal -- style, no evasion.');
 
     $f = filter_xss('<img onerror   =alert(0)>', array('img'));
-    $this->assertNoNormalized($f, 'onerror', t('HTML filter attributes removal evasion -- spaces before equals sign.'));
+    $this->assertNoNormalized($f, 'onerror', 'HTML filter attributes removal evasion -- spaces before equals sign.');
 
     $f = filter_xss('<img onabort!#$%&()*~+-_.,:;?@[/|\]^`=alert(0)>', array('img'));
-    $this->assertNoNormalized($f, 'onabort', t('HTML filter attributes removal evasion -- non alphanumeric characters before equals sign.'));
+    $this->assertNoNormalized($f, 'onabort', 'HTML filter attributes removal evasion -- non alphanumeric characters before equals sign.');
 
     $f = filter_xss('<img oNmediAError=alert(0)>', array('img'));
-    $this->assertNoNormalized($f, 'onmediaerror', t('HTML filter attributes removal evasion -- varying case.'));
+    $this->assertNoNormalized($f, 'onmediaerror', 'HTML filter attributes removal evasion -- varying case.');
 
     // Works at least with IE6.
     $f = filter_xss("<img o\0nfocus\0=alert(0)>", array('img'));
-    $this->assertNoNormalized($f, 'focus', t('HTML filter attributes removal evasion -- breaking with nulls.'));
+    $this->assertNoNormalized($f, 'focus', 'HTML filter attributes removal evasion -- breaking with nulls.');
 
     // Only whitelisted scheme names allowed in attributes.
     $f = filter_xss('<img src="javascript:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing -- no evasion.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing -- no evasion.');
 
     $f = filter_xss('<img src=javascript:alert(0)>', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- no quotes.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- no quotes.');
 
     // A bit like CVE-2006-0070.
     $f = filter_xss('<img src="javascript:confirm(0)">', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- no alert ;)'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- no alert ;)');
 
     $f = filter_xss('<img src=`javascript:alert(0)`>', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- grave accents.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- grave accents.');
 
     $f = filter_xss('<img dynsrc="javascript:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing -- rare attribute.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing -- rare attribute.');
 
     $f = filter_xss('<table background="javascript:alert(0)">', array('table'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing -- another tag.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing -- another tag.');
 
     $f = filter_xss('<base href="javascript:alert(0);//">', array('base'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing -- one more attribute and tag.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing -- one more attribute and tag.');
 
     $f = filter_xss('<img src="jaVaSCriPt:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- varying case.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- varying case.');
 
     $f = filter_xss('<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#48;&#41;>', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- UTF-8 decimal encoding.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- UTF-8 decimal encoding.');
 
     $f = filter_xss('<img src=&#00000106&#0000097&#00000118&#0000097&#00000115&#0000099&#00000114&#00000105&#00000112&#00000116&#0000058&#0000097&#00000108&#00000101&#00000114&#00000116&#0000040&#0000048&#0000041>', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- long UTF-8 encoding.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- long UTF-8 encoding.');
 
     $f = filter_xss('<img src=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x30&#x29>', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- UTF-8 hex encoding.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- UTF-8 hex encoding.');
 
     $f = filter_xss("<img src=\"jav\tascript:alert(0)\">", array('img'));
-    $this->assertNoNormalized($f, 'script', t('HTML scheme clearing evasion -- an embedded tab.'));
+    $this->assertNoNormalized($f, 'script', 'HTML scheme clearing evasion -- an embedded tab.');
 
     $f = filter_xss('<img src="jav&#x09;ascript:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'script', t('HTML scheme clearing evasion -- an encoded, embedded tab.'));
+    $this->assertNoNormalized($f, 'script', 'HTML scheme clearing evasion -- an encoded, embedded tab.');
 
     $f = filter_xss('<img src="jav&#x000000A;ascript:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'script', t('HTML scheme clearing evasion -- an encoded, embedded newline.'));
+    $this->assertNoNormalized($f, 'script', 'HTML scheme clearing evasion -- an encoded, embedded newline.');
 
     // With &#xD; this test would fail, but the entity gets turned into
     // &amp;#xD;, so it's OK.
     $f = filter_xss('<img src="jav&#x0D;ascript:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'script', t('HTML scheme clearing evasion -- an encoded, embedded carriage return.'));
+    $this->assertNoNormalized($f, 'script', 'HTML scheme clearing evasion -- an encoded, embedded carriage return.');
 
     $f = filter_xss("<img src=\"\n\n\nj\na\nva\ns\ncript:alert(0)\">", array('img'));
-    $this->assertNoNormalized($f, 'cript', t('HTML scheme clearing evasion -- broken into many lines.'));
+    $this->assertNoNormalized($f, 'cript', 'HTML scheme clearing evasion -- broken into many lines.');
 
     $f = filter_xss("<img src=\"jav\0a\0\0cript:alert(0)\">", array('img'));
-    $this->assertNoNormalized($f, 'cript', t('HTML scheme clearing evasion -- embedded nulls.'));
+    $this->assertNoNormalized($f, 'cript', 'HTML scheme clearing evasion -- embedded nulls.');
 
     $f = filter_xss('<img src=" &#14;  javascript:alert(0)">', array('img'));
-    $this->assertNoNormalized($f, 'javascript', t('HTML scheme clearing evasion -- spaces and metacharacters before scheme.'));
+    $this->assertNoNormalized($f, 'javascript', 'HTML scheme clearing evasion -- spaces and metacharacters before scheme.');
 
     $f = filter_xss('<img src="vbscript:msgbox(0)">', array('img'));
-    $this->assertNoNormalized($f, 'vbscript', t('HTML scheme clearing evasion -- another scheme.'));
+    $this->assertNoNormalized($f, 'vbscript', 'HTML scheme clearing evasion -- another scheme.');
 
     $f = filter_xss('<img src="nosuchscheme:notice(0)">', array('img'));
-    $this->assertNoNormalized($f, 'nosuchscheme', t('HTML scheme clearing evasion -- unknown scheme.'));
+    $this->assertNoNormalized($f, 'nosuchscheme', 'HTML scheme clearing evasion -- unknown scheme.');
 
     // Netscape 4.x javascript entities.
     $f = filter_xss('<br size="&{alert(0)}">', array('br'));
-    $this->assertNoNormalized($f, 'alert', t('Netscape 4.x javascript entities.'));
+    $this->assertNoNormalized($f, 'alert', 'Netscape 4.x javascript entities.');
 
     // DRUPAL-SA-2008-006: Invalid UTF-8, these only work as reflected XSS with
     // Internet Explorer 6.
     $f = filter_xss("<p arg=\"\xe0\">\" style=\"background-image: url(javascript:alert(0));\"\xe0<p>", array('p'));
-    $this->assertNoNormalized($f, 'style', t('HTML filter -- invalid UTF-8.'));
+    $this->assertNoNormalized($f, 'style', 'HTML filter -- invalid UTF-8.');
 
     $f = filter_xss("\xc0aaa");
-    $this->assertEqual($f, '', t('HTML filter -- overlong UTF-8 sequences.'));
+    $this->assertEqual($f, '', 'HTML filter -- overlong UTF-8 sequences.');
 
     $f = filter_xss("Who&#039;s Online");
-    $this->assertNormalized($f, "who's online", t('HTML filter -- html entity number'));
+    $this->assertNormalized($f, "who's online", 'HTML filter -- html entity number');
 
     $f = filter_xss("Who&amp;#039;s Online");
-    $this->assertNormalized($f, "who&#039;s online", t('HTML filter -- encoded html entity number'));
+    $this->assertNormalized($f, "who&#039;s online", 'HTML filter -- encoded html entity number');
 
     $f = filter_xss("Who&amp;amp;#039; Online");
-    $this->assertNormalized($f, "who&amp;#039; online", t('HTML filter -- double encoded html entity number'));
+    $this->assertNormalized($f, "who&amp;#039; online", 'HTML filter -- double encoded html entity number');
   }
 
   /**
-   * Test filter settings, defaults, access restrictions and similar.
+   * Tests filter settings, defaults, access restrictions and similar.
    *
    * @todo This is for functions like filter_filter and check_markup, whose
    *   functionality is not completely focused on filtering. Some ideas:
@@ -1085,38 +1147,38 @@ class FilterUnitTestCase extends DrupalUnitTestCase {
     // HTML filter is not able to secure some tags, these should never be
     // allowed.
     $f = _filter_html('<script />', $filter);
-    $this->assertNoNormalized($f, 'script', t('HTML filter should always remove script tags.'));
+    $this->assertNoNormalized($f, 'script', 'HTML filter should always remove script tags.');
 
     $f = _filter_html('<iframe />', $filter);
-    $this->assertNoNormalized($f, 'iframe', t('HTML filter should always remove iframe tags.'));
+    $this->assertNoNormalized($f, 'iframe', 'HTML filter should always remove iframe tags.');
 
     $f = _filter_html('<object />', $filter);
-    $this->assertNoNormalized($f, 'object', t('HTML filter should always remove object tags.'));
+    $this->assertNoNormalized($f, 'object', 'HTML filter should always remove object tags.');
 
     $f = _filter_html('<style />', $filter);
-    $this->assertNoNormalized($f, 'style', t('HTML filter should always remove style tags.'));
+    $this->assertNoNormalized($f, 'style', 'HTML filter should always remove style tags.');
 
     // Some tags make CSRF attacks easier, let the user take the risk herself.
     $f = _filter_html('<img />', $filter);
-    $this->assertNoNormalized($f, 'img', t('HTML filter should remove img tags on default.'));
+    $this->assertNoNormalized($f, 'img', 'HTML filter should remove img tags on default.');
 
     $f = _filter_html('<input />', $filter);
-    $this->assertNoNormalized($f, 'img', t('HTML filter should remove input tags on default.'));
+    $this->assertNoNormalized($f, 'img', 'HTML filter should remove input tags on default.');
 
     // Filtering content of some attributes is infeasible, these shouldn't be
     // allowed too.
     $f = _filter_html('<p style="display: none;" />', $filter);
-    $this->assertNoNormalized($f, 'style', t('HTML filter should remove style attribute on default.'));
+    $this->assertNoNormalized($f, 'style', 'HTML filter should remove style attribute on default.');
 
     $f = _filter_html('<p onerror="alert(0);" />', $filter);
-    $this->assertNoNormalized($f, 'onerror', t('HTML filter should remove on* attributes on default.'));
+    $this->assertNoNormalized($f, 'onerror', 'HTML filter should remove on* attributes on default.');
 
     $f = _filter_html('<code onerror>&nbsp;</code>', $filter);
-    $this->assertNoNormalized($f, 'onerror', t('HTML filter should remove empty on* attributes on default.'));
+    $this->assertNoNormalized($f, 'onerror', 'HTML filter should remove empty on* attributes on default.');
   }
 
   /**
-   * Test the spam deterrent.
+   * Tests the spam deterrent.
    */
   function testNoFollowFilter() {
     // Setup dummy filter object.
@@ -1130,35 +1192,35 @@ class FilterUnitTestCase extends DrupalUnitTestCase {
     // Test if the rel="nofollow" attribute is added, even if we try to prevent
     // it.
     $f = _filter_html('<a href="http://www.example.com/">text</a>', $filter);
-    $this->assertNormalized($f, 'rel="nofollow"', t('Spam deterrent -- no evasion.'));
+    $this->assertNormalized($f, 'rel="nofollow"', 'Spam deterrent -- no evasion.');
 
     $f = _filter_html('<A href="http://www.example.com/">text</a>', $filter);
-    $this->assertNormalized($f, 'rel="nofollow"', t('Spam deterrent evasion -- capital A.'));
+    $this->assertNormalized($f, 'rel="nofollow"', 'Spam deterrent evasion -- capital A.');
 
     $f = _filter_html("<a/href=\"http://www.example.com/\">text</a>", $filter);
-    $this->assertNormalized($f, 'rel="nofollow"', t('Spam deterrent evasion -- non whitespace character after tag name.'));
+    $this->assertNormalized($f, 'rel="nofollow"', 'Spam deterrent evasion -- non whitespace character after tag name.');
 
     $f = _filter_html("<\0a\0 href=\"http://www.example.com/\">text</a>", $filter);
-    $this->assertNormalized($f, 'rel="nofollow"', t('Spam deterrent evasion -- some nulls.'));
+    $this->assertNormalized($f, 'rel="nofollow"', 'Spam deterrent evasion -- some nulls.');
 
     $f = _filter_html('<a href="http://www.example.com/" rel="follow">text</a>', $filter);
-    $this->assertNoNormalized($f, 'rel="follow"', t('Spam deterrent evasion -- with rel set - rel="follow" removed.'));
-    $this->assertNormalized($f, 'rel="nofollow"', t('Spam deterrent evasion -- with rel set - rel="nofollow" added.'));
+    $this->assertNoNormalized($f, 'rel="follow"', 'Spam deterrent evasion -- with rel set - rel="follow" removed.');
+    $this->assertNormalized($f, 'rel="nofollow"', 'Spam deterrent evasion -- with rel set - rel="nofollow" added.');
   }
 
   /**
-   * Test the loose, admin HTML filter.
+   * Tests the loose, admin HTML filter.
    */
   function testFilterXSSAdmin() {
     // DRUPAL-SA-2008-044
     $f = filter_xss_admin('<object />');
-    $this->assertNoNormalized($f, 'object', t('Admin HTML filter -- should not allow object tag.'));
+    $this->assertNoNormalized($f, 'object', 'Admin HTML filter -- should not allow object tag.');
 
     $f = filter_xss_admin('<script />');
-    $this->assertNoNormalized($f, 'script', t('Admin HTML filter -- should not allow script tag.'));
+    $this->assertNoNormalized($f, 'script', 'Admin HTML filter -- should not allow script tag.');
 
     $f = filter_xss_admin('<style /><iframe /><frame /><frameset /><meta /><link /><embed /><applet /><param /><layer />');
-    $this->assertEqual($f, '', t('Admin HTML filter -- should never allow some tags.'));
+    $this->assertEqual($f, '', 'Admin HTML filter -- should never allow some tags.');
   }
 
   /**
@@ -1487,13 +1549,13 @@ www.example.com with a newline in comments -->
       foreach ($tasks as $value => $is_expected) {
         // Not using assertIdentical, since combination with strpos() is hard to grok.
         if ($is_expected) {
-          $success = $this->assertTrue(strpos($result, $value) !== FALSE, t('@source: @value found.', array(
+          $success = $this->assertTrue(strpos($result, $value) !== FALSE, format_string('@source: @value found.', array(
             '@source' => var_export($source, TRUE),
             '@value' => var_export($value, TRUE),
           )));
         }
         else {
-          $success = $this->assertTrue(strpos($result, $value) === FALSE, t('@source: @value not found.', array(
+          $success = $this->assertTrue(strpos($result, $value) === FALSE, format_string('@source: @value not found.', array(
             '@source' => var_export($source, TRUE),
             '@value' => var_export($value, TRUE),
           )));
@@ -1541,121 +1603,121 @@ www.example.com with a newline in comments -->
   }
 
   /**
-   * Test the HTML corrector filter.
+   * Tests the HTML corrector filter.
    *
    * @todo This test could really use some validity checking function.
    */
   function testHtmlCorrectorFilter() {
     // Tag closing.
     $f = _filter_htmlcorrector('<p>text');
-    $this->assertEqual($f, '<p>text</p>', t('HTML corrector -- tag closing at the end of input.'));
+    $this->assertEqual($f, '<p>text</p>', 'HTML corrector -- tag closing at the end of input.');
 
     $f = _filter_htmlcorrector('<p>text<p><p>text');
-    $this->assertEqual($f, '<p>text</p><p></p><p>text</p>', t('HTML corrector -- tag closing.'));
+    $this->assertEqual($f, '<p>text</p><p></p><p>text</p>', 'HTML corrector -- tag closing.');
 
     $f = _filter_htmlcorrector("<ul><li>e1<li>e2");
-    $this->assertEqual($f, "<ul><li>e1</li><li>e2</li></ul>", t('HTML corrector -- unclosed list tags.'));
+    $this->assertEqual($f, "<ul><li>e1</li><li>e2</li></ul>", 'HTML corrector -- unclosed list tags.');
 
     $f = _filter_htmlcorrector('<div id="d">content');
-    $this->assertEqual($f, '<div id="d">content</div>', t('HTML corrector -- unclosed tag with attribute.'));
+    $this->assertEqual($f, '<div id="d">content</div>', 'HTML corrector -- unclosed tag with attribute.');
 
     // XHTML slash for empty elements.
     $f = _filter_htmlcorrector('<hr><br>');
-    $this->assertEqual($f, '<hr /><br />', t('HTML corrector -- XHTML closing slash.'));
+    $this->assertEqual($f, '<hr /><br />', 'HTML corrector -- XHTML closing slash.');
 
     $f = _filter_htmlcorrector('<P>test</P>');
-    $this->assertEqual($f, '<p>test</p>', t('HTML corrector -- Convert uppercased tags to proper lowercased ones.'));
+    $this->assertEqual($f, '<p>test</p>', 'HTML corrector -- Convert uppercased tags to proper lowercased ones.');
 
     $f = _filter_htmlcorrector('<P>test</p>');
-    $this->assertEqual($f, '<p>test</p>', t('HTML corrector -- Convert uppercased tags to proper lowercased ones.'));
+    $this->assertEqual($f, '<p>test</p>', 'HTML corrector -- Convert uppercased tags to proper lowercased ones.');
 
     $f = _filter_htmlcorrector('test<hr />');
-    $this->assertEqual($f, 'test<hr />', t('HTML corrector -- Let proper XHTML pass through.'));
+    $this->assertEqual($f, 'test<hr />', 'HTML corrector -- Let proper XHTML pass through.');
 
     $f = _filter_htmlcorrector('test<hr/>');
-    $this->assertEqual($f, 'test<hr />', t('HTML corrector -- Let proper XHTML pass through, but ensure there is a single space before the closing slash.'));
+    $this->assertEqual($f, 'test<hr />', 'HTML corrector -- Let proper XHTML pass through, but ensure there is a single space before the closing slash.');
 
     $f = _filter_htmlcorrector('test<hr    />');
-    $this->assertEqual($f, 'test<hr />', t('HTML corrector -- Let proper XHTML pass through, but ensure there are not too many spaces before the closing slash.'));
+    $this->assertEqual($f, 'test<hr />', 'HTML corrector -- Let proper XHTML pass through, but ensure there are not too many spaces before the closing slash.');
 
     $f = _filter_htmlcorrector('<span class="test" />');
-    $this->assertEqual($f, '<span class="test"></span>', t('HTML corrector -- Convert XHTML that is properly formed but that would not be compatible with typical HTML user agents.'));
+    $this->assertEqual($f, '<span class="test"></span>', 'HTML corrector -- Convert XHTML that is properly formed but that would not be compatible with typical HTML user agents.');
 
     $f = _filter_htmlcorrector('test1<br class="test">test2');
-    $this->assertEqual($f, 'test1<br class="test" />test2', t('HTML corrector -- Automatically close single tags.'));
+    $this->assertEqual($f, 'test1<br class="test" />test2', 'HTML corrector -- Automatically close single tags.');
 
     $f = _filter_htmlcorrector('line1<hr>line2');
-    $this->assertEqual($f, 'line1<hr />line2', t('HTML corrector -- Automatically close single tags.'));
+    $this->assertEqual($f, 'line1<hr />line2', 'HTML corrector -- Automatically close single tags.');
 
     $f = _filter_htmlcorrector('line1<HR>line2');
-    $this->assertEqual($f, 'line1<hr />line2', t('HTML corrector -- Automatically close single tags.'));
+    $this->assertEqual($f, 'line1<hr />line2', 'HTML corrector -- Automatically close single tags.');
 
     $f = _filter_htmlcorrector('<img src="http://example.com/test.jpg">test</img>');
-    $this->assertEqual($f, '<img src="http://example.com/test.jpg" />test', t('HTML corrector -- Automatically close single tags.'));
+    $this->assertEqual($f, '<img src="http://example.com/test.jpg" />test', 'HTML corrector -- Automatically close single tags.');
 
     $f = _filter_htmlcorrector('<br></br>');
-    $this->assertEqual($f, '<br />', t("HTML corrector -- Transform empty tags to a single closed tag if the tag's content model is EMPTY."));
+    $this->assertEqual($f, '<br />', "HTML corrector -- Transform empty tags to a single closed tag if the tag's content model is EMPTY.");
 
     $f = _filter_htmlcorrector('<div></div>');
-    $this->assertEqual($f, '<div></div>', t("HTML corrector -- Do not transform empty tags to a single closed tag if the tag's content model is not EMPTY."));
+    $this->assertEqual($f, '<div></div>', "HTML corrector -- Do not transform empty tags to a single closed tag if the tag's content model is not EMPTY.");
 
     $f = _filter_htmlcorrector('<p>line1<br/><hr/>line2</p>');
-    $this->assertEqual($f, '<p>line1<br /></p><hr />line2', t('HTML corrector -- Move non-inline elements outside of inline containers.'));
+    $this->assertEqual($f, '<p>line1<br /></p><hr />line2', 'HTML corrector -- Move non-inline elements outside of inline containers.');
 
     $f = _filter_htmlcorrector('<p>line1<div>line2</div></p>');
-    $this->assertEqual($f, '<p>line1</p><div>line2</div>', t('HTML corrector -- Move non-inline elements outside of inline containers.'));
+    $this->assertEqual($f, '<p>line1</p><div>line2</div>', 'HTML corrector -- Move non-inline elements outside of inline containers.');
 
     $f = _filter_htmlcorrector('<p>test<p>test</p>\n');
-    $this->assertEqual($f, '<p>test</p><p>test</p>\n', t('HTML corrector -- Auto-close improperly nested tags.'));
+    $this->assertEqual($f, '<p>test</p><p>test</p>\n', 'HTML corrector -- Auto-close improperly nested tags.');
 
     $f = _filter_htmlcorrector('<p>Line1<br><STRONG>bold stuff</b>');
-    $this->assertEqual($f, '<p>Line1<br /><strong>bold stuff</strong></p>', t('HTML corrector -- Properly close unclosed tags, and remove useless closing tags.'));
+    $this->assertEqual($f, '<p>Line1<br /><strong>bold stuff</strong></p>', 'HTML corrector -- Properly close unclosed tags, and remove useless closing tags.');
 
     $f = _filter_htmlcorrector('test <!-- this is a comment -->');
-    $this->assertEqual($f, 'test <!-- this is a comment -->', t('HTML corrector -- Do not touch HTML comments.'));
+    $this->assertEqual($f, 'test <!-- this is a comment -->', 'HTML corrector -- Do not touch HTML comments.');
 
     $f = _filter_htmlcorrector('test <!--this is a comment-->');
-    $this->assertEqual($f, 'test <!--this is a comment-->', t('HTML corrector -- Do not touch HTML comments.'));
+    $this->assertEqual($f, 'test <!--this is a comment-->', 'HTML corrector -- Do not touch HTML comments.');
 
     $f = _filter_htmlcorrector('test <!-- comment <p>another
     <strong>multiple</strong> line
     comment</p> -->');
     $this->assertEqual($f, 'test <!-- comment <p>another
     <strong>multiple</strong> line
-    comment</p> -->', t('HTML corrector -- Do not touch HTML comments.'));
+    comment</p> -->', 'HTML corrector -- Do not touch HTML comments.');
 
     $f = _filter_htmlcorrector('test <!-- comment <p>another comment</p> -->');
-    $this->assertEqual($f, 'test <!-- comment <p>another comment</p> -->', t('HTML corrector -- Do not touch HTML comments.'));
+    $this->assertEqual($f, 'test <!-- comment <p>another comment</p> -->', 'HTML corrector -- Do not touch HTML comments.');
 
     $f = _filter_htmlcorrector('test <!--break-->');
-    $this->assertEqual($f, 'test <!--break-->', t('HTML corrector -- Do not touch HTML comments.'));
+    $this->assertEqual($f, 'test <!--break-->', 'HTML corrector -- Do not touch HTML comments.');
 
     $f = _filter_htmlcorrector('<p>test\n</p>\n');
-    $this->assertEqual($f, '<p>test\n</p>\n', t('HTML corrector -- New-lines are accepted and kept as-is.'));
+    $this->assertEqual($f, '<p>test\n</p>\n', 'HTML corrector -- New-lines are accepted and kept as-is.');
 
     $f = _filter_htmlcorrector('<p>دروبال');
-    $this->assertEqual($f, '<p>دروبال</p>', t('HTML corrector -- Encoding is correctly kept.'));
+    $this->assertEqual($f, '<p>دروبال</p>', 'HTML corrector -- Encoding is correctly kept.');
 
     $f = _filter_htmlcorrector('<script type="text/javascript">alert("test")</script>');
     $this->assertEqual($f, '<script type="text/javascript">
 <!--//--><![CDATA[// ><!--
 alert("test")
 //--><!]]>
-</script>', t('HTML corrector -- CDATA added to script element'));
+</script>', 'HTML corrector -- CDATA added to script element');
 
     $f = _filter_htmlcorrector('<p><script type="text/javascript">alert("test")</script></p>');
     $this->assertEqual($f, '<p><script type="text/javascript">
 <!--//--><![CDATA[// ><!--
 alert("test")
 //--><!]]>
-</script></p>', t('HTML corrector -- CDATA added to a nested script element'));
+</script></p>', 'HTML corrector -- CDATA added to a nested script element');
 
     $f = _filter_htmlcorrector('<p><style> /* Styling */ body {color:red}</style></p>');
     $this->assertEqual($f, '<p><style>
 <!--/*--><![CDATA[/* ><!--*/
  /* Styling */ body {color:red}
 /*--><!]]>*/
-</style></p>', t('HTML corrector -- CDATA added to a style element.'));
+</style></p>', 'HTML corrector -- CDATA added to a style element.');
 
     $filtered_data = _filter_htmlcorrector('<p><style>
 /*<![CDATA[*/
@@ -1673,7 +1735,7 @@ body {color:red}
 
 /*--><!]]>*/
 </style></p>',
-      t('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '/*<![CDATA[*/'))
+      format_string('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '/*<![CDATA[*/'))
     );
 
     $filtered_data = _filter_htmlcorrector('<p><style>
@@ -1692,7 +1754,7 @@ body {color:red}
 
 /*--><!]]>*/
 </style></p>',
-      t('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '<!--/*--><![CDATA[/* ><!--*/'))
+      format_string('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '<!--/*--><![CDATA[/* ><!--*/'))
     );
 
     $filtered_data = _filter_htmlcorrector('<p><script type="text/javascript">
@@ -1709,7 +1771,7 @@ body {color:red}
 
 //--><!]]>
 </script></p>',
-      t('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '<!--//--><![CDATA[// ><!--'))
+      format_string('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '<!--//--><![CDATA[// ><!--'))
     );
 
     $filtered_data = _filter_htmlcorrector('<p><script type="text/javascript">
@@ -1726,7 +1788,7 @@ body {color:red}
 
 //--><!]]>
 </script></p>',
-      t('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '// <![CDATA['))
+      format_string('HTML corrector -- Existing cdata section @pattern_name properly escaped', array('@pattern_name' => '// <![CDATA['))
     );
 
   }
@@ -1745,9 +1807,9 @@ body {color:red}
    * @param $needle
    *   Lowercase, plain text to look for.
    * @param $message
-   *   Message to display if failed.
+   *   (optional) Message to display if failed. Defaults to an empty string.
    * @param $group
-   *   The group this message belongs to, defaults to 'Other'.
+   *   (optional) The group this message belongs to. Defaults to 'Other'.
    * @return
    *   TRUE on pass, FALSE on fail.
    */
@@ -1769,9 +1831,9 @@ body {color:red}
    * @param $needle
    *   Lowercase, plain text to look for.
    * @param $message
-   *   Message to display if failed.
+   *   (optional) Message to display if failed. Defaults to an empty string.
    * @param $group
-   *   The group this message belongs to, defaults to 'Other'.
+   *   (optional) The group this message belongs to. Defaults to 'Other'.
    * @return
    *   TRUE on pass, FALSE on fail.
    */
@@ -1781,7 +1843,7 @@ body {color:red}
 }
 
 /**
- * Tests for filter hook invocation.
+ * Tests for Filter's hook invocations.
  */
 class FilterHooksTestCase extends DrupalWebTestCase {
   public static function getInfo() {
@@ -1799,7 +1861,10 @@ class FilterHooksTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test that hooks run correctly on creating, editing, and deleting a text format.
+   * Tests hooks on format management.
+   *
+   * Tests that hooks run correctly on creating, editing, and deleting a text
+   * format.
    */
   function testFilterHooks() {
     // Add a text format.
@@ -1809,8 +1874,8 @@ class FilterHooksTestCase extends DrupalWebTestCase {
     $edit['name'] = $name;
     $edit['roles[' . DRUPAL_ANONYMOUS_RID . ']'] = 1;
     $this->drupalPost('admin/config/content/formats/add', $edit, t('Save configuration'));
-    $this->assertRaw(t('Added text format %format.', array('%format' => $name)), t('New format created.'));
-    $this->assertText('hook_filter_format_insert invoked.', t('hook_filter_format_insert was invoked.'));
+    $this->assertRaw(t('Added text format %format.', array('%format' => $name)), 'New format created.');
+    $this->assertText('hook_filter_format_insert invoked.', 'hook_filter_format_insert was invoked.');
 
     $format_id = $edit['format'];
 
@@ -1818,8 +1883,8 @@ class FilterHooksTestCase extends DrupalWebTestCase {
     $edit = array();
     $edit['roles[' . DRUPAL_AUTHENTICATED_RID . ']'] = 1;
     $this->drupalPost('admin/config/content/formats/' . $format_id, $edit, t('Save configuration'));
-    $this->assertRaw(t('The text format %format has been updated.', array('%format' => $name)), t('Format successfully updated.'));
-    $this->assertText('hook_filter_format_update invoked.', t('hook_filter_format_update() was invoked.'));
+    $this->assertRaw(t('The text format %format has been updated.', array('%format' => $name)), 'Format successfully updated.');
+    $this->assertText('hook_filter_format_update invoked.', 'hook_filter_format_update() was invoked.');
 
     // Add a new custom block.
     $custom_block = array();
@@ -1829,16 +1894,16 @@ class FilterHooksTestCase extends DrupalWebTestCase {
     // Use the format created.
     $custom_block['body[format]'] = $format_id;
     $this->drupalPost('admin/structure/block/add', $custom_block, t('Save block'));
-    $this->assertText(t('The block has been created.'), t('New block successfully created.'));
+    $this->assertText(t('The block has been created.'), 'New block successfully created.');
 
     // Verify the new block is in the database.
     $bid = db_query("SELECT bid FROM {block_custom} WHERE info = :info", array(':info' => $custom_block['info']))->fetchField();
-    $this->assertNotNull($bid, t('New block found in database'));
+    $this->assertNotNull($bid, 'New block found in database');
 
     // Disable the text format.
     $this->drupalPost('admin/config/content/formats/' . $format_id . '/disable', array(), t('Disable'));
-    $this->assertRaw(t('Disabled text format %format.', array('%format' => $name)), t('Format successfully disabled.'));
-    $this->assertText('hook_filter_format_disable invoked.', t('hook_filter_format_disable() was invoked.'));
+    $this->assertRaw(t('Disabled text format %format.', array('%format' => $name)), 'Format successfully disabled.');
+    $this->assertText('hook_filter_format_disable invoked.', 'hook_filter_format_disable() was invoked.');
   }
 }
 
@@ -1846,6 +1911,11 @@ class FilterHooksTestCase extends DrupalWebTestCase {
  * Tests filter settings.
  */
 class FilterSettingsTestCase extends DrupalWebTestCase {
+  /**
+   * The installation profile to use with this test class.
+   *
+   * @var string
+   */
   protected $profile = 'testing';
 
   public static function getInfo() {
diff --git a/modules/forum/forum-rtl.css b/modules/forum/forum-rtl.css
index b475e42..3f2a88b 100644
--- a/modules/forum/forum-rtl.css
+++ b/modules/forum/forum-rtl.css
@@ -7,6 +7,10 @@
   float: right;
   margin: 0 0 0 9px;
 }
+#forum div.indent {
+  margin-left: 0;
+  margin-right: 20px;
+}
 .forum-topic-navigation {
   padding: 1em 3em 0 0;
 }
diff --git a/modules/forum/forum.css b/modules/forum/forum.css
index a758bc6..480e07b 100644
--- a/modules/forum/forum.css
+++ b/modules/forum/forum.css
@@ -29,7 +29,7 @@
 }
 
 #forum div.indent {
-  margin-left: 20px;
+  margin-left: 20px; /* LTR */
 }
 #forum .icon div {
   background-image: url(../../misc/forum-icons.png);
diff --git a/modules/forum/forum.module b/modules/forum/forum.module
index fe0ef79..575de36 100644
--- a/modules/forum/forum.module
+++ b/modules/forum/forum.module
@@ -233,6 +233,8 @@ function forum_entity_info_alter(&$info) {
 }
 
 /**
+ * Implements callback_entity_info_uri().
+ *
  * Entity URI callback used in forum_entity_info_alter().
  */
 function forum_uri($forum) {
@@ -658,7 +660,12 @@ function forum_block_info() {
  * Implements hook_block_configure().
  */
 function forum_block_configure($delta = '') {
-  $form['forum_block_num_' . $delta] = array('#type' => 'select', '#title' => t('Number of topics'), '#default_value' => variable_get('forum_block_num_' . $delta, '5'), '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));
+  $form['forum_block_num_' . $delta] = array(
+    '#type' => 'select',
+    '#title' => t('Number of topics'),
+    '#default_value' => variable_get('forum_block_num_' . $delta, '5'),
+    '#options' => drupal_map_assoc(range(2, 20))
+  );
   return $form;
 }
 
diff --git a/modules/forum/forum.test b/modules/forum/forum.test
index 6937c62..bc68a3e 100644
--- a/modules/forum/forum.test
+++ b/modules/forum/forum.test
@@ -94,18 +94,18 @@ class ForumTestCase extends DrupalWebTestCase {
     $edit = array();
     $edit['modules[Core][forum][enable]'] = FALSE;
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
     module_list(TRUE);
-    $this->assertFalse(module_exists('forum'), t('Forum module is not enabled.'));
+    $this->assertFalse(module_exists('forum'), 'Forum module is not enabled.');
 
     // Attempt to re-enable the Forum module and ensure it does not try to
     // recreate the taxonomy_forums field.
     $edit = array();
     $edit['modules[Core][forum][enable]'] = 'forum';
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
     module_list(TRUE);
-    $this->assertTrue(module_exists('forum'), t('Forum module is enabled.'));
+    $this->assertTrue(module_exists('forum'), 'Forum module is enabled.');
   }
 
   /**
@@ -166,17 +166,17 @@ class ForumTestCase extends DrupalWebTestCase {
     $xpath = $this->buildXPathQuery('//tr[@id=:forum]//td[@class="topics"]', $forum_arg);
     $topics = $this->xpath($xpath);
     $topics = trim($topics[0]);
-    $this->assertEqual($topics, '6', t('Number of topics found.'));
+    $this->assertEqual($topics, '6', 'Number of topics found.');
 
     // Verify the number of unread topics.
     $unread_topics = _forum_topics_unread($this->forum['tid'], $this->edit_any_topics_user->uid);
     $unread_topics = format_plural($unread_topics, '1 new', '@count new');
     $xpath = $this->buildXPathQuery('//tr[@id=:forum]//td[@class="topics"]//a', $forum_arg);
-    $this->assertFieldByXPath($xpath, $unread_topics, t('Number of unread topics found.'));
+    $this->assertFieldByXPath($xpath, $unread_topics, 'Number of unread topics found.');
 
     // Verify total number of posts in forum.
     $xpath = $this->buildXPathQuery('//tr[@id=:forum]//td[@class="posts"]', $forum_arg);
-    $this->assertFieldByXPath($xpath, '6', t('Number of posts found.'));
+    $this->assertFieldByXPath($xpath, '6', 'Number of posts found.');
 
     // Test loading multiple forum nodes on the front page.
     $this->drupalLogin($this->drupalCreateUser(array('administer content types', 'create forum content')));
@@ -226,7 +226,7 @@ class ForumTestCase extends DrupalWebTestCase {
     $this->drupalPost('node/add/forum', array('title' => $this->randomName(10), 'body[' . LANGUAGE_NONE .'][0][value]' => $this->randomName(120)), t('Save'));
 
     $nid_count = db_query('SELECT COUNT(nid) FROM {node}')->fetchField();
-    $this->assertEqual(0, $nid_count, t('A forum node was not created when missing a forum vocabulary.'));
+    $this->assertEqual(0, $nid_count, 'A forum node was not created when missing a forum vocabulary.');
 
     // Reset the defaults for future tests.
     module_enable(array('forum'));
@@ -247,14 +247,14 @@ class ForumTestCase extends DrupalWebTestCase {
     $edit['blocks[forum_active][region]'] = 'sidebar_second';
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
     $this->assertResponse(200);
-    $this->assertText(t('The block settings have been updated.'), t('Active forum topics forum block was enabled'));
+    $this->assertText(t('The block settings have been updated.'), 'Active forum topics forum block was enabled');
 
     // Enable the new forum block.
     $edit = array();
     $edit['blocks[forum_new][region]'] = 'sidebar_second';
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
     $this->assertResponse(200);
-    $this->assertText(t('The block settings have been updated.'), t('[New forum topics] Forum block was enabled'));
+    $this->assertText(t('The block settings have been updated.'), '[New forum topics] Forum block was enabled');
 
     // Retrieve forum menu id.
     $mlid = db_query_range("SELECT mlid FROM {menu_links} WHERE link_path = 'forum' AND menu_name = 'navigation' AND module = 'system' ORDER BY mlid ASC", 0, 1)->fetchField();
@@ -272,13 +272,13 @@ class ForumTestCase extends DrupalWebTestCase {
     // Verify "edit container" link exists and functions correctly.
     $this->drupalGet('admin/structure/forum');
     $this->clickLink('edit container');
-    $this->assertRaw('Edit container', t('Followed the link to edit the container'));
+    $this->assertRaw('Edit container', 'Followed the link to edit the container');
     // Create forum inside the forum container.
     $this->forum = $this->createForum('forum', $this->container['tid']);
     // Verify the "edit forum" link exists and functions correctly.
     $this->drupalGet('admin/structure/forum');
     $this->clickLink('edit forum');
-    $this->assertRaw('Edit forum', t('Followed the link to edit the forum'));
+    $this->assertRaw('Edit forum', 'Followed the link to edit the forum');
     // Navigate back to forum structure page.
     $this->drupalGet('admin/structure/forum');
     // Create second forum in container.
@@ -334,15 +334,15 @@ class ForumTestCase extends DrupalWebTestCase {
     // Edit the vocabulary.
     $this->drupalPost('admin/structure/taxonomy/' . $original_settings->machine_name . '/edit', $edit, t('Save'));
     $this->assertResponse(200);
-    $this->assertRaw(t('Updated vocabulary %name.', array('%name' => $title)), t('Vocabulary was edited'));
+    $this->assertRaw(t('Updated vocabulary %name.', array('%name' => $title)), 'Vocabulary was edited');
 
     // Grab the newly edited vocabulary.
     entity_get_controller('taxonomy_vocabulary')->resetCache();
     $current_settings = taxonomy_vocabulary_load($vid);
 
     // Make sure we actually edited the vocabulary properly.
-    $this->assertEqual($current_settings->name, $title, t('The name was updated'));
-    $this->assertEqual($current_settings->description, $description, t('The description was updated'));
+    $this->assertEqual($current_settings->name, $title, 'The name was updated');
+    $this->assertEqual($current_settings->description, $description, 'The description was updated');
 
     // Restore the original vocabulary.
     taxonomy_vocabulary_save($original_settings);
@@ -379,7 +379,7 @@ class ForumTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/structure/forum/add/' . $type, $edit, t('Save'));
     $this->assertResponse(200);
     $type = ($type == 'container') ? 'forum container' : 'forum';
-    $this->assertRaw(t('Created new @type %term.', array('%term' => $name, '@type' => t($type))), t(ucfirst($type) . ' was created'));
+    $this->assertRaw(t('Created new @type %term.', array('%term' => $name, '@type' => t($type))), format_string('@type was created', array('@type' => ucfirst($type))));
 
     // Verify forum.
     $term = db_query("SELECT * FROM {taxonomy_term_data} t WHERE t.vid = :vid AND t.name = :name AND t.description = :desc", array(':vid' => variable_get('forum_nav_vocabulary', ''), ':name' => $name, ':desc' => $description))->fetchAssoc();
@@ -461,24 +461,24 @@ class ForumTestCase extends DrupalWebTestCase {
 
     $type = t('Forum topic');
     if ($container) {
-      $this->assertNoRaw(t('@type %title has been created.', array('@type' => $type, '%title' => $title)), t('Forum topic was not created'));
-      $this->assertRaw(t('The item %title is a forum container, not a forum.', array('%title' => $forum['name'])), t('Error message was shown'));
+      $this->assertNoRaw(t('@type %title has been created.', array('@type' => $type, '%title' => $title)), 'Forum topic was not created');
+      $this->assertRaw(t('The item %title is a forum container, not a forum.', array('%title' => $forum['name'])), 'Error message was shown');
       return;
     }
     else {
-      $this->assertRaw(t('@type %title has been created.', array('@type' => $type, '%title' => $title)), t('Forum topic was created'));
-      $this->assertNoRaw(t('The item %title is a forum container, not a forum.', array('%title' => $forum['name'])), t('No error message was shown'));
+      $this->assertRaw(t('@type %title has been created.', array('@type' => $type, '%title' => $title)), 'Forum topic was created');
+      $this->assertNoRaw(t('The item %title is a forum container, not a forum.', array('%title' => $forum['name'])), 'No error message was shown');
     }
 
     // Retrieve node object, ensure that the topic was created and in the proper forum.
     $node = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($node != NULL, t('Node @title was loaded', array('@title' => $title)));
+    $this->assertTrue($node != NULL, format_string('Node @title was loaded', array('@title' => $title)));
     $this->assertEqual($node->taxonomy_forums[LANGUAGE_NONE][0]['tid'], $tid, 'Saved forum topic was in the expected forum');
 
     // View forum topic.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertRaw($title, t('Subject was found'));
-    $this->assertRaw($body, t('Body was found'));
+    $this->assertRaw($title, 'Subject was found');
+    $this->assertRaw($body, 'Body was found');
 
     return $node;
   }
@@ -502,14 +502,14 @@ class ForumTestCase extends DrupalWebTestCase {
     $this->drupalGet('admin/help/forum');
     $this->assertResponse($response2);
     if ($response2 == 200) {
-      $this->assertTitle(t('Forum | Drupal'), t('Forum help title was displayed'));
-      $this->assertText(t('Forum'), t('Forum help node was displayed'));
+      $this->assertTitle(t('Forum | Drupal'), 'Forum help title was displayed');
+      $this->assertText(t('Forum'), 'Forum help node was displayed');
     }
 
     // Verify the forum blocks were displayed.
     $this->drupalGet('');
     $this->assertResponse(200);
-    $this->assertText(t('New forum topics'), t('[New forum topics] Forum block was displayed'));
+    $this->assertText(t('New forum topics'), '[New forum topics] Forum block was displayed');
 
     // View forum container page.
     $this->verifyForumView($this->container);
@@ -521,20 +521,20 @@ class ForumTestCase extends DrupalWebTestCase {
     // View forum node.
     $this->drupalGet('node/' . $node->nid);
     $this->assertResponse(200);
-    $this->assertTitle($node->title . ' | Drupal', t('Forum node was displayed'));
+    $this->assertTitle($node->title . ' | Drupal', 'Forum node was displayed');
     $breadcrumb = array(
       l(t('Home'), NULL),
       l(t('Forums'), 'forum'),
       l($this->container['name'], 'forum/' . $this->container['tid']),
       l($this->forum['name'], 'forum/' . $this->forum['tid']),
     );
-    $this->assertRaw(theme('breadcrumb', array('breadcrumb' => $breadcrumb)), t('Breadcrumbs were displayed'));
+    $this->assertRaw(theme('breadcrumb', array('breadcrumb' => $breadcrumb)), 'Breadcrumbs were displayed');
 
     // View forum edit node.
     $this->drupalGet('node/' . $node->nid . '/edit');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertTitle('Edit Forum topic ' . $node->title . ' | Drupal', t('Forum edit node was displayed'));
+      $this->assertTitle('Edit Forum topic ' . $node->title . ' | Drupal', 'Forum edit node was displayed');
     }
 
     if ($response == 200) {
@@ -547,7 +547,7 @@ class ForumTestCase extends DrupalWebTestCase {
       $edit["taxonomy_forums[$langcode]"] = $this->root_forum['tid'];
       $edit['shadow'] = TRUE;
       $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
-      $this->assertRaw(t('Forum topic %title has been updated.', array('%title' => $edit["title"])), t('Forum node was edited'));
+      $this->assertRaw(t('Forum topic %title has been updated.', array('%title' => $edit["title"])), 'Forum node was edited');
 
       // Verify topic was moved to a different forum.
       $forum_tid = db_query("SELECT tid FROM {forum} WHERE nid = :nid AND vid = :vid", array(
@@ -559,7 +559,7 @@ class ForumTestCase extends DrupalWebTestCase {
       // Delete forum node.
       $this->drupalPost('node/' . $node->nid . '/delete', array(), t('Delete'));
       $this->assertResponse($response);
-      $this->assertRaw(t('Forum topic %title has been deleted.', array('%title' => $edit['title'])), t('Forum node was deleted'));
+      $this->assertRaw(t('Forum topic %title has been deleted.', array('%title' => $edit['title'])), 'Forum node was deleted');
     }
   }
 
@@ -575,7 +575,7 @@ class ForumTestCase extends DrupalWebTestCase {
     // View forum page.
     $this->drupalGet('forum/' . $forum['tid']);
     $this->assertResponse(200);
-    $this->assertTitle($forum['name'] . ' | Drupal', t('Forum name was displayed'));
+    $this->assertTitle($forum['name'] . ' | Drupal', 'Forum name was displayed');
 
     $breadcrumb = array(
       l(t('Home'), NULL),
@@ -585,7 +585,7 @@ class ForumTestCase extends DrupalWebTestCase {
       $breadcrumb[] = l($parent['name'], 'forum/' . $parent['tid']);
     }
 
-    $this->assertRaw(theme('breadcrumb', array('breadcrumb' => $breadcrumb)), t('Breadcrumbs were displayed'));
+    $this->assertRaw(theme('breadcrumb', array('breadcrumb' => $breadcrumb)), 'Breadcrumbs were displayed');
   }
 
   /**
@@ -677,6 +677,7 @@ class ForumIndexTestCase extends DrupalWebTestCase {
       'status' => FALSE,
     );
     $this->drupalPost("node/{$node->nid}/edit", $edit, t('Save'));
+    $this->drupalGet("node/{$node->nid}");
     $this->assertText(t('Access denied'), 'Unpublished node is no longer accessible.');
 
     // Verify that the node no longer appears on the index.
diff --git a/modules/help/help.test b/modules/help/help.test
index a18e68c..da12ccc 100644
--- a/modules/help/help.test
+++ b/modules/help/help.test
@@ -52,17 +52,17 @@ class HelpTestCase extends DrupalWebTestCase {
     // Check for css on admin/help.
     $this->drupalLogin($this->big_user);
     $this->drupalGet('admin/help');
-    $this->assertRaw(drupal_get_path('module', 'help') . '/help.css', t('The help.css file is present in the HTML.'));
+    $this->assertRaw(drupal_get_path('module', 'help') . '/help.css', 'The help.css file is present in the HTML.');
 
     // Verify that introductory help text exists, goes for 100% module coverage.
     $this->assertRaw(t('For more information, refer to the specific topics listed in the next section or to the <a href="@drupal">online Drupal handbooks</a>.', array('@drupal' => 'http://drupal.org/documentation')), 'Help intro text correctly appears.');
 
     // Verify that help topics text appears.
-    $this->assertRaw('<h2>' . t('Help topics') . '</h2><p>' . t('Help is available on the following items:') . '</p>', t('Help topics text correctly appears.'));
+    $this->assertRaw('<h2>' . t('Help topics') . '</h2><p>' . t('Help is available on the following items:') . '</p>', 'Help topics text correctly appears.');
 
     // Make sure links are properly added for modules implementing hook_help().
     foreach ($this->modules as $module => $name) {
-      $this->assertLink($name, 0, t('Link properly added to @name (admin/help/@module)', array('@module' => $module, '@name' => $name)));
+      $this->assertLink($name, 0, format_string('Link properly added to @name (admin/help/@module)', array('@module' => $module, '@name' => $name)));
     }
   }
 
@@ -78,8 +78,8 @@ class HelpTestCase extends DrupalWebTestCase {
       $this->drupalGet('admin/help/' . $module);
       $this->assertResponse($response);
       if ($response == 200) {
-        $this->assertTitle($name . ' | Drupal', t('[' . $module . '] Title was displayed'));
-        $this->assertRaw('<h1 class="page-title">' . t($name) . '</h1>', t('[' . $module . '] Heading was displayed'));
+        $this->assertTitle($name . ' | Drupal', format_string('%module title was displayed', array('%module' => $module)));
+        $this->assertRaw('<h1 class="page-title">' . t($name) . '</h1>', format_string('%module heading was displayed', array('%module' => $module)));
        }
     }
   }
@@ -132,6 +132,6 @@ class NoHelpTestCase extends DrupalWebTestCase {
     $this->drupalLogin($this->big_user);
 
     $this->drupalGet('admin/help');
-    $this->assertNoText('Hook menu tests', t('Making sure the test module menu_test does not display a help link in admin/help'));
+    $this->assertNoText('Hook menu tests', 'Making sure the test module menu_test does not display a help link in admin/help');
   }
 }
diff --git a/modules/image/image.admin.inc b/modules/image/image.admin.inc
index ab99a49..7e62621 100644
--- a/modules/image/image.admin.inc
+++ b/modules/image/image.admin.inc
@@ -32,10 +32,9 @@ function image_style_list() {
  *   An image style array.
  * @ingroup forms
  * @see image_style_form_submit()
- * @see image_style_name_validate()
  */
 function image_style_form($form, &$form_state, $style) {
-  $title = t('Edit %name style', array('%name' => $style['name']));
+  $title = t('Edit %name style', array('%name' => $style['label']));
   drupal_set_title($title, PASS_THROUGH);
 
   // Adjust this form for styles that must be overridden to edit.
@@ -56,27 +55,31 @@ function image_style_form($form, &$form_state, $style) {
     '#markup' => theme('image_style_preview', array('style' => $style)),
   );
 
+  // Show the Image Style label.
+  $form['label'] = array(
+    '#type' => 'textfield',
+    '#title' => t('Image style name'),
+    '#default_value' => $style['label'],
+    '#disabled' => !$editable,
+    '#required' => TRUE,
+  );
+
   // Allow the name of the style to be changed, unless this style is
   // provided by a module's hook_default_image_styles().
-  if ($style['storage'] & IMAGE_STORAGE_MODULE) {
-    $form['name'] = array(
-      '#type' => 'item',
-      '#title' => t('Image style name'),
-      '#markup' => $style['name'],
-      '#description' => t('This image style is being provided by %module module and may not be renamed.', array('%module' => $style['module'])),
-    );
-  }
-  else {
-    $form['name'] = array(
-      '#type' => 'textfield',
-      '#size' => '64',
-      '#title' => t('Image style name'),
-      '#default_value' => $style['name'],
-      '#description' => t('The name is used in URLs for generated images. Use only lowercase alphanumeric characters, underscores (_), and hyphens (-).'),
-      '#element_validate' => array('image_style_name_validate'),
-      '#required' => TRUE,
-    );
-  }
+  $form['name'] = array(
+    '#type' => 'machine_name',
+    '#size' => '64',
+    '#default_value' => $style['name'],
+    '#disabled' => !$editable,
+    '#description' => t('The name is used in URLs for generated images. Use only lowercase alphanumeric characters, underscores (_), and hyphens (-).'),
+    '#required' => TRUE,
+    '#machine_name' => array(
+      'exists' => 'image_style_load',
+      'source' => array('label'),
+      'replace_pattern' => '[^0-9a-z_\-]',
+      'error' => t('Please only use lowercase alphanumeric characters, underscores (_), and hyphens (-) for style names.'),
+    ),
+  );
 
   // Build the list of existing image effects for this image style.
   $form['effects'] = array(
@@ -199,7 +202,7 @@ function image_style_form_add_submit($form, &$form_state) {
  * Submit handler for overriding a module-defined style.
  */
 function image_style_form_override_submit($form, &$form_state) {
-  drupal_set_message(t('The %style style has been overridden, allowing you to change its settings.', array('%style' => $form_state['image_style']['name'])));
+  drupal_set_message(t('The %style style has been overridden, allowing you to change its settings.', array('%style' => $form_state['image_style']['label'])));
   image_default_style_save($form_state['image_style']);
 }
 
@@ -207,11 +210,10 @@ function image_style_form_override_submit($form, &$form_state) {
  * Submit handler for saving an image style.
  */
 function image_style_form_submit($form, &$form_state) {
-  // Update the image style name if it has changed.
+  // Update the image style.
   $style = $form_state['image_style'];
-  if (isset($form_state['values']['name']) && $style['name'] != $form_state['values']['name']) {
-    $style['name'] = $form_state['values']['name'];
-  }
+  $style['name'] = $form_state['values']['name'];
+  $style['label'] = $form_state['values']['label'];
 
   // Update image effect weights.
   if (!empty($form_state['values']['effects'])) {
@@ -236,17 +238,25 @@ function image_style_form_submit($form, &$form_state) {
  *
  * @ingroup forms
  * @see image_style_add_form_submit()
- * @see image_style_name_validate()
  */
 function image_style_add_form($form, &$form_state) {
-  $form['name'] = array(
+  $form['label'] = array(
     '#type' => 'textfield',
-    '#size' => '64',
     '#title' => t('Style name'),
     '#default_value' => '',
+    '#required' => TRUE,
+  );
+  $form['name'] = array(
+    '#type' => 'machine_name',
     '#description' => t('The name is used in URLs for generated images. Use only lowercase alphanumeric characters, underscores (_), and hyphens (-).'),
-    '#element_validate' => array('image_style_name_validate'),
+    '#size' => '64',
     '#required' => TRUE,
+    '#machine_name' => array(
+      'exists' => 'image_style_load',
+      'source' => array('label'),
+      'replace_pattern' => '[^0-9a-z_\-]',
+      'error' => t('Please only use lowercase alphanumeric characters, underscores (_), and hyphens (-) for style names.'),
+    ),
   );
 
   $form['submit'] = array(
@@ -261,14 +271,22 @@ function image_style_add_form($form, &$form_state) {
  * Submit handler for adding a new image style.
  */
 function image_style_add_form_submit($form, &$form_state) {
-  $style = array('name' => $form_state['values']['name']);
+  $style = array(
+    'name' => $form_state['values']['name'],
+    'label' => $form_state['values']['label'],
+  );
   $style = image_style_save($style);
-  drupal_set_message(t('Style %name was created.', array('%name' => $style['name'])));
+  drupal_set_message(t('Style %name was created.', array('%name' => $style['label'])));
   $form_state['redirect'] = 'admin/config/media/image-styles/edit/' . $style['name'];
 }
 
 /**
  * Element validate function to ensure unique, URL safe style names.
+ *
+ * This function is no longer used in Drupal core since image style names are
+ * now validated using #machine_name functionality. It is kept for backwards
+ * compatibility (since non-core modules may be using it) and will be removed
+ * in Drupal 8.
  */
 function image_style_name_validate($element, $form_state) {
   // Check for duplicates.
@@ -295,7 +313,7 @@ function image_style_name_validate($element, $form_state) {
 function image_style_delete_form($form, &$form_state, $style) {
   $form_state['image_style'] = $style;
 
-  $replacement_styles = array_diff_key(image_style_options(), array($style['name'] => ''));
+  $replacement_styles = array_diff_key(image_style_options(TRUE, PASS_THROUGH), array($style['name'] => ''));
   $form['replacement'] = array(
     '#title' => t('Replacement style'),
     '#type' => 'select',
@@ -305,7 +323,7 @@ function image_style_delete_form($form, &$form_state, $style) {
 
   return confirm_form(
     $form,
-    t('Optionally select a style before deleting %style', array('%style' => $style['name'])),
+    t('Optionally select a style before deleting %style', array('%style' => $style['label'])),
     'admin/config/media/image-styles',
     t('If this style is in use on the site, you may select another style to replace it. All images that have been generated for this style will be permanently deleted.'),
     t('Delete'),  t('Cancel')
@@ -319,19 +337,19 @@ function image_style_delete_form_submit($form, &$form_state) {
   $style = $form_state['image_style'];
 
   image_style_delete($style, $form_state['values']['replacement']);
-  drupal_set_message(t('Style %name was deleted.', array('%name' => $style['name'])));
+  drupal_set_message(t('Style %name was deleted.', array('%name' => $style['label'])));
   $form_state['redirect'] = 'admin/config/media/image-styles';
 }
 
 /**
  * Confirmation form to revert a database style to its default.
  */
-function image_style_revert_form($form, $form_state, $style) {
+function image_style_revert_form($form, &$form_state, $style) {
   $form_state['image_style'] = $style;
 
   return confirm_form(
     $form,
-    t('Revert the %style style?', array('%style' => $style['name'])),
+    t('Revert the %style style?', array('%style' => $style['label'])),
     'admin/config/media/image-styles',
     t('Reverting this style will delete the customized settings and restore the defaults provided by the @module module.', array('@module' => $style['module'])),
     t('Revert'),  t('Cancel')
@@ -342,7 +360,7 @@ function image_style_revert_form($form, $form_state, $style) {
  * Submit handler to convert an overridden style to its default.
  */
 function image_style_revert_form_submit($form, &$form_state) {
-  drupal_set_message(t('The %style style has been reverted to its defaults.', array('%style' => $form_state['image_style']['name'])));
+  drupal_set_message(t('The %style style has been reverted to its defaults.', array('%style' => $form_state['image_style']['label'])));
   image_default_style_revert($form_state['image_style']);
   $form_state['redirect'] = 'admin/config/media/image-styles';
 }
@@ -439,7 +457,7 @@ function image_effect_delete_form($form, &$form_state, $style, $effect) {
   $form_state['image_style'] = $style;
   $form_state['image_effect'] = $effect;
 
-  $question = t('Are you sure you want to delete the @effect effect from the %style style?', array('%style' => $style['name'], '@effect' => $effect['label']));
+  $question = t('Are you sure you want to delete the @effect effect from the %style style?', array('%style' => $style['label'], '@effect' => $effect['label']));
   return confirm_form($form, $question, 'admin/config/media/image-styles/edit/' . $style['name'], '', t('Delete'));
 }
 
@@ -650,7 +668,7 @@ function theme_image_style_list($variables) {
   $rows = array();
   foreach ($styles as $style) {
     $row = array();
-    $row[] = l($style['name'], 'admin/config/media/image-styles/edit/' . $style['name']);
+    $row[] = l($style['label'], 'admin/config/media/image-styles/edit/' . $style['name']);
     $link_attributes = array(
       'attributes' => array(
         'class' => array('image-style-link'),
@@ -805,7 +823,7 @@ function theme_image_style_preview($variables) {
   // Build the preview of the image style.
   $preview_url = file_create_url($preview_file) . '?cache_bypass=' . REQUEST_TIME;
   $output .= '<div class="preview-image-wrapper">';
-  $output .= check_plain($style['name']) . ' (' . l(t('view actual size'), file_create_url($preview_file) . '?' . time()) . ')';
+  $output .= check_plain($style['label']) . ' (' . l(t('view actual size'), file_create_url($preview_file) . '?' . time()) . ')';
   $output .= '<div class="preview-image modified-image" style="' . $preview_attributes['style'] . '">';
   $output .= '<a href="' . file_create_url($preview_file) . '?' . time() . '">' . theme('image', array('path' => $preview_url, 'alt' => t('Sample modified image'), 'title' => '', 'attributes' => $preview_attributes)) . '</a>';
   $output .= '<div class="height" style="height: ' . $preview_height . 'px"><span>' . $preview_image['height'] . 'px</span></div>';
diff --git a/modules/image/image.api.php b/modules/image/image.api.php
index 1cb2b0d..8115116 100644
--- a/modules/image/image.api.php
+++ b/modules/image/image.api.php
@@ -177,6 +177,7 @@ function hook_image_default_styles() {
   $styles = array();
 
   $styles['mymodule_preview'] = array(
+    'label' => 'My module preview',
     'effects' => array(
       array(
         'name' => 'image_scale',
diff --git a/modules/image/image.field.inc b/modules/image/image.field.inc
index 60c0f5a..2354738 100644
--- a/modules/image/image.field.inc
+++ b/modules/image/image.field.inc
@@ -311,7 +311,7 @@ function image_field_widget_settings_form($field, $instance) {
   $form['preview_image_style'] = array(
     '#title' => t('Preview image style'),
     '#type' => 'select',
-    '#options' => image_style_options(FALSE),
+    '#options' => image_style_options(FALSE, PASS_THROUGH),
     '#empty_option' => '<' . t('no preview') . '>',
     '#default_value' => $settings['preview_image_style'],
     '#description' => t('The preview image will be shown while editing the content.'),
@@ -495,7 +495,7 @@ function image_field_formatter_settings_form($field, $instance, $view_mode, $for
   $display = $instance['display'][$view_mode];
   $settings = $display['settings'];
 
-  $image_styles = image_style_options(FALSE);
+  $image_styles = image_style_options(FALSE, PASS_THROUGH);
   $element['image_style'] = array(
     '#title' => t('Image style'),
     '#type' => 'select',
@@ -528,7 +528,7 @@ function image_field_formatter_settings_summary($field, $instance, $view_mode) {
 
   $summary = array();
 
-  $image_styles = image_style_options(FALSE);
+  $image_styles = image_style_options(FALSE, PASS_THROUGH);
   // Unset possible 'No defined styles' option.
   unset($image_styles['']);
   // Styles could be lost because of enabled/disabled modules that defines
diff --git a/modules/image/image.install b/modules/image/image.install
index b7aac71..45bcbbb 100644
--- a/modules/image/image.install
+++ b/modules/image/image.install
@@ -41,11 +41,18 @@ function image_schema() {
         'not null' => TRUE,
       ),
       'name' => array(
-        'description' => 'The style name.',
+        'description' => 'The style machine name.',
         'type' => 'varchar',
         'length' => 255,
         'not null' => TRUE,
       ),
+      'label' => array(
+        'description' => 'The style administrative name.',
+        'type' => 'varchar',
+        'length' => 255,
+        'not null' => TRUE,
+        'default' => '',
+      ),
     ),
     'primary key' => array('isid'),
     'unique keys' => array(
@@ -391,7 +398,8 @@ function image_update_7002(array &$sandbox) {
   }
 
   // Process the table at the top of the list.
-  $table = reset(array_keys($sandbox['tables']));
+  $keys = array_keys($sandbox['tables']);
+  $table = reset($keys);
   $sandbox['processed'] += _image_update_7002_populate_dimensions($table, $sandbox['tables'][$table], $sandbox['last_fid']);
 
   // Has the table been fully processed?
@@ -448,6 +456,30 @@ function image_update_7004() {
 }
 
 /**
+ * Add a column to the 'image_style' table to store administrative labels.
+ */
+function image_update_7005() {
+  $field = array(
+    'type' => 'varchar',
+    'length' => 255,
+    'not null' => TRUE,
+    'default' => '',
+    'description' => 'The style administrative name.',
+  );
+  db_add_field('image_styles', 'label', $field);
+
+  // Do a direct query here, rather than calling image_styles(),
+  // in case Image module is disabled.
+  $styles = db_query('SELECT name FROM {image_styles}')->fetchCol();
+  foreach ($styles as $style) {
+    db_update('image_styles')
+      ->fields(array('label' => $style))
+      ->condition('name', $style)
+      ->execute();
+  }
+}
+
+/**
  * @} End of "addtogroup updates-7.x-extra".
  */
 
diff --git a/modules/image/image.module b/modules/image/image.module
index d7178ad..b3ba7c4 100644
--- a/modules/image/image.module
+++ b/modules/image/image.module
@@ -254,7 +254,7 @@ function image_form_system_file_system_settings_alter(&$form, &$form_state) {
 }
 
 /**
- * Submit handler for the file system settings form.
+ * Form submission handler for system_file_system_settings().
  *
  * Adds a menu rebuild after the public file path has been changed, so that the
  * menu router item depending on that file path will be regenerated.
@@ -312,9 +312,9 @@ function image_file_download($uri) {
     return -1;
   }
 
-  // Private file access for the original files. Note that we only
-  // check access for non-temporary images, since file.module will
-  // grant access for all temporary files.
+  // Private file access for the original files. Note that we only check access
+  // for non-temporary images, since file.module will grant access for all
+  // temporary files.
   $files = file_load_multiple(array(), array('uri' => $uri));
   if (count($files)) {
     $file = reset($files);
@@ -347,6 +347,7 @@ function image_image_default_styles() {
   $styles = array();
 
   $styles['thumbnail'] = array(
+    'label' => 'Thumbnail (100x100)',
     'effects' => array(
       array(
         'name' => 'image_scale',
@@ -357,6 +358,7 @@ function image_image_default_styles() {
   );
 
   $styles['medium'] = array(
+    'label' => 'Medium (220x220)',
     'effects' => array(
       array(
         'name' => 'image_scale',
@@ -367,6 +369,7 @@ function image_image_default_styles() {
   );
 
   $styles['large'] = array(
+    'label' => 'Large (480x480)',
     'effects' => array(
       array(
         'name' => 'image_scale',
@@ -537,7 +540,7 @@ function image_field_update_instance($instance, $prior_instance) {
 }
 
 /**
- * Clear cached versions of a specific file in all styles.
+ * Clears cached versions of a specific file in all styles.
  *
  * @param $path
  *   The Drupal file path to the original image.
@@ -553,7 +556,7 @@ function image_path_flush($path) {
 }
 
 /**
- * Get an array of all styles and their settings.
+ * Gets an array of all styles and their settings.
  *
  * @return
  *   An array of styles keyed by the image style ID (isid).
@@ -575,6 +578,7 @@ function image_styles() {
         $module_styles = module_invoke($module, 'image_default_styles');
         foreach ($module_styles as $style_name => $style) {
           $style['name'] = $style_name;
+          $style['label'] = empty($style['label']) ? $style_name : $style['label'];
           $style['module'] = $module;
           $style['storage'] = IMAGE_STORAGE_DEFAULT;
           foreach ($style['effects'] as $key => $effect) {
@@ -614,7 +618,9 @@ function image_styles() {
 }
 
 /**
- * Load a style by style name or ID. May be used as a loader for menu items.
+ * Loads a style by style name or ID.
+ *
+ * May be used as a loader for menu items.
  *
  * @param $name
  *   The name of the style.
@@ -623,6 +629,7 @@ function image_styles() {
  * @param $include
  *   If set, this loader will restrict to a specific type of image style, may be
  *   one of the defined Image style storage constants.
+ *
  * @return
  *   An image style array containing the following keys:
  *   - "isid": The unique image style ID.
@@ -660,12 +667,20 @@ function image_style_load($name = NULL, $isid = NULL, $include = NULL) {
 }
 
 /**
- * Save an image style.
+ * Saves an image style.
  *
- * @param style
- *   An image style array.
- * @return
- *   An image style array. In the case of a new style, 'isid' will be populated.
+ * @param array $style
+ *   An image style array containing:
+ *   - name: A unique name for the style.
+ *   - isid: (optional) An image style ID.
+ *
+ * @return array
+ *   An image style array containing:
+ *   - name: An unique name for the style.
+ *   - old_name: The original name for the style.
+ *   - isid: An image style ID.
+ *   - is_new: TRUE if this is a new style, and FALSE if it is an existing
+ *     style.
  */
 function image_style_save($style) {
   if (isset($style['isid']) && is_numeric($style['isid'])) {
@@ -678,6 +693,10 @@ function image_style_save($style) {
     }
   }
   else {
+    // Add a default label when not given.
+    if (empty($style['label'])) {
+      $style['label'] = $style['name'];
+    }
     drupal_write_record('image_styles', $style);
     $style['is_new'] = TRUE;
   }
@@ -692,13 +711,14 @@ function image_style_save($style) {
 }
 
 /**
- * Delete an image style.
+ * Deletes an image style.
  *
  * @param $style
  *   An image style array.
  * @param $replacement_style_name
  *   (optional) When deleting a style, specify a replacement style name so
  *   that existing settings (if any) may be converted to a new style.
+ *
  * @return
  *   TRUE on success.
  */
@@ -717,14 +737,17 @@ function image_style_delete($style, $replacement_style_name = '') {
 }
 
 /**
- * Load all the effects for an image style.
+ * Loads all the effects for an image style.
  *
- * @param $style
- *   An image style array.
- * @return
+ * @param array $style
+ *   An image style array containing:
+ *   - isid: The unique image style ID that contains this image effect.
+ *
+ * @return array
  *   An array of image effects associated with specified image style in the
  *   format array('isid' => array()), or an empty array if the specified style
  *   has no effects.
+ * @see image_effects()
  */
 function image_style_effects($style) {
   $effects = image_effects();
@@ -739,23 +762,32 @@ function image_style_effects($style) {
 }
 
 /**
- * Get an array of image styles suitable for using as select list options.
+ * Gets an array of image styles suitable for using as select list options.
  *
  * @param $include_empty
  *   If TRUE a <none> option will be inserted in the options array.
+ * @param $output
+ *   Optional flag determining how the options will be sanitized on output.
+ *   Leave this at the default (CHECK_PLAIN) if you are using the output of
+ *   this function directly in an HTML context, such as for checkbox or radio
+ *   button labels, and do not plan to sanitize it on your own. If using the
+ *   output of this function as select list options (its primary use case), you
+ *   should instead set this flag to PASS_THROUGH to avoid double-escaping of
+ *   the output (the form API sanitizes select list options by default).
+ *
  * @return
- *   Array of image styles both key and value are set to style name.
+ *   Array of image styles with the machine name as key and the label as value.
  */
-function image_style_options($include_empty = TRUE) {
+function image_style_options($include_empty = TRUE, $output = CHECK_PLAIN) {
   $styles = image_styles();
   $options = array();
   if ($include_empty && !empty($styles)) {
     $options[''] = t('<none>');
   }
-  // Use the array concatenation operator '+' here instead of array_merge(),
-  // because the latter loses the datatype of the array keys, turning
-  // associative string keys into numeric ones without warning.
-  $options = $options + drupal_map_assoc(array_keys($styles));
+  foreach ($styles as $name => $style) {
+    $options[$name] = ($output == PASS_THROUGH) ? $style['label'] : check_plain($style['label']);
+  }
+
   if (empty($options)) {
     $options[''] = t('No defined styles');
   }
@@ -763,7 +795,7 @@ function image_style_options($include_empty = TRUE) {
 }
 
 /**
- * Menu callback; Given a style and image path, generate a derivative.
+ * Page callback: Generates a derivative, given a style and image path.
  *
  * After generating an image, transfer it to the requesting agent.
  *
@@ -780,9 +812,11 @@ function image_style_deliver($style, $scheme) {
   // derivative token is valid. (Sites which require image derivatives to be
   // generated without a token can set the 'image_allow_insecure_derivatives'
   // variable to TRUE to bypass the latter check, but this will increase the
-  // site's vulnerability to denial-of-service attacks.)
+  // site's vulnerability to denial-of-service attacks. To prevent this
+  // variable from leaving the site vulnerable to the most serious attacks, a
+  // token is always required when a derivative of a derivative is requested.)
   $valid = !empty($style) && file_stream_wrapper_valid_scheme($scheme);
-  if (!variable_get('image_allow_insecure_derivatives', FALSE)) {
+  if (!variable_get('image_allow_insecure_derivatives', FALSE) || strpos(ltrim($target, '\/'), 'styles/') === 0) {
     $valid = $valid && isset($_GET[IMAGE_DERIVATIVE_TOKEN]) && $_GET[IMAGE_DERIVATIVE_TOKEN] === image_style_path_token($style['name'], $scheme . '://' . $target);
   }
   if (!$valid) {
@@ -867,6 +901,11 @@ function image_style_deliver($style, $scheme) {
  * @see image_style_load()
  */
 function image_style_create_derivative($style, $source, $destination) {
+  // If the source file doesn't exist, return FALSE without creating folders.
+  if (!$image = image_load($source)) {
+    return FALSE;
+  }
+
   // Get the folder for the final location of this style.
   $directory = drupal_dirname($destination);
 
@@ -876,10 +915,6 @@ function image_style_create_derivative($style, $source, $destination) {
     return FALSE;
   }
 
-  if (!$image = image_load($source)) {
-    return FALSE;
-  }
-
   foreach ($style['effects'] as $effect) {
     image_effect_apply($image, $effect);
   }
@@ -928,15 +963,16 @@ function image_style_transform_dimensions($style_name, array &$dimensions) {
 }
 
 /**
- * Flush cached media for a style.
+ * Flushes cached media for a style.
  *
  * @param $style
  *   An image style array.
  */
 function image_style_flush($style) {
-  $style_directory = drupal_realpath(file_default_scheme() . '://styles/' . $style['name']);
-  if (is_dir($style_directory)) {
-    file_unmanaged_delete_recursive($style_directory);
+  // Delete the style directory in each registered wrapper.
+  $wrappers = file_get_stream_wrappers(STREAM_WRAPPERS_WRITE_VISIBLE);
+  foreach ($wrappers as $wrapper => $wrapper_data) {
+    file_unmanaged_delete_recursive($wrapper . '://styles/' . $style['name']);
   }
 
   // Let other modules update as necessary on flush.
@@ -960,12 +996,13 @@ function image_style_flush($style) {
 }
 
 /**
- * Return the URL for an image derivative given a style and image path.
+ * Returns the URL for an image derivative given a style and image path.
  *
  * @param $style_name
  *   The name of the style to be used with this image.
  * @param $path
  *   The path to the image.
+ *
  * @return
  *   The absolute URL where a style image can be downloaded, suitable for use
  *   in an <img> tag. Requesting the URL will cause the image to be created.
@@ -976,7 +1013,7 @@ function image_style_url($style_name, $path) {
   // The token query is added even if the 'image_allow_insecure_derivatives'
   // variable is TRUE, so that the emitted links remain valid if it is changed
   // back to the default FALSE.
-  $token_query = array(IMAGE_DERIVATIVE_TOKEN => image_style_path_token($style_name, $path));
+  $token_query = array(IMAGE_DERIVATIVE_TOKEN => image_style_path_token($style_name, file_stream_wrapper_uri_normalize($path)));
 
   // If not using clean URLs, the image derivative callback is only available
   // with the query string. If the file does not exist, use url() to ensure
@@ -1014,7 +1051,7 @@ function image_style_path_token($style_name, $uri) {
 }
 
 /**
- * Return the URI of an image when using a style.
+ * Returns the URI of an image when using a style.
  *
  * The path returned by this function may not exist. The default generation
  * method only creates images when they are requested by a user's browser.
@@ -1023,6 +1060,7 @@ function image_style_path_token($style_name, $uri) {
  *   The name of the style to be used with this image.
  * @param $uri
  *   The URI or path to the image.
+ *
  * @return
  *   The URI to an image style image.
  * @see image_style_url()
@@ -1040,10 +1078,11 @@ function image_style_path($style_name, $uri) {
 }
 
 /**
- * Save a default image style to the database.
+ * Saves a default image style to the database.
  *
  * @param style
  *   An image style array provided by a module.
+ *
  * @return
  *   An image style array. The returned style array will include the new 'isid'
  *   assigned to the style.
@@ -1061,7 +1100,7 @@ function image_default_style_save($style) {
 }
 
 /**
- * Revert the changes made by users to a default image style.
+ * Reverts the changes made by users to a default image style.
  *
  * @param style
  *   An image style array.
@@ -1078,7 +1117,10 @@ function image_default_style_revert($style) {
 }
 
 /**
- * Pull in image effects exposed by modules implementing hook_image_effect_info().
+ * Returns a set of image effects.
+ *
+ * These image effects are exposed by modules implementing
+ * hook_image_effect_info().
  *
  * @return
  *   An array of image effects to be used when transforming images.
@@ -1120,7 +1162,7 @@ function image_effect_definitions() {
 }
 
 /**
- * Load the definition for an image effect.
+ * Loads the definition for an image effect.
  *
  * The effect definition is a set of core properties for an image effect, not
  * containing any user-settings. The definition defines various functions to
@@ -1132,6 +1174,7 @@ function image_effect_definitions() {
  *   The name of the effect definition to load.
  * @param $style
  *   An image style array to which this effect will be added.
+ *
  * @return
  *   An array containing the image effect definition with the following keys:
  *   - "effect": The unique name for the effect being performed. Usually prefixed
@@ -1159,7 +1202,7 @@ function image_effect_definition_load($effect, $style_name = NULL) {
 }
 
 /**
- * Load all image effects from the database.
+ * Loads all image effects from the database.
  *
  * @return
  *   An array of all image effects.
@@ -1191,7 +1234,7 @@ function image_effects() {
 }
 
 /**
- * Load a single image effect.
+ * Loads a single image effect.
  *
  * @param $ieid
  *   The image effect ID.
@@ -1200,6 +1243,7 @@ function image_effects() {
  * @param $include
  *   If set, this loader will restrict to a specific type of image style, may be
  *   one of the defined Image style storage constants.
+ *
  * @return
  *   An image effect array, consisting of the following keys:
  *   - "ieid": The unique image effect ID.
@@ -1221,10 +1265,11 @@ function image_effect_load($ieid, $style_name, $include = NULL) {
 }
 
 /**
- * Save an image effect.
+ * Saves an image effect.
  *
  * @param $effect
  *   An image effect array.
+ *
  * @return
  *   An image effect array. In the case of a new effect, 'ieid' will be set.
  */
@@ -1241,7 +1286,7 @@ function image_effect_save($effect) {
 }
 
 /**
- * Delete an image effect.
+ * Deletes an image effect.
  *
  * @param $effect
  *   An image effect array.
@@ -1253,12 +1298,13 @@ function image_effect_delete($effect) {
 }
 
 /**
- * Given an image object and effect, perform the effect on the file.
+ * Applies an image effect to the image object.
  *
  * @param $image
  *   An image object returned by image_load().
  * @param $effect
  *   An image effect array.
+ *
  * @return
  *   TRUE on success. FALSE if unable to perform the image effect on the image.
  */
@@ -1309,7 +1355,7 @@ function theme_image_style($variables) {
 }
 
 /**
- * Accept a keyword (center, top, left, etc) and return it as a pixel offset.
+ * Accepts a keyword (center, top, left, etc) and returns it as a pixel offset.
  *
  * @param $value
  * @param $current_pixels
diff --git a/modules/image/image.test b/modules/image/image.test
index d4db213..7db68e6 100644
--- a/modules/image/image.test
+++ b/modules/image/image.test
@@ -17,7 +17,6 @@
  *   image_style_save()
  *   image_style_delete()
  *   image_style_options()
- *   image_style_flush()
  *   image_effect_definition_load()
  *   image_effect_load()
  *   image_effect_save()
@@ -122,7 +121,7 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
     parent::setUp('image_module_test');
 
     $this->style_name = 'style_foo';
-    image_style_save(array('name' => $this->style_name));
+    image_style_save(array('name' => $this->style_name, 'label' => $this->randomString()));
   }
 
   /**
@@ -132,11 +131,11 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
     $scheme = 'public';
     $actual = image_style_path($this->style_name, "$scheme://foo/bar.gif");
     $expected = "$scheme://styles/" . $this->style_name . "/$scheme/foo/bar.gif";
-    $this->assertEqual($actual, $expected, t('Got the path for a file URI.'));
+    $this->assertEqual($actual, $expected, 'Got the path for a file URI.');
 
     $actual = image_style_path($this->style_name, 'foo/bar.gif');
     $expected = "$scheme://styles/" . $this->style_name . "/$scheme/foo/bar.gif";
-    $this->assertEqual($actual, $expected, t('Got the path for a relative file path.'));
+    $this->assertEqual($actual, $expected, 'Got the path for a relative file path.');
   }
 
   /**
@@ -168,9 +167,16 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
   }
 
   /**
+   * Test image_style_url() with a file URL that has an extra slash in it.
+   */
+  function testImageStyleUrlExtraSlash() {
+    $this->_testImageStyleUrlAndPath('public', TRUE, TRUE);
+  }
+
+  /**
    * Test image_style_url().
    */
-  function _testImageStyleUrlAndPath($scheme, $clean_url = TRUE) {
+  function _testImageStyleUrlAndPath($scheme, $clean_url = TRUE, $extra_slash = FALSE) {
     // Make the default scheme neither "public" nor "private" to verify the
     // functions work for other than the default scheme.
     variable_set('file_default_scheme', 'temporary');
@@ -179,7 +185,7 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
     // Create the directories for the styles.
     $directory = $scheme . '://styles/' . $this->style_name;
     $status = file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
-    $this->assertNotIdentical(FALSE, $status, t('Created the directory for the generated images for the test style.'));
+    $this->assertNotIdentical(FALSE, $status, 'Created the directory for the generated images for the test style.');
 
     // Create a working copy of the file.
     $files = $this->drupalGetTestFiles('image');
@@ -189,13 +195,22 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
     // Let the image_module_test module know about this file, so it can claim
     // ownership in hook_file_download().
     variable_set('image_module_test_file_download', $original_uri);
-    $this->assertNotIdentical(FALSE, $original_uri, t('Created the generated image file.'));
+    $this->assertNotIdentical(FALSE, $original_uri, 'Created the generated image file.');
 
     // Get the URL of a file that has not been generated and try to create it.
     $generated_uri = image_style_path($this->style_name, $original_uri);
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $generate_url = image_style_url($this->style_name, $original_uri);
 
+    // Ensure that the tests still pass when the file is generated by accessing
+    // a poorly constructed (but still valid) file URL that has an extra slash
+    // in it.
+    if ($extra_slash) {
+      $modified_uri = str_replace('://', ':///', $original_uri);
+      $this->assertNotEqual($original_uri, $modified_uri, 'An extra slash was added to the generated file URI.');
+      $generate_url = image_style_url($this->style_name, $modified_uri);
+    }
+
     if (!$clean_url) {
       $this->assertTrue(strpos($generate_url, '?q=') !== FALSE, 'When using non-clean URLS, the system path contains the query string.');
     }
@@ -208,32 +223,38 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
 
     // Fetch the URL that generates the file.
     $this->drupalGet($generate_url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
-    $this->assertRaw(file_get_contents($generated_uri), t('URL returns expected file.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
+    $this->assertRaw(file_get_contents($generated_uri), 'URL returns expected file.');
     $generated_image_info = image_get_info($generated_uri);
-    $this->assertEqual($this->drupalGetHeader('Content-Type'), $generated_image_info['mime_type'], t('Expected Content-Type was reported.'));
-    $this->assertEqual($this->drupalGetHeader('Content-Length'), $generated_image_info['file_size'], t('Expected Content-Length was reported.'));
+    $this->assertEqual($this->drupalGetHeader('Content-Type'), $generated_image_info['mime_type'], 'Expected Content-Type was reported.');
+    $this->assertEqual($this->drupalGetHeader('Content-Length'), $generated_image_info['file_size'], 'Expected Content-Length was reported.');
     if ($scheme == 'private') {
-      $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', t('Expires header was sent.'));
-      $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'no-cache, must-revalidate, post-check=0, pre-check=0', t('Cache-Control header was set to prevent caching.'));
-      $this->assertEqual($this->drupalGetHeader('X-Image-Owned-By'), 'image_module_test', t('Expected custom header has been added.'));
+      $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', 'Expires header was sent.');
+      $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'no-cache, must-revalidate, post-check=0, pre-check=0', 'Cache-Control header was set to prevent caching.');
+      $this->assertEqual($this->drupalGetHeader('X-Image-Owned-By'), 'image_module_test', 'Expected custom header has been added.');
 
       // Make sure that a second request to the already existing derivate works
       // too.
       $this->drupalGet($generate_url);
-      $this->assertResponse(200, t('Image was generated at the URL.'));
+      $this->assertResponse(200, 'Image was generated at the URL.');
+
+      // Make sure that access is denied for existing style files if we do not
+      // have access.
+      variable_del('image_module_test_file_download');
+      $this->drupalGet($generate_url);
+      $this->assertResponse(403, 'Confirmed that access is denied for the private image style.');
 
       // Repeat this with a different file that we do not have access to and
       // make sure that access is denied.
       $file_noaccess = array_shift($files);
       $original_uri_noaccess = file_unmanaged_copy($file_noaccess->uri, $scheme . '://', FILE_EXISTS_RENAME);
       $generated_uri_noaccess = $scheme . '://styles/' . $this->style_name . '/' . $scheme . '/'. drupal_basename($original_uri_noaccess);
-      $this->assertFalse(file_exists($generated_uri_noaccess), t('Generated file does not exist.'));
+      $this->assertFalse(file_exists($generated_uri_noaccess), 'Generated file does not exist.');
       $generate_url_noaccess = image_style_url($this->style_name, $original_uri_noaccess);
 
       $this->drupalGet($generate_url_noaccess);
-      $this->assertResponse(403, t('Confirmed that access is denied for the private image style.') );
+      $this->assertResponse(403, 'Confirmed that access is denied for the private image style.');
       // Verify that images are not appended to the response. Currently this test only uses PNG images.
       if (strpos($generate_url, '.png') === FALSE ) {
         $this->fail('Confirming that private image styles are not appended require PNG file.');
@@ -249,6 +270,51 @@ class ImageStylesPathAndUrlTestCase extends DrupalWebTestCase {
       $this->drupalGet(str_replace(IMAGE_DERIVATIVE_TOKEN . '=', IMAGE_DERIVATIVE_TOKEN . '=Zo', $generate_url));
       $this->assertResponse(200, 'Existing image was accessible at the URL wih an invalid token.');
     }
+
+    // Allow insecure image derivatives to be created for the remainder of this
+    // test.
+    variable_set('image_allow_insecure_derivatives', TRUE);
+
+    // Create another working copy of the file.
+    $files = $this->drupalGetTestFiles('image');
+    $file = array_shift($files);
+    $image_info = image_get_info($file->uri);
+    $original_uri = file_unmanaged_copy($file->uri, $scheme . '://', FILE_EXISTS_RENAME);
+    // Let the image_module_test module know about this file, so it can claim
+    // ownership in hook_file_download().
+    variable_set('image_module_test_file_download', $original_uri);
+
+    // Get the URL of a file that has not been generated and try to create it.
+    $generated_uri = image_style_path($this->style_name, $original_uri);
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
+    $generate_url = image_style_url($this->style_name, $original_uri);
+
+    // Check that the image is accessible even without the security token.
+    $this->drupalGet(str_replace(IMAGE_DERIVATIVE_TOKEN . '=', 'wrongparam=', $generate_url));
+    $this->assertResponse(200, 'Image was accessible at the URL with a missing token.');
+
+    // Check that a security token is still required when generating a second
+    // image derivative using the first one as a source.
+    $nested_uri = image_style_path($this->style_name, $generated_uri);
+    $nested_url = image_style_url($this->style_name, $generated_uri);
+    $nested_url_with_wrong_token = str_replace(IMAGE_DERIVATIVE_TOKEN . '=', 'wrongparam=', $nested_url);
+    $this->drupalGet($nested_url_with_wrong_token);
+    $this->assertResponse(403, 'Image generated from an earlier derivative was inaccessible at the URL with a missing token.');
+    // Check that this restriction cannot be bypassed by adding extra slashes
+    // to the URL.
+    $this->drupalGet(substr_replace($nested_url_with_wrong_token, '//styles/', strrpos($nested_url_with_wrong_token, '/styles/'), strlen('/styles/')));
+    $this->assertResponse(403, 'Image generated from an earlier derivative was inaccessible at the URL with a missing token, even with an extra forward slash in the URL.');
+    $this->drupalGet(substr_replace($nested_url_with_wrong_token, '/\styles/', strrpos($nested_url_with_wrong_token, '/styles/'), strlen('/styles/')));
+    $this->assertResponse(403, 'Image generated from an earlier derivative was inaccessible at the URL with a missing token, even with an extra backslash in the URL.');
+    // Make sure the image can still be generated if a correct token is used.
+    $this->drupalGet($nested_url);
+    $this->assertResponse(200, 'Image was accessible when a correct token was provided in the URL.');
+
+    // Check that requesting a nonexistent image does not create any new
+    // directories in the file system.
+    $directory = $scheme . '://styles/' . $this->style_name . '/' . $scheme . '/' . $this->randomName();
+    $this->drupalGet(file_create_url($directory . '/' . $this->randomName()));
+    $this->assertFalse(file_exists($directory), 'New directory was not created in the filesystem when requesting an unauthorized image.');
   }
 }
 
@@ -274,13 +340,13 @@ class ImageEffectsUnitTest extends ImageToolkitTestCase {
    * Test the image_resize_effect() function.
    */
   function testResizeEffect() {
-    $this->assertTrue(image_resize_effect($this->image, array('width' => 1, 'height' => 2)), t('Function returned the expected value.'));
+    $this->assertTrue(image_resize_effect($this->image, array('width' => 1, 'height' => 2)), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('resize'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['resize'][0][1], 1, t('Width was passed correctly'));
-    $this->assertEqual($calls['resize'][0][2], 2, t('Height was passed correctly'));
+    $this->assertEqual($calls['resize'][0][1], 1, 'Width was passed correctly');
+    $this->assertEqual($calls['resize'][0][2], 2, 'Height was passed correctly');
   }
 
   /**
@@ -288,13 +354,13 @@ class ImageEffectsUnitTest extends ImageToolkitTestCase {
    */
   function testScaleEffect() {
     // @todo: need to test upscaling.
-    $this->assertTrue(image_scale_effect($this->image, array('width' => 10, 'height' => 10)), t('Function returned the expected value.'));
+    $this->assertTrue(image_scale_effect($this->image, array('width' => 10, 'height' => 10)), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('resize'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['resize'][0][1], 10, t('Width was passed correctly'));
-    $this->assertEqual($calls['resize'][0][2], 5, t('Height was based off aspect ratio and passed correctly'));
+    $this->assertEqual($calls['resize'][0][1], 10, 'Width was passed correctly');
+    $this->assertEqual($calls['resize'][0][2], 5, 'Height was based off aspect ratio and passed correctly');
   }
 
   /**
@@ -302,42 +368,42 @@ class ImageEffectsUnitTest extends ImageToolkitTestCase {
    */
   function testCropEffect() {
     // @todo should test the keyword offsets.
-    $this->assertTrue(image_crop_effect($this->image, array('anchor' => 'top-1', 'width' => 3, 'height' => 4)), t('Function returned the expected value.'));
+    $this->assertTrue(image_crop_effect($this->image, array('anchor' => 'top-1', 'width' => 3, 'height' => 4)), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('crop'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['crop'][0][1], 0, t('X was passed correctly'));
-    $this->assertEqual($calls['crop'][0][2], 1, t('Y was passed correctly'));
-    $this->assertEqual($calls['crop'][0][3], 3, t('Width was passed correctly'));
-    $this->assertEqual($calls['crop'][0][4], 4, t('Height was passed correctly'));
+    $this->assertEqual($calls['crop'][0][1], 0, 'X was passed correctly');
+    $this->assertEqual($calls['crop'][0][2], 1, 'Y was passed correctly');
+    $this->assertEqual($calls['crop'][0][3], 3, 'Width was passed correctly');
+    $this->assertEqual($calls['crop'][0][4], 4, 'Height was passed correctly');
   }
 
   /**
    * Test the image_scale_and_crop_effect() function.
    */
   function testScaleAndCropEffect() {
-    $this->assertTrue(image_scale_and_crop_effect($this->image, array('width' => 5, 'height' => 10)), t('Function returned the expected value.'));
+    $this->assertTrue(image_scale_and_crop_effect($this->image, array('width' => 5, 'height' => 10)), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('resize', 'crop'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['crop'][0][1], 7.5, t('X was computed and passed correctly'));
-    $this->assertEqual($calls['crop'][0][2], 0, t('Y was computed and passed correctly'));
-    $this->assertEqual($calls['crop'][0][3], 5, t('Width was computed and passed correctly'));
-    $this->assertEqual($calls['crop'][0][4], 10, t('Height was computed and passed correctly'));
+    $this->assertEqual($calls['crop'][0][1], 7.5, 'X was computed and passed correctly');
+    $this->assertEqual($calls['crop'][0][2], 0, 'Y was computed and passed correctly');
+    $this->assertEqual($calls['crop'][0][3], 5, 'Width was computed and passed correctly');
+    $this->assertEqual($calls['crop'][0][4], 10, 'Height was computed and passed correctly');
   }
 
   /**
    * Test the image_desaturate_effect() function.
    */
   function testDesaturateEffect() {
-    $this->assertTrue(image_desaturate_effect($this->image, array()), t('Function returned the expected value.'));
+    $this->assertTrue(image_desaturate_effect($this->image, array()), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('desaturate'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual(count($calls['desaturate'][0]), 1, t('Only the image was passed.'));
+    $this->assertEqual(count($calls['desaturate'][0]), 1, 'Only the image was passed.');
   }
 
   /**
@@ -345,13 +411,13 @@ class ImageEffectsUnitTest extends ImageToolkitTestCase {
    */
   function testRotateEffect() {
     // @todo: need to test with 'random' => TRUE
-    $this->assertTrue(image_rotate_effect($this->image, array('degrees' => 90, 'bgcolor' => '#fff')), t('Function returned the expected value.'));
+    $this->assertTrue(image_rotate_effect($this->image, array('degrees' => 90, 'bgcolor' => '#fff')), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('rotate'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['rotate'][0][1], 90, t('Degrees were passed correctly'));
-    $this->assertEqual($calls['rotate'][0][2], 0xffffff, t('Background color was passed correctly'));
+    $this->assertEqual($calls['rotate'][0][1], 90, 'Degrees were passed correctly');
+    $this->assertEqual($calls['rotate'][0][2], 0xffffff, 'Background color was passed correctly');
   }
 
   /**
@@ -417,13 +483,15 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
    */
   function testNumericStyleName() {
     $style_name = rand();
+    $style_label = $this->randomString();
     $edit = array(
       'name' => $style_name,
+      'label' => $style_label,
     );
     $this->drupalPost('admin/config/media/image-styles/add', $edit, t('Create new style'));
-    $this->assertRaw(t('Style %name was created.', array('%name' => $style_name)), t('Image style successfully created.'));
+    $this->assertRaw(t('Style %name was created.', array('%name' => $style_label)), 'Image style successfully created.');
     $options = image_style_options();
-    $this->assertTrue(array_key_exists($style_name, $options), t('Array key %key exists.', array('%key' => $style_name)));
+    $this->assertTrue(array_key_exists($style_name, $options), format_string('Array key %key exists.', array('%key' => $style_name)));
   }
 
   /**
@@ -432,6 +500,7 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
   function testStyle() {
     // Setup a style to be created and effects to add to it.
     $style_name = strtolower($this->randomName(10));
+    $style_label = $this->randomString();
     $style_path = 'admin/config/media/image-styles/edit/' . $style_name;
     $effect_edits = array(
       'image_resize' => array(
@@ -466,9 +535,10 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     $edit = array(
       'name' => $style_name,
+      'label' => $style_label,
     );
     $this->drupalPost('admin/config/media/image-styles/add', $edit, t('Create new style'));
-    $this->assertRaw(t('Style %name was created.', array('%name' => $style_name)), t('Image style successfully created.'));
+    $this->assertRaw(t('Style %name was created.', array('%name' => $style_label)), 'Image style successfully created.');
 
     // Add effect form.
 
@@ -490,7 +560,7 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
     foreach ($style['effects'] as $ieid => $effect) {
       $this->drupalGet($style_path . '/effects/' . $ieid);
       foreach ($effect_edits[$effect['name']] as $field => $value) {
-        $this->assertFieldByName($field, $value, t('The %field field in the %effect effect has the correct value of %value.', array('%field' => $field, '%effect' => $effect['name'], '%value' => $value)));
+        $this->assertFieldByName($field, $value, format_string('The %field field in the %effect effect has the correct value of %value.', array('%field' => $field, '%effect' => $effect['name'], '%value' => $value)));
       }
     }
 
@@ -506,14 +576,16 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
         $order_correct = FALSE;
       }
     }
-    $this->assertTrue($order_correct, t('The order of the effects is correctly set by default.'));
+    $this->assertTrue($order_correct, 'The order of the effects is correctly set by default.');
 
     // Test the style overview form.
     // Change the name of the style and adjust the weights of effects.
     $style_name = strtolower($this->randomName(10));
+    $style_label = $this->randomString();
     $weight = count($effect_edits);
     $edit = array(
       'name' => $style_name,
+      'label' => $style_label,
     );
     foreach ($style['effects'] as $ieid => $effect) {
       $edit['effects[' . $ieid . '][weight]'] = $weight;
@@ -522,7 +594,7 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     // Create an image to make sure it gets flushed after saving.
     $image_path = $this->createSampleImage($style);
-    $this->assertEqual($this->getImageCount($style), 1, t('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
+    $this->assertEqual($this->getImageCount($style), 1, format_string('Image style %style image %file successfully generated.', array('%style' => $style['label'], '%file' => $image_path)));
 
     $this->drupalPost($style_path, $edit, t('Update style'));
 
@@ -531,12 +603,12 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     // Check that the URL was updated.
     $this->drupalGet($style_path);
-    $this->assertResponse(200, t('Image style %original renamed to %new', array('%original' => $style['name'], '%new' => $style_name)));
+    $this->assertResponse(200, format_string('Image style %original renamed to %new', array('%original' => $style['label'], '%new' => $style_label)));
 
     // Check that the image was flushed after updating the style.
     // This is especially important when renaming the style. Make sure that
     // the old image directory has been deleted.
-    $this->assertEqual($this->getImageCount($style), 0, t('Image style %style was flushed after renaming the style and updating the order of effects.', array('%style' => $style['name'])));
+    $this->assertEqual($this->getImageCount($style), 0, format_string('Image style %style was flushed after renaming the style and updating the order of effects.', array('%style' => $style['label'])));
 
     // Load the style by the new name with the new weights.
     drupal_static_reset('image_styles');
@@ -551,18 +623,18 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
         $order_correct = FALSE;
       }
     }
-    $this->assertTrue($order_correct, t('The order of the effects is correctly set by default.'));
+    $this->assertTrue($order_correct, 'The order of the effects is correctly set by default.');
 
     // Image effect deletion form.
 
     // Create an image to make sure it gets flushed after deleting an effect.
     $image_path = $this->createSampleImage($style);
-    $this->assertEqual($this->getImageCount($style), 1, t('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
+    $this->assertEqual($this->getImageCount($style), 1, format_string('Image style %style image %file successfully generated.', array('%style' => $style['label'], '%file' => $image_path)));
 
     // Test effect deletion form.
     $effect = array_pop($style['effects']);
     $this->drupalPost($style_path . '/effects/' . $effect['ieid'] . '/delete', array(), t('Delete'));
-    $this->assertRaw(t('The image effect %name has been deleted.', array('%name' => $effect['label'])), t('Image effect deleted.'));
+    $this->assertRaw(t('The image effect %name has been deleted.', array('%name' => $effect['label'])), 'Image effect deleted.');
 
     // Style deletion form.
 
@@ -571,10 +643,10 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     // Confirm the style directory has been removed.
     $directory = file_default_scheme() . '://styles/' . $style_name;
-    $this->assertFalse(is_dir($directory), t('Image style %style directory removed on style deletion.', array('%style' => $style['name'])));
+    $this->assertFalse(is_dir($directory), format_string('Image style %style directory removed on style deletion.', array('%style' => $style['label'])));
 
     drupal_static_reset('image_styles');
-    $this->assertFalse(image_style_load($style_name), t('Image style %style successfully deleted.', array('%style' => $style['name'])));
+    $this->assertFalse(image_style_load($style_name), format_string('Image style %style successfully deleted.', array('%style' => $style['label'])));
 
   }
 
@@ -584,34 +656,36 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
   function testDefaultStyle() {
     // Setup a style to be created and effects to add to it.
     $style_name = 'thumbnail';
+    $style_label = 'Thumbnail (100x100)';
     $edit_path = 'admin/config/media/image-styles/edit/' . $style_name;
     $delete_path = 'admin/config/media/image-styles/delete/' . $style_name;
     $revert_path = 'admin/config/media/image-styles/revert/' . $style_name;
 
     // Ensure deleting a default is not possible.
     $this->drupalGet($delete_path);
-    $this->assertText(t('Page not found'), t('Default styles may not be deleted.'));
+    $this->assertText(t('Page not found'), 'Default styles may not be deleted.');
 
     // Ensure that editing a default is not possible (without overriding).
     $this->drupalGet($edit_path);
-    $this->assertNoField('edit-name', t('Default styles may not be renamed.'));
-    $this->assertNoField('edit-submit', t('Default styles may not be edited.'));
-    $this->assertNoField('edit-add', t('Default styles may not have new effects added.'));
+    $disabled_field = $this->xpath('//input[@id=:id and @disabled="disabled"]', array(':id' => 'edit-name'));
+    $this->assertTrue($disabled_field, 'Default styles may not be renamed.');
+    $this->assertNoField('edit-submit', 'Default styles may not be edited.');
+    $this->assertNoField('edit-add', 'Default styles may not have new effects added.');
 
     // Create an image to make sure the default works before overriding.
     drupal_static_reset('image_styles');
     $style = image_style_load($style_name);
     $image_path = $this->createSampleImage($style);
-    $this->assertEqual($this->getImageCount($style), 1, t('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
+    $this->assertEqual($this->getImageCount($style), 1, format_string('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
 
     // Verify that effects attached to a default style do not have an ieid key.
     foreach ($style['effects'] as $effect) {
-      $this->assertFalse(isset($effect['ieid']), t('The %effect effect does not have an ieid.', array('%effect' => $effect['name'])));
+      $this->assertFalse(isset($effect['ieid']), format_string('The %effect effect does not have an ieid.', array('%effect' => $effect['name'])));
     }
 
     // Override the default.
     $this->drupalPost($edit_path, array(), t('Override defaults'));
-    $this->assertRaw(t('The %style style has been overridden, allowing you to change its settings.', array('%style' => $style_name)), t('Default image style may be overridden.'));
+    $this->assertRaw(t('The %style style has been overridden, allowing you to change its settings.', array('%style' => $style_label)), 'Default image style may be overridden.');
 
     // Add sample effect to the overridden style.
     $this->drupalPost($edit_path, array('new' => 'image_desaturate'), t('Add'));
@@ -620,22 +694,23 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     // Verify that effects attached to the style have an ieid now.
     foreach ($style['effects'] as $effect) {
-      $this->assertTrue(isset($effect['ieid']), t('The %effect effect has an ieid.', array('%effect' => $effect['name'])));
+      $this->assertTrue(isset($effect['ieid']), format_string('The %effect effect has an ieid.', array('%effect' => $effect['name'])));
     }
 
     // The style should now have 2 effect, the original scale provided by core
     // and the desaturate effect we added in the override.
     $effects = array_values($style['effects']);
-    $this->assertEqual($effects[0]['name'], 'image_scale', t('The default effect still exists in the overridden style.'));
-    $this->assertEqual($effects[1]['name'], 'image_desaturate', t('The added effect exists in the overridden style.'));
+    $this->assertEqual($effects[0]['name'], 'image_scale', 'The default effect still exists in the overridden style.');
+    $this->assertEqual($effects[1]['name'], 'image_desaturate', 'The added effect exists in the overridden style.');
 
-    // Check that we are unable to rename an overridden style.
+    // Check that we are able to rename an overridden style.
     $this->drupalGet($edit_path);
-    $this->assertNoField('edit-name', t('Overridden styles may not be renamed.'));
+    $disabled_field = $this->xpath('//input[@id=:id and @disabled="disabled"]', array(':id' => 'edit-name'));
+    $this->assertFalse($disabled_field, 'Overridden styles may be renamed.');
 
     // Create an image to ensure the override works properly.
     $image_path = $this->createSampleImage($style);
-    $this->assertEqual($this->getImageCount($style), 1, t('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
+    $this->assertEqual($this->getImageCount($style), 1, format_string('Image style %style image %file successfully generated.', array('%style' => $style['label'], '%file' => $image_path)));
 
     // Revert the image style.
     $this->drupalPost($revert_path, array(), t('Revert'));
@@ -644,8 +719,8 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     // The style should now have the single effect for scale.
     $effects = array_values($style['effects']);
-    $this->assertEqual($effects[0]['name'], 'image_scale', t('The default effect still exists in the reverted style.'));
-    $this->assertFalse(array_key_exists(1, $effects), t('The added effect has been removed in the reverted style.'));
+    $this->assertEqual($effects[0]['name'], 'image_scale', 'The default effect still exists in the reverted style.');
+    $this->assertFalse(array_key_exists(1, $effects), 'The added effect has been removed in the reverted style.');
   }
 
   /**
@@ -654,7 +729,8 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
   function testStyleReplacement() {
     // Create a new style.
     $style_name = strtolower($this->randomName(10));
-    image_style_save(array('name' => $style_name));
+    $style_label = $this->randomString();
+    image_style_save(array('name' => $style_name, 'label' => $style_label));
     $style_path = 'admin/config/media/image-styles/edit/' . $style_name;
 
     // Create an image field that uses the new style.
@@ -672,28 +748,30 @@ class ImageAdminStylesUnitTest extends ImageFieldTestCase {
 
     // Test that image is displayed using newly created style.
     $this->drupalGet('node/' . $nid);
-    $this->assertRaw(check_plain(image_style_url($style_name, $node->{$field_name}[LANGUAGE_NONE][0]['uri'])), t('Image displayed using style @style.', array('@style' => $style_name)));
+    $this->assertRaw(check_plain(image_style_url($style_name, $node->{$field_name}[LANGUAGE_NONE][0]['uri'])), format_string('Image displayed using style @style.', array('@style' => $style_name)));
 
     // Rename the style and make sure the image field is updated.
     $new_style_name = strtolower($this->randomName(10));
+    $new_style_label = $this->randomString();
     $edit = array(
       'name' => $new_style_name,
+      'label' => $new_style_label,
     );
     $this->drupalPost('admin/config/media/image-styles/edit/' . $style_name, $edit, t('Update style'));
-    $this->assertText(t('Changes to the style have been saved.'), t('Style %name was renamed to %new_name.', array('%name' => $style_name, '%new_name' => $new_style_name)));
+    $this->assertText(t('Changes to the style have been saved.'), format_string('Style %name was renamed to %new_name.', array('%name' => $style_name, '%new_name' => $new_style_name)));
     $this->drupalGet('node/' . $nid);
-    $this->assertRaw(check_plain(image_style_url($new_style_name, $node->{$field_name}[LANGUAGE_NONE][0]['uri'])), t('Image displayed using style replacement style.'));
+    $this->assertRaw(check_plain(image_style_url($new_style_name, $node->{$field_name}[LANGUAGE_NONE][0]['uri'])), format_string('Image displayed using style replacement style.'));
 
     // Delete the style and choose a replacement style.
     $edit = array(
       'replacement' => 'thumbnail',
     );
     $this->drupalPost('admin/config/media/image-styles/delete/' . $new_style_name, $edit, t('Delete'));
-    $message = t('Style %name was deleted.', array('%name' => $new_style_name));
+    $message = t('Style %name was deleted.', array('%name' => $new_style_label));
     $this->assertRaw($message, $message);
 
     $this->drupalGet('node/' . $nid);
-    $this->assertRaw(check_plain(image_style_url('thumbnail', $node->{$field_name}[LANGUAGE_NONE][0]['uri'])), t('Image displayed using style replacement style.'));
+    $this->assertRaw(check_plain(image_style_url('thumbnail', $node->{$field_name}[LANGUAGE_NONE][0]['uri'])), format_string('Image displayed using style replacement style.'));
   }
 }
 
@@ -744,7 +822,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
       'height' => 20,
     );
     $default_output = theme('image', $image_info);
-    $this->assertRaw($default_output, t('Default formatter displaying correctly on full node view.'));
+    $this->assertRaw($default_output, 'Default formatter displaying correctly on full node view.');
 
     // Test the image linked to file formatter.
     $instance = field_info_instance('node', $field_name, 'article');
@@ -753,20 +831,19 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     field_update_instance($instance);
     $default_output = l(theme('image', $image_info), file_create_url($image_uri), array('html' => TRUE));
     $this->drupalGet('node/' . $nid);
-    $this->assertRaw($default_output, t('Image linked to file formatter displaying correctly on full node view.'));
+    $this->assertRaw($default_output, 'Image linked to file formatter displaying correctly on full node view.');
     // Verify that the image can be downloaded.
-    $this->assertEqual(file_get_contents($test_image->uri), $this->drupalGet(file_create_url($image_uri)), t('File was downloaded successfully.'));
+    $this->assertEqual(file_get_contents($test_image->uri), $this->drupalGet(file_create_url($image_uri)), 'File was downloaded successfully.');
     if ($scheme == 'private') {
       // Only verify HTTP headers when using private scheme and the headers are
       // sent by Drupal.
-      $this->assertEqual($this->drupalGetHeader('Content-Type'), 'image/png', t('Content-Type header was sent.'));
-      $this->assertEqual($this->drupalGetHeader('Content-Disposition'), 'inline; filename="' . $test_image->filename . '"', t('Content-Disposition header was sent.'));
-      $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'private', t('Cache-Control header was sent.'));
+      $this->assertEqual($this->drupalGetHeader('Content-Type'), 'image/png', 'Content-Type header was sent.');
+      $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'private', 'Cache-Control header was sent.');
 
       // Log out and try to access the file.
       $this->drupalLogout();
       $this->drupalGet(file_create_url($image_uri));
-      $this->assertResponse('403', t('Access denied to original image as anonymous user.'));
+      $this->assertResponse('403', 'Access denied to original image as anonymous user.');
 
       // Log in again.
       $this->drupalLogin($this->admin_user);
@@ -777,7 +854,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     field_update_instance($instance);
     $default_output = l(theme('image', $image_info), 'node/' . $nid, array('html' => TRUE, 'attributes' => array('class' => 'active')));
     $this->drupalGet('node/' . $nid);
-    $this->assertRaw($default_output, t('Image linked to content formatter displaying correctly on full node view.'));
+    $this->assertRaw($default_output, 'Image linked to content formatter displaying correctly on full node view.');
 
     // Test the image style 'thumbnail' formatter.
     $instance['display']['default']['settings']['image_link'] = '';
@@ -793,13 +870,13 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     $image_info['height'] = 50;
     $default_output = theme('image', $image_info);
     $this->drupalGet('node/' . $nid);
-    $this->assertRaw($default_output, t('Image style thumbnail formatter displaying correctly on full node view.'));
+    $this->assertRaw($default_output, 'Image style thumbnail formatter displaying correctly on full node view.');
 
     if ($scheme == 'private') {
       // Log out and try to access the file.
       $this->drupalLogout();
       $this->drupalGet(image_style_url('thumbnail', $image_uri));
-      $this->assertResponse('403', t('Access denied to image style thumbnail as anonymous user.'));
+      $this->assertResponse('403', 'Access denied to image style thumbnail as anonymous user.');
     }
   }
 
@@ -828,16 +905,16 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     $instance = field_info_instance('node', $field_name, 'article');
 
     $this->drupalGet('node/add/article');
-    $this->assertText(t('Files must be less than 50 KB.'), t('Image widget max file size is displayed on article form.'));
-    $this->assertText(t('Allowed file types: ' . $test_image_extension . '.'), t('Image widget allowed file types displayed on article form.'));
-    $this->assertText(t('Images must be between 10x10 and 100x100 pixels.'), t('Image widget allowed resolution displayed on article form.'));
+    $this->assertText(t('Files must be less than 50 KB.'), 'Image widget max file size is displayed on article form.');
+    $this->assertText(t('Allowed file types: ' . $test_image_extension . '.'), 'Image widget allowed file types displayed on article form.');
+    $this->assertText(t('Images must be between 10x10 and 100x100 pixels.'), 'Image widget allowed resolution displayed on article form.');
 
     // We have to create the article first and then edit it because the alt
     // and title fields do not display until the image has been attached.
     $nid = $this->uploadNodeImage($test_image, $field_name, 'article');
     $this->drupalGet('node/' . $nid . '/edit');
-    $this->assertFieldByName($field_name . '[' . LANGUAGE_NONE . '][0][alt]', '', t('Alt field displayed on article form.'));
-    $this->assertFieldByName($field_name . '[' . LANGUAGE_NONE . '][0][title]', '', t('Title field displayed on article form.'));
+    $this->assertFieldByName($field_name . '[' . LANGUAGE_NONE . '][0][alt]', '', 'Alt field displayed on article form.');
+    $this->assertFieldByName($field_name . '[' . LANGUAGE_NONE . '][0][title]', '', 'Title field displayed on article form.');
     // Verify that the attached image is being previewed using the 'medium'
     // style.
     $node = node_load($nid, NULL, TRUE);
@@ -847,7 +924,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
       'height' => 110,
     );
     $default_output = theme('image', $image_info);
-    $this->assertRaw($default_output, t("Preview image is displayed using 'medium' style."));
+    $this->assertRaw($default_output, "Preview image is displayed using 'medium' style.");
 
     // Add alt/title fields to the image and verify that they are displayed.
     $image_info = array(
@@ -863,7 +940,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     );
     $this->drupalPost('node/' . $nid . '/edit', $edit, t('Save'));
     $default_output = theme('image', $image_info);
-    $this->assertRaw($default_output, t('Image displayed using user supplied alt and title attributes.'));
+    $this->assertRaw($default_output, 'Image displayed using user supplied alt and title attributes.');
 
     // Verify that alt/title longer than allowed results in a validation error.
     $test_size = 2000;
@@ -896,7 +973,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
         'title' => t('Image field formatter'),
       ),
     ));
-    $this->assertTrue(stripos($image, 'testFound') > 0, t('Image field formatters can have attributes.'));
+    $this->assertTrue(stripos($image, 'testFound') > 0, 'Image field formatters can have attributes.');
   }
 
   /**
@@ -913,7 +990,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     $this->drupalGet('node/' . $node->nid);
     // Verify that no image is displayed on the page by checking for the class
     // that would be used on the image field.
-    $this->assertNoPattern('<div class="(.*?)field-name-' . strtr($field_name, '_', '-') . '(.*?)">', t('No image displayed when no image is attached and no default image specified.'));
+    $this->assertNoPattern('<div class="(.*?)field-name-' . strtr($field_name, '_', '-') . '(.*?)">', 'No image displayed when no image is attached and no default image specified.');
 
     // Add a default image to the public imagefield instance.
     $images = $this->drupalGetTestFiles('image');
@@ -925,10 +1002,10 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     field_info_cache_clear();
     $field = field_info_field($field_name);
     $image = file_load($field['settings']['default_image']);
-    $this->assertTrue($image->status == FILE_STATUS_PERMANENT, t('The default image status is permanent.'));
+    $this->assertTrue($image->status == FILE_STATUS_PERMANENT, 'The default image status is permanent.');
     $default_output = theme('image', array('path' => $image->uri));
     $this->drupalGet('node/' . $node->nid);
-    $this->assertRaw($default_output, t('Default image displayed when no user supplied image is present.'));
+    $this->assertRaw($default_output, 'Default image displayed when no user supplied image is present.');
 
     // Create a node with an image attached and ensure that the default image
     // is not displayed.
@@ -941,8 +1018,8 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     );
     $image_output = theme('image', $image_info);
     $this->drupalGet('node/' . $nid);
-    $this->assertNoRaw($default_output, t('Default image is not displayed when user supplied image is present.'));
-    $this->assertRaw($image_output, t('User supplied image is displayed.'));
+    $this->assertNoRaw($default_output, 'Default image is not displayed when user supplied image is present.');
+    $this->assertRaw($image_output, 'User supplied image is displayed.');
 
     // Remove default image from the field and make sure it is no longer used.
     $edit = array(
@@ -952,7 +1029,7 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     // Clear field info cache so the new default image is detected.
     field_info_cache_clear();
     $field = field_info_field($field_name);
-    $this->assertFalse($field['settings']['default_image'], t('Default image removed from field.'));
+    $this->assertFalse($field['settings']['default_image'], 'Default image removed from field.');
     // Create an image field that uses the private:// scheme and test that the
     // default image works as expected.
     $private_field_name = strtolower($this->randomName());
@@ -964,14 +1041,14 @@ class ImageFieldDisplayTestCase extends ImageFieldTestCase {
     $this->drupalPost('admin/structure/types/manage/article/fields/' . $private_field_name, $edit, t('Save settings'));
     $private_field = field_info_field($private_field_name);
     $image = file_load($private_field['settings']['default_image']);
-    $this->assertEqual('private', file_uri_scheme($image->uri), t('Default image uses private:// scheme.'));
-    $this->assertTrue($image->status == FILE_STATUS_PERMANENT, t('The default image status is permanent.'));
+    $this->assertEqual('private', file_uri_scheme($image->uri), 'Default image uses private:// scheme.');
+    $this->assertTrue($image->status == FILE_STATUS_PERMANENT, 'The default image status is permanent.');
     // Create a new node with no image attached and ensure that default private
     // image is displayed.
     $node = $this->drupalCreateNode(array('type' => 'article'));
     $default_output = theme('image', array('path' => $image->uri));
     $this->drupalGet('node/' . $node->nid);
-    $this->assertRaw($default_output, t('Default private image displayed when no user supplied image is present.'));
+    $this->assertRaw($default_output, 'Default private image displayed when no user supplied image is present.');
   }
 }
 
@@ -1017,9 +1094,9 @@ class ImageFieldValidateTestCase extends ImageFieldTestCase {
       }
     }
     $nid = $this->uploadNodeImage($image_that_is_too_small, $field_name, 'article');
-    $this->assertText(t('The specified file ' . $image_that_is_too_small->filename . ' could not be uploaded. The image is too small; the minimum dimensions are 50x50 pixels.'), t('Node save failed when minimum image resolution was not met.'));
+    $this->assertText(t('The specified file ' . $image_that_is_too_small->filename . ' could not be uploaded. The image is too small; the minimum dimensions are 50x50 pixels.'), 'Node save failed when minimum image resolution was not met.');
     $nid = $this->uploadNodeImage($image_that_is_too_big, $field_name, 'article');
-    $this->assertText(t('The image was resized to fit within the maximum allowed dimensions of 100x100 pixels.'), t('Image exceeding max resolution was properly resized.'));
+    $this->assertText(t('The image was resized to fit within the maximum allowed dimensions of 100x100 pixels.'), 'Image exceeding max resolution was properly resized.');
   }
 }
 
@@ -1050,7 +1127,7 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
     $original_uri = file_unmanaged_copy($file->uri, 'public://', FILE_EXISTS_RENAME);
 
     // Create a style.
-    $style = image_style_save(array('name' => 'test'));
+    $style = image_style_save(array('name' => 'test', 'label' => 'Test'));
     $generated_uri = 'public://styles/test/public/'. drupal_basename($original_uri);
     $url = image_style_url('test', $original_uri);
 
@@ -1074,14 +1151,14 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="120" height="60" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="120" height="60" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
     $image_info = image_get_info($generated_uri);
-    $this->assertEqual($image_info['width'], 120, t('Expected width was found.'));
-    $this->assertEqual($image_info['height'], 60, t('Expected height was found.'));
+    $this->assertEqual($image_info['width'], 120, 'Expected width was found.');
+    $this->assertEqual($image_info['height'], 60, 'Expected height was found.');
 
     // Rotate 90 degrees anticlockwise.
     $effect = array(
@@ -1095,14 +1172,14 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="60" height="120" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="60" height="120" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
     $image_info = image_get_info($generated_uri);
-    $this->assertEqual($image_info['width'], 60, t('Expected width was found.'));
-    $this->assertEqual($image_info['height'], 120, t('Expected height was found.'));
+    $this->assertEqual($image_info['width'], 60, 'Expected width was found.');
+    $this->assertEqual($image_info['height'], 120, 'Expected height was found.');
 
     // Scale an image that is higher than it is wide (rotated by previous effect).
     $effect = array(
@@ -1117,14 +1194,14 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="45" height="90" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="45" height="90" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
     $image_info = image_get_info($generated_uri);
-    $this->assertEqual($image_info['width'], 45, t('Expected width was found.'));
-    $this->assertEqual($image_info['height'], 90, t('Expected height was found.'));
+    $this->assertEqual($image_info['width'], 45, 'Expected width was found.');
+    $this->assertEqual($image_info['height'], 90, 'Expected height was found.');
 
     // Test upscale disabled.
     $effect = array(
@@ -1139,14 +1216,14 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="45" height="90" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="45" height="90" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
     $image_info = image_get_info($generated_uri);
-    $this->assertEqual($image_info['width'], 45, t('Expected width was found.'));
-    $this->assertEqual($image_info['height'], 90, t('Expected height was found.'));
+    $this->assertEqual($image_info['width'], 45, 'Expected width was found.');
+    $this->assertEqual($image_info['height'], 90, 'Expected height was found.');
 
     // Add a desaturate effect.
     $effect = array(
@@ -1157,14 +1234,14 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="45" height="90" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="45" height="90" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
     $image_info = image_get_info($generated_uri);
-    $this->assertEqual($image_info['width'], 45, t('Expected width was found.'));
-    $this->assertEqual($image_info['height'], 90, t('Expected height was found.'));
+    $this->assertEqual($image_info['width'], 45, 'Expected width was found.');
+    $this->assertEqual($image_info['height'], 90, 'Expected height was found.');
 
     // Add a random rotate effect.
     $effect = array(
@@ -1178,11 +1255,11 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
 
 
     // Add a crop effect.
@@ -1198,14 +1275,14 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="30" height="30" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" width="30" height="30" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
     $image_info = image_get_info($generated_uri);
-    $this->assertEqual($image_info['width'], 30, t('Expected width was found.'));
-    $this->assertEqual($image_info['height'], 30, t('Expected height was found.'));
+    $this->assertEqual($image_info['width'], 30, 'Expected width was found.');
+    $this->assertEqual($image_info['height'], 30, 'Expected height was found.');
 
     // Rotate to a non-multiple of 90 degrees.
     $effect = array(
@@ -1219,11 +1296,11 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     $effect = image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" alt="" />', t('Expected img tag was found.'));
-    $this->assertFalse(file_exists($generated_uri), t('Generated file does not exist.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" alt="" />', 'Expected img tag was found.');
+    $this->assertFalse(file_exists($generated_uri), 'Generated file does not exist.');
     $this->drupalGet($url);
-    $this->assertResponse(200, t('Image was generated at the URL.'));
-    $this->assertTrue(file_exists($generated_uri), t('Generated file does exist after we accessed it.'));
+    $this->assertResponse(200, 'Image was generated at the URL.');
+    $this->assertTrue(file_exists($generated_uri), 'Generated file does exist after we accessed it.');
 
     image_effect_delete($effect);
 
@@ -1237,7 +1314,7 @@ class ImageDimensionsTestCase extends DrupalWebTestCase {
 
     image_effect_save($effect);
     $img_tag = theme_image_style($variables);
-    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" alt="" />', t('Expected img tag was found.'));
+    $this->assertEqual($img_tag, '<img typeof="foaf:Image" src="' . check_plain($url) . '" alt="" />', 'Expected img tag was found.');
   }
 }
 
@@ -1371,13 +1448,13 @@ class ImageDimensionsScaleTestCase extends DrupalUnitTestCase {
       $return_value = image_dimensions_scale($test['input']['dimensions'], $test['input']['width'], $test['input']['height'], $test['input']['upscale']);
 
       // Check the width.
-      $this->assertEqual($test['output']['dimensions']['width'], $test['input']['dimensions']['width'], t('Computed width (@computed_width) equals expected width (@expected_width)', array('@computed_width' => $test['output']['dimensions']['width'], '@expected_width' => $test['input']['dimensions']['width'])));
+      $this->assertEqual($test['output']['dimensions']['width'], $test['input']['dimensions']['width'], format_string('Computed width (@computed_width) equals expected width (@expected_width)', array('@computed_width' => $test['output']['dimensions']['width'], '@expected_width' => $test['input']['dimensions']['width'])));
 
       // Check the height.
-      $this->assertEqual($test['output']['dimensions']['height'], $test['input']['dimensions']['height'], t('Computed height (@computed_height) equals expected height (@expected_height)', array('@computed_height' => $test['output']['dimensions']['height'], '@expected_height' => $test['input']['dimensions']['height'])));
+      $this->assertEqual($test['output']['dimensions']['height'], $test['input']['dimensions']['height'], format_string('Computed height (@computed_height) equals expected height (@expected_height)', array('@computed_height' => $test['output']['dimensions']['height'], '@expected_height' => $test['input']['dimensions']['height'])));
 
       // Check the return value.
-      $this->assertEqual($test['output']['return_value'], $return_value, t('Correct return value.'));
+      $this->assertEqual($test['output']['return_value'], $return_value, 'Correct return value.');
     }
   }
 }
@@ -1638,7 +1715,7 @@ class ImageThemeFunctionWebTestCase extends DrupalWebTestCase {
     $original_uri = file_unmanaged_copy($file->uri, 'public://', FILE_EXISTS_RENAME);
 
     // Create a style.
-    image_style_save(array('name' => 'test'));
+    image_style_save(array('name' => 'test', 'label' => 'Test'));
     $url = image_style_url('test', $original_uri);
 
     // Test using theme_image_formatter() without an image title, alt text, or
@@ -1671,3 +1748,108 @@ class ImageThemeFunctionWebTestCase extends DrupalWebTestCase {
   }
 
 }
+
+/**
+ * Tests flushing of image styles.
+ */
+class ImageStyleFlushTest extends ImageFieldTestCase {
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Image style flushing',
+      'description' => 'Tests flushing of image styles.',
+      'group' => 'Image',
+    );
+  }
+
+  /**
+   * Given an image style and a wrapper, generate an image.
+   */
+  function createSampleImage($style, $wrapper) {
+    static $file;
+
+    if (!isset($file)) {
+      $files = $this->drupalGetTestFiles('image');
+      $file = reset($files);
+    }
+
+    // Make sure we have an image in our wrapper testing file directory.
+    $source_uri = file_unmanaged_copy($file->uri, $wrapper . '://');
+    // Build the derivative image.
+    $derivative_uri = image_style_path($style['name'], $source_uri);
+    $derivative = image_style_create_derivative($style, $source_uri, $derivative_uri);
+
+    return $derivative ? $derivative_uri : FALSE;
+  }
+
+  /**
+   * Count the number of images currently created for a style in a wrapper.
+   */
+  function getImageCount($style, $wrapper) {
+    return count(file_scan_directory($wrapper . '://styles/' . $style['name'], '/.*/'));
+  }
+
+  /**
+   * General test to flush a style.
+   */
+  function testFlush() {
+
+    // Setup a style to be created and effects to add to it.
+    $style_name = strtolower($this->randomName(10));
+    $style_label = $this->randomString();
+    $style_path = 'admin/config/media/image-styles/edit/' . $style_name;
+    $effect_edits = array(
+      'image_resize' => array(
+        'data[width]' => 100,
+        'data[height]' => 101,
+      ),
+      'image_scale' => array(
+        'data[width]' => 110,
+        'data[height]' => 111,
+        'data[upscale]' => 1,
+      ),
+    );
+
+    // Add style form.
+    $edit = array(
+      'name' => $style_name,
+      'label' => $style_label,
+    );
+    $this->drupalPost('admin/config/media/image-styles/add', $edit, t('Create new style'));
+    // Add each sample effect to the style.
+    foreach ($effect_edits as $effect => $edit) {
+      // Add the effect.
+      $this->drupalPost($style_path, array('new' => $effect), t('Add'));
+      if (!empty($edit)) {
+        $this->drupalPost(NULL, $edit, t('Add effect'));
+      }
+    }
+
+    // Load the saved image style.
+    $style = image_style_load($style_name);
+
+    // Create an image for the 'public' wrapper.
+    $image_path = $this->createSampleImage($style, 'public');
+    // Expecting to find 2 images, one is the sample.png image shown in
+    // image style preview.
+    $this->assertEqual($this->getImageCount($style, 'public'), 2, format_string('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
+
+    // Create an image for the 'private' wrapper.
+    $image_path = $this->createSampleImage($style, 'private');
+    $this->assertEqual($this->getImageCount($style, 'private'), 1, format_string('Image style %style image %file successfully generated.', array('%style' => $style['name'], '%file' => $image_path)));
+
+    // Remove the 'image_scale' effect and updates the style, which in turn
+    // forces an image style flush.
+    $effect = array_pop($style['effects']);
+    $this->drupalPost($style_path . '/effects/' . $effect['ieid'] . '/delete', array(), t('Delete'));
+    $this->assertResponse(200);
+    $this->drupalPost($style_path, array(), t('Update style'));
+    $this->assertResponse(200);
+
+    // Post flush, expected 1 image in the 'public' wrapper (sample.png).
+    $this->assertEqual($this->getImageCount($style, 'public'), 1, format_string('Image style %style flushed correctly for %wrapper wrapper.', array('%style' => $style['name'], '%wrapper' => 'public')));
+
+    // Post flush, expected no image in the 'private' wrapper.
+    $this->assertEqual($this->getImageCount($style, 'private'), 0, format_string('Image style %style flushed correctly for %wrapper wrapper.', array('%style' => $style['name'], '%wrapper' => 'private')));
+  }
+}
diff --git a/modules/locale/locale.admin.inc b/modules/locale/locale.admin.inc
index 2535357..f1a71dd 100644
--- a/modules/locale/locale.admin.inc
+++ b/modules/locale/locale.admin.inc
@@ -388,13 +388,13 @@ function locale_languages_edit_form_validate($form, &$form_state) {
     form_set_error('prefix', t('Domain and path prefix values should not be set at the same time.'));
   }
   if (!empty($form_state['values']['domain']) && $duplicate = db_query("SELECT language FROM {languages} WHERE domain = :domain AND language <> :language", array(':domain' => $form_state['values']['domain'], ':language' => $form_state['values']['langcode']))->fetchField()) {
-    form_set_error('domain', t('The domain (%domain) is already tied to a language (%language).', array('%domain' => $form_state['values']['domain'], '%language' => $duplicate->language)));
+    form_set_error('domain', t('The domain (%domain) is already tied to a language (%language).', array('%domain' => $form_state['values']['domain'], '%language' => $duplicate)));
   }
   if (empty($form_state['values']['prefix']) && language_default('language') != $form_state['values']['langcode'] && empty($form_state['values']['domain'])) {
     form_set_error('prefix', t('Only the default language can have both the domain and prefix empty.'));
   }
   if (!empty($form_state['values']['prefix']) && $duplicate = db_query("SELECT language FROM {languages} WHERE prefix = :prefix AND language <> :language", array(':prefix' => $form_state['values']['prefix'], ':language' => $form_state['values']['langcode']))->fetchField()) {
-    form_set_error('prefix', t('The prefix (%prefix) is already tied to a language (%language).', array('%prefix' => $form_state['values']['prefix'], '%language' => $duplicate->language)));
+    form_set_error('prefix', t('The prefix (%prefix) is already tied to a language (%language).', array('%prefix' => $form_state['values']['prefix'], '%language' => $duplicate)));
   }
 }
 
diff --git a/modules/locale/locale.module b/modules/locale/locale.module
index 94e7cd1..768fead 100644
--- a/modules/locale/locale.module
+++ b/modules/locale/locale.module
@@ -386,20 +386,53 @@ function locale_form_node_form_alter(&$form, &$form_state) {
 /**
  * Form submit handler for node_form().
  *
- * Checks if Locale is registered as a translation handler and handle possible
- * node language changes.
- *
  * This submit handler needs to run before entity_form_submit_build_entity()
  * is invoked by node_form_submit_build_node(), because it alters the values of
  * attached fields. Therefore, it cannot be a hook_node_submit() implementation.
  */
 function locale_field_node_form_submit($form, &$form_state) {
-  if (field_has_translation_handler('node', 'locale')) {
-    $node = (object) $form_state['values'];
-    $current_language = entity_language('node', $node);
-    list(, , $bundle) = entity_extract_ids('node', $node);
+  locale_field_entity_form_submit('node', $form, $form_state);
+}
+
+/**
+ * Implements hook_form_FORM_ID_alter().
+ */
+function locale_form_comment_form_alter(&$form, &$form_state, $form_id) {
+  // If a content type has multilingual support we set the content language as
+  // comment language.
+  if ($form['language']['#value'] == LANGUAGE_NONE && locale_multilingual_node_type($form['#node']->type)) {
+    global $language_content;
+    $form['language']['#value'] = $language_content->language;
+    $submit_callback = 'locale_field_comment_form_submit';
+    array_unshift($form['actions']['preview']['#submit'], $submit_callback);
+    array_unshift($form['#submit'], $submit_callback);
+  }
+}
 
-    foreach (field_info_instances('node', $bundle) as $instance) {
+/**
+ * Form submit handler for comment_form().
+ *
+ * This submit handler needs to run before entity_form_submit_build_entity()
+ * is invoked by comment_form_submit_build_comment(), because it alters the
+ * values of attached fields.
+ */
+function locale_field_comment_form_submit($form, &$form_state) {
+  locale_field_entity_form_submit('comment', $form, $form_state);
+}
+
+/**
+ * Handles field language on submit for the given entity type.
+ *
+ * Checks if Locale is registered as a translation handler and handle possible
+ * language changes.
+ */
+function locale_field_entity_form_submit($entity_type, $form, &$form_state ) {
+  if (field_has_translation_handler($entity_type, 'locale')) {
+    $entity = (object) $form_state['values'];
+    $current_language = entity_language($entity_type, $entity);
+    list(, , $bundle) = entity_extract_ids($entity_type, $entity);
+
+    foreach (field_info_instances($entity_type, $bundle) as $instance) {
       $field_name = $instance['field_name'];
       $field = field_info_field($field_name);
       $previous_language = $form[$field_name]['#language'];
@@ -407,7 +440,7 @@ function locale_field_node_form_submit($form, &$form_state) {
       // Handle a possible language change: new language values are inserted,
       // previous ones are deleted.
       if ($field['translatable'] && $previous_language != $current_language) {
-        $form_state['values'][$field_name][$current_language] = $node->{$field_name}[$previous_language];
+        $form_state['values'][$field_name][$current_language] = $entity->{$field_name}[$previous_language];
         $form_state['values'][$field_name][$previous_language] = array();
       }
     }
@@ -491,6 +524,9 @@ function locale_field_language_fallback(&$display_language, $entity, $langcode)
  */
 function locale_entity_info_alter(&$entity_info) {
   $entity_info['node']['translation']['locale'] = TRUE;
+  if (isset($entity_info['comment'])) {
+    $entity_info['comment']['translation']['locale'] = TRUE;
+  }
 }
 
 /**
@@ -936,7 +972,7 @@ function locale_css_alter(&$css) {
           // Replicate the same item, but with the RTL path and a little larger
           // weight so that it appears directly after the original CSS file.
           $item['data'] = $rtl_path;
-          $item['weight'] += 0.01;
+          $item['weight'] += 0.0001;
           $css[$rtl_path] = $item;
         }
       }
@@ -1060,15 +1096,3 @@ function locale_url_outbound_alter(&$path, &$options, $original_path) {
     }
   }
 }
-
-/**
- * Implements hook_form_FORM_ID_alter().
- */
-function locale_form_comment_form_alter(&$form, &$form_state, $form_id) {
-  // If a content type has multilingual support we set the content language as
-  // comment language.
-  if ($form['language']['#value'] == LANGUAGE_NONE && locale_multilingual_node_type($form['#node']->type)) {
-    global $language_content;
-    $form['language']['#value'] = $language_content->language;
-  }
-}
diff --git a/modules/locale/locale.test b/modules/locale/locale.test
index 632506e..edf72e4 100644
--- a/modules/locale/locale.test
+++ b/modules/locale/locale.test
@@ -52,8 +52,8 @@ class LocaleConfigurationTest extends DrupalWebTestCase {
       'langcode' => 'fr',
     );
     $this->drupalPost('admin/config/regional/language/add', $edit, t('Add language'));
-    $this->assertText('fr', t('Language added successfully.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertText('fr', 'Language added successfully.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
 
     // Add custom language.
     // Code for the language.
@@ -72,109 +72,109 @@ class LocaleConfigurationTest extends DrupalWebTestCase {
       'direction' => '0',
     );
     $this->drupalPost('admin/config/regional/language/add', $edit, t('Add custom language'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertText($langcode, t('Language code found.'));
-    $this->assertText($name, t('Name found.'));
-    $this->assertText($native, t('Native found.'));
-    $this->assertText($native, t('Test language added.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertText($langcode, 'Language code found.');
+    $this->assertText($name, 'Name found.');
+    $this->assertText($native, 'Native found.');
+    $this->assertText($native, 'Test language added.');
 
     // Check if we can change the default language.
     $path = 'admin/config/regional/language';
     $this->drupalGet($path);
-    $this->assertFieldChecked('edit-site-default-en', t('English is the default language.'));
+    $this->assertFieldChecked('edit-site-default-en', 'English is the default language.');
     // Change the default language.
     $edit = array(
       'site_default' => $langcode,
     );
     $this->drupalPost(NULL, $edit, t('Save configuration'));
-    $this->assertNoFieldChecked('edit-site-default-en', t('Default language updated.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertNoFieldChecked('edit-site-default-en', 'Default language updated.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
 
     // Check if a valid language prefix is added after changing the default
     // language.
     $this->drupalGet('admin/config/regional/language/edit/en');
-    $this->assertFieldByXPath('//input[@name="prefix"]', 'en', t('A valid path prefix has been added to the previous default language.'));
+    $this->assertFieldByXPath('//input[@name="prefix"]', 'en', 'A valid path prefix has been added to the previous default language.');
 
     // Ensure we can't delete the default language.
     $this->drupalGet('admin/config/regional/language/delete/' . $langcode);
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertText(t('The default language cannot be deleted.'), t('Failed to delete the default language.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertText(t('The default language cannot be deleted.'), 'Failed to delete the default language.');
 
     // Check if we can disable a language.
     $edit = array(
       'enabled[en]' => FALSE,
     );
     $this->drupalPost($path, $edit, t('Save configuration'));
-    $this->assertNoFieldChecked('edit-enabled-en', t('Language disabled.'));
+    $this->assertNoFieldChecked('edit-enabled-en', 'Language disabled.');
 
     // Set disabled language to be the default and ensure it is re-enabled.
     $edit = array(
       'site_default' => 'en',
     );
     $this->drupalPost(NULL, $edit, t('Save configuration'));
-    $this->assertFieldChecked('edit-enabled-en', t('Default language re-enabled.'));
+    $this->assertFieldChecked('edit-enabled-en', 'Default language re-enabled.');
 
     // Ensure 'edit' link works.
     $this->clickLink(t('edit'));
-    $this->assertTitle(t('Edit language | Drupal'), t('Page title is "Edit language".'));
+    $this->assertTitle(t('Edit language | Drupal'), 'Page title is "Edit language".');
     // Edit a language.
     $name = $this->randomName(16);
     $edit = array(
       'name' => $name,
     );
     $this->drupalPost('admin/config/regional/language/edit/' . $langcode, $edit, t('Save language'));
-    $this->assertRaw($name, t('The language has been updated.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertRaw($name, 'The language has been updated.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
 
     // Ensure 'delete' link works.
     $this->drupalGet('admin/config/regional/language');
     $this->clickLink(t('delete'));
-    $this->assertText(t('Are you sure you want to delete the language'), t('"delete" link is correct.'));
+    $this->assertText(t('Are you sure you want to delete the language'), '"delete" link is correct.');
     // Delete an enabled language.
     $this->drupalGet('admin/config/regional/language/delete/' . $langcode);
     // First test the 'cancel' link.
     $this->clickLink(t('Cancel'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertRaw($name, t('The language was not deleted.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertRaw($name, 'The language was not deleted.');
     // Delete the language for real. This a confirm form, we do not need any
     // fields changed.
     $this->drupalPost('admin/config/regional/language/delete/' . $langcode, array(), t('Delete'));
     // We need raw here because %locale will add HTML.
-    $this->assertRaw(t('The language %locale has been removed.', array('%locale' => $name)), t('The test language has been removed.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertRaw(t('The language %locale has been removed.', array('%locale' => $name)), 'The test language has been removed.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
     // Verify that language is no longer found.
     $this->drupalGet('admin/config/regional/language/delete/' . $langcode);
-    $this->assertResponse(404, t('Language no longer found.'));
+    $this->assertResponse(404, 'Language no longer found.');
     // Make sure the "language_count" variable has been updated correctly.
     drupal_static_reset('language_list');
     $enabled = language_list('enabled');
-    $this->assertEqual(variable_get('language_count', 1), count($enabled[1]), t('Language count is correct.'));
+    $this->assertEqual(variable_get('language_count', 1), count($enabled[1]), 'Language count is correct.');
     // Delete a disabled language.
     // Disable an enabled language.
     $edit = array(
       'enabled[fr]' => FALSE,
     );
     $this->drupalPost($path, $edit, t('Save configuration'));
-    $this->assertNoFieldChecked('edit-enabled-fr', t('French language disabled.'));
+    $this->assertNoFieldChecked('edit-enabled-fr', 'French language disabled.');
     // Get the count of enabled languages.
     drupal_static_reset('language_list');
     $enabled = language_list('enabled');
     // Delete the disabled language.
     $this->drupalPost('admin/config/regional/language/delete/fr', array(), t('Delete'));
     // We need raw here because %locale will add HTML.
-    $this->assertRaw(t('The language %locale has been removed.', array('%locale' => 'French')), t('Disabled language has been removed.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertRaw(t('The language %locale has been removed.', array('%locale' => 'French')), 'Disabled language has been removed.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
     // Verify that language is no longer found.
     $this->drupalGet('admin/config/regional/language/delete/fr');
-    $this->assertResponse(404, t('Language no longer found.'));
+    $this->assertResponse(404, 'Language no longer found.');
     // Make sure the "language_count" variable has not changed.
-    $this->assertEqual(variable_get('language_count', 1), count($enabled[1]), t('Language count is correct.'));
+    $this->assertEqual(variable_get('language_count', 1), count($enabled[1]), 'Language count is correct.');
 
 
     // Ensure we can't delete the English language.
     $this->drupalGet('admin/config/regional/language/delete/en');
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertText(t('The English language cannot be deleted.'), t('Failed to delete English language.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertText(t('The English language cannot be deleted.'), 'Failed to delete English language.');
   }
 
 }
@@ -205,7 +205,7 @@ class LocaleLibraryInfoAlterTest extends DrupalWebTestCase {
   public function testLibraryInfoAlter() {
     drupal_add_library('system', 'ui.datepicker');
     $scripts = drupal_get_js();
-    $this->assertTrue(strpos($scripts, 'locale.datepicker.js'), t('locale.datepicker.js added to scripts.'));
+    $this->assertTrue(strpos($scripts, 'locale.datepicker.js'), 'locale.datepicker.js added to scripts.');
   }
 }
 
@@ -289,13 +289,13 @@ class LocaleJavascriptTranslationTest extends DrupalWebTestCase {
       $args = array('%source' => $str, '%context' => $context);
 
       // Make sure that the string was found in the file.
-      $this->assertTrue(isset($source_strings[$str]), t("Found source string: %source", $args));
+      $this->assertTrue(isset($source_strings[$str]), format_string('Found source string: %source', $args));
 
       // Make sure that the proper context was matched.
-      $this->assertTrue(isset($source_strings[$str]) && $source_strings[$str] === $context, strlen($context) > 0 ? t("Context for %source is %context", $args) : t("Context for %source is blank", $args));
+      $this->assertTrue(isset($source_strings[$str]) && $source_strings[$str] === $context, strlen($context) > 0 ? format_string('Context for %source is %context', $args) : format_string('Context for %source is blank', $args));
     }
 
-    $this->assertEqual(count($source_strings), count($test_strings), t("Found correct number of source strings."));
+    $this->assertEqual(count($source_strings), count($test_strings), 'Found correct number of source strings.');
   }
 }
 /**
@@ -352,12 +352,12 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     t($name, array(), array('langcode' => $langcode));
     // Reset locale cache.
     locale_reset();
-    $this->assertText($langcode, t('Language code found.'));
-    $this->assertText($name, t('Name found.'));
-    $this->assertText($native, t('Native found.'));
+    $this->assertText($langcode, 'Language code found.');
+    $this->assertText($name, 'Name found.');
+    $this->assertText($native, 'Native found.');
     // No t() here, we do not want to add this string to the database and it's
     // surely not translated yet.
-    $this->assertText($native, t('Test language added.'));
+    $this->assertText($native, 'Test language added.');
     $this->drupalLogout();
 
     // Search for the name and translate it.
@@ -372,8 +372,8 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     // assertText() seems to remove the input field where $name always could be
     // found, so this is not a false assert. See how assertNoText succeeds
     // later.
-    $this->assertText($name, t('Search found the name.'));
-    $this->assertRaw($language_indicator, t('Name is untranslated.'));
+    $this->assertText($name, 'Search found the name.');
+    $this->assertRaw($language_indicator, 'Name is untranslated.');
     // Assume this is the only result, given the random name.
     $this->clickLink(t('edit'));
     // We save the lid from the path.
@@ -381,24 +381,24 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     preg_match('!admin/config/regional/translate/edit/(\d+)!', $this->getUrl(), $matches);
     $lid = $matches[1];
     // No t() here, it's surely not translated yet.
-    $this->assertText($name, t('name found on edit screen.'));
+    $this->assertText($name, 'name found on edit screen.');
     $edit = array(
       "translations[$langcode]" => $translation,
     );
     $this->drupalPost(NULL, $edit, t('Save translations'));
-    $this->assertText(t('The string has been saved.'), t('The string has been saved.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertTrue($name != $translation && t($name, array(), array('langcode' => $langcode)) == $translation, t('t() works.'));
+    $this->assertText(t('The string has been saved.'), 'The string has been saved.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertTrue($name != $translation && t($name, array(), array('langcode' => $langcode)) == $translation, 't() works.');
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
     // The indicator should not be here.
-    $this->assertNoRaw($language_indicator, t('String is translated.'));
+    $this->assertNoRaw($language_indicator, 'String is translated.');
 
     // Try to edit a non-existent string and ensure we're redirected correctly.
     // Assuming we don't have 999,999 strings already.
     $random_lid = 999999;
     $this->drupalGet('admin/config/regional/translate/edit/' . $random_lid);
-    $this->assertText(t('String not found'), t('String not found.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertText(t('String not found'), 'String not found.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->drupalLogout();
 
     // Delete the language.
@@ -407,11 +407,11 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     // This a confirm form, we do not need any fields changed.
     $this->drupalPost($path, array(), t('Delete'));
     // We need raw here because %locale will add HTML.
-    $this->assertRaw(t('The language %locale has been removed.', array('%locale' => $name)), t('The test language has been removed.'));
+    $this->assertRaw(t('The language %locale has been removed.', array('%locale' => $name)), 'The test language has been removed.');
     // Reload to remove $name.
     $this->drupalGet($path);
     // Verify that language is no longer found.
-    $this->assertResponse(404, t('Language no longer found.'));
+    $this->assertResponse(404, 'Language no longer found.');
     $this->drupalLogout();
 
     // Delete the string.
@@ -425,20 +425,20 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
     // Assume this is the only result, given the random name.
     $this->clickLink(t('delete'));
-    $this->assertText(t('Are you sure you want to delete the string'), t('"delete" link is correct.'));
+    $this->assertText(t('Are you sure you want to delete the string'), '"delete" link is correct.');
     // Delete the string.
     $path = 'admin/config/regional/translate/delete/' . $lid;
     $this->drupalGet($path);
     // First test the 'cancel' link.
     $this->clickLink(t('Cancel'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertRaw($name, t('The string was not deleted.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertRaw($name, 'The string was not deleted.');
     // Delete the name string.
     $this->drupalPost('admin/config/regional/translate/delete/' . $lid, array(), t('Delete'));
-    $this->assertText(t('The string has been removed.'), t('The string has been removed message.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertText(t('The string has been removed.'), 'The string has been removed message.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/translate', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText($name, t('Search now can not find the name.'));
+    $this->assertNoText($name, 'Search now can not find the name.');
   }
 
   /*
@@ -494,14 +494,14 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       ->execute()
       ->fetchObject();
     $js_file = 'public://' . variable_get('locale_js_directory', 'languages') . '/' . $langcode . '_' . $file->javascript . '.js';
-    $this->assertTrue($result = file_exists($js_file), t('JavaScript file created: %file', array('%file' => $result ? $js_file : t('not found'))));
+    $this->assertTrue($result = file_exists($js_file), format_string('JavaScript file created: %file', array('%file' => $result ? $js_file : 'not found')));
 
     // Test JavaScript translation rebuilding.
     file_unmanaged_delete($js_file);
-    $this->assertTrue($result = !file_exists($js_file), t('JavaScript file deleted: %file', array('%file' => $result ? $js_file : t('found'))));
+    $this->assertTrue($result = !file_exists($js_file), format_string('JavaScript file deleted: %file', array('%file' => $result ? $js_file : 'found')));
     cache_clear_all();
     _locale_rebuild_js($langcode);
-    $this->assertTrue($result = file_exists($js_file), t('JavaScript file rebuilt: %file', array('%file' => $result ? $js_file : t('not found'))));
+    $this->assertTrue($result = file_exists($js_file), format_string('JavaScript file rebuilt: %file', array('%file' => $result ? $js_file : 'not found')));
   }
 
   /**
@@ -554,7 +554,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
     // Find the edit path.
     $content = $this->drupalGetContent();
-    $this->assertTrue(preg_match('@(admin/config/regional/translate/edit/[0-9]+)@', $content, $matches), t('Found the edit path.'));
+    $this->assertTrue(preg_match('@(admin/config/regional/translate/edit/[0-9]+)@', $content, $matches), 'Found the edit path.');
     $path = $matches[0];
     foreach ($bad_translations as $key => $translation) {
       $edit = array(
@@ -563,8 +563,8 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       $this->drupalPost($path, $edit, t('Save translations'));
       // Check for a form error on the textarea.
       $form_class = $this->xpath('//form[@id="locale-translate-edit-form"]//textarea/@class');
-      $this->assertNotIdentical(FALSE, strpos($form_class[0], 'error'), t('The string was rejected as unsafe.'));
-      $this->assertNoText(t('The string has been saved.'), t('The string was not saved.'));
+      $this->assertNotIdentical(FALSE, strpos($form_class[0], 'error'), 'The string was rejected as unsafe.');
+      $this->assertNoText(t('The string has been saved.'), 'The string was not saved.');
     }
   }
 
@@ -621,7 +621,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
     // assertText() seems to remove the input field where $name always could be
     // found, so this is not a false assert. See how assertNoText succeeds
     // later.
-    $this->assertText($name, t('Search found the string.'));
+    $this->assertText($name, 'Search found the string.');
 
     // Ensure untranslated string doesn't appear if searching on 'only
     // translated strings'.
@@ -632,7 +632,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertText(t('No strings available.'), t("Search didn't find the string."));
+    $this->assertText(t('No strings available.'), "Search didn't find the string.");
 
     // Ensure untranslated string appears if searching on 'only untranslated
     // strings' in "all" (hasn't been translated to any language).
@@ -643,7 +643,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText(t('No strings available.'), t('Search found the string.'));
+    $this->assertNoText(t('No strings available.'), 'Search found the string.');
 
     // Ensure untranslated string appears if searching on 'only untranslated
     // strings' in the custom language (hasn't been translated to that specific language).
@@ -654,7 +654,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText(t('No strings available.'), t('Search found the string.'));
+    $this->assertNoText(t('No strings available.'), 'Search found the string.');
 
     // Add translation.
     // Assume this is the only result, given the random name.
@@ -677,7 +677,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText(t('No strings available.'), t('Search found the translation.'));
+    $this->assertNoText(t('No strings available.'), 'Search found the translation.');
 
     // Ensure translated source string doesn't appear if searching on 'only
     // untranslated strings'.
@@ -688,7 +688,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertText(t('No strings available.'), t("Search didn't find the source string."));
+    $this->assertText(t('No strings available.'), "Search didn't find the source string.");
 
     // Ensure translated string doesn't appear if searching on 'only
     // untranslated strings'.
@@ -699,7 +699,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertText(t('No strings available.'), t("Search didn't find the translation."));
+    $this->assertText(t('No strings available.'), "Search didn't find the translation.");
 
     // Ensure translated string does appear if searching on the custom language.
     $search = array(
@@ -709,7 +709,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText(t('No strings available.'), t('Search found the translation.'));
+    $this->assertNoText(t('No strings available.'), 'Search found the translation.');
 
     // Ensure translated string doesn't appear if searching on English.
     $search = array(
@@ -719,7 +719,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertText(t('No strings available.'), t("Search didn't find the translation."));
+    $this->assertText(t('No strings available.'), "Search didn't find the translation.");
 
     // Search for a string that isn't in the system.
     $unavailable_string = $this->randomName(16);
@@ -730,7 +730,7 @@ class LocaleTranslationFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertText(t('No strings available.'), t("Search didn't find the invalid string."));
+    $this->assertText(t('No strings available.'), "Search didn't find the invalid string.");
   }
 }
 
@@ -898,16 +898,16 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
     ));
 
     // The import should automatically create the corresponding language.
-    $this->assertRaw(t('The language %language has been created.', array('%language' => 'French')), t('The language has been automatically created.'));
+    $this->assertRaw(t('The language %language has been created.', array('%language' => 'French')), 'The language has been automatically created.');
 
     // The import should have created 7 strings.
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 9, '%update' => 0, '%delete' => 0)), t('The translation file was successfully imported.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 9, '%update' => 0, '%delete' => 0)), 'The translation file was successfully imported.');
 
     // This import should have saved plural forms to have 2 variants.
-    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, t('Plural number initialized.'));
+    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, 'Plural number initialized.');
 
     // Ensure we were redirected correctly.
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate', array('absolute' => TRUE)), 'Correct page redirection.');
 
 
     // Try importing a .po file with invalid tags in the default text group.
@@ -916,9 +916,9 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
     ));
 
     // The import should have created 1 string and rejected 2.
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 1, '%update' => 0, '%delete' => 0)), t('The translation file was successfully imported.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 1, '%update' => 0, '%delete' => 0)), 'The translation file was successfully imported.');
     $skip_message = format_plural(2, 'One translation string was skipped because it contains disallowed HTML.', '@count translation strings were skipped because they contain disallowed HTML.');
-    $this->assertRaw($skip_message, t('Unsafe strings were skipped.'));
+    $this->assertRaw($skip_message, 'Unsafe strings were skipped.');
 
 
     // Try importing a .po file with invalid tags in a non default text group.
@@ -928,7 +928,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
     ));
 
     // The import should have created 3 strings.
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 3, '%update' => 0, '%delete' => 0)), t('The translation file was successfully imported.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 3, '%update' => 0, '%delete' => 0)), 'The translation file was successfully imported.');
 
 
     // Try importing a .po file which doesn't exist.
@@ -938,8 +938,8 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
       'files[file]' => $name,
       'group' => 'custom',
     ), t('Import'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/import', array('absolute' => TRUE)), t('Correct page redirection.'));
-    $this->assertText(t('File to import not found.'), t('File to import not found message.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/translate/import', array('absolute' => TRUE)), 'Correct page redirection.');
+    $this->assertText(t('File to import not found.'), 'File to import not found message.');
 
 
     // Try importing a .po file with overriding strings, and ensure existing
@@ -950,7 +950,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
     ));
 
     // The import should have created 1 string.
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 1, '%update' => 0, '%delete' => 0)), t('The translation file was successfully imported.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 1, '%update' => 0, '%delete' => 0)), 'The translation file was successfully imported.');
     // Ensure string wasn't overwritten.
     $search = array(
       'string' => 'Montag',
@@ -959,10 +959,10 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertText(t('No strings available.'), t('String not overwritten by imported string.'));
+    $this->assertText(t('No strings available.'), 'String not overwritten by imported string.');
 
     // This import should not have changed number of plural forms.
-    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, t('Plural numbers untouched.'));
+    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, 'Plural numbers untouched.');
 
     $this->importPoFile($this->getPoFileWithBrokenPlural(), array(
       'langcode' => 'fr',
@@ -971,7 +971,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
 
     // Attempt to import broken .po file as well to prove that this
     // will not overwrite the proper plural formula imported above.
-    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, t('Broken plurals: plural numbers untouched.'));
+    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, 'Broken plurals: plural numbers untouched.');
 
     $this->importPoFile($this->getPoFileWithMissingPlural(), array(
       'langcode' => 'fr',
@@ -980,7 +980,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
 
     // Attempt to import .po file which has no plurals and prove that this
     // will not overwrite the proper plural formula imported above.
-    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, t('No plurals: plural numbers untouched.'));
+    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 2, 'No plurals: plural numbers untouched.');
 
 
     // Try importing a .po file with overriding strings, and ensure existing
@@ -991,7 +991,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
     ));
 
     // The import should have updated 2 strings.
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 0, '%update' => 2, '%delete' => 0)), t('The translation file was successfully imported.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 0, '%update' => 2, '%delete' => 0)), 'The translation file was successfully imported.');
     // Ensure string was overwritten.
     $search = array(
       'string' => 'Montag',
@@ -1000,9 +1000,9 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText(t('No strings available.'), t('String overwritten by imported string.'));
+    $this->assertNoText(t('No strings available.'), 'String overwritten by imported string.');
     // This import should have changed number of plural forms.
-    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 3, t('Plural numbers changed.'));
+    $this->assert(db_query("SELECT plurals FROM {languages} WHERE language = 'fr'")->fetchField() == 3, 'Plural numbers changed.');
   }
 
   /**
@@ -1031,7 +1031,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
 
     // Ensure the translation file was automatically imported when language was
     // added.
-    $this->assertText(t('One translation file imported for the enabled modules.'), t('Language file automatically imported.'));
+    $this->assertText(t('One translation file imported for the enabled modules.'), 'Language file automatically imported.');
 
     // Ensure strings were successfully imported.
     $search = array(
@@ -1041,7 +1041,7 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
       'group' => 'all',
     );
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
-    $this->assertNoText(t('No strings available.'), t('String successfully imported.'));
+    $this->assertNoText(t('No strings available.'), 'String successfully imported.');
   }
 
   /**
@@ -1053,8 +1053,8 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
       'langcode' => 'hr',
     ));
 
-    $this->assertIdentical(t('May', array(), array('langcode' => 'hr', 'context' => 'Long month name')), 'Svibanj', t('Long month name context is working.'));
-    $this->assertIdentical(t('May', array(), array('langcode' => 'hr')), 'Svi.', t('Default context is working.'));
+    $this->assertIdentical(t('May', array(), array('langcode' => 'hr', 'context' => 'Long month name')), 'Svibanj', 'Long month name context is working.');
+    $this->assertIdentical(t('May', array(), array('langcode' => 'hr')), 'Svi.', 'Default context is working.');
   }
 
   /**
@@ -1068,15 +1068,15 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
       'langcode' => $langcode,
     ));
 
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 1, '%update' => 0, '%delete' => 0)), t('The translation file was successfully imported.'));
-    $this->assertIdentical(t('Operations', array(), array('langcode' => $langcode)), 'Műveletek', t('String imported and translated.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 1, '%update' => 0, '%delete' => 0)), 'The translation file was successfully imported.');
+    $this->assertIdentical(t('Operations', array(), array('langcode' => $langcode)), 'Műveletek', 'String imported and translated.');
 
     // Try importing a .po file.
     $this->importPoFile($this->getPoFileWithEmptyMsgstr(), array(
       'langcode' => $langcode,
       'mode' => 0,
     ));
-    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 0, '%update' => 0, '%delete' => 1)), t('The translation file was successfully imported.'));
+    $this->assertRaw(t('The translation was successfully imported. There are %number newly created translated strings, %update strings were updated and %delete strings were removed.', array('%number' => 0, '%update' => 0, '%delete' => 1)), 'The translation file was successfully imported.');
     // This is the language indicator on the translation search screen for
     // untranslated strings. Copied straight from locale.inc.
     $language_indicator = "<em class=\"locale-untranslated\">$langcode</em> ";
@@ -1090,8 +1090,8 @@ class LocaleImportFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/config/regional/translate/translate', $search, t('Filter'));
     // assertText() seems to remove the input field where $str always could be
     // found, so this is not a false assert.
-    $this->assertText($str, t('Search found the string.'));
-    $this->assertRaw($language_indicator, t('String is untranslated again.'));
+    $this->assertText($str, 'Search found the string.');
+    $this->assertRaw($language_indicator, 'String is untranslated again.');
   }
 
   /**
@@ -1344,9 +1344,9 @@ class LocaleExportFunctionalTest extends DrupalWebTestCase {
     ), t('Export'));
 
     // Ensure we have a translation file.
-    $this->assertRaw('# French translation of Drupal', t('Exported French translation file.'));
+    $this->assertRaw('# French translation of Drupal', 'Exported French translation file.');
     // Ensure our imported translations exist in the file.
-    $this->assertRaw('msgstr "lundi"', t('French translations present in exported file.'));
+    $this->assertRaw('msgstr "lundi"', 'French translations present in exported file.');
   }
 
   /**
@@ -1359,7 +1359,7 @@ class LocaleExportFunctionalTest extends DrupalWebTestCase {
     // doesn't work.
     $this->drupalPost('admin/config/regional/translate/export', array(), t('Export'));
     // Ensure we have a translation file.
-    $this->assertRaw('# LANGUAGE translation of PROJECT', t('Exported translation template file.'));
+    $this->assertRaw('# LANGUAGE translation of PROJECT', 'Exported translation template file.');
   }
 
   /**
@@ -1407,7 +1407,7 @@ class LocaleInstallTest extends DrupalWebTestCase {
   function testFunctionSignatures() {
     $reflector_t = new ReflectionFunction('t');
     $reflector_st = new ReflectionFunction('st');
-    $this->assertEqual($reflector_t->getParameters(), $reflector_st->getParameters(), t('Function signatures of t() and st() are equal.'));
+    $this->assertEqual($reflector_t->getParameters(), $reflector_st->getParameters(), 'Function signatures of t() and st() are equal.');
   }
 }
 
@@ -1446,7 +1446,7 @@ class LocaleUninstallFunctionalTest extends DrupalWebTestCase {
     // Check the UI language.
     drupal_language_initialize();
     global $language;
-    $this->assertEqual($language->language, $this->language, t('Current language: %lang', array('%lang' => $language->language)));
+    $this->assertEqual($language->language, $this->language, format_string('Current language: %lang', array('%lang' => $language->language)));
 
     // Enable multilingual workflow option for articles.
     variable_set('language_content_type_article', 1);
@@ -1467,7 +1467,7 @@ class LocaleUninstallFunctionalTest extends DrupalWebTestCase {
     _locale_rebuild_js('fr');
     $file = db_query('SELECT javascript FROM {languages} WHERE language = :language', array(':language' => 'fr'))->fetchObject();
     $js_file = 'public://' . variable_get('locale_js_directory', 'languages') . '/fr_' . $file->javascript . '.js';
-    $this->assertTrue($result = file_exists($js_file), t('JavaScript file created: %file', array('%file' => $result ? $js_file : t('none'))));
+    $this->assertTrue($result = file_exists($js_file), format_string('JavaScript file created: %file', array('%file' => $result ? $js_file : 'none')));
 
     // Disable string caching.
     variable_set('locale_cache_strings', 0);
@@ -1492,44 +1492,44 @@ class LocaleUninstallFunctionalTest extends DrupalWebTestCase {
 
     // Check the init language logic.
     drupal_language_initialize();
-    $this->assertEqual($language->language, 'en', t('Language after uninstall: %lang', array('%lang' => $language->language)));
+    $this->assertEqual($language->language, 'en', format_string('Language after uninstall: %lang', array('%lang' => $language->language)));
 
     // Check JavaScript files deletion.
-    $this->assertTrue($result = !file_exists($js_file), t('JavaScript file deleted: %file', array('%file' => $result ? $js_file : t('found'))));
+    $this->assertTrue($result = !file_exists($js_file), format_string('JavaScript file deleted: %file', array('%file' => $result ? $js_file : 'found')));
 
     // Check language count.
     $language_count = variable_get('language_count', 1);
-    $this->assertEqual($language_count, 1, t('Language count: %count', array('%count' => $language_count)));
+    $this->assertEqual($language_count, 1, format_string('Language count: %count', array('%count' => $language_count)));
 
     // Check language negotiation.
     require_once DRUPAL_ROOT . '/includes/language.inc';
-    $this->assertTrue(count(language_types()) == count(drupal_language_types()), t('Language types reset'));
+    $this->assertTrue(count(language_types()) == count(drupal_language_types()), 'Language types reset');
     $language_negotiation = language_negotiation_get(LANGUAGE_TYPE_INTERFACE) == LANGUAGE_NEGOTIATION_DEFAULT;
-    $this->assertTrue($language_negotiation, t('Interface language negotiation: %setting', array('%setting' => t($language_negotiation ? 'none' : 'set'))));
+    $this->assertTrue($language_negotiation, format_string('Interface language negotiation: %setting', array('%setting' => $language_negotiation ? 'none' : 'set')));
     $language_negotiation = language_negotiation_get(LANGUAGE_TYPE_CONTENT) == LANGUAGE_NEGOTIATION_DEFAULT;
-    $this->assertTrue($language_negotiation, t('Content language negotiation: %setting', array('%setting' => t($language_negotiation ? 'none' : 'set'))));
+    $this->assertTrue($language_negotiation, format_string('Content language negotiation: %setting', array('%setting' => $language_negotiation ? 'none' : 'set')));
     $language_negotiation = language_negotiation_get(LANGUAGE_TYPE_URL) == LANGUAGE_NEGOTIATION_DEFAULT;
-    $this->assertTrue($language_negotiation, t('URL language negotiation: %setting', array('%setting' => t($language_negotiation ? 'none' : 'set'))));
+    $this->assertTrue($language_negotiation, format_string('URL language negotiation: %setting', array('%setting' => $language_negotiation ? 'none' : 'set')));
 
     // Check language providers settings.
-    $this->assertFalse(variable_get('locale_language_negotiation_url_part', FALSE), t('URL language provider indicator settings cleared.'));
-    $this->assertFalse(variable_get('locale_language_negotiation_session_param', FALSE), t('Visit language provider settings cleared.'));
+    $this->assertFalse(variable_get('locale_language_negotiation_url_part', FALSE), 'URL language provider indicator settings cleared.');
+    $this->assertFalse(variable_get('locale_language_negotiation_session_param', FALSE), 'Visit language provider settings cleared.');
 
     // Check JavaScript parsed.
     $javascript_parsed_count = count(variable_get('javascript_parsed', array()));
-    $this->assertEqual($javascript_parsed_count, 0, t('JavaScript parsed count: %count', array('%count' => $javascript_parsed_count)));
+    $this->assertEqual($javascript_parsed_count, 0, format_string('JavaScript parsed count: %count', array('%count' => $javascript_parsed_count)));
 
     // Check multilingual workflow option for articles.
     $multilingual = variable_get('language_content_type_article', 0);
-    $this->assertEqual($multilingual, 0, t('Multilingual workflow option: %status', array('%status' => t($multilingual ? 'enabled': 'disabled'))));
+    $this->assertEqual($multilingual, 0, format_string('Multilingual workflow option: %status', array('%status' => $multilingual ? 'enabled': 'disabled')));
 
     // Check JavaScript translations directory.
     $locale_js_directory = variable_get('locale_js_directory', 'languages');
-    $this->assertEqual($locale_js_directory, 'languages', t('JavaScript translations directory: %dir', array('%dir' => $locale_js_directory)));
+    $this->assertEqual($locale_js_directory, 'languages', format_string('JavaScript translations directory: %dir', array('%dir' => $locale_js_directory)));
 
     // Check string caching.
     $locale_cache_strings = variable_get('locale_cache_strings', 1);
-    $this->assertEqual($locale_cache_strings, 1, t('String caching: %status', array('%status' => t($locale_cache_strings ? 'enabled': 'disabled'))));
+    $this->assertEqual($locale_cache_strings, 1, format_string('String caching: %status', array('%status' => $locale_cache_strings ? 'enabled': 'disabled')));
   }
 }
 
@@ -1600,7 +1600,7 @@ class LocaleLanguageSwitchingFunctionalTest extends DrupalWebTestCase {
 
     // Assert that the language switching block is displayed on the frontpage.
     $this->drupalGet('');
-    $this->assertText(t('Languages'), t('Language switcher block found.'));
+    $this->assertText(t('Languages'), 'Language switcher block found.');
 
     // Assert that only the current language is marked as active.
     list($language_switcher) = $this->xpath('//div[@id=:id]/div[@class="content"]', array(':id' => 'block-locale-' . $language_type));
@@ -1629,8 +1629,8 @@ class LocaleLanguageSwitchingFunctionalTest extends DrupalWebTestCase {
         $anchors['inactive'][] = $language;
       }
     }
-    $this->assertIdentical($links, array('active' => array('en'), 'inactive' => array('fr')), t('Only the current language list item is marked as active on the language switcher block.'));
-    $this->assertIdentical($anchors, array('active' => array('en'), 'inactive' => array('fr')), t('Only the current language anchor is marked as active on the language switcher block.'));
+    $this->assertIdentical($links, array('active' => array('en'), 'inactive' => array('fr')), 'Only the current language list item is marked as active on the language switcher block.');
+    $this->assertIdentical($anchors, array('active' => array('en'), 'inactive' => array('fr')), 'Only the current language anchor is marked as active on the language switcher block.');
   }
 }
 
@@ -1749,7 +1749,7 @@ class LocaleBrowserDetectionTest extends DrupalUnitTestCase {
     foreach ($test_cases as $accept_language => $expected_result) {
       $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $accept_language;
       $result = locale_language_from_browser($languages);
-      $this->assertIdentical($result, $expected_result, t("Language selection '@accept-language' selects '@result', result = '@actual'", array('@accept-language' => $accept_language, '@result' => $expected_result, '@actual' => isset($result) ? $result : 'none')));
+      $this->assertIdentical($result, $expected_result, format_string("Language selection '@accept-language' selects '@result', result = '@actual'", array('@accept-language' => $accept_language, '@result' => $expected_result, '@actual' => isset($result) ? $result : 'none')));
     }
   }
 }
@@ -1829,21 +1829,21 @@ class LocaleUserLanguageFunctionalTest extends DrupalWebTestCase {
     $path = 'user/' . $web_user->uid . '/edit';
     $this->drupalGet($path);
     // Ensure language settings fieldset is available.
-    $this->assertText(t('Language settings'), t('Language settings available.'));
+    $this->assertText(t('Language settings'), 'Language settings available.');
     // Ensure custom language is present.
-    $this->assertText($name, t('Language present on form.'));
+    $this->assertText($name, 'Language present on form.');
     // Ensure disabled language isn't present.
-    $this->assertNoText($name_disabled, t('Disabled language not present on form.'));
+    $this->assertNoText($name_disabled, 'Disabled language not present on form.');
     // Switch to our custom language.
     $edit = array(
       'language' => $langcode,
     );
     $this->drupalPost($path, $edit, t('Save'));
     // Ensure form was submitted successfully.
-    $this->assertText(t('The changes have been saved.'), t('Changes were saved.'));
+    $this->assertText(t('The changes have been saved.'), 'Changes were saved.');
     // Check if language was changed.
     $elements = $this->xpath('//input[@id=:id]', array(':id' => 'edit-language-' . $langcode));
-    $this->assertTrue(isset($elements[0]) && !empty($elements[0]['checked']), t('Default language successfully updated.'));
+    $this->assertTrue(isset($elements[0]) && !empty($elements[0]['checked']), 'Default language successfully updated.');
 
     $this->drupalLogout();
   }
@@ -1881,20 +1881,20 @@ class LocaleUserCreationTest extends DrupalWebTestCase {
       'langcode' => 'fr',
     );
     $this->drupalPost('admin/config/regional/language/add', $edit, t('Add language'));
-    $this->assertText($langcode, t('Language added successfully.'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertText($langcode, 'Language added successfully.');
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/language', array('absolute' => TRUE)), 'Correct page redirection.');
 
     // Set language negotiation.
     $edit = array(
       'language[enabled][locale-url]' => TRUE,
     );
     $this->drupalPost('admin/config/regional/language/configure', $edit, t('Save settings'));
-    $this->assertText(t('Language negotiation configuration saved.'), t('Set language negotiation.'));
+    $this->assertText(t('Language negotiation configuration saved.'), 'Set language negotiation.');
 
     // Check if the language selector is available on admin/people/create and
     // set to the currently active language.
     $this->drupalGet($langcode . '/admin/people/create');
-    $this->assertFieldChecked("edit-language-$langcode", t('Global language set in the language selector.'));
+    $this->assertFieldChecked("edit-language-$langcode", 'Global language set in the language selector.');
 
     // Create a user with the admin/people/create form and check if the correct
     // language is set.
@@ -1909,13 +1909,13 @@ class LocaleUserCreationTest extends DrupalWebTestCase {
     $this->drupalPost($langcode . '/admin/people/create', $edit, t('Create new account'));
 
     $user = user_load_by_name($username);
-    $this->assertEqual($user->language, $langcode, t('New user has correct language set.'));
+    $this->assertEqual($user->language, $langcode, 'New user has correct language set.');
 
     // Register a new user and check if the language selector is hidden.
     $this->drupalLogout();
 
     $this->drupalGet($langcode . '/user/register');
-    $this->assertNoFieldByName('language[fr]', t('Language selector is not accessible.'));
+    $this->assertNoFieldByName('language[fr]', 'Language selector is not accessible.');
 
     $username = $this->randomName(10);
     $edit = array(
@@ -1926,7 +1926,7 @@ class LocaleUserCreationTest extends DrupalWebTestCase {
     $this->drupalPost($langcode . '/user/register', $edit, t('Create new account'));
 
     $user = user_load_by_name($username);
-    $this->assertEqual($user->language, $langcode, t('New user has correct language set.'));
+    $this->assertEqual($user->language, $langcode, 'New user has correct language set.');
 
     // Test if the admin can use the language selector and if the
     // correct language is was saved.
@@ -1934,7 +1934,7 @@ class LocaleUserCreationTest extends DrupalWebTestCase {
 
     $this->drupalLogin($admin_user);
     $this->drupalGet($user_edit);
-    $this->assertFieldChecked("edit-language-$langcode", t('Language selector is accessible and correct language is selected.'));
+    $this->assertFieldChecked("edit-language-$langcode", 'Language selector is accessible and correct language is selected.');
 
     // Set pass_raw so we can login the new user.
     $user->pass_raw = $this->randomName(10);
@@ -1947,7 +1947,7 @@ class LocaleUserCreationTest extends DrupalWebTestCase {
 
     $this->drupalLogin($user);
     $this->drupalGet($user_edit);
-    $this->assertFieldChecked("edit-language-$langcode", t('Language selector is accessible and correct language is selected.'));
+    $this->assertFieldChecked("edit-language-$langcode", 'Language selector is accessible and correct language is selected.');
   }
 }
 
@@ -1999,7 +1999,7 @@ class LocalePathFunctionalTest extends DrupalWebTestCase {
     // not enabled yet.
     $this->drupalPost('admin/config/regional/language/configure', array(), t('Save settings'));
     $this->drupalGet($prefix);
-    $this->assertResponse(404, t('The "xx" front page is not available yet.'));
+    $this->assertResponse(404, 'The "xx" front page is not available yet.');
 
     // Enable URL language detection and selection.
     $edit = array('language[enabled][locale-url]' => 1);
@@ -2029,11 +2029,11 @@ class LocalePathFunctionalTest extends DrupalWebTestCase {
 
     // Confirm English language path alias works.
     $this->drupalGet($english_path);
-    $this->assertText($node->title, t('English alias works.'));
+    $this->assertText($node->title, 'English alias works.');
 
     // Confirm custom language path alias works.
     $this->drupalGet($prefix . '/' . $custom_language_path);
-    $this->assertText($node->title, t('Custom language alias works.'));
+    $this->assertText($node->title, 'Custom language alias works.');
 
     // Create a custom path.
     $custom_path = $this->randomName(8);
@@ -2046,10 +2046,10 @@ class LocalePathFunctionalTest extends DrupalWebTestCase {
     );
     path_save($edit);
     $lookup_path = drupal_lookup_path('alias', 'node/' . $node->nid, 'en');
-    $this->assertEqual($english_path, $lookup_path, t('English language alias has priority.'));
+    $this->assertEqual($english_path, $lookup_path, 'English language alias has priority.');
     // Same check for language 'xx'.
     $lookup_path = drupal_lookup_path('alias', 'node/' . $node->nid, $prefix);
-    $this->assertEqual($custom_language_path, $lookup_path, t('Custom language alias has priority.'));
+    $this->assertEqual($custom_language_path, $lookup_path, 'Custom language alias has priority.');
     path_delete($edit);
 
     // Create language nodes to check priority of aliases.
@@ -2076,17 +2076,17 @@ class LocalePathFunctionalTest extends DrupalWebTestCase {
     $this->drupalGet('<front>');
     $custom_path_url = base_path() . (variable_get('clean_url', 0) ? $custom_path : '?q=' . $custom_path);
     $elements = $this->xpath('//a[@href=:href and .=:title]', array(':href' => $custom_path_url, ':title' => $first_node->title));
-    $this->assertTrue(!empty($elements), t('First node links to the path alias.'));
+    $this->assertTrue(!empty($elements), 'First node links to the path alias.');
     $elements = $this->xpath('//a[@href=:href and .=:title]', array(':href' => $custom_path_url, ':title' => $second_node->title));
-    $this->assertTrue(!empty($elements), t('Second node links to the path alias.'));
+    $this->assertTrue(!empty($elements), 'Second node links to the path alias.');
 
     // Confirm that the custom path leads to the first node.
     $this->drupalGet($custom_path);
-    $this->assertText($first_node->title, t('Custom alias returns first node.'));
+    $this->assertText($first_node->title, 'Custom alias returns first node.');
 
     // Confirm that the custom path with prefix leads to the second node.
     $this->drupalGet($prefix . '/' . $custom_path);
-    $this->assertText($second_node->title, t('Custom alias with prefix returns second node.'));
+    $this->assertText($second_node->title, 'Custom alias with prefix returns second node.');
   }
 }
 
@@ -2191,28 +2191,28 @@ class LocaleContentFunctionalTest extends DrupalWebTestCase {
 
     // Set "Basic page" content type to use multilingual support.
     $this->drupalGet('admin/structure/types/manage/page');
-    $this->assertText(t('Multilingual support'), t('Multilingual support fieldset present on content type configuration form.'));
+    $this->assertText(t('Multilingual support'), 'Multilingual support fieldset present on content type configuration form.');
     $edit = array(
       'language_content_type' => 1,
     );
     $this->drupalPost('admin/structure/types/manage/page', $edit, t('Save content type'));
-    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Basic page')), t('Basic page content type has been updated.'));
+    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Basic page')), 'Basic page content type has been updated.');
     $this->drupalLogout();
 
     // Verify language selection is not present on add article form.
     $this->drupalLogin($web_user);
     $this->drupalGet('node/add/article');
     // Verify language select list is not present.
-    $this->assertNoFieldByName('language', NULL, t('Language select not present on add article form.'));
+    $this->assertNoFieldByName('language', NULL, 'Language select not present on add article form.');
 
     // Verify language selection appears on add "Basic page" form.
     $this->drupalGet('node/add/page');
     // Verify language select list is present.
-    $this->assertFieldByName('language', NULL, t('Language select present on add Basic page form.'));
+    $this->assertFieldByName('language', NULL, 'Language select present on add Basic page form.');
     // Ensure enabled language appears.
-    $this->assertText($name, t('Enabled language present.'));
+    $this->assertText($name, 'Enabled language present.');
     // Ensure disabled language doesn't appear.
-    $this->assertNoText($name_disabled, t('Disabled language not present.'));
+    $this->assertNoText($name_disabled, 'Disabled language not present.');
 
     // Create "Basic page" content.
     $node_title = $this->randomName();
@@ -2227,13 +2227,13 @@ class LocaleContentFunctionalTest extends DrupalWebTestCase {
     // Edit the content and ensure correct language is selected.
     $path = 'node/' . $node->nid . '/edit';
     $this->drupalGet($path);
-    $this->assertRaw('<option value="' . $langcode . '" selected="selected">' .  $name . '</option>', t('Correct language selected.'));
+    $this->assertRaw('<option value="' . $langcode . '" selected="selected">' .  $name . '</option>', 'Correct language selected.');
     // Ensure we can change the node language.
     $edit = array(
       'language' => 'en',
     );
     $this->drupalPost($path, $edit, t('Save'));
-    $this->assertRaw(t('%title has been updated.', array('%title' => $node_title)), t('Basic page content updated.'));
+    $this->assertRaw(t('%title has been updated.', array('%title' => $node_title)), 'Basic page content updated.');
 
     $this->drupalLogout();
   }
@@ -2484,11 +2484,11 @@ class LocaleUILanguageNegotiationTest extends DrupalWebTestCase {
     // language.
     $args = array(':url' => base_path() . (!empty($GLOBALS['conf']['clean_url']) ? $language_browser_fallback : "?q=$language_browser_fallback"));
     $fields = $this->xpath('//div[@id="block-locale-language"]//a[@class="language-link active" and @href=:url]', $args);
-    $this->assertTrue($fields[0] == $languages[$language_browser_fallback]->native, t('The browser language is the URL active language'));
+    $this->assertTrue($fields[0] == $languages[$language_browser_fallback]->native, 'The browser language is the URL active language');
 
     // Check that URLs are rewritten using the given browser language.
     $fields = $this->xpath('//div[@id="site-name"]//a[@rel="home" and @href=:url]//span', $args);
-    $this->assertTrue($fields[0] == 'Drupal', t('URLs are rewritten using the browser language.'));
+    $this->assertTrue($fields[0] == 'Drupal', 'URLs are rewritten using the browser language.');
   }
 
   /**
@@ -2522,13 +2522,13 @@ class LocaleUILanguageNegotiationTest extends DrupalWebTestCase {
       $url = url('admin', array('language' => $languages[$langcode]));
       $url_scheme = ($is_https) ? 'https://' : 'http://';
       $correct_link = $url_scheme . $link;
-      $this->assertTrue($url == $correct_link, t('The url() function returns the right url (@url) in accordance with the chosen language', array('@url' => $url . " == " . $correct_link)));
+      $this->assertTrue($url == $correct_link, format_string('The url() function returns the right url (@url) in accordance with the chosen language', array('@url' => $url . " == " . $correct_link)));
 
       // Test HTTPS via options.
       variable_set('https', TRUE);
       $url = url('admin', array('https' => TRUE, 'language' => $languages[$langcode]));
       $correct_link = 'https://' . $link;
-      $this->assertTrue($url == $correct_link, t('The url() function returns the right https url (via options) (@url) in accordance with the chosen language', array('@url' => $url . " == " . $correct_link)));
+      $this->assertTrue($url == $correct_link, format_string('The url() function returns the right https url (via options) (@url) in accordance with the chosen language', array('@url' => $url . " == " . $correct_link)));
       variable_set('https', FALSE);
 
       // Test HTTPS via current URL scheme.
@@ -2536,7 +2536,7 @@ class LocaleUILanguageNegotiationTest extends DrupalWebTestCase {
       $is_https = TRUE;
       $url = url('admin', array('language' => $languages[$langcode]));
       $correct_link = 'https://' . $link;
-      $this->assertTrue($url == $correct_link, t('The url() function returns the right url (via current url scheme) (@url) in accordance with the chosen language', array('@url' => $url . " == " . $correct_link)));
+      $this->assertTrue($url == $correct_link, format_string('The url() function returns the right url (via current url scheme) (@url) in accordance with the chosen language', array('@url' => $url . " == " . $correct_link)));
       $is_https = $temp_https;
     }
   }
@@ -2591,13 +2591,13 @@ class LocaleUrlRewritingTest extends DrupalWebTestCase {
   function testUrlRewritingEdgeCases() {
     // Check URL rewriting with a disabled language.
     $languages = language_list();
-    $this->checkUrl($languages['it'], t('Path language is ignored if language is disabled.'), t('URL language negotiation does not work with disabled languages'));
+    $this->checkUrl($languages['it'], 'Path language is ignored if language is disabled.', 'URL language negotiation does not work with disabled languages');
 
     // Check URL rewriting with a non-installed language.
     $non_existing = language_default();
     $non_existing->language = $this->randomName();
     $non_existing->prefix = $this->randomName();
-    $this->checkUrl($non_existing, t('Path language is ignored if language is not installed.'), t('URL language negotiation does not work with non-installed languages'));
+    $this->checkUrl($non_existing, 'Path language is ignored if language is not installed.', 'URL language negotiation does not work with non-installed languages');
   }
 
   /**
@@ -2606,6 +2606,13 @@ class LocaleUrlRewritingTest extends DrupalWebTestCase {
    * The test is performed with a fixed URL (the default front page) to simply
    * check that language prefixes are not added to it and that the prefixed URL
    * is actually not working.
+   *
+   * @param string $language
+   *   The language prefix, e.g. 'es'.
+   * @param string $message1
+   *   Message to display in assertion that language prefixes are not added.
+   * @param string $message2
+   *   The message to display confirming prefixed URL is not working.
    */
   private function checkUrl($language, $message1, $message2) {
     $options = array('language' => $language);
@@ -2655,7 +2662,7 @@ class LocaleMultilingualFieldsFunctionalTest extends DrupalWebTestCase {
       'language_content_type' => 1,
     );
     $this->drupalPost('admin/structure/types/manage/page', $edit, t('Save content type'));
-    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Basic page')), t('Basic page content type has been updated.'));
+    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Basic page')), 'Basic page content type has been updated.');
 
     // Make node body translatable.
     $field = field_info_field('body');
@@ -2683,10 +2690,10 @@ class LocaleMultilingualFieldsFunctionalTest extends DrupalWebTestCase {
 
     // Check that the node exists in the database.
     $node = $this->drupalGetNodeByTitle($edit[$title_key]);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
 
     $assert = isset($node->body['en']) && !isset($node->body[LANGUAGE_NONE]) && $node->body['en'][0]['value'] == $body_value;
-    $this->assertTrue($assert, t('Field language correctly set.'));
+    $this->assertTrue($assert, 'Field language correctly set.');
 
     // Change node language.
     $this->drupalGet("node/$node->nid/edit");
@@ -2696,20 +2703,20 @@ class LocaleMultilingualFieldsFunctionalTest extends DrupalWebTestCase {
     );
     $this->drupalPost(NULL, $edit, t('Save'));
     $node = $this->drupalGetNodeByTitle($edit[$title_key]);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
 
     $assert = isset($node->body['it']) && !isset($node->body['en']) && $node->body['it'][0]['value'] == $body_value;
-    $this->assertTrue($assert, t('Field language correctly changed.'));
+    $this->assertTrue($assert, 'Field language correctly changed.');
 
     // Enable content language URL detection.
     language_negotiation_set(LANGUAGE_TYPE_CONTENT, array(LOCALE_LANGUAGE_NEGOTIATION_URL => 0));
 
     // Test multilingual field language fallback logic.
     $this->drupalGet("it/node/$node->nid");
-    $this->assertRaw($body_value, t('Body correctly displayed using Italian as requested language'));
+    $this->assertRaw($body_value, 'Body correctly displayed using Italian as requested language');
 
     $this->drupalGet("node/$node->nid");
-    $this->assertRaw($body_value, t('Body correctly displayed using English as requested language'));
+    $this->assertRaw($body_value, 'Body correctly displayed using English as requested language');
   }
 
   /*
@@ -2732,7 +2739,7 @@ class LocaleMultilingualFieldsFunctionalTest extends DrupalWebTestCase {
 
     // Check that the node exists in the database.
     $node = $this->drupalGetNodeByTitle($edit[$title_key]);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
 
     // Check if node body is showed.
     $this->drupalGet("node/$node->nid");
@@ -2758,7 +2765,7 @@ class LocaleCommentLanguageFunctionalTest extends DrupalWebTestCase {
     parent::setUp('locale', 'locale_test');
 
     // Create and login user.
-    $admin_user = $this->drupalCreateUser(array('administer site configuration', 'administer languages', 'access administration pages', 'administer content types', 'create article content'));
+    $admin_user = $this->drupalCreateUser(array('administer site configuration', 'administer languages', 'access administration pages', 'administer content types', 'administer comments', 'create article content'));
     $this->drupalLogin($admin_user);
 
     // Add language.
@@ -2787,6 +2794,12 @@ class LocaleCommentLanguageFunctionalTest extends DrupalWebTestCase {
     // French no matter what path prefix the URLs have.
     $edit = array('language' => 'fr');
     $this->drupalPost("user/{$admin_user->uid}/edit", $edit, t('Save'));
+
+    // Make comment body translatable.
+    $field = field_info_field('comment_body');
+    $field['translatable'] = TRUE;
+    field_update_field($field);
+    $this->assertTrue(field_is_translatable('comment', $field), 'Comment body is translatable.');
   }
 
   /**
@@ -2817,22 +2830,46 @@ class LocaleCommentLanguageFunctionalTest extends DrupalWebTestCase {
       foreach (language_list() as $langcode => $language) {
         // Post a comment with content language $langcode.
         $prefix = empty($language->prefix) ? '' : $language->prefix . '/';
-        $edit = array("comment_body[$language_none][0][value]" => $this->randomName());
-        $this->drupalPost("{$prefix}node/{$node->nid}", $edit, t('Save'));
+        $comment_values[$node_langcode][$langcode] = $this->randomName();
+        // Initially field form widgets have no language.
+        $edit = array(
+          'subject' => $this->randomName(),
+          "comment_body[$language_none][0][value]" => $comment_values[$node_langcode][$langcode],
+        );
+        $this->drupalPost("{$prefix}node/{$node->nid}", $edit, t('Preview'));
+        // After the first submit the submitted entity language is taken into
+        // account.
+        $edit = array(
+          'subject' => $edit['subject'],
+          "comment_body[$langcode][0][value]" => $comment_values[$node_langcode][$langcode],
+        );
+        $this->drupalPost(NULL, $edit, t('Save'));
 
         // Check that comment language matches the current content language.
-        $comment = db_select('comment', 'c')
-          ->fields('c')
+        $cid = db_select('comment', 'c')
+          ->fields('c', array('cid'))
           ->condition('nid', $node->nid)
           ->orderBy('cid', 'DESC')
+          ->range(0, 1)
           ->execute()
-          ->fetchObject();
+          ->fetchField();
+        $comment = comment_load($cid);
         $comment_langcode = entity_language('comment', $comment);
         $args = array('%node_language' => $node_langcode, '%comment_language' => $comment_langcode, '%langcode' => $langcode);
-        $this->assertEqual($comment_langcode, $langcode, t('The comment posted with content language %langcode and belonging to the node with language %node_language has language %comment_language', $args));
+        $this->assertEqual($comment_langcode, $langcode, format_string('The comment posted with content language %langcode and belonging to the node with language %node_language has language %comment_language', $args));
+        $this->assertEqual($comment->comment_body[$langcode][0]['value'], $comment_values[$node_langcode][$langcode], 'Comment body correctly stored.');
+      }
+    }
+
+    // Check that comment bodies appear in the administration UI.
+    $this->drupalGet('admin/content/comment');
+    foreach ($comment_values as $node_values) {
+      foreach ($node_values as $value) {
+        $this->assertRaw($value);
       }
     }
   }
+
 }
 
 /**
@@ -2897,10 +2934,10 @@ class LocaleDateFormatsFunctionalTest extends DrupalWebTestCase {
     // Configure format for the node posted date changes with the language.
     $this->drupalGet('node/' . $node->nid);
     $english_date = format_date($node->created, 'custom', 'j M Y');
-    $this->assertText($english_date, t('English date format appears'));
+    $this->assertText($english_date, 'English date format appears');
     $this->drupalGet('fr/node/' . $node->nid);
     $french_date = format_date($node->created, 'custom', 'd.m.Y');
-    $this->assertText($french_date, t('French date format appears'));
+    $this->assertText($french_date, 'French date format appears');
   }
 }
 
@@ -2944,7 +2981,7 @@ class LocaleLanguageNegotiationInfoFunctionalTest extends DrupalWebTestCase {
     $this->languageNegotiationUpdate();
     $type = LANGUAGE_TYPE_CONTENT;
     $language_types = variable_get('language_types', drupal_language_types());
-    $this->assertTrue($language_types[$type], t('Content language type is configurable.'));
+    $this->assertTrue($language_types[$type], 'Content language type is configurable.');
 
     // Enable some core and custom language providers. The test language type is
     // supposed to be configurable.
@@ -2964,18 +3001,18 @@ class LocaleLanguageNegotiationInfoFunctionalTest extends DrupalWebTestCase {
     variable_set('locale_test_language_negotiation_info_alter', TRUE);
     $this->languageNegotiationUpdate();
     $negotiation = variable_get("language_negotiation_$type", array());
-    $this->assertFalse(isset($negotiation[$provider]), t('Interface language provider removed from the stored settings.'));
-    $this->assertNoFieldByXPath("//input[@name=\"$form_field\"]", NULL, t('Interface language provider unavailable.'));
+    $this->assertFalse(isset($negotiation[$provider]), 'Interface language provider removed from the stored settings.');
+    $this->assertNoFieldByXPath("//input[@name=\"$form_field\"]", NULL, 'Interface language provider unavailable.');
 
     // Check that type-specific language providers can be assigned only to the
     // corresponding language types.
     foreach (language_types_configurable() as $type) {
       $form_field = $type . '[enabled][test_language_provider_ts]';
       if ($type == $test_type) {
-        $this->assertFieldByXPath("//input[@name=\"$form_field\"]", NULL, t('Type-specific test language provider available for %type.', array('%type' => $type)));
+        $this->assertFieldByXPath("//input[@name=\"$form_field\"]", NULL, format_string('Type-specific test language provider available for %type.', array('%type' => $type)));
       }
       else {
-        $this->assertNoFieldByXPath("//input[@name=\"$form_field\"]", NULL, t('Type-specific test language provider unavailable for %type.', array('%type' => $type)));
+        $this->assertNoFieldByXPath("//input[@name=\"$form_field\"]", NULL, format_string('Type-specific test language provider unavailable for %type.', array('%type' => $type)));
       }
     }
 
@@ -2985,7 +3022,7 @@ class LocaleLanguageNegotiationInfoFunctionalTest extends DrupalWebTestCase {
     foreach (language_types() as $type) {
       $langcode = $last[$type];
       $value = $type == LANGUAGE_TYPE_CONTENT || strpos($type, 'test') !== FALSE ? 'it' : 'en';
-      $this->assertEqual($langcode, $value, t('The negotiated language for %type is %language', array('%type' => $type, '%language' => $langcode)));
+      $this->assertEqual($langcode, $value, format_string('The negotiated language for %type is %language', array('%type' => $type, '%language' => $langcode)));
     }
 
     // Disable locale_test and check that everything is set back to the original
@@ -2994,7 +3031,7 @@ class LocaleLanguageNegotiationInfoFunctionalTest extends DrupalWebTestCase {
 
     // Check that only the core language types are available.
     foreach (language_types() as $type) {
-      $this->assertTrue(strpos($type, 'test') === FALSE, t('The %type language is still available', array('%type' => $type)));
+      $this->assertTrue(strpos($type, 'test') === FALSE, format_string('The %type language is still available', array('%type' => $type)));
     }
 
     // Check that fixed language types are properly configured, even those
@@ -3004,11 +3041,11 @@ class LocaleLanguageNegotiationInfoFunctionalTest extends DrupalWebTestCase {
     // Check that unavailable language providers are not present in the
     // negotiation settings.
     $negotiation = variable_get("language_negotiation_$type", array());
-    $this->assertFalse(isset($negotiation[$test_provider]), t('The disabled test language provider is not part of the content language negotiation settings.'));
+    $this->assertFalse(isset($negotiation[$test_provider]), 'The disabled test language provider is not part of the content language negotiation settings.');
 
     // Check that configuration page presents the correct options and settings.
-    $this->assertNoRaw(t('Test language detection'), t('No test language type configuration available.'));
-    $this->assertNoRaw(t('This is a test language provider'), t('No test language provider available.'));
+    $this->assertNoRaw(t('Test language detection'), 'No test language type configuration available.');
+    $this->assertNoRaw(t('This is a test language provider'), 'No test language provider available.');
   }
 
   /**
@@ -3053,9 +3090,54 @@ class LocaleLanguageNegotiationInfoFunctionalTest extends DrupalWebTestCase {
           list(, $info_id) = each($info['fixed']);
           $equal = $info_id == $id;
         }
-        $this->assertTrue($equal, t('language negotiation for %type is properly set up', array('%type' => $type)));
+        $this->assertTrue($equal, format_string('language negotiation for %type is properly set up', array('%type' => $type)));
       }
     }
   }
 }
 
+/**
+ * Functional tests for CSS alter functions.
+ */
+class LocaleCSSAlterTest extends DrupalWebTestCase {
+  public static function getInfo() {
+    return array(
+      'name' => 'CSS altering',
+      'description' => 'Test CSS alter functions.',
+      'group' => 'Locale',
+    );
+  }
+
+  function setUp() {
+    parent::setUp('locale');
+  }
+
+  /**
+   * Verifies that -rtl.css file is added directly after LTR .css file.
+   */
+  function testCSSFilesOrderInRTLMode() {
+    global $base_url;
+
+    // User to add and remove language.
+    $admin_user = $this->drupalCreateUser(array('administer languages', 'administer content types', 'access administration pages'));
+
+    // Log in as admin.
+    $this->drupalLogin($admin_user);
+
+    // Install the Arabic language (which is RTL) and configure as the default.
+    $edit = array();
+    $edit['langcode'] = 'ar';
+    $this->drupalPost('admin/config/regional/language/add', $edit, t('Add language'));
+
+    $edit = array();
+    $edit['site_default'] = 'ar';
+    $this->drupalPost(NULL, $edit, t('Save configuration'));
+
+    // Verify that the -rtl.css file is added directly after LTR file.
+    $this->drupalGet('');
+    $query_string = '?' . variable_get('css_js_query_string', '0');
+    $this->assertRaw('@import url("' . $base_url . '/modules/system/system.base.css' . $query_string . '");' . "\n" . '@import url("' . $base_url . '/modules/system/system.base-rtl.css' . $query_string . '");' . "\n", 'CSS: system.base-rtl.css is added directly after system.base.css.');
+    $this->assertRaw('@import url("' . $base_url . '/modules/system/system.menus.css' . $query_string . '");' . "\n" . '@import url("' . $base_url . '/modules/system/system.menus-rtl.css' . $query_string . '");' . "\n", 'CSS: system.menus-rtl.css is added directly after system.menus.css.');
+    $this->assertRaw('@import url("' . $base_url . '/modules/system/system.messages.css' . $query_string . '");' . "\n" . '@import url("' . $base_url . '/modules/system/system.messages-rtl.css' . $query_string . '");' . "\n", 'CSS: system.messages-rtl.css is added directly after system.messages.css.');
+  }
+}
diff --git a/modules/menu/menu.admin.inc b/modules/menu/menu.admin.inc
index 5ac755e..68d8e12 100644
--- a/modules/menu/menu.admin.inc
+++ b/modules/menu/menu.admin.inc
@@ -395,7 +395,7 @@ function menu_edit_item_validate($form, &$form_state) {
     else {
       unset($item['options']['fragment']);
     }
-    if ($item['link_path'] != $parsed_link['path']) {
+    if (isset($parsed_link['path']) && $item['link_path'] != $parsed_link['path']) {
       $item['link_path'] = $parsed_link['path'];
     }
   }
diff --git a/modules/menu/menu.api.php b/modules/menu/menu.api.php
index 3f3818e..22d93ef 100644
--- a/modules/menu/menu.api.php
+++ b/modules/menu/menu.api.php
@@ -11,7 +11,7 @@
  */
 
 /**
- * Informs modules that a custom menu was created.
+ * Respond to a custom menu creation.
  *
  * This hook is used to notify modules that a custom menu has been created.
  * Contributed modules may use the information to perform actions based on the
@@ -34,7 +34,7 @@ function hook_menu_insert($menu) {
 }
 
 /**
- * Informs modules that a custom menu was updated.
+ * Respond to a custom menu update.
  *
  * This hook is used to notify modules that a custom menu has been updated.
  * Contributed modules may use the information to perform actions based on the
@@ -59,14 +59,14 @@ function hook_menu_update($menu) {
 }
 
 /**
- * Informs modules that a custom menu was deleted.
+ * Respond to a custom menu deletion.
  *
  * This hook is used to notify modules that a custom menu along with all links
  * contained in it (if any) has been deleted. Contributed modules may use the
  * information to perform actions based on the information entered into the menu
  * system.
  *
- * @param $link
+ * @param $menu
  *   An array representing a custom menu:
  *   - menu_name: The unique name of the custom menu.
  *   - title: The human readable menu title.
diff --git a/modules/menu/menu.test b/modules/menu/menu.test
index 324ba67..95e0ee9 100644
--- a/modules/menu/menu.test
+++ b/modules/menu/menu.test
@@ -70,7 +70,7 @@ class MenuTestCase extends DrupalWebTestCase {
     $item['options']['attributes']['title']  = $description;
     menu_link_save($item);
     $saved_item = menu_link_load($item['mlid']);
-    $this->assertEqual($description, $saved_item['options']['attributes']['title'], t('Saving an existing link updates the description (title attribute)'));
+    $this->assertEqual($description, $saved_item['options']['attributes']['title'], 'Saving an existing link updates the description (title attribute)');
     $this->resetMenuLink($item, $old_title);
   }
 
@@ -111,14 +111,14 @@ class MenuTestCase extends DrupalWebTestCase {
 
     // Assert the new menu.
     $this->drupalGet('admin/structure/menu/manage/' . $menu_name . '/edit');
-    $this->assertRaw($title, t('Custom menu was added.'));
+    $this->assertRaw($title, 'Custom menu was added.');
 
     // Edit the menu.
     $new_title = $this->randomName(16);
     $menu['title'] = $new_title;
     menu_save($menu);
     $this->drupalGet('admin/structure/menu/manage/' . $menu_name . '/edit');
-    $this->assertRaw($new_title, t('Custom menu was edited.'));
+    $this->assertRaw($new_title, 'Custom menu was edited.');
   }
 
   /**
@@ -167,7 +167,7 @@ class MenuTestCase extends DrupalWebTestCase {
     $edit['blocks[menu_' . $menu_name . '][region]'] = 'sidebar_first';
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
     $this->assertResponse(200);
-    $this->assertText(t('The block settings have been updated.'), t('Custom menu block was enabled'));
+    $this->assertText(t('The block settings have been updated.'), 'Custom menu block was enabled');
 
     return menu_load($menu_name);
   }
@@ -184,11 +184,11 @@ class MenuTestCase extends DrupalWebTestCase {
     // Delete custom menu.
     $this->drupalPost("admin/structure/menu/manage/$menu_name/delete", array(), t('Delete'));
     $this->assertResponse(200);
-    $this->assertRaw(t('The custom menu %title has been deleted.', array('%title' => $title)), t('Custom menu was deleted'));
+    $this->assertRaw(t('The custom menu %title has been deleted.', array('%title' => $title)), 'Custom menu was deleted');
     $this->assertFalse(menu_load($menu_name), 'Custom menu was deleted');
     // Test if all menu links associated to the menu were removed from database.
     $result = db_query("SELECT menu_name FROM {menu_links} WHERE menu_name = :menu_name", array(':menu_name' => $menu_name))->fetchField();
-    $this->assertFalse($result, t('All menu links associated to the custom menu were deleted.'));
+    $this->assertFalse($result, 'All menu links associated to the custom menu were deleted.');
   }
 
   /**
@@ -266,13 +266,13 @@ class MenuTestCase extends DrupalWebTestCase {
     $item = $this->addMenuLink(0, $path);
 
     $this->drupalGet('admin/structure/menu/item/' . $item['mlid'] . '/edit');
-    $this->assertFieldByName('link_path', $path, t('Path is found with both query and fragment.'));
+    $this->assertFieldByName('link_path', $path, 'Path is found with both query and fragment.');
 
     // Now change the path to something without query and fragment.
     $path = 'node';
     $this->drupalPost('admin/structure/menu/item/' . $item['mlid'] . '/edit', array('link_path' => $path), t('Save'));
     $this->drupalGet('admin/structure/menu/item/' . $item['mlid'] . '/edit');
-    $this->assertFieldByName('link_path', $path, t('Path no longer has query or fragment.'));
+    $this->assertFieldByName('link_path', $path, 'Path no longer has query or fragment.');
   }
 
   /**
@@ -318,7 +318,7 @@ class MenuTestCase extends DrupalWebTestCase {
    * @param string $menu_name Menu name.
    */
   function addInvalidMenuLink($menu_name = 'navigation') {
-    foreach (array('-&-', 'admin/people/permissions') as $link_path) {
+    foreach (array('-&-', 'admin/people/permissions', '#') as $link_path) {
       $edit = array(
         'link_path' => $link_path,
         'link_title' => 'title',
@@ -350,7 +350,7 @@ class MenuTestCase extends DrupalWebTestCase {
       // Verify menu link link.
       $this->clickLink($title);
       $title = $parent_node->title;
-      $this->assertTitle(t("@title | Drupal", array('@title' => $title)), t('Parent menu link link target was correct'));
+      $this->assertTitle(t("@title | Drupal", array('@title' => $title)), 'Parent menu link link target was correct');
     }
 
     // Verify menu link.
@@ -360,7 +360,7 @@ class MenuTestCase extends DrupalWebTestCase {
     // Verify menu link link.
     $this->clickLink($title);
     $title = $item_node->title;
-    $this->assertTitle(t("@title | Drupal", array('@title' => $title)), t('Menu link link target was correct'));
+    $this->assertTitle(t("@title | Drupal", array('@title' => $title)), 'Menu link link target was correct');
   }
 
   /**
@@ -412,7 +412,7 @@ class MenuTestCase extends DrupalWebTestCase {
     // Reset menu link.
     $this->drupalPost("admin/structure/menu/item/$mlid/reset", array(), t('Reset'));
     $this->assertResponse(200);
-    $this->assertRaw(t('The menu link was reset to its default settings.'), t('Menu link was reset'));
+    $this->assertRaw(t('The menu link was reset to its default settings.'), 'Menu link was reset');
 
     // Verify menu link.
     $this->drupalGet('');
@@ -432,7 +432,7 @@ class MenuTestCase extends DrupalWebTestCase {
     // Delete menu link.
     $this->drupalPost("admin/structure/menu/item/$mlid/delete", array(), t('Confirm'));
     $this->assertResponse(200);
-    $this->assertRaw(t('The menu link %title has been deleted.', array('%title' => $title)), t('Menu link was deleted'));
+    $this->assertRaw(t('The menu link %title has been deleted.', array('%title' => $title)), 'Menu link was deleted');
 
     // Verify deletion.
     $this->drupalGet('');
@@ -509,7 +509,7 @@ class MenuTestCase extends DrupalWebTestCase {
       $item['link_path'] .= '#' . $options['fragment'];
     }
     foreach ($expected_item as $key => $value) {
-      $this->assertEqual($item[$key], $value, t('Parameter %key had expected value.', array('%key' => $key)));
+      $this->assertEqual($item[$key], $value, format_string('Parameter %key had expected value.', array('%key' => $key)));
     }
   }
 
@@ -537,21 +537,21 @@ class MenuTestCase extends DrupalWebTestCase {
     $this->drupalGet('admin/help/menu');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Menu'), t('Menu help was displayed'));
+      $this->assertText(t('Menu'), 'Menu help was displayed');
     }
 
     // View menu build overview node.
     $this->drupalGet('admin/structure/menu');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Menus'), t('Menu build overview node was displayed'));
+      $this->assertText(t('Menus'), 'Menu build overview node was displayed');
     }
 
     // View navigation menu customization node.
     $this->drupalGet('admin/structure/menu/manage/navigation');
         $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Navigation'), t('Navigation menu node was displayed'));
+      $this->assertText(t('Navigation'), 'Navigation menu node was displayed');
     }
 
     // View menu edit node.
@@ -559,21 +559,21 @@ class MenuTestCase extends DrupalWebTestCase {
     $this->drupalGet('admin/structure/menu/item/' . $item['mlid'] . '/edit');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Edit menu item'), t('Menu edit node was displayed'));
+      $this->assertText(t('Edit menu item'), 'Menu edit node was displayed');
     }
 
     // View menu settings node.
     $this->drupalGet('admin/structure/menu/settings');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Menus'), t('Menu settings node was displayed'));
+      $this->assertText(t('Menus'), 'Menu settings node was displayed');
     }
 
     // View add menu node.
     $this->drupalGet('admin/structure/menu/add');
     $this->assertResponse($response);
     if ($response == 200) {
-      $this->assertText(t('Menus'), t('Add menu node was displayed'));
+      $this->assertText(t('Menus'), 'Add menu node was displayed');
     }
   }
 }
@@ -654,7 +654,7 @@ class MenuNodeTestCase extends DrupalWebTestCase {
     $this->assertLink($node_title);
 
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertOptionSelected('edit-menu-weight', 17, t('Menu weight correct in edit form'));
+    $this->assertOptionSelected('edit-menu-weight', 17, 'Menu weight correct in edit form');
 
     // Edit the node and remove the menu link.
     $edit = array(
@@ -675,11 +675,11 @@ class MenuNodeTestCase extends DrupalWebTestCase {
 
     // Assert that disabled Management menu is not shown on the node/$nid/edit page.
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertText('Provide a menu link', t('Link in not allowed menu not shown in node edit form'));
+    $this->assertText('Provide a menu link', 'Link in not allowed menu not shown in node edit form');
     // Assert that the link is still in the management menu after save.
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
     $link = menu_link_load($item['mlid']);
-    $this->assertTrue($link, t('Link in not allowed menu still exists after saving node'));
+    $this->assertTrue($link, 'Link in not allowed menu still exists after saving node');
 
     // Move the menu link back to the Navigation menu.
     $item['menu_name'] = 'navigation';
diff --git a/modules/node/content_types.inc b/modules/node/content_types.inc
index 72adc34..4b722ee 100644
--- a/modules/node/content_types.inc
+++ b/modules/node/content_types.inc
@@ -2,7 +2,7 @@
 
 /**
  * @file
- * Content type editing UI.
+ * Content type editing user interface.
  */
 
 /**
@@ -388,8 +388,7 @@ function node_node_type_update($info) {
 }
 
 /**
- * Resets all of the relevant fields of a module-defined node type to their
- * default values.
+ * Resets relevant fields of a module-defined node type to their default values.
  *
  * @param $type
  *   The node type to reset. The node type is passed back by reference with its
@@ -410,6 +409,8 @@ function node_type_reset($type) {
 
 /**
  * Menu callback; delete a single content type.
+ *
+ * @ingroup forms
  */
 function node_type_delete_confirm($form, &$form_state, $type) {
   $form['type'] = array('#type' => 'value', '#value' => $type->type);
@@ -430,6 +431,8 @@ function node_type_delete_confirm($form, &$form_state, $type) {
 
 /**
  * Process content type delete confirm submissions.
+ *
+ * @see node_type_delete_confirm()
  */
 function node_type_delete_confirm_submit($form, &$form_state) {
   node_type_delete($form_state['values']['type']);
diff --git a/modules/node/node.admin.inc b/modules/node/node.admin.inc
index 1508bc0..be09b37 100644
--- a/modules/node/node.admin.inc
+++ b/modules/node/node.admin.inc
@@ -7,6 +7,10 @@
 
 /**
  * Menu callback: confirm rebuilding of permissions.
+ *
+ * @see node_configure_rebuild_confirm_submit()
+ * @see node_menu()
+ * @ingroup forms
  */
 function node_configure_rebuild_confirm() {
   return confirm_form(array(), t('Are you sure you want to rebuild the permissions on site content?'),
@@ -15,6 +19,8 @@ function node_configure_rebuild_confirm() {
 
 /**
  * Handler for wipe confirmation
+ *
+ * @see node_configure_rebuild_confirm()
  */
 function node_configure_rebuild_confirm_submit($form, &$form_state) {
   node_access_rebuild(TRUE);
@@ -66,6 +72,9 @@ function node_node_operations() {
 
 /**
  * List node administration filters that can be applied.
+ *
+ * @return
+ *   An associative array of filters.
  */
 function node_filters() {
   // Regular filters
@@ -110,7 +119,7 @@ function node_filters() {
 }
 
 /**
- * Apply filters for node administration filters based on session.
+ * Applies filters for node administration filters based on session.
  *
  * @param $query
  *   A SelectQuery to which the filters should be applied.
@@ -133,7 +142,16 @@ function node_build_filter_query(SelectQueryInterface $query) {
 }
 
 /**
- * Return form for node administration filters.
+ * Returns the node administration filters form array to node_admin_content().
+ *
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_submit()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form_submit()
+ * @see node_multiple_delete_confirm()
+ * @see node_multiple_delete_confirm_submit()
+ *
+ * @ingroup forms
  */
 function node_filter_form() {
   $session = isset($_SESSION['node_overview_filter']) ? $_SESSION['node_overview_filter'] : array();
@@ -208,7 +226,15 @@ function node_filter_form() {
 }
 
 /**
- * Process result from node administration filter form.
+ * Form submission handler for node_filter_form().
+ *
+ * @see node_admin_content()
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_submit()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form()
+ * @see node_multiple_delete_confirm()
+ * @see node_multiple_delete_confirm_submit()
  */
 function node_filter_form_submit($form, &$form_state) {
   $filters = node_filters();
@@ -240,15 +266,15 @@ function node_filter_form_submit($form, &$form_state) {
  * Make mass update of nodes, changing all nodes in the $nodes array
  * to update them with the field values in $updates.
  *
- * IMPORTANT NOTE: This function is intended to work when called
- * from a form submit handler. Calling it outside of the form submission
- * process may not work correctly.
+ * IMPORTANT NOTE: This function is intended to work when called from a form
+ * submission handler. Calling it outside of the form submission process may not
+ * work correctly.
  *
  * @param array $nodes
  *   Array of node nids to update.
  * @param array $updates
- *   Array of key/value pairs with node field names and the
- *   value to update that field to.
+ *   Array of key/value pairs with node field names and the value to update that
+ *   field to.
  */
 function node_mass_update($nodes, $updates) {
   // We use batch processing to prevent timeout when updating a large number
@@ -279,7 +305,17 @@ function node_mass_update($nodes, $updates) {
 }
 
 /**
- * Node Mass Update - helper function.
+ * Updates individual nodes when fewer than 10 are queued.
+ *
+ * @param $nid
+ *   ID of node to update.
+ * @param $updates
+ *   Associative array of updates.
+ *
+ * @return object
+ *   An updated node object.
+ *
+ * @see node_mass_update()
  */
 function _node_mass_update_helper($nid, $updates) {
   $node = node_load($nid, NULL, TRUE);
@@ -293,7 +329,14 @@ function _node_mass_update_helper($nid, $updates) {
 }
 
 /**
- * Node Mass Update Batch operation
+ * Executes a batch operation for node_mass_update().
+ *
+ * @param array $nodes
+ *   An array of node IDs.
+ * @param array $updates
+ *   Associative array of updates.
+ * @param array $context
+ *   An array of contextual key/values.
  */
 function _node_mass_update_batch_process($nodes, $updates, &$context) {
   if (!isset($context['sandbox']['progress'])) {
@@ -324,7 +367,15 @@ function _node_mass_update_batch_process($nodes, $updates, &$context) {
 }
 
 /**
- * Node Mass Update Batch 'finished' callback.
+ * Menu callback: Reports the status of batch operation for node_mass_update().
+ *
+ * @param bool $success
+ *   A boolean indicating whether the batch mass update operation successfully
+ *   concluded.
+ * @param int $results
+ *   The number of nodes updated via the batch mode process.
+ * @param array $operations
+ *   An array of function calls (not used in this function).
  */
 function _node_mass_update_batch_finished($success, $results, $operations) {
   if ($success) {
@@ -339,7 +390,17 @@ function _node_mass_update_batch_finished($success, $results, $operations) {
 }
 
 /**
- * Menu callback: content administration.
+ * Page callback: Form constructor for the content administration form.
+ *
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_submit()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form()
+ * @see node_filter_form_submit()
+ * @see node_menu()
+ * @see node_multiple_delete_confirm()
+ * @see node_multiple_delete_confirm_submit()
+ * @ingroup forms
  */
 function node_admin_content($form, $form_state) {
   if (isset($form_state['values']['operation']) && $form_state['values']['operation'] == 'delete') {
@@ -354,6 +415,15 @@ function node_admin_content($form, $form_state) {
 
 /**
  * Form builder: Builds the node administration overview.
+ *
+ * @see node_admin_nodes_submit()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form()
+ * @see node_filter_form_submit()
+ * @see node_multiple_delete_confirm()
+ * @see node_multiple_delete_confirm_submit()
+ *
+ * @ingroup forms
  */
 function node_admin_nodes() {
   $admin_access = user_access('administer nodes');
@@ -525,8 +595,15 @@ function node_admin_nodes() {
 /**
  * Validate node_admin_nodes form submissions.
  *
- * Check if any nodes have been selected to perform the chosen
- * 'Update option' on.
+ * Checks whether any nodes have been selected to perform the chosen 'Update
+ * option' on.
+ *
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_submit()
+ * @see node_filter_form()
+ * @see node_filter_form_submit()
+ * @see node_multiple_delete_confirm()
+ * @see node_multiple_delete_confirm_submit()
  */
 function node_admin_nodes_validate($form, &$form_state) {
   // Error if there are no items to select.
@@ -538,7 +615,14 @@ function node_admin_nodes_validate($form, &$form_state) {
 /**
  * Process node_admin_nodes form submissions.
  *
- * Execute the chosen 'Update option' on the selected nodes.
+ * Executes the chosen 'Update option' on the selected nodes.
+ *
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form()
+ * @see node_filter_form_submit()
+ * @see node_multiple_delete_confirm()
+ * @see node_multiple_delete_confirm_submit()
  */
 function node_admin_nodes_submit($form, &$form_state) {
   $operations = module_invoke_all('node_operations');
@@ -564,6 +648,17 @@ function node_admin_nodes_submit($form, &$form_state) {
   }
 }
 
+/**
+ * Multiple node deletion confirmation form for node_admin_content().
+ *
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_submit()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form()
+ * @see node_filter_form_submit()
+ * @see node_multiple_delete_confirm_submit()
+ * @ingroup forms
+ */
 function node_multiple_delete_confirm($form, &$form_state, $nodes) {
   $form['nodes'] = array('#prefix' => '<ul>', '#suffix' => '</ul>', '#tree' => TRUE);
   // array_filter returns only elements with TRUE values
@@ -587,6 +682,16 @@ function node_multiple_delete_confirm($form, &$form_state, $nodes) {
                     t('Delete'), t('Cancel'));
 }
 
+/**
+ * Form submission handler for node_multiple_delete_confirm().
+ *
+ * @see node_admin_nodes()
+ * @see node_admin_nodes_submit()
+ * @see node_admin_nodes_validate()
+ * @see node_filter_form()
+ * @see node_filter_form_submit()
+ * @see node_multiple_delete_confirm()
+ */
 function node_multiple_delete_confirm_submit($form, &$form_state) {
   if ($form_state['values']['confirm']) {
     node_delete_multiple(array_keys($form_state['values']['nodes']));
diff --git a/modules/node/node.api.php b/modules/node/node.api.php
index 052effc..f8dcfde 100644
--- a/modules/node/node.api.php
+++ b/modules/node/node.api.php
@@ -11,8 +11,8 @@
  * Functions to define and modify content types.
  *
  * Each content type is maintained by a primary module, which is either
- * node.module (for content types created in the user interface) or the
- * module that implements hook_node_info() to define the content type.
+ * node.module (for content types created in the user interface) or the module
+ * that implements hook_node_info() to define the content type.
  *
  * During node operations (create, update, view, delete, etc.), there are
  * several sets of hooks that get invoked to allow modules to modify the base
@@ -22,10 +22,10 @@
  *   function prefix.  For example, poll.module defines the base for the Poll
  *   content type as "poll", so during creation of a poll node, hook_insert() is
  *   only invoked by calling poll_insert().
- * - All-module hooks: This set of hooks is invoked on all implementing
- *   modules, to allow other modules to modify what the primary node module is
- *   doing. For example, hook_node_insert() is invoked on all modules when
- *   creating a poll node.
+ * - All-module hooks: This set of hooks is invoked on all implementing modules,
+ *   to allow other modules to modify what the primary node module is doing. For
+ *   example, hook_node_insert() is invoked on all modules when creating a poll
+ *   node.
  * - Field hooks: Hooks related to the fields attached to the node. These are
  *   invoked from the field operations functions described below, and can be
  *   either field-type-specific or all-module hooks.
@@ -56,16 +56,15 @@
  *   - hook_entity_update() (all)
  *   - hook_node_access_records() (all)
  *   - hook_node_access_records_alter() (all)
- * - Loading a node (calling node_load(), node_load_multiple(), or
- *   entity_load() with $entity_type of 'node'):
+ * - Loading a node (calling node_load(), node_load_multiple() or entity_load()
+ *   with $entity_type of 'node'):
  *   - Node and revision information is read from database.
  *   - hook_load() (node-type-specific)
  *   - field_attach_load_revision() and field_attach_load()
  *   - hook_entity_load() (all)
  *   - hook_node_load() (all)
  * - Viewing a single node (calling node_view() - note that the input to
- *   node_view() is a loaded node, so the Loading steps above are already
- *   done):
+ *   node_view() is a loaded node, so the Loading steps above are already done):
  *   - hook_view() (node-type-specific)
  *   - field_attach_prepare_view()
  *   - hook_entity_prepare_view() (all)
@@ -97,9 +96,8 @@
  *   - Revision information is deleted from database
  *   - hook_node_revision_delete() (all)
  *   - field_attach_delete_revision()
- * - Preparing a node for editing (calling node_form() - note that if it's
- *   an existing node, it will already be loaded; see the Loading section
- *   above):
+ * - Preparing a node for editing (calling node_form() - note that if it is an
+ *   existing node, it will already be loaded; see the Loading section above):
  *   - hook_prepare() (node-type-specific)
  *   - hook_node_prepare() (all)
  *   - hook_form() (node-type-specific)
@@ -137,16 +135,16 @@
  * associated with permission to view, edit, and delete individual nodes.
  *
  * The realms and grant IDs can be arbitrarily defined by your node access
- * module; it is common to use role IDs as grant IDs, but that is not
- * required. Your module could instead maintain its own list of users, where
- * each list has an ID. In that case, the return value of this hook would be
- * an array of the list IDs that this user is a member of.
+ * module; it is common to use role IDs as grant IDs, but that is not required.
+ * Your module could instead maintain its own list of users, where each list has
+ * an ID. In that case, the return value of this hook would be an array of the
+ * list IDs that this user is a member of.
  *
- * A node access module may implement as many realms as necessary to
- * properly define the access privileges for the nodes. Note that the system
- * makes no distinction between published and unpublished nodes. It is the
- * module's responsibility to provide appropriate realms to limit access to
- * unpublished content.
+ * A node access module may implement as many realms as necessary to properly
+ * define the access privileges for the nodes. Note that the system makes no
+ * distinction between published and unpublished nodes. It is the module's
+ * responsibility to provide appropriate realms to limit access to unpublished
+ * content.
  *
  * Node access records are stored in the {node_access} table and define which
  * grants are required to access a node. There is a special case for the view
@@ -183,7 +181,7 @@
  * @param $account
  *   The user object whose grants are requested.
  * @param $op
- *   The node operation to be performed, such as "view", "update", or "delete".
+ *   The node operation to be performed, such as 'view', 'update', or 'delete'.
  *
  * @return
  *   An array whose keys are "realms" of grants, and whose values are arrays of
@@ -264,6 +262,7 @@ function hook_node_grants($account, $op) {
  * @return
  *   An array of grants as defined above.
  *
+ * @see hook_node_access_records_alter()
  * @ingroup node_access
  */
 function hook_node_access_records($node) {
@@ -350,12 +349,11 @@ function hook_node_access_records_alter(&$grants, $node) {
  * Alter user access rules when trying to view, edit or delete a node.
  *
  * Node access modules establish rules for user access to content.
- * hook_node_grants() defines permissions for a user to view, edit or
- * delete nodes by building a $grants array that indicates the permissions
- * assigned to the user by each node access module. This hook is called to allow
- * modules to modify the $grants array by reference, so the interaction of
- * multiple node access modules can be altered or advanced business logic can be
- * applied.
+ * hook_node_grants() defines permissions for a user to view, edit or delete
+ * nodes by building a $grants array that indicates the permissions assigned to
+ * the user by each node access module. This hook is called to allow modules to
+ * modify the $grants array by reference, so the interaction of multiple node
+ * access modules can be altered or advanced business logic can be applied.
  *
  * @see hook_node_grants()
  *
@@ -374,8 +372,8 @@ function hook_node_access_records_alter(&$grants, $node) {
  * @param $op
  *   The operation being performed, 'view', 'update' or 'delete'.
  *
- * Developers may use this hook to either add additional grants to a user
- * or to remove existing grants. These rules are typically based on either the
+ * Developers may use this hook to either add additional grants to a user or to
+ * remove existing grants. These rules are typically based on either the
  * permissions assigned to a user role, or specific attributes of a user
  * account.
  *
@@ -412,10 +410,10 @@ function hook_node_grants_alter(&$grants, $account, $op) {
  * @return
  *   An array of operations. Each operation is an associative array that may
  *   contain the following key-value pairs:
- *   - 'label': Required. The label for the operation, displayed in the dropdown
+ *   - label: (required) The label for the operation, displayed in the dropdown
  *     menu.
- *   - 'callback': Required. The function to call for the operation.
- *   - 'callback arguments': Optional. An array of additional arguments to pass
+ *   - callback: (required) The function to call for the operation.
+ *   - callback arguments: (optional) An array of additional arguments to pass
  *     to the callback function.
  */
 function hook_node_operations() {
@@ -528,11 +526,10 @@ function hook_node_insert($node) {
 /**
  * Act on arbitrary nodes being loaded from the database.
  *
- * This hook should be used to add information that is not in the node or
- * node revisions table, not to replace information that is in these tables
- * (which could interfere with the entity cache). For performance reasons,
- * information for all available nodes should be loaded in a single query where
- * possible.
+ * This hook should be used to add information that is not in the node or node
+ * revisions table, not to replace information that is in these tables (which
+ * could interfere with the entity cache). For performance reasons, information
+ * for all available nodes should be loaded in a single query where possible.
  *
  * This hook is invoked during node loading, which is handled by entity_load(),
  * via classes NodeController and DrupalDefaultEntityController. After the node
@@ -572,15 +569,15 @@ function hook_node_load($nodes, $types) {
  * Modules may implement this hook if they want to have a say in whether or not
  * a given user has access to perform a given operation on a node.
  *
- * The administrative account (user ID #1) always passes any access check,
- * so this hook is not called in that case. Users with the "bypass node access"
+ * The administrative account (user ID #1) always passes any access check, so
+ * this hook is not called in that case. Users with the "bypass node access"
  * permission may always view and edit content through the administrative
  * interface.
  *
- * Note that not all modules will want to influence access on all
- * node types. If your module does not want to actively grant or
- * block access, return NODE_ACCESS_IGNORE or simply return nothing.
- * Blindly returning FALSE will break other node access modules.
+ * Note that not all modules will want to influence access on all node types. If
+ * your module does not want to actively grant or block access, return
+ * NODE_ACCESS_IGNORE or simply return nothing. Blindly returning FALSE will
+ * break other node access modules.
  *
  * Also note that this function isn't called for node listings (e.g., RSS feeds,
  * the default home page at path 'node', a recent content block, etc.) See
@@ -651,17 +648,17 @@ function hook_node_prepare($node) {
 /**
  * Act on a node being displayed as a search result.
  *
- * This hook is invoked from node_search_execute(), after node_load()
- * and node_view() have been called.
+ * This hook is invoked from node_search_execute(), after node_load() and
+ * node_view() have been called.
  *
  * @param $node
  *   The node being displayed in a search result.
  *
  * @return array
  *   Extra information to be displayed with search result. This information
- *   should be presented as an associative array. It will be concatenated
- *   with the post information (last updated, author) in the default search
- *   result theming.
+ *   should be presented as an associative array. It will be concatenated with
+ *   the post information (last updated, author) in the default search result
+ *   theming.
  *
  * @see template_preprocess_search_result()
  * @see search-result.tpl.php
@@ -724,8 +721,8 @@ function hook_node_update($node) {
 /**
  * Act on a node being indexed for searching.
  *
- * This hook is invoked during search indexing, after node_load(), and after
- * the result of node_view() is added as $node->rendered to the node object.
+ * This hook is invoked during search indexing, after node_load(), and after the
+ * result of node_view() is added as $node->rendered to the node object.
  *
  * @param $node
  *   The node being indexed.
@@ -756,8 +753,8 @@ function hook_node_update_index($node) {
  *
  * Note: Changes made to the $node object within your hook implementation will
  * have no effect.  The preferred method to change a node's content is to use
- * hook_node_presave() instead. If it is really necessary to change
- * the node at the validate stage, you can use form_set_value().
+ * hook_node_presave() instead. If it is really necessary to change the node at
+ * the validate stage, you can use form_set_value().
  *
  * @param $node
  *   The node being validated.
@@ -874,8 +871,8 @@ function hook_node_view_alter(&$build) {
  *
  * This hook allows a module to define one or more of its own node types. For
  * example, the blog module uses it to define a blog node-type named "Blog
- * entry." The name and attributes of each desired node type are specified in
- * an array returned by the hook.
+ * entry." The name and attributes of each desired node type are specified in an
+ * array returned by the hook.
  *
  * Only module-provided node types should be defined through this hook. User-
  * provided (or 'custom') node types should be defined only in the 'node_type'
@@ -887,22 +884,22 @@ function hook_node_view_alter(&$build) {
  *   contains a sub-array for each node type, with the machine-readable type
  *   name as the key. Each sub-array has up to 10 attributes. Possible
  *   attributes:
- *   - "name": the human-readable name of the node type. Required.
- *   - "base": the base string used to construct callbacks corresponding to
- *      this node type.
- *      (i.e. if base is defined as example_foo, then example_foo_insert will
- *      be called when inserting a node of that type). This string is usually
- *      the name of the module, but not always. Required.
- *   - "description": a brief description of the node type. Required.
- *   - "help": help information shown to the user when creating a node of
- *      this type.. Optional (defaults to '').
- *   - "has_title": boolean indicating whether or not this node type has a title
- *      field. Optional (defaults to TRUE).
- *   - "title_label": the label for the title field of this content type.
- *      Optional (defaults to 'Title').
- *   - "locked": boolean indicating whether the administrator can change the
- *      machine name of this type. FALSE = changeable (not locked),
- *      TRUE = unchangeable (locked). Optional (defaults to TRUE).
+ *   - name: (required) The human-readable name of the node type.
+ *   - base: (required) The base string used to construct callbacks
+ *     corresponding to this node type (for example, if base is defined as
+ *     example_foo, then example_foo_insert will be called when inserting a node
+ *     of that type). This string is usually the name of the module, but not
+ *     always.
+ *   - description: (required) A brief description of the node type.
+ *   - help: (optional) Help information shown to the user when creating a node
+ *     of this type.
+ *   - has_title: (optional) A Boolean indicating whether or not this node type
+ *     has a title field.
+ *   - title_label: (optional) The label for the title field of this content
+ *     type.
+ *   - locked: (optional) A Boolean indicating whether the administrator can
+ *     change the machine name of this type. FALSE = changeable (not locked),
+ *     TRUE = unchangeable (locked).
  *
  * The machine name of a node type should contain only letters, numbers, and
  * underscores. Underscores will be converted into hyphens for the purpose of
@@ -950,20 +947,20 @@ function hook_node_info() {
  *   corresponding to the internal name of the ranking mechanism, such as
  *   'recent', or 'comments'. The values should be arrays themselves, with the
  *   following keys available:
- *   - "title": the human readable name of the ranking mechanism. Required.
- *   - "join": part of a query string to join to any additional necessary
- *     table. This is not necessary if the table required is already joined to
- *     by the base query, such as for the {node} table. Other tables should use
- *     the full table name as an alias to avoid naming collisions. Optional.
- *   - "score": part of a query string to calculate the score for the ranking
- *     mechanism based on values in the database. This does not need to be
- *     wrapped in parentheses, as it will be done automatically; it also does
- *     not need to take the weighted system into account, as it will be done
- *     automatically. It does, however, need to calculate a decimal between
+ *   - title: (required) The human readable name of the ranking mechanism.
+ *   - join: (optional) The part of a query string to join to any additional
+ *     necessary table. This is not necessary if the table required is already
+ *     joined to by the base query, such as for the {node} table. Other tables
+ *     should use the full table name as an alias to avoid naming collisions.
+ *   - score: (required) The part of a query string to calculate the score for
+ *     the ranking mechanism based on values in the database. This does not need
+ *     to be wrapped in parentheses, as it will be done automatically; it also
+ *     does not need to take the weighted system into account, as it will be
+ *     done automatically. It does, however, need to calculate a decimal between
  *     0 and 1; be careful not to cast the entire score to an integer by
- *     inadvertently introducing a variable argument. Required.
- *   - "arguments": if any arguments are required for the score, they can be
- *     specified in an array here.
+ *     inadvertently introducing a variable argument.
+ *   - arguments: (optional) If any arguments are required for the score, they
+ *     can be specified in an array here.
  *
  * @ingroup node_api_hooks
  */
@@ -990,8 +987,8 @@ function hook_ranking() {
 /**
  * Respond to node type creation.
  *
- * This hook is invoked from node_type_save() after the node type is added
- * to the database.
+ * This hook is invoked from node_type_save() after the node type is added to
+ * the database.
  *
  * @param $info
  *   The node type object that is being created.
@@ -1003,8 +1000,8 @@ function hook_node_type_insert($info) {
 /**
  * Respond to node type updates.
  *
- * This hook is invoked from node_type_save() after the node type is updated
- * in the database.
+ * This hook is invoked from node_type_save() after the node type is updated in
+ * the database.
  *
  * @param $info
  *   The node type object that is being updated.
@@ -1258,25 +1255,24 @@ function hook_validate($node, $form, &$form_state) {
  * This hook is invoked only on the module that defines the node's content type
  * (use hook_node_view() to act on all node views).
  *
- * This hook is invoked during node viewing after the node is fully loaded,
- * so that the node type module can define a custom method for display, or
- * add to the default display.
+ * This hook is invoked during node viewing after the node is fully loaded, so
+ * that the node type module can define a custom method for display, or add to
+ * the default display.
  *
  * @param $node
  *   The node to be displayed, as returned by node_load().
  * @param $view_mode
  *   View mode, e.g. 'full', 'teaser', ...
  * @return
- *   $node. The passed $node parameter should be modified as necessary and
- *   returned so it can be properly presented. Nodes are prepared for display
- *   by assembling a structured array, formatted as in the Form API, in
- *   $node->content. As with Form API arrays, the #weight property can be
- *   used to control the relative positions of added elements. After this
- *   hook is invoked, node_view() calls field_attach_view() to add field
- *   views to $node->content, and then invokes hook_node_view() and
- *   hook_node_view_alter(), so if you want to affect the final
- *   view of the node, you might consider implementing one of these hooks
- *   instead.
+ *   The passed $node parameter should be modified as necessary and returned so
+ *   it can be properly presented. Nodes are prepared for display by assembling
+ *   a structured array, formatted as in the Form API, in $node->content. As
+ *   with Form API arrays, the #weight property can be used to control the
+ *   relative positions of added elements. After this hook is invoked,
+ *   node_view() calls field_attach_view() to add field views to $node->content,
+ *   and then invokes hook_node_view() and hook_node_view_alter(), so if you
+ *   want to affect the final view of the node, you might consider implementing
+ *   one of these hooks instead.
  *
  * @ingroup node_api_hooks
  */
diff --git a/modules/node/node.install b/modules/node/node.install
index 16d3dba..43bfd53 100644
--- a/modules/node/node.install
+++ b/modules/node/node.install
@@ -914,6 +914,7 @@ function node_update_7012() {
  * Change {node}.vid default value from 0 to NULL to avoid deadlock issues on MySQL.
  */
 function node_update_7013() {
+  db_drop_unique_key('node', 'vid');
   db_change_field('node', 'vid', 'vid', array(
     'description' => 'The current {node_revision}.vid version identifier.',
     'type' => 'int',
@@ -921,6 +922,7 @@ function node_update_7013() {
     'not null' => FALSE,
     'default' => NULL,
   ));
+  db_add_unique_key('node', 'vid', array('vid'));
 }
 
 /**
diff --git a/modules/node/node.module b/modules/node/node.module
index d86c74d..2680762 100644
--- a/modules/node/node.module
+++ b/modules/node/node.module
@@ -141,6 +141,7 @@ function node_theme() {
     ),
     'node_admin_overview' => array(
       'variables' => array('name' => NULL, 'type' => NULL),
+      'file' => 'content_types.inc',
     ),
     'node_recent_block' => array(
       'variables' => array('nodes' => NULL),
@@ -200,8 +201,8 @@ function node_entity_info() {
     ),
   );
 
-  // Search integration is provided by node.module, so search-related
-  // view modes for nodes are defined here and not in search.module.
+  // Search integration is provided by node.module, so search-related view modes
+  // for nodes are defined here and not in search.module.
   if (module_exists('search')) {
     $return['node']['view modes'] += array(
       'search_index' => array(
@@ -243,7 +244,7 @@ function node_field_display_node_alter(&$display, $context) {
 }
 
 /**
- * Entity URI callback.
+ * Implements callback_entity_info_uri().
  */
 function node_uri($node) {
   return array(
@@ -296,7 +297,7 @@ function node_title_list($result, $title = NULL) {
 }
 
 /**
- * Update the 'last viewed' timestamp of the specified node for current user.
+ * Updates the 'last viewed' timestamp of the specified node for current user.
  *
  * @param $node
  *   A node object.
@@ -315,8 +316,14 @@ function node_tag_new($node) {
 }
 
 /**
- * Retrieves the timestamp at which the current user last viewed the
- * specified node.
+ * Retrieves the timestamp for the current user's last view of a specified node.
+ *
+ * @param $nid
+ *   A node ID.
+ *
+ * @return
+ *   If a node has been previously viewed by the user, the timestamp in seconds
+ *   of when the last view occurred; otherwise, zero.
  */
 function node_last_viewed($nid) {
   global $user;
@@ -330,12 +337,13 @@ function node_last_viewed($nid) {
 }
 
 /**
- * Decide on the type of marker to be displayed for a given node.
+ * Determines the type of marker to be displayed for a given node.
  *
  * @param $nid
  *   Node ID whose history supplies the "last viewed" timestamp.
  * @param $timestamp
  *   Time which is compared against node's "last viewed" timestamp.
+ *
  * @return
  *   One of the MARK constants.
  */
@@ -359,7 +367,7 @@ function node_mark($nid, $timestamp) {
 }
 
 /**
- * Extract the type name.
+ * Extracts the type name.
  *
  * @param $node
  *   Either a string or object, containing the node type information.
@@ -461,6 +469,8 @@ function node_type_get_name($node) {
  * node_type_save(), and obsolete ones are deleted via a call to
  * node_type_delete(). See _node_types_build() for an explanation of the new
  * and obsolete types.
+ *
+ * @see _node_types_build()
  */
 function node_types_rebuild() {
   _node_types_build(TRUE);
@@ -483,11 +493,34 @@ function node_type_load($name) {
 /**
  * Saves a node type to the database.
  *
- * @param $info
- *   The node type to save, as an object.
- *
- * @return
- *   Status flag indicating outcome of the operation.
+ * @param object $info
+ *   The node type to save; an object with the following properties:
+ *   - type: A string giving the machine name of the node type.
+ *   - name: A string giving the human-readable name of the node type.
+ *   - base: A string that indicates the base string for hook functions. For
+ *     example, 'node_content' is the value used by the UI when creating a new
+ *     node type.
+ *   - description: A string that describes the node type.
+ *   - help: A string giving the help information shown to the user when
+ *     creating a node of this type.
+ *   - custom: TRUE or FALSE indicating whether this type is defined by a module
+ *     (FALSE) or by a user (TRUE) via Add Content Type.
+ *   - modified: TRUE or FALSE indicating whether this type has been modified by
+ *     an administrator. Currently not used in any way.
+ *   - locked: TRUE or FALSE indicating whether the administrator can change the
+ *     machine name of this type.
+ *   - disabled: TRUE or FALSE indicating whether this type has been disabled.
+ *   - has_title: TRUE or FALSE indicating whether this type uses the node title
+ *     field.
+ *   - title_label: A string containing the label for the title.
+ *   - module: A string giving the module defining this type of node.
+ *   - orig_type: A string giving the original machine-readable name of this
+ *     node type. This may be different from the current type name if the
+ *     'locked' key is FALSE.
+ *
+ * @return int
+ *   A status flag indicating the outcome of the operation, either SAVED_NEW or
+ *   SAVED_UPDATED.
  */
 function node_type_save($info) {
   $existing_type = !empty($info->old_type) ? $info->old_type : $info->type;
@@ -540,7 +573,7 @@ function node_type_save($info) {
 }
 
 /**
- * Add default body field to a node type.
+ * Adds default body field to a node type.
  *
  * @param $type
  *   A node type object.
@@ -655,6 +688,7 @@ function node_type_update_nodes($old_type, $type) {
  *
  * @param $rebuild
  *  TRUE to rebuild node types. Equivalent to calling node_types_rebuild().
+ *
  * @return
  *   An object with two properties:
  *   - names: Associative array of the names of node types, keyed by the type.
@@ -761,8 +795,9 @@ function node_type_cache_reset() {
  * which prevents users from changing the machine name of the type.
  *
  * @param $info
- *   An object or array containing values to override the defaults. See
- *   hook_node_info() for details on what the array elements mean.
+ *   (optional) An object or array containing values to override the defaults.
+ *   See hook_node_info() for details on what the array elements mean. Defaults
+ *   to an empty array.
  *
  * @return
  *   A node type object, with missing values in $info set to their defaults.
@@ -845,12 +880,13 @@ function node_rdf_mapping() {
 }
 
 /**
- * Determine whether a node hook exists.
+ * Determines whether a node hook exists.
  *
  * @param $node
  *   A node object or a string containing the node type.
  * @param $hook
  *   A string containing the name of the hook.
+ *
  * @return
  *   TRUE if the $hook exists in the node type of $node.
  */
@@ -860,7 +896,7 @@ function node_hook($node, $hook) {
 }
 
 /**
- * Invoke a node hook.
+ * Invokes a node hook.
  *
  * @param $node
  *   A node object or a string containing the node type.
@@ -868,6 +904,7 @@ function node_hook($node, $hook) {
  *   A string containing the name of the hook.
  * @param $a2, $a3, $a4
  *   Arguments to pass on to the hook, after the $node argument.
+ *
  * @return
  *   The returned value of the invoked hook.
  */
@@ -880,11 +917,11 @@ function node_invoke($node, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {
 }
 
 /**
- * Load node entities from the database.
+ * Loads node entities from the database.
  *
  * This function should be used whenever you need to load more than one node
- * from the database. Nodes are loaded into memory and will not require
- * database access if loaded again during the same page request.
+ * from the database. Nodes are loaded into memory and will not require database
+ * access if loaded again during the same page request.
  *
  * @see entity_load()
  * @see EntityFieldQuery
@@ -910,7 +947,7 @@ function node_load_multiple($nids = array(), $conditions = array(), $reset = FAL
 }
 
 /**
- * Load a node object from the database.
+ * Loads a node object from the database.
  *
  * @param $nid
  *   The node ID.
@@ -934,6 +971,9 @@ function node_load($nid = NULL, $vid = NULL, $reset = FALSE) {
  *
  * Fills in a few default values, and then invokes hook_prepare() on the node
  * type module, and hook_node_prepare() on all modules.
+ *
+ * @param $node
+ *   A node object.
  */
 function node_object_prepare($node) {
   // Set up default values, if required.
@@ -963,11 +1003,11 @@ function node_object_prepare($node) {
 }
 
 /**
- * Perform validation checks on the given node.
+ * Implements hook_validate().
+ *
+ * Performs validation checks on the given node.
  */
 function node_validate($node, $form, &$form_state) {
-  $type = node_type_get_type($node);
-
   if (isset($node->nid) && (node_last_changed($node->nid) > $node->changed)) {
     form_set_error('changed', t('The content on this page has either been modified by another user, or you have already submitted modifications using this form. As a result, your changes cannot be saved.'));
   }
@@ -1000,7 +1040,13 @@ function node_validate($node, $form, &$form_state) {
 }
 
 /**
- * Prepare node for saving by populating author and creation date.
+ * Prepares node for saving by populating author and creation date.
+ *
+ * @param $node
+ *   A node object.
+ *
+ * @return
+ *   An updated node object.
  */
 function node_submit($node) {
   // A user might assign the node author by entering a user name in the node
@@ -1021,7 +1067,7 @@ function node_submit($node) {
 }
 
 /**
- * Save changes to a node or add a new node.
+ * Saves changes to a node or adds a new node.
  *
  * @param $node
  *   The $node object to be saved. If $node->nid is
@@ -1159,6 +1205,13 @@ function node_save($node) {
  * Helper function to save a revision with the uid of the current user.
  *
  * The resulting revision ID is available afterward in $node->vid.
+ *
+ * @param $node
+ *   A node object.
+ * @param $uid
+ *   The current user's UID.
+ * @param $update
+ *   (optional) An array of primary keys' field names to update.
  */
 function _node_save_revision($node, $uid, $update = NULL) {
   $temp_uid = $node->uid;
@@ -1174,7 +1227,7 @@ function _node_save_revision($node, $uid, $update = NULL) {
 }
 
 /**
- * Delete a node.
+ * Deletes a node.
  *
  * @param $nid
  *   A node ID.
@@ -1184,7 +1237,7 @@ function node_delete($nid) {
 }
 
 /**
- * Delete multiple nodes.
+ * Deletes multiple nodes.
  *
  * @param $nids
  *   An array of node IDs.
@@ -1237,7 +1290,7 @@ function node_delete_multiple($nids) {
 }
 
 /**
- * Delete a node revision.
+ * Deletes a node revision.
  *
  * @param $revision_id
  *   The revision ID to delete.
@@ -1262,7 +1315,7 @@ function node_revision_delete($revision_id) {
 }
 
 /**
- * Generate an array for rendering the given node.
+ * Generates an array for rendering the given node.
  *
  * @param $node
  *   A node object.
@@ -1367,8 +1420,8 @@ function node_build_content($node, $view_mode = 'full', $langcode = NULL) {
   entity_prepare_view('node', array($node->nid => $node), $langcode);
   $node->content += field_attach_view('node', $node, $view_mode, $langcode);
 
-  // Always display a read more link on teasers because we have no way
-  // to know when a teaser view is different than a full view.
+  // Always display a read more link on teasers because we have no way to know
+  // when a teaser view is different than a full view.
   $links = array();
   $node->content['links'] = array(
     '#theme' => 'links__node',
@@ -1400,12 +1453,13 @@ function node_build_content($node, $view_mode = 'full', $langcode = NULL) {
 }
 
 /**
- * Generate an array which displays a node detail page.
+ * Generates an array which displays a node detail page.
  *
  * @param $node
  *   A node object.
  * @param $message
  *   A flag which sets a page title relevant to the revision being viewed.
+ *
  * @return
  *   A $page element suitable for use by drupal_render().
  */
@@ -1428,6 +1482,9 @@ function node_show($node, $message = FALSE) {
  *
  * @param $node
  *   A node object.
+ *
+ * @return
+ *   The ID of the node if this is a full page view, otherwise FALSE.
  */
 function node_is_page($node) {
   $page_node = menu_get_object();
@@ -1435,7 +1492,7 @@ function node_is_page($node) {
 }
 
 /**
- * Process variables for node.tpl.php
+ * Processes variables for node.tpl.php
  *
  * Most themes utilize their own copy of node.tpl.php. The default is located
  * inside "modules/node/node.tpl.php". Look in there for the full list of
@@ -1530,6 +1587,9 @@ function node_permission() {
     ),
     'access content overview' => array(
       'title' => t('Access the content overview page'),
+      'description' => user_access('access content overview')
+        ? t('Get an overview of <a href="@url">all content</a>.', array('@url' => url('admin/content')))
+        : t('Get an overview of all content.'),
     ),
     'access content' => array(
       'title' => t('View published content'),
@@ -1557,7 +1617,7 @@ function node_permission() {
 }
 
 /**
- * Gather the rankings from the the hook_ranking implementations.
+ * Gathers the rankings from the the hook_ranking() implementations.
  *
  * @param $query
  *   A query object that has been extended with the Search DB Extender.
@@ -1804,6 +1864,7 @@ function node_user_delete($account) {
  *   An associative array containing:
  *   - form: A render element representing the form.
  *
+ * @see node_search_admin()
  * @ingroup themeable
  */
 function theme_node_search_admin($variables) {
@@ -1872,11 +1933,11 @@ function _node_revision_access($node, $op = 'view', $account = NULL) {
     $node_current_revision = node_load($node->nid);
     $is_current_revision = $node_current_revision->vid == $node->vid;
 
-    // There should be at least two revisions. If the vid of the given node
-    // and the vid of the current revision differ, then we already have two
+    // There should be at least two revisions. If the vid of the given node and
+    // the vid of the current revision differ, then we already have two
     // different revisions so there is no need for a separate database check.
-    // Also, if you try to revert to or delete the current revision, that's
-    // not good.
+    // Also, if you try to revert to or delete the current revision, that's not
+    // good.
     if ($is_current_revision && (db_query('SELECT COUNT(vid) FROM {node_revision} WHERE nid = :nid', array(':nid' => $node->nid))->fetchField() == 1 || $op == 'update' || $op == 'delete')) {
       $access[$cid] = FALSE;
     }
@@ -1884,8 +1945,8 @@ function _node_revision_access($node, $op = 'view', $account = NULL) {
       $access[$cid] = TRUE;
     }
     else {
-      // First check the access to the current revision and finally, if the
-      // node passed in is not the current revision then access to that, too.
+      // First check the access to the current revision and finally, if the node
+      // passed in is not the current revision then access to that, too.
       $access[$cid] = node_access($op, $node_current_revision, $account) && ($is_current_revision || node_access($op, $node, $account));
     }
   }
@@ -1893,6 +1954,14 @@ function _node_revision_access($node, $op = 'view', $account = NULL) {
   return $access[$cid];
 }
 
+/**
+ * Access callback: Checks whether the user has permission to add a node.
+ *
+ * @return
+ *   TRUE if the user has add permission, otherwise FALSE.
+ *
+ * @see node_menu()
+ */
 function _node_add_access() {
   $types = node_type_get_types();
   foreach ($types as $type) {
@@ -2110,14 +2179,30 @@ function node_menu_local_tasks_alter(&$data, $router_item, $root_path) {
 }
 
 /**
- * Title callback for a node type.
+ * Title callback: Returns the unsanitized title of the node type edit form.
+ *
+ * @param $type
+ *   The node type object.
+ *
+ * @return string
+ *   An unsanitized string that is the title of the node type edit form.
+ *
+ * @see node_menu()
  */
 function node_type_page_title($type) {
   return $type->name;
 }
 
 /**
- * Title callback.
+ * Title callback: Returns the title of the node.
+ *
+ * @param $node
+ *   The node object.
+ *
+ * @return
+ *   An unsanitized string that is the title of the node.
+ *
+ * @see node_menu()
  */
 function node_page_title($node) {
   return $node->title;
@@ -2137,7 +2222,13 @@ function node_last_changed($nid) {
 }
 
 /**
- * Return a list of all the existing revision numbers.
+ * Returns a list of all the existing revision numbers.
+ *
+ * @param Drupal\node\Node $node
+ *   The node entity.
+ *
+ * @return
+ *   An associative array keyed by node revision number.
  */
 function node_revision_list($node) {
   $revisions = array();
@@ -2223,16 +2314,16 @@ function node_block_save($delta = '', $edit = array()) {
  *   (optional) The maximum number of nodes to find. Defaults to 10.
  *
  * @return
- *   An array of partial node objects or an empty array if there are no recent
- *   nodes visible to the current user.
+ *   An array of node entities or an empty array if there are no recent nodes
+ *   visible to the current user.
  */
 function node_get_recent($number = 10) {
   $query = db_select('node', 'n');
 
   if (!user_access('bypass node access')) {
-    // If the user is able to view their own unpublished nodes, allow them
-    // to see these in addition to published nodes. Check that they actually
-    // have some unpublished nodes to view before adding the condition.
+    // If the user is able to view their own unpublished nodes, allow them to
+    // see these in addition to published nodes. Check that they actually have
+    // some unpublished nodes to view before adding the condition.
     if (user_access('view own unpublished content') && $own_unpublished = db_query('SELECT nid FROM {node} WHERE uid = :uid AND status = :status', array(':uid' => $GLOBALS['user']->uid, ':status' => NODE_NOT_PUBLISHED))->fetchCol()) {
       $query->condition(db_or()
         ->condition('n.status', NODE_PUBLISHED)
@@ -2362,7 +2453,7 @@ function node_form_block_admin_configure_alter(&$form, &$form_state) {
 }
 
 /**
- * Form submit handler for block configuration form.
+ * Form submission handler for node_form_block_admin_configure_alter().
  *
  * @see node_form_block_admin_configure_alter()
  */
@@ -2394,7 +2485,7 @@ function node_form_block_custom_block_delete_alter(&$form, &$form_state) {
 }
 
 /**
- * Form submit handler for custom block delete form.
+ * Form submission handler for node_form_block_custom_block_delete_alter().
  *
  * @see node_form_block_custom_block_delete_alter()
  */
@@ -2419,8 +2510,8 @@ function node_modules_uninstalled($modules) {
 /**
  * Implements hook_block_list_alter().
  *
- * Check the content type specific visibilty settings.
- * Remove the block if the visibility conditions are not met.
+ * Check the content type specific visibilty settings. Remove the block if the
+ * visibility conditions are not met.
  */
 function node_block_list_alter(&$blocks) {
   global $theme_key;
@@ -2485,7 +2576,8 @@ function node_block_list_alter(&$blocks) {
  * @param $channel
  *   An associative array containing title, link, description and other keys,
  *   to be parsed by format_rss_channel() and format_xml_elements().
- *   A list of channel elements can be found at the @link http://cyber.law.harvard.edu/rss/rss.html RSS 2.0 Specification. @endlink
+ *   A list of channel elements can be found at the
+ *   @link http://cyber.law.harvard.edu/rss/rss.html RSS 2.0 Specification. @endlink
  *   The link should be an absolute URL.
  */
 function node_feed($nids = FALSE, $channel = array()) {
@@ -2505,7 +2597,6 @@ function node_feed($nids = FALSE, $channel = array()) {
 
   $item_length = variable_get('feed_item_length', 'fulltext');
   $namespaces = array('xmlns:dc' => 'http://purl.org/dc/elements/1.1/');
-  $teaser = ($item_length == 'teaser');
 
   // Load all nodes to be rendered.
   $nodes = node_load_multiple($nids);
@@ -2559,7 +2650,7 @@ function node_feed($nids = FALSE, $channel = array()) {
 }
 
 /**
- * Construct a drupal_render() style array from an array of loaded nodes.
+ * Constructs a drupal_render() style array from an array of loaded nodes.
  *
  * @param $nodes
  *   An array of nodes as returned by node_load_multiple().
@@ -2568,8 +2659,8 @@ function node_feed($nids = FALSE, $channel = array()) {
  * @param $weight
  *   An integer representing the weight of the first node in the list.
  * @param $langcode
- *   (optional) A language code to use for rendering. Defaults to the global
- *   content language of the current request.
+ *   (optional) A language code to use for rendering. Defaults to NULL which is
+ *   the global content language of the current request.
  *
  * @return
  *   An array in the format expected by drupal_render().
@@ -2588,7 +2679,12 @@ function node_view_multiple($nodes, $view_mode = 'teaser', $weight = 0, $langcod
 }
 
 /**
- * Menu callback; Generate a listing of promoted nodes.
+ * Menu callback: Generates a listing of promoted nodes.
+ *
+ * @return array
+ *   An array in the format expected by drupal_render().
+ *
+ * @see node_menu()
  */
 function node_page_default() {
   $select = db_select('node', 'n')
@@ -2638,7 +2734,15 @@ function node_page_default() {
 }
 
 /**
- * Menu callback; view a single node.
+ * Menu callback: Displays a single node.
+ *
+ * @param $node
+ *   The node object.
+ *
+ * @return
+ *   A page array suitable for use by drupal_render().
+ *
+ * @see node_menu()
  */
 function node_page_view($node) {
   // If there is a menu link to this node, the link becomes the last part
@@ -2667,7 +2771,7 @@ function node_update_index() {
 }
 
 /**
- * Index a single node.
+ * Indexes a single node.
  *
  * @param $node
  *   The node to index.
@@ -2771,7 +2875,7 @@ function node_form_search_form_alter(&$form, $form_state) {
 }
 
 /**
- * Form API callback for the search form. Registered in node_form_alter().
+ * Form validation handler for node_form_alter().
  */
 function node_search_validate($form, &$form_state) {
   // Initialize using any existing basic search keywords.
@@ -2819,8 +2923,8 @@ function node_search_validate($form, &$form_state) {
  * @{
  * The node access system determines who can do what to which nodes.
  *
- * In determining access rights for a node, node_access() first checks
- * whether the user has the "bypass node access" permission. Such users have
+ * In determining access rights for a node, node_access() first checks whether
+ * the user has the "bypass node access" permission. Such users have
  * unrestricted access to all nodes. user 1 will always pass this check.
  *
  * Next, all implementations of hook_node_access() will be called. Each
@@ -2858,8 +2962,7 @@ function node_search_validate($form, &$form_state) {
  */
 
 /**
- * Determine whether the current user may perform the given operation on the
- * specified node.
+ * Determines whether the current user may perform the operation on the node.
  *
  * @param $op
  *   The operation to be performed on the node. Possible values are:
@@ -2873,6 +2976,7 @@ function node_search_validate($form, &$form_state) {
  * @param $account
  *   Optional, a user object representing the user for whom the operation is to
  *   be performed. Determines access for a user other than the current user.
+ *
  * @return
  *   TRUE if the operation may be performed, FALSE otherwise.
  */
@@ -3005,6 +3109,7 @@ function node_node_access($node, $op, $account) {
  *
  * @param $type
  *   The machine-readable name of the node type.
+ *
  * @return array
  *   An array of permission names and descriptions.
  */
@@ -3038,11 +3143,11 @@ function node_list_permissions($type) {
  *
  * By default, this will include all node types in the system. To exclude a
  * specific node from getting permissions defined for it, set the
- * node_permissions_$type variable to 0. Core does not provide an interface
- * for doing so, however, contrib modules may exclude their own nodes in
+ * node_permissions_$type variable to 0. Core does not provide an interface for
+ * doing so. However, contrib modules may exclude their own nodes in
  * hook_install(). Alternatively, contrib modules may configure all node types
- * at once, or decide to apply some other hook_node_access() implementation
- * to some or all node types.
+ * at once, or decide to apply some other hook_node_access() implementation to
+ * some or all node types.
  *
  * @return
  *   An array of node types managed by this module.
@@ -3061,21 +3166,22 @@ function node_permissions_get_configured_types() {
 }
 
 /**
- * Fetch an array of permission IDs granted to the given user ID.
+ * Fetches an array of permission IDs granted to the given user ID.
  *
  * The implementation here provides only the universal "all" grant. A node
- * access module should implement hook_node_grants() to provide a grant
- * list for the user.
+ * access module should implement hook_node_grants() to provide a grant list for
+ * the user.
  *
- * After the default grants have been loaded, we allow modules to alter
- * the grants array by reference. This hook allows for complex business
- * logic to be applied when integrating multiple node access modules.
+ * After the default grants have been loaded, we allow modules to alter the
+ * grants array by reference. This hook allows for complex business logic to be
+ * applied when integrating multiple node access modules.
  *
  * @param $op
  *   The operation that the user is trying to perform.
  * @param $account
  *   The user object for the user performing the operation. If omitted, the
  *   current user is used.
+ *
  * @return
  *   An associative array in which the keys are realms, and the values are
  *   arrays of grants for those realms.
@@ -3163,11 +3269,10 @@ function node_access_view_all_nodes($account = NULL) {
 /**
  * Implements hook_query_TAG_alter().
  *
- * This is the hook_query_alter() for queries tagged with 'node_access'.
- * It adds node access checks for the user account given by the 'account'
- * meta-data (or global $user if not provided), for an operation given by
- * the 'op' meta-data (or 'view' if not provided; other possible values are
- * 'update' and 'delete').
+ * This is the hook_query_alter() for queries tagged with 'node_access'. It adds
+ * node access checks for the user account given by the 'account' meta-data (or
+ * global $user if not provided), for an operation given by the 'op' meta-data
+ * (or 'view' if not provided; other possible values are 'update' and 'delete').
  */
 function node_query_node_access_alter(QueryAlterableInterface $query) {
   _node_query_node_access_alter($query, 'node');
@@ -3206,8 +3311,8 @@ function _node_query_node_access_alter($query, $type) {
   }
 
   // If $account can bypass node access, or there are no node access modules,
-  // or the operation is 'view' and the $acount has a global view grant (i.e.,
-  // a view grant for node ID 0), we don't need to alter the query.
+  // or the operation is 'view' and the $account has a global view grant
+  // (such as a view grant for node ID 0), we don't need to alter the query.
   if (user_access('bypass node access', $account)) {
     return;
   }
@@ -3394,15 +3499,14 @@ function node_access_acquire_grants($node, $delete = TRUE) {
  *
  * If a realm is provided, it will only delete grants from that realm, but it
  * will always delete a grant from the 'all' realm. Modules that utilize
- * node_access can use this function when doing mass updates due to widespread
+ * node_access() can use this function when doing mass updates due to widespread
  * permission changes.
  *
  * Note: Don't call this function directly from a contributed module. Call
  * node_access_acquire_grants() instead.
  *
  * @param $node
- *   The $node being written to. All that is necessary is that it contains a
- *   nid.
+ *   The node whose grants are being written.
  * @param $grants
  *   A list of grants to write. Each grant is an array that must contain the
  *   following keys: realm, gid, grant_view, grant_update, grant_delete.
@@ -3410,10 +3514,14 @@ function node_access_acquire_grants($node, $delete = TRUE) {
  *   is a module-defined id to define grant privileges. each grant_* field
  *   is a boolean value.
  * @param $realm
- *   If provided, only read/write grants for that realm.
+ *   (optional) If provided, read/write grants for that realm only. Defaults to
+ *   NULL.
  * @param $delete
- *   If false, do not delete records. This is only for optimization purposes,
- *   and assumes the caller has already performed a mass delete of some form.
+ *   (optional) If false, does not delete records. This is only for optimization
+ *   purposes, and assumes the caller has already performed a mass delete of
+ *   some form. Defaults to TRUE.
+ *
+ * @see node_access_acquire_grants()
  */
 function node_access_write_grants($node, $grants, $realm = NULL, $delete = TRUE) {
   if ($delete) {
@@ -3442,21 +3550,23 @@ function node_access_write_grants($node, $grants, $realm = NULL, $delete = TRUE)
 }
 
 /**
- * Flag / unflag the node access grants for rebuilding, or read the current
- * value of the flag.
+ * Flags or unflags the node access grants for rebuilding.
  *
+ * If the argument isn't specified, the current value of the flag is returned.
  * When the flag is set, a message is displayed to users with 'access
  * administration pages' permission, pointing to the 'rebuild' confirm form.
  * This can be used as an alternative to direct node_access_rebuild calls,
  * allowing administrators to decide when they want to perform the actual
- * (possibly time consuming) rebuild.
- * When unsure the current user is an administrator, node_access_rebuild
- * should be used instead.
+ * (possibly time consuming) rebuild. When unsure if the current user is an
+ * administrator, node_access_rebuild() should be used instead.
  *
  * @param $rebuild
  *   (Optional) The boolean value to be written.
-  * @return
- *   (If no value was provided for $rebuild) The current value of the flag.
+ *
+ * @return
+ *   The current value of the flag if no value was provided for $rebuild.
+ *
+ * @see node_access_rebuild()
  */
 function node_access_needs_rebuild($rebuild = NULL) {
   if (!isset($rebuild)) {
@@ -3471,15 +3581,15 @@ function node_access_needs_rebuild($rebuild = NULL) {
 }
 
 /**
- * Rebuild the node access database. This is occasionally needed by modules
- * that make system-wide changes to access levels.
+ * Rebuilds the node access database.
  *
- * When the rebuild is required by an admin-triggered action (e.g module
- * settings form), calling node_access_needs_rebuild(TRUE) instead of
+ * This is occasionally needed by modules that make system-wide changes to
+ * access levels. When the rebuild is required by an admin-triggered action (e.g
+ * module settings form), calling node_access_needs_rebuild(TRUE) instead of
  * node_access_rebuild() lets the user perform his changes and actually
  * rebuild only once he is done.
  *
- * Note : As of Drupal 6, node access modules are not required to (and actually
+ * Note: As of Drupal 6, node access modules are not required to (and actually
  * should not) call node_access_rebuild() in hook_enable/disable anymore.
  *
  * @see node_access_needs_rebuild()
@@ -3543,11 +3653,14 @@ function node_access_rebuild($batch_mode = FALSE) {
 }
 
 /**
- * Batch operation for node_access_rebuild_batch.
+ * Performs batch operation for node_access_rebuild().
  *
- * This is a multistep operation : we go through all nodes by packs of 20.
- * The batch processing engine interrupts processing and sends progress
- * feedback after 1 second execution time.
+ * This is a multistep operation: we go through all nodes by packs of 20. The
+ * batch processing engine interrupts processing and sends progress feedback
+ * after 1 second execution time.
+ *
+ * @param array $context
+ *   An array of contextual key/value information for rebuild batch process.
  */
 function _node_access_rebuild_batch_operation(&$context) {
   if (empty($context['sandbox'])) {
@@ -3578,7 +3691,14 @@ function _node_access_rebuild_batch_operation(&$context) {
 }
 
 /**
- * Post-processing for node_access_rebuild_batch.
+ * Performs post-processing for node_access_rebuild().
+ *
+ * @param bool $success
+ *   A boolean indicating whether the re-build process has completed.
+ * @param array $results
+ *   An array of results information.
+ * @param array $operations
+ *   An array of function calls (not used in this function).
  */
 function _node_access_rebuild_batch_finished($success, $results, $operations) {
   if ($success) {
@@ -3595,7 +3715,6 @@ function _node_access_rebuild_batch_finished($success, $results, $operations) {
  * @} End of "defgroup node_access".
  */
 
-
 /**
  * @defgroup node_content Hook implementations for user-created content types
  * @{
@@ -3631,6 +3750,7 @@ function node_content_form($node, $form_state) {
 
 /**
  * Implements hook_forms().
+ *
  * All node forms share the same form handler.
  */
 function node_forms() {
@@ -3715,6 +3835,12 @@ function node_action_info() {
 /**
  * Sets the status of a node to 1 (published).
  *
+ * @param $node
+ *   A node object.
+ * @param $context
+ *   (optional) Array of additional information about what triggered the action.
+ *   Not used for this action.
+ *
  * @ingroup actions
  */
 function node_publish_action($node, $context = array()) {
@@ -3725,6 +3851,12 @@ function node_publish_action($node, $context = array()) {
 /**
  * Sets the status of a node to 0 (unpublished).
  *
+ * @param $node
+ *   A node object.
+ * @param $context
+ *   (optional) Array of additional information about what triggered the action.
+ *   Not used for this action.
+ *
  * @ingroup actions
  */
 function node_unpublish_action($node, $context = array()) {
@@ -3735,6 +3867,12 @@ function node_unpublish_action($node, $context = array()) {
 /**
  * Sets the sticky-at-top-of-list property of a node to 1.
  *
+ * @param $node
+ *   A node object.
+ * @param $context
+ *   (optional) Array of additional information about what triggered the action.
+ *   Not used for this action.
+ *
  * @ingroup actions
  */
 function node_make_sticky_action($node, $context = array()) {
@@ -3745,6 +3883,12 @@ function node_make_sticky_action($node, $context = array()) {
 /**
  * Sets the sticky-at-top-of-list property of a node to 0.
  *
+ * @param $node
+ *   A node object.
+ * @param $context
+ *   (optional) Array of additional information about what triggered the action.
+ *   Not used for this action.
+ *
  * @ingroup actions
  */
 function node_make_unsticky_action($node, $context = array()) {
@@ -3755,6 +3899,12 @@ function node_make_unsticky_action($node, $context = array()) {
 /**
  * Sets the promote property of a node to 1.
  *
+ * @param $node
+ *   A node object.
+ * @param $context
+ *   (optional) Array of additional information about what triggered the action.
+ *   Not used for this action.
+ *
  * @ingroup actions
  */
 function node_promote_action($node, $context = array()) {
@@ -3765,6 +3915,12 @@ function node_promote_action($node, $context = array()) {
 /**
  * Sets the promote property of a node to 0.
  *
+ * @param $node
+ *   A node object.
+ * @param $context
+ *   (optional) Array of additional information about what triggered the action.
+ *   Not used for this action.
+ *
  * @ingroup actions
  */
 function node_unpromote_action($node, $context = array()) {
@@ -3775,6 +3931,9 @@ function node_unpromote_action($node, $context = array()) {
 /**
  * Saves a node.
  *
+ * @param $node
+ *   The node to be saved.
+ *
  * @ingroup actions
  */
 function node_save_action($node) {
@@ -3791,6 +3950,9 @@ function node_save_action($node) {
  *   Array with the following elements:
  *   - 'owner_uid': User ID to assign to the node.
  *
+ * @see node_assign_owner_action_form()
+ * @see node_assign_owner_action_validate()
+ * @see node_assign_owner_action_submit()
  * @ingroup actions
  */
 function node_assign_owner_action($node, $context) {
@@ -3801,6 +3963,16 @@ function node_assign_owner_action($node, $context) {
 
 /**
  * Generates the settings form for node_assign_owner_action().
+ *
+ * @param $context
+ *   Array of additional information about what triggered the action. Includes
+ *   the following elements:
+ *   - 'owner_uid': User ID to assign to the node.
+ *
+ * @see node_assign_owner_action_submit()
+ * @see node_assign_owner_action_validate()
+ *
+ * @ingroup forms
  */
 function node_assign_owner_action_form($context) {
   $description = t('The username of the user to which you would like to assign ownership.');
@@ -3841,6 +4013,8 @@ function node_assign_owner_action_form($context) {
 
 /**
  * Validates settings form for node_assign_owner_action().
+ *
+ * @see node_assign_owner_action_submit()
  */
 function node_assign_owner_action_validate($form, $form_state) {
   $exists = (bool) db_query_range('SELECT 1 FROM {users} WHERE name = :name', 0, 1, array(':name' => $form_state['values']['owner_name']))->fetchField();
@@ -3851,6 +4025,8 @@ function node_assign_owner_action_validate($form, $form_state) {
 
 /**
  * Saves settings form for node_assign_owner_action().
+ *
+ * @see node_assign_owner_action_validate()
  */
 function node_assign_owner_action_submit($form, $form_state) {
   // Username can change, so we need to store the ID, not the username.
@@ -3860,6 +4036,14 @@ function node_assign_owner_action_submit($form, $form_state) {
 
 /**
  * Generates settings form for node_unpublish_by_keyword_action().
+ *
+ * @param array $context
+ *   Array of additional information about what triggered this action.
+ *
+ * @return array
+ *   A form array.
+ *
+ * @see node_unpublish_by_keyword_action_submit()
  */
 function node_unpublish_by_keyword_action_form($context) {
   $form['keywords'] = array(
diff --git a/modules/node/node.pages.inc b/modules/node/node.pages.inc
index c6cb1bc..75ed0dd 100644
--- a/modules/node/node.pages.inc
+++ b/modules/node/node.pages.inc
@@ -5,7 +5,6 @@
  * Page callbacks for adding, editing, deleting, and revisions management for content.
  */
 
-
 /**
  * Menu callback; presents the node editing form.
  */
@@ -63,6 +62,12 @@ function theme_node_add_list($variables) {
 
 /**
  * Returns a node submission form.
+ *
+ * @param $type
+ *   The node type for the submitted node.
+ *
+ * @return
+ *   The themed form.
  */
 function node_add($type) {
   global $user;
@@ -75,6 +80,12 @@ function node_add($type) {
   return $output;
 }
 
+/**
+ * Form validation handler for node_form().
+ *
+ * @see node_form()
+ * @see node_form_submit()
+ */
 function node_form_validate($form, &$form_state) {
   // $form_state['node'] contains the actual entity being edited, but we must
   // not update it with form values that have not yet been validated, so we
@@ -85,7 +96,13 @@ function node_form_validate($form, &$form_state) {
 }
 
 /**
- * Generate the node add/edit form array.
+ * Form constructor for the node add/edit form.
+ *
+ * @see node_form_validate()
+ * @see node_form_submit()
+ * @see node_form_build_preview()
+ * @see node_form_delete_submit()
+ * @ingroup forms
  */
 function node_form($form, &$form_state, $node) {
   global $user;
@@ -311,7 +328,12 @@ function node_form($form, &$form_state, $node) {
 }
 
 /**
- * Button submit function: handle the 'Delete' button on the node form.
+ * Form submission handler for node_form().
+ *
+ * Handles the 'Delete' button on the node form.
+ *
+ * @see node_form()
+ * @see node_form_validate()
  */
 function node_form_delete_submit($form, &$form_state) {
   $destination = array();
@@ -323,7 +345,14 @@ function node_form_delete_submit($form, &$form_state) {
   $form_state['redirect'] = array('node/' . $node->nid . '/delete', array('query' => $destination));
 }
 
-
+/**
+ * Form submission handler for node_form().
+ *
+ * Handles the 'Preview' button on the node form.
+ *
+ * @see node_form()
+ * @see node_form_validate()
+ */
 function node_form_build_preview($form, &$form_state) {
   $node = node_form_submit_build_node($form, $form_state);
   $form_state['node_preview'] = node_preview($node);
@@ -331,7 +360,15 @@ function node_form_build_preview($form, &$form_state) {
 }
 
 /**
- * Generate a node preview.
+ * Generates a node preview.
+ *
+ * @param $node
+ *   The node to preview.
+ *
+ * @return
+ *   An HTML-formatted string of a node preview.
+ *
+ * @see node_form_build_preview()
  */
 function node_preview($node) {
   if (node_access('create', $node) || node_access('update', $node)) {
@@ -377,6 +414,7 @@ function node_preview($node) {
  *   An associative array containing:
  *   - node: The node object which is being previewed.
  *
+ * @see node_preview()
  * @ingroup themeable
  */
 function theme_node_preview($variables) {
@@ -407,6 +445,12 @@ function theme_node_preview($variables) {
   return $output;
 }
 
+/**
+ * Form submission handler for node_form().
+ *
+ * @see node_form()
+ * @see node_form_validate()
+ */
 function node_form_submit($form, &$form_state) {
   $node = node_form_submit_build_node($form, $form_state);
   $insert = empty($node->nid);
@@ -426,7 +470,7 @@ function node_form_submit($form, &$form_state) {
   if ($node->nid) {
     $form_state['values']['nid'] = $node->nid;
     $form_state['nid'] = $node->nid;
-    $form_state['redirect'] = 'node/' . $node->nid;
+    $form_state['redirect'] = node_access('view', $node) ? 'node/' . $node->nid : '<front>';
   }
   else {
     // In the unlikely case something went wrong on save, the node will be
@@ -472,7 +516,9 @@ function node_form_submit_build_node($form, &$form_state) {
 }
 
 /**
- * Menu callback -- ask for confirmation of node deletion
+ * Form constructor for the node deletion confirmation form.
+ *
+ * @see node_delete_confirm_submit()
  */
 function node_delete_confirm($form, &$form_state, $node) {
   $form['#node'] = $node;
@@ -488,7 +534,9 @@ function node_delete_confirm($form, &$form_state, $node) {
 }
 
 /**
- * Execute node deletion
+ * Executes node deletion.
+ *
+ * @see node_delete_confirm()
  */
 function node_delete_confirm_submit($form, &$form_state) {
   if ($form_state['values']['confirm']) {
@@ -502,7 +550,15 @@ function node_delete_confirm_submit($form, &$form_state) {
 }
 
 /**
- * Generate an overview table of older revisions of a node.
+ * Generates an overview table of older revisions of a node.
+ *
+ * @param $node
+ *   A node object.
+ *
+ * @return array
+ *   An array as expected by drupal_render().
+ *
+ * @see node_menu()
  */
 function node_revision_overview($node) {
   drupal_set_title(t('Revisions for %title', array('%title' => $node->title)), PASS_THROUGH);
@@ -553,13 +609,26 @@ function node_revision_overview($node) {
 }
 
 /**
- * Ask for confirmation of the reversion to prevent against CSRF attacks.
+ * Asks for confirmation of the reversion to prevent against CSRF attacks.
+ *
+ * @param int $node_revision
+ *   The node revision ID.
+ *
+ * @return array
+ *   An array as expected by drupal_render().
+ *
+ * @see node_menu()
+ * @see node_revision_revert_confirm_submit()
+ * @ingroup forms
  */
 function node_revision_revert_confirm($form, $form_state, $node_revision) {
   $form['#node_revision'] = $node_revision;
   return confirm_form($form, t('Are you sure you want to revert to the revision from %revision-date?', array('%revision-date' => format_date($node_revision->revision_timestamp))), 'node/' . $node_revision->nid . '/revisions', '', t('Revert'), t('Cancel'));
 }
 
+/**
+ * Form submission handler for node_revision_revert_confirm().
+ */
 function node_revision_revert_confirm_submit($form, &$form_state) {
   $node_revision = $form['#node_revision'];
   $node_revision->revision = 1;
@@ -572,11 +641,29 @@ function node_revision_revert_confirm_submit($form, &$form_state) {
   $form_state['redirect'] = 'node/' . $node_revision->nid . '/revisions';
 }
 
+/**
+ * Form constructor for the revision deletion confirmation form.
+ *
+ * This form prevents against CSRF attacks.
+ *
+ * @param $node_revision
+ *   The node revision ID.
+ *
+ * @return
+ *   An array as expected by drupal_render().
+ *
+ * @see node_menu()
+ * @see node_revision_delete_confirm_submit()
+ * @ingroup forms
+ */
 function node_revision_delete_confirm($form, $form_state, $node_revision) {
   $form['#node_revision'] = $node_revision;
   return confirm_form($form, t('Are you sure you want to delete the revision from %revision-date?', array('%revision-date' => format_date($node_revision->revision_timestamp))), 'node/' . $node_revision->nid . '/revisions', t('This action cannot be undone.'), t('Delete'), t('Cancel'));
 }
 
+/**
+ * Form submission handler for node_revision_delete_confirm().
+ */
 function node_revision_delete_confirm_submit($form, &$form_state) {
   $node_revision = $form['#node_revision'];
   node_revision_delete($node_revision->vid);
diff --git a/modules/node/node.test b/modules/node/node.test
index d789d3c..b1d78fa 100644
--- a/modules/node/node.test
+++ b/modules/node/node.test
@@ -55,53 +55,53 @@ class NodeLoadMultipleTestCase extends DrupalWebTestCase {
 
     // Confirm that promoted nodes appear in the default node listing.
     $this->drupalGet('node');
-    $this->assertText($node1->title, t('Node title appears on the default listing.'));
-    $this->assertText($node2->title, t('Node title appears on the default listing.'));
-    $this->assertNoText($node3->title, t('Node title does not appear in the default listing.'));
-    $this->assertNoText($node4->title, t('Node title does not appear in the default listing.'));
+    $this->assertText($node1->title, 'Node title appears on the default listing.');
+    $this->assertText($node2->title, 'Node title appears on the default listing.');
+    $this->assertNoText($node3->title, 'Node title does not appear in the default listing.');
+    $this->assertNoText($node4->title, 'Node title does not appear in the default listing.');
 
     // Load nodes with only a condition. Nodes 3 and 4 will be loaded.
     $nodes = node_load_multiple(NULL, array('promote' => 0));
-    $this->assertEqual($node3->title, $nodes[$node3->nid]->title, t('Node was loaded.'));
-    $this->assertEqual($node4->title, $nodes[$node4->nid]->title, t('Node was loaded.'));
+    $this->assertEqual($node3->title, $nodes[$node3->nid]->title, 'Node was loaded.');
+    $this->assertEqual($node4->title, $nodes[$node4->nid]->title, 'Node was loaded.');
     $count = count($nodes);
-    $this->assertTrue($count == 2, t('@count nodes loaded.', array('@count' => $count)));
+    $this->assertTrue($count == 2, format_string('@count nodes loaded.', array('@count' => $count)));
 
     // Load nodes by nid. Nodes 1, 2 and 4 will be loaded.
     $nodes = node_load_multiple(array(1, 2, 4));
     $count = count($nodes);
-    $this->assertTrue(count($nodes) == 3, t('@count nodes loaded', array('@count' => $count)));
-    $this->assertTrue(isset($nodes[$node1->nid]), t('Node is correctly keyed in the array'));
-    $this->assertTrue(isset($nodes[$node2->nid]), t('Node is correctly keyed in the array'));
-    $this->assertTrue(isset($nodes[$node4->nid]), t('Node is correctly keyed in the array'));
+    $this->assertTrue(count($nodes) == 3, format_string('@count nodes loaded', array('@count' => $count)));
+    $this->assertTrue(isset($nodes[$node1->nid]), 'Node is correctly keyed in the array');
+    $this->assertTrue(isset($nodes[$node2->nid]), 'Node is correctly keyed in the array');
+    $this->assertTrue(isset($nodes[$node4->nid]), 'Node is correctly keyed in the array');
     foreach ($nodes as $node) {
-      $this->assertTrue(is_object($node), t('Node is an object'));
+      $this->assertTrue(is_object($node), 'Node is an object');
     }
 
     // Load nodes by nid, where type = article. Nodes 1, 2 and 3 will be loaded.
     $nodes = node_load_multiple(array(1, 2, 3, 4), array('type' => 'article'));
     $count = count($nodes);
-    $this->assertTrue($count == 3, t('@count nodes loaded', array('@count' => $count)));
-    $this->assertEqual($nodes[$node1->nid]->title, $node1->title, t('Node successfully loaded.'));
-    $this->assertEqual($nodes[$node2->nid]->title, $node2->title, t('Node successfully loaded.'));
-    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, t('Node successfully loaded.'));
+    $this->assertTrue($count == 3, format_string('@count nodes loaded', array('@count' => $count)));
+    $this->assertEqual($nodes[$node1->nid]->title, $node1->title, 'Node successfully loaded.');
+    $this->assertEqual($nodes[$node2->nid]->title, $node2->title, 'Node successfully loaded.');
+    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, 'Node successfully loaded.');
     $this->assertFalse(isset($nodes[$node4->nid]));
 
     // Now that all nodes have been loaded into the static cache, ensure that
     // they are loaded correctly again when a condition is passed.
     $nodes = node_load_multiple(array(1, 2, 3, 4), array('type' => 'article'));
     $count = count($nodes);
-    $this->assertTrue($count == 3, t('@count nodes loaded.', array('@count' => $count)));
-    $this->assertEqual($nodes[$node1->nid]->title, $node1->title, t('Node successfully loaded'));
-    $this->assertEqual($nodes[$node2->nid]->title, $node2->title, t('Node successfully loaded'));
-    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, t('Node successfully loaded'));
-    $this->assertFalse(isset($nodes[$node4->nid]), t('Node was not loaded'));
+    $this->assertTrue($count == 3, format_string('@count nodes loaded.', array('@count' => $count)));
+    $this->assertEqual($nodes[$node1->nid]->title, $node1->title, 'Node successfully loaded');
+    $this->assertEqual($nodes[$node2->nid]->title, $node2->title, 'Node successfully loaded');
+    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, 'Node successfully loaded');
+    $this->assertFalse(isset($nodes[$node4->nid]), 'Node was not loaded');
 
     // Load nodes by nid, where type = article and promote = 0.
     $nodes = node_load_multiple(array(1, 2, 3, 4), array('type' => 'article', 'promote' => 0));
     $count = count($nodes);
-    $this->assertTrue($count == 1, t('@count node loaded', array('@count' => $count)));
-    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, t('Node successfully loaded.'));
+    $this->assertTrue($count == 1, format_string('@count node loaded', array('@count' => $count)));
+    $this->assertEqual($nodes[$node3->nid]->title, $node3->title, 'Node successfully loaded.');
   }
 }
 
@@ -136,21 +136,36 @@ class NodeLoadHooksTestCase extends DrupalWebTestCase {
     // reflect the expected values.
     $nodes = node_load_multiple(array(), array('status' => NODE_PUBLISHED));
     $loaded_node = end($nodes);
-    $this->assertEqual($loaded_node->node_test_loaded_nids, array($node1->nid, $node2->nid), t('hook_node_load() received the correct list of node IDs the first time it was called.'));
-    $this->assertEqual($loaded_node->node_test_loaded_types, array('article'), t('hook_node_load() received the correct list of node types the first time it was called.'));
+    $this->assertEqual($loaded_node->node_test_loaded_nids, array($node1->nid, $node2->nid), 'hook_node_load() received the correct list of node IDs the first time it was called.');
+    $this->assertEqual($loaded_node->node_test_loaded_types, array('article'), 'hook_node_load() received the correct list of node types the first time it was called.');
 
     // Now, as part of the same page request, load a set of nodes that contain
     // both articles and pages, and make sure the parameters passed to
     // node_test_node_load() are correctly updated.
     $nodes = node_load_multiple(array(), array('status' => NODE_NOT_PUBLISHED));
     $loaded_node = end($nodes);
-    $this->assertEqual($loaded_node->node_test_loaded_nids, array($node3->nid, $node4->nid), t('hook_node_load() received the correct list of node IDs the second time it was called.'));
-    $this->assertEqual($loaded_node->node_test_loaded_types, array('article', 'page'), t('hook_node_load() received the correct list of node types the second time it was called.'));
+    $this->assertEqual($loaded_node->node_test_loaded_nids, array($node3->nid, $node4->nid), 'hook_node_load() received the correct list of node IDs the second time it was called.');
+    $this->assertEqual($loaded_node->node_test_loaded_types, array('article', 'page'), 'hook_node_load() received the correct list of node types the second time it was called.');
   }
 }
 
+/**
+ * Tests the node revision functionality.
+ */
 class NodeRevisionsTestCase extends DrupalWebTestCase {
+
+  /**
+   * Nodes used by the test.
+   *
+   * @var array
+   */
   protected $nodes;
+
+  /**
+   * The revision messages for node revisions created in the test.
+   *
+   * @var array
+   */
   protected $logs;
 
   public static function getInfo() {
@@ -198,7 +213,7 @@ class NodeRevisionsTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Check node revision related operations.
+   * Checks node revision related operations.
    */
   function testRevisions() {
     $nodes = $this->nodes;
@@ -209,28 +224,28 @@ class NodeRevisionsTestCase extends DrupalWebTestCase {
 
     // Confirm the correct revision text appears on "view revisions" page.
     $this->drupalGet("node/$node->nid/revisions/$node->vid/view");
-    $this->assertText($node->body[LANGUAGE_NONE][0]['value'], t('Correct text displays for version.'));
+    $this->assertText($node->body[LANGUAGE_NONE][0]['value'], 'Correct text displays for version.');
 
     // Confirm the correct log message appears on "revisions overview" page.
     $this->drupalGet("node/$node->nid/revisions");
     foreach ($logs as $log) {
-      $this->assertText($log, t('Log message found.'));
+      $this->assertText($log, 'Log message found.');
     }
 
     // Confirm that revisions revert properly.
     $this->drupalPost("node/$node->nid/revisions/{$nodes[1]->vid}/revert", array(), t('Revert'));
     $this->assertRaw(t('@type %title has been reverted back to the revision from %revision-date.',
                         array('@type' => 'Basic page', '%title' => $nodes[1]->title,
-                              '%revision-date' => format_date($nodes[1]->revision_timestamp))), t('Revision reverted.'));
+                              '%revision-date' => format_date($nodes[1]->revision_timestamp))), 'Revision reverted.');
     $reverted_node = node_load($node->nid);
-    $this->assertTrue(($nodes[1]->body[LANGUAGE_NONE][0]['value'] == $reverted_node->body[LANGUAGE_NONE][0]['value']), t('Node reverted correctly.'));
+    $this->assertTrue(($nodes[1]->body[LANGUAGE_NONE][0]['value'] == $reverted_node->body[LANGUAGE_NONE][0]['value']), 'Node reverted correctly.');
 
     // Confirm revisions delete properly.
     $this->drupalPost("node/$node->nid/revisions/{$nodes[1]->vid}/delete", array(), t('Delete'));
     $this->assertRaw(t('Revision from %revision-date of @type %title has been deleted.',
                         array('%revision-date' => format_date($nodes[1]->revision_timestamp),
-                              '@type' => 'Basic page', '%title' => $nodes[1]->title)), t('Revision deleted.'));
-    $this->assertTrue(db_query('SELECT COUNT(vid) FROM {node_revision} WHERE nid = :nid and vid = :vid', array(':nid' => $node->nid, ':vid' => $nodes[1]->vid))->fetchField() == 0, t('Revision not found.'));
+                              '@type' => 'Basic page', '%title' => $nodes[1]->title)), 'Revision deleted.');
+    $this->assertTrue(db_query('SELECT COUNT(vid) FROM {node_revision} WHERE nid = :nid and vid = :vid', array(':nid' => $node->nid, ':vid' => $nodes[1]->vid))->fetchField() == 0, 'Revision not found.');
   }
 
   /**
@@ -256,9 +271,9 @@ class NodeRevisionsTestCase extends DrupalWebTestCase {
     );
     node_save($updated_node);
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText($new_title, t('New node title appears on the page.'));
+    $this->assertText($new_title, 'New node title appears on the page.');
     $node_revision = node_load($node->nid, NULL, TRUE);
-    $this->assertEqual($node_revision->log, $log, t('After an existing node revision is re-saved without a log message, the original log message is preserved.'));
+    $this->assertEqual($node_revision->log, $log, 'After an existing node revision is re-saved without a log message, the original log message is preserved.');
 
     // Create another node with an initial log message.
     $node = $this->drupalCreateNode(array('log' => $log));
@@ -282,8 +297,23 @@ class NodeRevisionsTestCase extends DrupalWebTestCase {
   }
 }
 
+/**
+ * Tests the node edit functionality.
+ */
 class PageEditTestCase extends DrupalWebTestCase {
+
+  /**
+   * A user with permission to create and edit own page content.
+   *
+   * @var object
+   */
   protected $web_user;
+
+  /**
+   * A user with permission to bypass node access and administer nodes.
+   *
+   * @var object
+   */
   protected $admin_user;
 
   public static function getInfo() {
@@ -302,7 +332,7 @@ class PageEditTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Check node edit functionality.
+   * Checks node edit functionality.
    */
   function testPageEdit() {
     $this->drupalLogin($this->web_user);
@@ -318,20 +348,20 @@ class PageEditTestCase extends DrupalWebTestCase {
 
     // Check that the node exists in the database.
     $node = $this->drupalGetNodeByTitle($edit[$title_key]);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
 
     // Check that "edit" link points to correct page.
     $this->clickLink(t('Edit'));
     $edit_url = url("node/$node->nid/edit", array('absolute' => TRUE));
     $actual_url = $this->getURL();
-    $this->assertEqual($edit_url, $actual_url, t('On edit page.'));
+    $this->assertEqual($edit_url, $actual_url, 'On edit page.');
 
     // Check that the title and body fields are displayed with the correct values.
     $active = '<span class="element-invisible">' . t('(active tab)') . '</span>';
     $link_text = t('!local-task-title!active', array('!local-task-title' => t('Edit'), '!active' => $active));
-    $this->assertText(strip_tags($link_text), 0, t('Edit tab found and marked active.'));
-    $this->assertFieldByName($title_key, $edit[$title_key], t('Title field displayed.'));
-    $this->assertFieldByName($body_key, $edit[$body_key], t('Body field displayed.'));
+    $this->assertText(strip_tags($link_text), 0, 'Edit tab found and marked active.');
+    $this->assertFieldByName($title_key, $edit[$title_key], 'Title field displayed.');
+    $this->assertFieldByName($body_key, $edit[$body_key], 'Body field displayed.');
 
     // Edit the content of the node.
     $edit = array();
@@ -341,8 +371,8 @@ class PageEditTestCase extends DrupalWebTestCase {
     $this->drupalPost(NULL, $edit, t('Save'));
 
     // Check that the title and body fields are displayed with the updated values.
-    $this->assertText($edit[$title_key], t('Title displayed.'));
-    $this->assertText($edit[$body_key], t('Body displayed.'));
+    $this->assertText($edit[$title_key], 'Title displayed.');
+    $this->assertText($edit[$body_key], 'Body displayed.');
 
     // Login as a second administrator user.
     $second_web_user = $this->drupalCreateUser(array('administer nodes', 'edit any page content'));
@@ -369,7 +399,7 @@ class PageEditTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Check changing node authored by fields.
+   * Tests changing a node's "authored by" field.
    */
   function testPageAuthoredBy() {
     $this->drupalLogin($this->admin_user);
@@ -414,6 +444,9 @@ class PageEditTestCase extends DrupalWebTestCase {
   }
 }
 
+/**
+ * Tests the node entity preview functionality.
+ */
 class PagePreviewTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -431,7 +464,7 @@ class PagePreviewTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Check the node preview functionality.
+   * Checks the node preview functionality.
    */
   function testPagePreview() {
     $langcode = LANGUAGE_NONE;
@@ -445,17 +478,17 @@ class PagePreviewTestCase extends DrupalWebTestCase {
     $this->drupalPost('node/add/page', $edit, t('Preview'));
 
     // Check that the preview is displaying the title and body.
-    $this->assertTitle(t('Preview | Drupal'), t('Basic page title is preview.'));
-    $this->assertText($edit[$title_key], t('Title displayed.'));
-    $this->assertText($edit[$body_key], t('Body displayed.'));
+    $this->assertTitle(t('Preview | Drupal'), 'Basic page title is preview.');
+    $this->assertText($edit[$title_key], 'Title displayed.');
+    $this->assertText($edit[$body_key], 'Body displayed.');
 
     // Check that the title and body fields are displayed with the correct values.
-    $this->assertFieldByName($title_key, $edit[$title_key], t('Title field displayed.'));
-    $this->assertFieldByName($body_key, $edit[$body_key], t('Body field displayed.'));
+    $this->assertFieldByName($title_key, $edit[$title_key], 'Title field displayed.');
+    $this->assertFieldByName($body_key, $edit[$body_key], 'Body field displayed.');
   }
 
   /**
-   * Check the node preview functionality, when using revisions.
+   * Checks the node preview functionality, when using revisions.
    */
   function testPagePreviewWithRevisions() {
     $langcode = LANGUAGE_NONE;
@@ -472,19 +505,22 @@ class PagePreviewTestCase extends DrupalWebTestCase {
     $this->drupalPost('node/add/page', $edit, t('Preview'));
 
     // Check that the preview is displaying the title and body.
-    $this->assertTitle(t('Preview | Drupal'), t('Basic page title is preview.'));
-    $this->assertText($edit[$title_key], t('Title displayed.'));
-    $this->assertText($edit[$body_key], t('Body displayed.'));
+    $this->assertTitle(t('Preview | Drupal'), 'Basic page title is preview.');
+    $this->assertText($edit[$title_key], 'Title displayed.');
+    $this->assertText($edit[$body_key], 'Body displayed.');
 
     // Check that the title and body fields are displayed with the correct values.
-    $this->assertFieldByName($title_key, $edit[$title_key], t('Title field displayed.'));
-    $this->assertFieldByName($body_key, $edit[$body_key], t('Body field displayed.'));
+    $this->assertFieldByName($title_key, $edit[$title_key], 'Title field displayed.');
+    $this->assertFieldByName($body_key, $edit[$body_key], 'Body field displayed.');
 
     // Check that the log field has the correct value.
-    $this->assertFieldByName('log', $edit['log'], t('Log field displayed.'));
+    $this->assertFieldByName('log', $edit['log'], 'Log field displayed.');
   }
 }
 
+/**
+ * Tests creating and saving a node.
+ */
 class NodeCreationTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -503,7 +539,7 @@ class NodeCreationTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create a "Basic page" node and verify its consistency in the database.
+   * Creates a "Basic page" node and verifies its consistency in the database.
    */
   function testNodeCreation() {
     // Create a node.
@@ -514,15 +550,15 @@ class NodeCreationTestCase extends DrupalWebTestCase {
     $this->drupalPost('node/add/page', $edit, t('Save'));
 
     // Check that the Basic page has been created.
-    $this->assertRaw(t('!post %title has been created.', array('!post' => 'Basic page', '%title' => $edit["title"])), t('Basic page created.'));
+    $this->assertRaw(t('!post %title has been created.', array('!post' => 'Basic page', '%title' => $edit["title"])), 'Basic page created.');
 
     // Check that the node exists in the database.
     $node = $this->drupalGetNodeByTitle($edit["title"]);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
   }
 
   /**
-   * Create a page node and verify that a transaction rolls back the failed creation
+   * Verifies that a transaction rolls back the failed creation.
    */
   function testFailedPageCreation() {
     // Create a node.
@@ -545,24 +581,46 @@ class NodeCreationTestCase extends DrupalWebTestCase {
     if (Database::getConnection()->supportsTransactions()) {
       // Check that the node does not exist in the database.
       $node = $this->drupalGetNodeByTitle($edit['title']);
-      $this->assertFalse($node, t('Transactions supported, and node not found in database.'));
+      $this->assertFalse($node, 'Transactions supported, and node not found in database.');
     }
     else {
       // Check that the node exists in the database.
       $node = $this->drupalGetNodeByTitle($edit['title']);
-      $this->assertTrue($node, t('Transactions not supported, and node found in database.'));
+      $this->assertTrue($node, 'Transactions not supported, and node found in database.');
 
       // Check that the failed rollback was logged.
       $records = db_query("SELECT wid FROM {watchdog} WHERE message LIKE 'Explicit rollback failed%'")->fetchAll();
-      $this->assertTrue(count($records) > 0, t('Transactions not supported, and rollback error logged to watchdog.'));
+      $this->assertTrue(count($records) > 0, 'Transactions not supported, and rollback error logged to watchdog.');
     }
 
     // Check that the rollback error was logged.
     $records = db_query("SELECT wid FROM {watchdog} WHERE variables LIKE '%Test exception for rollback.%'")->fetchAll();
-    $this->assertTrue(count($records) > 0, t('Rollback explanatory error logged to watchdog.'));
+    $this->assertTrue(count($records) > 0, 'Rollback explanatory error logged to watchdog.');
+  }
+
+  /**
+   * Create an unpublished node and confirm correct redirect behavior.
+   */
+  function testUnpublishedNodeCreation() {
+    // Set "Basic page" content type to be unpublished by default.
+    variable_set('node_options_page', array());
+    // Set the front page to the default "node" page.
+    variable_set('site_frontpage', 'node');
+
+    // Create a node.
+    $edit = array();
+    $edit["title"] = $this->randomName(8);
+    $edit["body[" . LANGUAGE_NONE . "][0][value]"] = $this->randomName(16);
+    $this->drupalPost('node/add/page', $edit, t('Save'));
+
+    // Check that the user was redirected to the home page.
+    $this->assertText(t('Welcome to Drupal'), t('The user is redirected to the home page.'));
   }
 }
 
+/**
+ * Tests the functionality of node entity edit permissions.
+ */
 class PageViewTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -573,12 +631,12 @@ class PageViewTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Creates a node and then an anonymous and unpermissioned user attempt to edit the node.
+   * Tests an anonymous and unpermissioned user attempting to edit the node.
    */
   function testPageView() {
     // Create a node to view.
     $node = $this->drupalCreateNode();
-    $this->assertTrue(node_load($node->nid), t('Node created.'));
+    $this->assertTrue(node_load($node->nid), 'Node created.');
 
     // Try to edit with anonymous user.
     $html = $this->drupalGet("node/$node->nid/edit");
@@ -602,6 +660,9 @@ class PageViewTestCase extends DrupalWebTestCase {
   }
 }
 
+/**
+ * Tests the summary length functionality.
+ */
 class SummaryLengthTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -612,7 +673,7 @@ class SummaryLengthTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Creates a node and then an anonymous and unpermissioned user attempt to edit the node.
+   * Tests the node summary length functionality.
    */
   function testSummaryLength() {
     // Create a node to view.
@@ -621,7 +682,7 @@ class SummaryLengthTestCase extends DrupalWebTestCase {
       'promote' => 1,
     );
     $node = $this->drupalCreateNode($settings);
-    $this->assertTrue(node_load($node->nid), t('Node created.'));
+    $this->assertTrue(node_load($node->nid), 'Node created.');
 
     // Create user with permission to view the node.
     $web_user = $this->drupalCreateUser(array('access content', 'administer content types'));
@@ -631,7 +692,7 @@ class SummaryLengthTestCase extends DrupalWebTestCase {
     $this->drupalGet("node");
     // The node teaser when it has 600 characters in length
     $expected = 'What is a Drupalism?';
-    $this->assertRaw($expected, t('Check that the summary is 600 characters in length'), 'Node');
+    $this->assertRaw($expected, 'Check that the summary is 600 characters in length', 'Node');
 
     // Change the teaser length for "Basic page" content type.
     $instance = field_info_instance('node', 'body', $node->type);
@@ -640,10 +701,13 @@ class SummaryLengthTestCase extends DrupalWebTestCase {
 
     // Attempt to access the front page again and check if the summary is now only 200 characters in length.
     $this->drupalGet("node");
-    $this->assertNoRaw($expected, t('Check that the summary is not longer than 200 characters'), 'Node');
+    $this->assertNoRaw($expected, 'Check that the summary is not longer than 200 characters', 'Node');
   }
 }
 
+/**
+ * Tests XSS functionality with a node entity.
+ */
 class NodeTitleXSSTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -653,6 +717,9 @@ class NodeTitleXSSTestCase extends DrupalWebTestCase {
     );
   }
 
+  /**
+   * Tests XSS functionality with a node entity.
+   */
   function testNodeTitleXSS() {
     // Prepare a user to do the stuff.
     $web_user = $this->drupalCreateUser(array('create page content', 'edit any page content'));
@@ -663,21 +730,24 @@ class NodeTitleXSSTestCase extends DrupalWebTestCase {
     $edit = array("title" => $title);
 
     $this->drupalPost('node/add/page', $edit, t('Preview'));
-    $this->assertNoRaw($xss, t('Harmful tags are escaped when previewing a node.'));
+    $this->assertNoRaw($xss, 'Harmful tags are escaped when previewing a node.');
 
     $settings = array('title' => $title);
     $node = $this->drupalCreateNode($settings);
 
     $this->drupalGet('node/' . $node->nid);
     // assertTitle() decodes HTML-entities inside the <title> element.
-    $this->assertTitle($edit["title"] . ' | Drupal', t('Title is diplayed when viewing a node.'));
-    $this->assertNoRaw($xss, t('Harmful tags are escaped when viewing a node.'));
+    $this->assertTitle($edit["title"] . ' | Drupal', 'Title is diplayed when viewing a node.');
+    $this->assertNoRaw($xss, 'Harmful tags are escaped when viewing a node.');
 
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertNoRaw($xss, t('Harmful tags are escaped when editing a node.'));
+    $this->assertNoRaw($xss, 'Harmful tags are escaped when editing a node.');
   }
 }
 
+/**
+ * Tests the availability of the syndicate block.
+ */
 class NodeBlockTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
@@ -695,21 +765,24 @@ class NodeBlockTestCase extends DrupalWebTestCase {
     $this->drupalLogin($admin_user);
   }
 
+  /**
+   * Tests that the "Syndicate" block is shown when enabled.
+   */
   function testSyndicateBlock() {
     // Set block title to confirm that the interface is available.
     $this->drupalPost('admin/structure/block/manage/node/syndicate/configure', array('title' => $this->randomName(8)), t('Save block'));
-    $this->assertText(t('The block configuration has been saved.'), t('Block configuration set.'));
+    $this->assertText(t('The block configuration has been saved.'), 'Block configuration set.');
 
     // Set the block to a region to confirm block is available.
     $edit = array();
     $edit['blocks[node_syndicate][region]'] = 'footer';
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
-    $this->assertText(t('The block settings have been updated.'), t('Block successfully move to footer region.'));
+    $this->assertText(t('The block settings have been updated.'), 'Block successfully move to footer region.');
   }
 }
 
 /**
- * Check that the post information displays when enabled for a content type.
+ * Checks that the post information displays when enabled for a content type.
  */
 class NodePostSettingsTestCase extends DrupalWebTestCase {
   public static function getInfo() {
@@ -728,7 +801,7 @@ class NodePostSettingsTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Set "Basic page" content type to display post information and confirm its presence on a new node.
+   * Confirms "Basic page" content type and post information is on a new node.
    */
   function testPagePostInfo() {
 
@@ -747,11 +820,11 @@ class NodePostSettingsTestCase extends DrupalWebTestCase {
     // Check that the post information is displayed.
     $node = $this->drupalGetNodeByTitle($edit["title"]);
     $elements = $this->xpath('//div[contains(@class,:class)]', array(':class' => 'submitted'));
-    $this->assertEqual(count($elements), 1, t('Post information is displayed.'));
+    $this->assertEqual(count($elements), 1, 'Post information is displayed.');
   }
 
   /**
-   * Set "Basic page" content type to not display post information and confirm its absence on a new node.
+   * Confirms absence of post information on a new node.
    */
   function testPageNotPostInfo() {
 
@@ -769,12 +842,12 @@ class NodePostSettingsTestCase extends DrupalWebTestCase {
 
     // Check that the post information is displayed.
     $node = $this->drupalGetNodeByTitle($edit["title"]);
-    $this->assertNoRaw('<span class="submitted">', t('Post information is not displayed.'));
+    $this->assertNoRaw('<span class="submitted">', 'Post information is not displayed.');
   }
 }
 
 /**
- * Ensure that data added to nodes by other modules appears in RSS feeds.
+ * Ensures that data added to nodes by other modules appears in RSS feeds.
  *
  * Create a node, enable the node_test module to ensure that extra data is
  * added to the node->content array, then verify that the data appears on the
@@ -801,8 +874,7 @@ class NodeRSSContentTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create a new node and ensure that it includes the custom data when added
-   * to an RSS feed.
+   * Ensures that a new node includes the custom data when added to an RSS feed.
    */
   function testNodeRSSContent() {
     // Create a node.
@@ -812,12 +884,12 @@ class NodeRSSContentTestCase extends DrupalWebTestCase {
 
     // Check that content added in 'rss' view mode appear in RSS feed.
     $rss_only_content = t('Extra data that should appear only in the RSS feed for node !nid.', array('!nid' => $node->nid));
-    $this->assertText($rss_only_content, t('Node content designated for RSS appear in RSS feed.'));
+    $this->assertText($rss_only_content, 'Node content designated for RSS appear in RSS feed.');
 
     // Check that content added in view modes other than 'rss' doesn't
     // appear in RSS feed.
     $non_rss_content = t('Extra data that should appear everywhere except the RSS feed for node !nid.', array('!nid' => $node->nid));
-    $this->assertNoText($non_rss_content, t('Node content not designed for RSS doesn\'t appear in RSS feed.'));
+    $this->assertNoText($non_rss_content, 'Node content not designed for RSS doesn\'t appear in RSS feed.');
 
     // Check that extra RSS elements and namespaces are added to RSS feed.
     $test_element = array(
@@ -825,25 +897,27 @@ class NodeRSSContentTestCase extends DrupalWebTestCase {
       'value' => t('Value of testElement RSS element for node !nid.', array('!nid' => $node->nid)),
     );
     $test_ns = 'xmlns:drupaltest="http://example.com/test-namespace"';
-    $this->assertRaw(format_xml_elements(array($test_element)), t('Extra RSS elements appear in RSS feed.'));
-    $this->assertRaw($test_ns, t('Extra namespaces appear in RSS feed.'));
+    $this->assertRaw(format_xml_elements(array($test_element)), 'Extra RSS elements appear in RSS feed.');
+    $this->assertRaw($test_ns, 'Extra namespaces appear in RSS feed.');
 
     // Check that content added in 'rss' view mode doesn't appear when
     // viewing node.
     $this->drupalGet("node/$node->nid");
-    $this->assertNoText($rss_only_content, t('Node content designed for RSS doesn\'t appear when viewing node.'));
-    
+    $this->assertNoText($rss_only_content, 'Node content designed for RSS doesn\'t appear when viewing node.');
+
     // Check that the node feed page does not try to interpret additional path
     // components as arguments for node_feed() and returns default content.
     $this->drupalGet('rss.xml/' . $this->randomName() . '/' . $this->randomName());
-    $this->assertText($rss_only_content, t('Ignore page arguments when delivering rss.xml.'));
+    $this->assertText($rss_only_content, 'Ignore page arguments when delivering rss.xml.');
   }
 }
 
 /**
- * Test case to verify basic node_access functionality.
+ * Tests basic node_access functionality.
+ *
+ * Note that hook_node_access_records() is covered in another test class.
+ *
  * @todo Cover hook_node_access in a separate test class.
- * hook_node_access_records is covered in another test class.
  */
 class NodeAccessTestCase extends DrupalWebTestCase {
   public static function getInfo() {
@@ -855,11 +929,11 @@ class NodeAccessTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Asserts node_access correctly grants or denies access.
+   * Asserts node_access() correctly grants or denies access.
    */
   function assertNodeAccess($ops, $node, $account) {
     foreach ($ops as $op => $result) {
-      $msg = t("node_access returns @result with operation '@op'.", array('@result' => $result ? 'true' : 'false', '@op' => $op));
+      $msg = format_string("node_access returns @result with operation '@op'.", array('@result' => $result ? 'true' : 'false', '@op' => $op));
       $this->assertEqual($result, node_access($op, $node, $account), $msg);
     }
   }
@@ -910,7 +984,7 @@ class NodeAccessTestCase extends DrupalWebTestCase {
 }
 
 /**
- * Test case to verify hook_node_access_records functionality.
+ * Tests hook_node_access_records() functionality.
  */
 class NodeAccessRecordsTestCase extends DrupalWebTestCase {
   public static function getInfo() {
@@ -929,49 +1003,49 @@ class NodeAccessRecordsTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Create a node and test the creation of node access rules.
+   * Creates a node and tests the creation of node access rules.
    */
   function testNodeAccessRecords() {
     // Create an article node.
     $node1 = $this->drupalCreateNode(array('type' => 'article'));
-    $this->assertTrue(node_load($node1->nid), t('Article node created.'));
+    $this->assertTrue(node_load($node1->nid), 'Article node created.');
 
     // Check to see if grants added by node_test_node_access_records made it in.
     $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node1->nid))->fetchAll();
-    $this->assertEqual(count($records), 1, t('Returned the correct number of rows.'));
-    $this->assertEqual($records[0]->realm, 'test_article_realm', t('Grant with article_realm acquired for node without alteration.'));
-    $this->assertEqual($records[0]->gid, 1, t('Grant with gid = 1 acquired for node without alteration.'));
+    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
+    $this->assertEqual($records[0]->realm, 'test_article_realm', 'Grant with article_realm acquired for node without alteration.');
+    $this->assertEqual($records[0]->gid, 1, 'Grant with gid = 1 acquired for node without alteration.');
 
     // Create an unpromoted "Basic page" node.
     $node2 = $this->drupalCreateNode(array('type' => 'page', 'promote' => 0));
-    $this->assertTrue(node_load($node2->nid), t('Unpromoted basic page node created.'));
+    $this->assertTrue(node_load($node2->nid), 'Unpromoted basic page node created.');
 
     // Check to see if grants added by node_test_node_access_records made it in.
     $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node2->nid))->fetchAll();
-    $this->assertEqual(count($records), 1, t('Returned the correct number of rows.'));
-    $this->assertEqual($records[0]->realm, 'test_page_realm', t('Grant with page_realm acquired for node without alteration.'));
-    $this->assertEqual($records[0]->gid, 1, t('Grant with gid = 1 acquired for node without alteration.'));
+    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
+    $this->assertEqual($records[0]->realm, 'test_page_realm', 'Grant with page_realm acquired for node without alteration.');
+    $this->assertEqual($records[0]->gid, 1, 'Grant with gid = 1 acquired for node without alteration.');
 
     // Create an unpromoted, unpublished "Basic page" node.
     $node3 = $this->drupalCreateNode(array('type' => 'page', 'promote' => 0, 'status' => 0));
-    $this->assertTrue(node_load($node3->nid), t('Unpromoted, unpublished basic page node created.'));
+    $this->assertTrue(node_load($node3->nid), 'Unpromoted, unpublished basic page node created.');
 
     // Check to see if grants added by node_test_node_access_records made it in.
     $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node3->nid))->fetchAll();
-    $this->assertEqual(count($records), 1, t('Returned the correct number of rows.'));
-    $this->assertEqual($records[0]->realm, 'test_page_realm', t('Grant with page_realm acquired for node without alteration.'));
-    $this->assertEqual($records[0]->gid, 1, t('Grant with gid = 1 acquired for node without alteration.'));
+    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
+    $this->assertEqual($records[0]->realm, 'test_page_realm', 'Grant with page_realm acquired for node without alteration.');
+    $this->assertEqual($records[0]->gid, 1, 'Grant with gid = 1 acquired for node without alteration.');
 
     // Create a promoted "Basic page" node.
     $node4 = $this->drupalCreateNode(array('type' => 'page', 'promote' => 1));
-    $this->assertTrue(node_load($node4->nid), t('Promoted basic page node created.'));
+    $this->assertTrue(node_load($node4->nid), 'Promoted basic page node created.');
 
     // Check to see if grant added by node_test_node_access_records was altered
     // by node_test_node_access_records_alter.
     $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node4->nid))->fetchAll();
-    $this->assertEqual(count($records), 1, t('Returned the correct number of rows.'));
-    $this->assertEqual($records[0]->realm, 'test_alter_realm', t('Altered grant with alter_realm acquired for node.'));
-    $this->assertEqual($records[0]->gid, 2, t('Altered grant with gid = 2 acquired for node.'));
+    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
+    $this->assertEqual($records[0]->realm, 'test_alter_realm', 'Altered grant with alter_realm acquired for node.');
+    $this->assertEqual($records[0]->gid, 2, 'Altered grant with gid = 2 acquired for node.');
 
     // Check to see if we can alter grants with hook_node_grants_alter().
     $operations = array('view', 'update', 'delete');
@@ -981,14 +1055,14 @@ class NodeAccessRecordsTestCase extends DrupalWebTestCase {
       $grants = node_test_node_grants($op, $web_user);
       $altered_grants = $grants;
       drupal_alter('node_grants', $altered_grants, $web_user, $op);
-      $this->assertNotEqual($grants, $altered_grants, t('Altered the %op grant for a user.', array('%op' => $op)));
+      $this->assertNotEqual($grants, $altered_grants, format_string('Altered the %op grant for a user.', array('%op' => $op)));
     }
 
     // Check that core does not grant access to an unpublished node when an
     // empty $grants array is returned.
     $node6 = $this->drupalCreateNode(array('status' => 0, 'disable_node_access' => TRUE));
     $records = db_query('SELECT realm, gid FROM {node_access} WHERE nid = :nid', array(':nid' => $node6->nid))->fetchAll();
-    $this->assertEqual(count($records), 0, t('Returned no records for unpublished node.'));
+    $this->assertEqual(count($records), 0, 'Returned no records for unpublished node.');
   }
 }
 
@@ -1005,9 +1079,6 @@ class NodeAccessBaseTableTestCase extends DrupalWebTestCase {
     );
   }
 
-  /**
-   * Enable modules and create user with specific permissions.
-   */
   public function setUp() {
     parent::setUp('node_access_test');
     node_access_rebuild();
@@ -1015,7 +1086,7 @@ class NodeAccessBaseTableTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test the "private" node access.
+   * Tests the "private" node access functionality.
    *
    * - Create 2 users with "access content" and "create article" permissions.
    * - Each user creates one private and one not private article.
@@ -1058,7 +1129,7 @@ class NodeAccessBaseTableTestCase extends DrupalWebTestCase {
         $this->drupalPost('node/add/article', $edit, t('Save'));
         $nid = db_query('SELECT nid FROM {node} WHERE title = :title', array(':title' => $edit['title']))->fetchField();
         $private_status = db_query('SELECT private FROM {node_access_test} where nid = :nid', array(':nid' => $nid))->fetchField();
-        $this->assertTrue($is_private == $private_status, t('The private status of the node was properly set in the node_access_test table.'));
+        $this->assertTrue($is_private == $private_status, 'The private status of the node was properly set in the node_access_test table.');
         if ($is_private) {
           $private_nodes[] = $nid;
         }
@@ -1068,8 +1139,8 @@ class NodeAccessBaseTableTestCase extends DrupalWebTestCase {
     }
     $this->publicTid = db_query('SELECT tid FROM {taxonomy_term_data} WHERE name = :name', array(':name' => 'public'))->fetchField();
     $this->privateTid = db_query('SELECT tid FROM {taxonomy_term_data} WHERE name = :name', array(':name' => 'private'))->fetchField();
-    $this->assertTrue($this->publicTid, t('Public tid was found'));
-    $this->assertTrue($this->privateTid, t('Private tid was found'));
+    $this->assertTrue($this->publicTid, 'Public tid was found');
+    $this->assertTrue($this->privateTid, 'Private tid was found');
     foreach ($simple_users as $this->webUser) {
       $this->drupalLogin($this->webUser);
       // Check own nodes to see that all are readable.
@@ -1152,7 +1223,7 @@ class NodeAccessBaseTableTestCase extends DrupalWebTestCase {
 }
 
 /**
- * Test case to check node save related functionality, including import-save
+ * Tests node save related functionality, including import-save.
  */
 class NodeSaveTestCase extends DrupalWebTestCase {
 
@@ -1173,7 +1244,8 @@ class NodeSaveTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Import test, to check if custom node ids are saved properly.
+   * Checks whether custom node IDs are saved properly during an import operation.
+   *
    * Workflow:
    *  - first create a piece of content
    *  - save the content
@@ -1195,20 +1267,19 @@ class NodeSaveTestCase extends DrupalWebTestCase {
     $node = node_submit((object) $node);
 
     // Verify that node_submit did not overwrite the user ID.
-    $this->assertEqual($node->uid, $this->web_user->uid, t('Function node_submit() preserves user ID'));
+    $this->assertEqual($node->uid, $this->web_user->uid, 'Function node_submit() preserves user ID');
 
     node_save($node);
     // Test the import.
     $node_by_nid = node_load($test_nid);
-    $this->assertTrue($node_by_nid, t('Node load by node ID.'));
+    $this->assertTrue($node_by_nid, 'Node load by node ID.');
 
     $node_by_title = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($node_by_title, t('Node load by node title.'));
+    $this->assertTrue($node_by_title, 'Node load by node title.');
   }
 
   /**
-   * Check that the "created" and "changed" timestamps are set correctly when
-   * saving a new node or updating an existing node.
+   * Verifies accuracy of the "created" and "changed" timestamp functionality.
    */
   function testTimestamps() {
     // Use the default timestamps.
@@ -1220,8 +1291,8 @@ class NodeSaveTestCase extends DrupalWebTestCase {
 
     node_save((object) $edit);
     $node = $this->drupalGetNodeByTitle($edit['title']);
-    $this->assertEqual($node->created, REQUEST_TIME, t('Creating a node sets default "created" timestamp.'));
-    $this->assertEqual($node->changed, REQUEST_TIME, t('Creating a node sets default "changed" timestamp.'));
+    $this->assertEqual($node->created, REQUEST_TIME, 'Creating a node sets default "created" timestamp.');
+    $this->assertEqual($node->changed, REQUEST_TIME, 'Creating a node sets default "changed" timestamp.');
 
     // Store the timestamps.
     $created = $node->created;
@@ -1229,15 +1300,15 @@ class NodeSaveTestCase extends DrupalWebTestCase {
 
     node_save($node);
     $node = $this->drupalGetNodeByTitle($edit['title'], TRUE);
-    $this->assertEqual($node->created, $created, t('Updating a node preserves "created" timestamp.'));
+    $this->assertEqual($node->created, $created, 'Updating a node preserves "created" timestamp.');
 
     // Programmatically set the timestamps using hook_node_presave.
     $node->title = 'testing_node_presave';
 
     node_save($node);
     $node = $this->drupalGetNodeByTitle('testing_node_presave', TRUE);
-    $this->assertEqual($node->created, 280299600, t('Saving a node uses "created" timestamp set in presave hook.'));
-    $this->assertEqual($node->changed, 979534800, t('Saving a node uses "changed" timestamp set in presave hook.'));
+    $this->assertEqual($node->created, 280299600, 'Saving a node uses "created" timestamp set in presave hook.');
+    $this->assertEqual($node->changed, 979534800, 'Saving a node uses "changed" timestamp set in presave hook.');
 
     // Programmatically set the timestamps on the node.
     $edit = array(
@@ -1250,8 +1321,8 @@ class NodeSaveTestCase extends DrupalWebTestCase {
 
     node_save((object) $edit);
     $node = $this->drupalGetNodeByTitle($edit['title']);
-    $this->assertEqual($node->created, 280299600, t('Creating a node uses user-set "created" timestamp.'));
-    $this->assertNotEqual($node->changed, 979534800, t('Creating a node doesn\'t use user-set "changed" timestamp.'));
+    $this->assertEqual($node->created, 280299600, 'Creating a node uses user-set "created" timestamp.');
+    $this->assertNotEqual($node->changed, 979534800, 'Creating a node doesn\'t use user-set "changed" timestamp.');
 
     // Update the timestamps.
     $node->created = 979534800;
@@ -1259,8 +1330,8 @@ class NodeSaveTestCase extends DrupalWebTestCase {
 
     node_save($node);
     $node = $this->drupalGetNodeByTitle($edit['title'], TRUE);
-    $this->assertEqual($node->created, 979534800, t('Updating a node uses user-set "created" timestamp.'));
-    $this->assertNotEqual($node->changed, 280299600, t('Updating a node doesn\'t use user-set "changed" timestamp.'));
+    $this->assertEqual($node->created, 979534800, 'Updating a node uses user-set "created" timestamp.');
+    $this->assertNotEqual($node->changed, 280299600, 'Updating a node doesn\'t use user-set "changed" timestamp.');
   }
 
   /**
@@ -1307,7 +1378,7 @@ class NodeTypeTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Ensure that node type functions (node_type_get_*) work correctly.
+   * Ensures that node type functions (node_type_get_*) work correctly.
    *
    * Load available node types and validate the returned data.
    */
@@ -1315,18 +1386,18 @@ class NodeTypeTestCase extends DrupalWebTestCase {
     $node_types = node_type_get_types();
     $node_names = node_type_get_names();
 
-    $this->assertTrue(isset($node_types['article']), t('Node type article is available.'));
-    $this->assertTrue(isset($node_types['page']), t('Node type basic page is available.'));
+    $this->assertTrue(isset($node_types['article']), 'Node type article is available.');
+    $this->assertTrue(isset($node_types['page']), 'Node type basic page is available.');
 
-    $this->assertEqual($node_types['article']->name, $node_names['article'], t('Correct node type base has been returned.'));
+    $this->assertEqual($node_types['article']->name, $node_names['article'], 'Correct node type base has been returned.');
 
-    $this->assertEqual($node_types['article'], node_type_get_type('article'), t('Correct node type has been returned.'));
-    $this->assertEqual($node_types['article']->name, node_type_get_name('article'), t('Correct node type name has been returned.'));
-    $this->assertEqual($node_types['page']->base, node_type_get_base('page'), t('Correct node type base has been returned.'));
+    $this->assertEqual($node_types['article'], node_type_get_type('article'), 'Correct node type has been returned.');
+    $this->assertEqual($node_types['article']->name, node_type_get_name('article'), 'Correct node type name has been returned.');
+    $this->assertEqual($node_types['page']->base, node_type_get_base('page'), 'Correct node type base has been returned.');
   }
 
   /**
-   * Test creating a content type programmatically and via a form.
+   * Tests creating a content type programmatically and via a form.
    */
   function testNodeTypeCreation() {
     // Create a content type programmaticaly.
@@ -1356,19 +1427,19 @@ class NodeTypeTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test editing a node type using the UI.
+   * Tests editing a node type using the UI.
    */
   function testNodeTypeEditing() {
     $web_user = $this->drupalCreateUser(array('bypass node access', 'administer content types'));
     $this->drupalLogin($web_user);
 
     $instance = field_info_instance('node', 'body', 'page');
-    $this->assertEqual($instance['label'], 'Body', t('Body field was found.'));
+    $this->assertEqual($instance['label'], 'Body', 'Body field was found.');
 
     // Verify that title and body fields are displayed.
     $this->drupalGet('node/add/page');
-    $this->assertRaw('Title', t('Title field was found.'));
-    $this->assertRaw('Body', t('Body field was found.'));
+    $this->assertRaw('Title', 'Title field was found.');
+    $this->assertRaw('Body', 'Body field was found.');
 
     // Rename the title field.
     $edit = array(
@@ -1379,8 +1450,8 @@ class NodeTypeTestCase extends DrupalWebTestCase {
     field_info_cache_clear();
 
     $this->drupalGet('node/add/page');
-    $this->assertRaw('Foo', t('New title label was displayed.'));
-    $this->assertNoRaw('Title', t('Old title label was not displayed.'));
+    $this->assertRaw('Foo', 'New title label was displayed.');
+    $this->assertNoRaw('Title', 'Old title label was not displayed.');
 
     // Change the name, machine name and description.
     $edit = array(
@@ -1392,12 +1463,12 @@ class NodeTypeTestCase extends DrupalWebTestCase {
     field_info_cache_clear();
 
     $this->drupalGet('node/add');
-    $this->assertRaw('Bar', t('New name was displayed.'));
-    $this->assertRaw('Lorem ipsum', t('New description was displayed.'));
+    $this->assertRaw('Bar', 'New name was displayed.');
+    $this->assertRaw('Lorem ipsum', 'New description was displayed.');
     $this->clickLink('Bar');
-    $this->assertEqual(url('node/add/bar', array('absolute' => TRUE)), $this->getUrl(), t('New machine name was used in URL.'));
-    $this->assertRaw('Foo', t('Title field was found.'));
-    $this->assertRaw('Body', t('Body field was found.'));
+    $this->assertEqual(url('node/add/bar', array('absolute' => TRUE)), $this->getUrl(), 'New machine name was used in URL.');
+    $this->assertRaw('Foo', 'Title field was found.');
+    $this->assertRaw('Body', 'Body field was found.');
 
     // Remove the body field.
     $this->drupalPost('admin/structure/types/manage/bar/fields/body/delete', NULL, t('Delete'));
@@ -1405,11 +1476,11 @@ class NodeTypeTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/structure/types/manage/bar', array(), t('Save content type'));
     // Check that the body field doesn't exist.
     $this->drupalGet('node/add/bar');
-    $this->assertNoRaw('Body', t('Body field was not found.'));
+    $this->assertNoRaw('Body', 'Body field was not found.');
   }
 
   /**
-   * Test that node_types_rebuild() correctly handles the 'disabled' flag.
+   * Tests that node_types_rebuild() correctly handles the 'disabled' flag.
    */
   function testNodeTypeStatus() {
     // Enable all core node modules, and all types should be active.
@@ -1417,42 +1488,42 @@ class NodeTypeTestCase extends DrupalWebTestCase {
     node_types_rebuild();
     $types = node_type_get_types();
     foreach (array('blog', 'book', 'poll', 'article', 'page') as $type) {
-      $this->assertTrue(isset($types[$type]), t('%type is found in node types.', array('%type' => $type)));
-      $this->assertTrue(isset($types[$type]->disabled) && empty($types[$type]->disabled), t('%type type is enabled.', array('%type' => $type)));
+      $this->assertTrue(isset($types[$type]), format_string('%type is found in node types.', array('%type' => $type)));
+      $this->assertTrue(isset($types[$type]->disabled) && empty($types[$type]->disabled), format_string('%type type is enabled.', array('%type' => $type)));
     }
 
     // Disable poll module and the respective type should be marked as disabled.
     module_disable(array('poll'), FALSE);
     node_types_rebuild();
     $types = node_type_get_types();
-    $this->assertTrue(!empty($types['poll']->disabled), t("Poll module's node type disabled."));
-    $this->assertTrue(isset($types['blog']) && empty($types['blog']->disabled), t("Blog module's node type still active."));
+    $this->assertTrue(!empty($types['poll']->disabled), "Poll module's node type disabled.");
+    $this->assertTrue(isset($types['blog']) && empty($types['blog']->disabled), "Blog module's node type still active.");
 
     // Disable blog module and the respective type should be marked as disabled.
     module_disable(array('blog'), FALSE);
     node_types_rebuild();
     $types = node_type_get_types();
-    $this->assertTrue(!empty($types['blog']->disabled), t("Blog module's node type disabled."));
-    $this->assertTrue(!empty($types['poll']->disabled), t("Poll module's node type still disabled."));
+    $this->assertTrue(!empty($types['blog']->disabled), "Blog module's node type disabled.");
+    $this->assertTrue(!empty($types['poll']->disabled), "Poll module's node type still disabled.");
 
     // Disable book module and the respective type should still be active, since
     // it is not provided by hook_node_info().
     module_disable(array('book'), FALSE);
     node_types_rebuild();
     $types = node_type_get_types();
-    $this->assertTrue(isset($types['book']) && empty($types['book']->disabled), t("Book module's node type still active."));
-    $this->assertTrue(!empty($types['blog']->disabled), t("Blog module's node type still disabled."));
-    $this->assertTrue(!empty($types['poll']->disabled), t("Poll module's node type still disabled."));
-    $this->assertTrue(isset($types['article']) && empty($types['article']->disabled), t("Article node type still active."));
-    $this->assertTrue(isset($types['page']) && empty($types['page']->disabled), t("Basic page node type still active."));
+    $this->assertTrue(isset($types['book']) && empty($types['book']->disabled), "Book module's node type still active.");
+    $this->assertTrue(!empty($types['blog']->disabled), "Blog module's node type still disabled.");
+    $this->assertTrue(!empty($types['poll']->disabled), "Poll module's node type still disabled.");
+    $this->assertTrue(isset($types['article']) && empty($types['article']->disabled), "Article node type still active.");
+    $this->assertTrue(isset($types['page']) && empty($types['page']->disabled), "Basic page node type still active.");
 
     // Re-enable the modules and verify that the types are active again.
     module_enable(array('blog', 'book', 'poll'), FALSE);
     node_types_rebuild();
     $types = node_type_get_types();
     foreach (array('blog', 'book', 'poll', 'article', 'page') as $type) {
-      $this->assertTrue(isset($types[$type]), t('%type is found in node types.', array('%type' => $type)));
-      $this->assertTrue(isset($types[$type]->disabled) && empty($types[$type]->disabled), t('%type type is enabled.', array('%type' => $type)));
+      $this->assertTrue(isset($types[$type]), format_string('%type is found in node types.', array('%type' => $type)));
+      $this->assertTrue(isset($types[$type]->disabled) && empty($types[$type]->disabled), format_string('%type type is enabled.', array('%type' => $type)));
     }
   }
 }
@@ -1470,7 +1541,7 @@ class NodeTypePersistenceTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Test node type customizations persist through disable and uninstall.
+   * Tests that node type customizations persist through disable and uninstall.
    */
   function testNodeTypeCustomizationPersistence() {
     $web_user = $this->drupalCreateUser(array('bypass node access', 'administer content types', 'administer modules'));
@@ -1483,12 +1554,12 @@ class NodeTypePersistenceTestCase extends DrupalWebTestCase {
     // disabled.
     $this->drupalPost('admin/modules', $poll_enable, t('Save configuration'));
     $disabled = db_query('SELECT disabled FROM {node_type} WHERE type = :type', array(':type' => 'poll'))->fetchField();
-    $this->assertNotIdentical($disabled, FALSE, t('Poll node type found in the database'));
-    $this->assertEqual($disabled, 0, t('Poll node type is not disabled'));
+    $this->assertNotIdentical($disabled, FALSE, 'Poll node type found in the database');
+    $this->assertEqual($disabled, 0, 'Poll node type is not disabled');
 
     // Check that poll node type (uncustomized) shows up.
     $this->drupalGet('node/add');
-    $this->assertText('poll', t('poll type is found on node/add'));
+    $this->assertText('poll', 'poll type is found on node/add');
 
     // Customize poll description.
     $description = $this->randomName();
@@ -1497,23 +1568,23 @@ class NodeTypePersistenceTestCase extends DrupalWebTestCase {
 
     // Check that poll node type customization shows up.
     $this->drupalGet('node/add');
-    $this->assertText($description, t('Customized description found'));
+    $this->assertText($description, 'Customized description found');
 
     // Disable poll and check that the node type gets disabled.
     $this->drupalPost('admin/modules', $poll_disable, t('Save configuration'));
     $disabled = db_query('SELECT disabled FROM {node_type} WHERE type = :type', array(':type' => 'poll'))->fetchField();
-    $this->assertEqual($disabled, 1, t('Poll node type is disabled'));
+    $this->assertEqual($disabled, 1, 'Poll node type is disabled');
     $this->drupalGet('node/add');
-    $this->assertNoText('poll', t('poll type is not found on node/add'));
+    $this->assertNoText('poll', 'poll type is not found on node/add');
 
     // Reenable poll and check that the customization survived the module
     // disable.
     $this->drupalPost('admin/modules', $poll_enable, t('Save configuration'));
     $disabled = db_query('SELECT disabled FROM {node_type} WHERE type = :type', array(':type' => 'poll'))->fetchField();
-    $this->assertNotIdentical($disabled, FALSE, t('Poll node type found in the database'));
-    $this->assertEqual($disabled, 0, t('Poll node type is not disabled'));
+    $this->assertNotIdentical($disabled, FALSE, 'Poll node type found in the database');
+    $this->assertEqual($disabled, 0, 'Poll node type is not disabled');
     $this->drupalGet('node/add');
-    $this->assertText($description, t('Customized description found'));
+    $this->assertText($description, 'Customized description found');
 
     // Disable and uninstall poll.
     $this->drupalPost('admin/modules', $poll_disable, t('Save configuration'));
@@ -1521,20 +1592,20 @@ class NodeTypePersistenceTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/modules/uninstall', $edit, t('Uninstall'));
     $this->drupalPost(NULL, array(), t('Uninstall'));
     $disabled = db_query('SELECT disabled FROM {node_type} WHERE type = :type', array(':type' => 'poll'))->fetchField();
-    $this->assertTrue($disabled, t('Poll node type is in the database and is disabled'));
+    $this->assertTrue($disabled, 'Poll node type is in the database and is disabled');
     $this->drupalGet('node/add');
-    $this->assertNoText('poll', t('poll type is no longer found on node/add'));
+    $this->assertNoText('poll', 'poll type is no longer found on node/add');
 
     // Reenable poll and check that the customization survived the module
     // uninstall.
     $this->drupalPost('admin/modules', $poll_enable, t('Save configuration'));
     $this->drupalGet('node/add');
-    $this->assertText($description, t('Customized description is found even after uninstall and reenable.'));
+    $this->assertText($description, 'Customized description is found even after uninstall and reenable.');
   }
 }
 
 /**
- * Rebuild the node_access table.
+ * Verifies the rebuild functionality for the node_access table.
  */
 class NodeAccessRebuildTestCase extends DrupalWebTestCase {
   public static function getInfo() {
@@ -1553,6 +1624,9 @@ class NodeAccessRebuildTestCase extends DrupalWebTestCase {
     $this->web_user = $web_user;
   }
 
+  /**
+   * Tests rebuilding the node access permissions table.
+   */
   function testNodeAccessRebuild() {
     $this->drupalGet('admin/reports/status');
     $this->clickLink(t('Rebuild permissions'));
@@ -1562,7 +1636,7 @@ class NodeAccessRebuildTestCase extends DrupalWebTestCase {
 }
 
 /**
- * Test node administration page functionality.
+ * Tests node administration page functionality.
  */
 class NodeAdminTestCase extends DrupalWebTestCase {
   public static function getInfo() {
@@ -1630,6 +1704,7 @@ class NodeAdminTestCase extends DrupalWebTestCase {
    * Tests content overview with different user permissions.
    *
    * Taxonomy filters are tested separately.
+   *
    * @see TaxonomyNodeFilterTestCase
    */
   function testContentAdminPages() {
@@ -1648,7 +1723,7 @@ class NodeAdminTestCase extends DrupalWebTestCase {
       $this->assertLinkByHref('node/' . $node->nid . '/edit');
       $this->assertLinkByHref('node/' . $node->nid . '/delete');
       // Verify tableselect.
-      $this->assertFieldByName('nodes[' . $node->nid . ']', '', t('Tableselect found.'));
+      $this->assertFieldByName('nodes[' . $node->nid . ']', '', 'Tableselect found.');
     }
 
     // Verify filtering by publishing status.
@@ -1657,7 +1732,7 @@ class NodeAdminTestCase extends DrupalWebTestCase {
     );
     $this->drupalPost(NULL, $edit, t('Filter'));
 
-    $this->assertRaw(t('where %property is %value', array('%property' => t('status'), '%value' => 'published')), t('Content list is filtered by status.'));
+    $this->assertRaw(t('where %property is %value', array('%property' => t('status'), '%value' => 'published')), 'Content list is filtered by status.');
 
     $this->assertLinkByHref('node/' . $nodes['published_page']->nid . '/edit');
     $this->assertLinkByHref('node/' . $nodes['published_article']->nid . '/edit');
@@ -1669,8 +1744,8 @@ class NodeAdminTestCase extends DrupalWebTestCase {
     );
     $this->drupalPost(NULL, $edit, t('Refine'));
 
-    $this->assertRaw(t('where %property is %value', array('%property' => t('status'), '%value' => 'published')), t('Content list is filtered by status.'));
-    $this->assertRaw(t('and where %property is %value', array('%property' => t('type'), '%value' => 'Basic page')), t('Content list is filtered by content type.'));
+    $this->assertRaw(t('where %property is %value', array('%property' => t('status'), '%value' => 'published')), 'Content list is filtered by status.');
+    $this->assertRaw(t('and where %property is %value', array('%property' => t('type'), '%value' => 'Basic page')), 'Content list is filtered by content type.');
 
     $this->assertLinkByHref('node/' . $nodes['published_page']->nid . '/edit');
     $this->assertNoLinkByHref('node/' . $nodes['published_article']->nid . '/edit');
@@ -1693,7 +1768,7 @@ class NodeAdminTestCase extends DrupalWebTestCase {
     $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/delete');
 
     // Verify no tableselect.
-    $this->assertNoFieldByName('nodes[' . $nodes['published_page']->nid . ']', '', t('No tableselect found.'));
+    $this->assertNoFieldByName('nodes[' . $nodes['published_page']->nid . ']', '', 'No tableselect found.');
 
     // Verify unpublished content is displayed with permission.
     $this->drupalLogout();
@@ -1711,7 +1786,7 @@ class NodeAdminTestCase extends DrupalWebTestCase {
     $this->assertNoLinkByHref('node/' . $nodes['unpublished_page_1']->nid . '/delete');
 
     // Verify no tableselect.
-    $this->assertNoFieldByName('nodes[' . $nodes['unpublished_page_2']->nid . ']', '', t('No tableselect found.'));
+    $this->assertNoFieldByName('nodes[' . $nodes['unpublished_page_2']->nid . ']', '', 'No tableselect found.');
 
     // Verify node access can be bypassed.
     $this->drupalLogout();
@@ -1727,9 +1802,15 @@ class NodeAdminTestCase extends DrupalWebTestCase {
 }
 
 /**
- * Test node title.
+ * Tests node title functionality.
  */
 class NodeTitleTestCase extends DrupalWebTestCase {
+
+  /**
+   * A user with permission to create and edit content and to administer nodes.
+   *
+   * @var object
+   */
   protected $admin_user;
 
   public static function getInfo() {
@@ -1747,7 +1828,7 @@ class NodeTitleTestCase extends DrupalWebTestCase {
   }
 
   /**
-   *  Create one node and test if the node title has the correct value.
+   *  Creates one node and tests if the node title has the correct value.
    */
   function testNodeTitle() {
     // Create "Basic page" content with title.
@@ -1790,7 +1871,7 @@ class NodeFeedTestCase extends DrupalWebTestCase {
   }
 
   /**
-   * Ensure that node_feed accepts and prints extra channel elements.
+   * Ensures that node_feed() accepts and prints extra channel elements.
    */
   function testNodeFeedExtraChannelElements() {
     ob_start();
@@ -1822,7 +1903,7 @@ class NodeBlockFunctionalTest extends DrupalWebTestCase {
   }
 
   /**
-   * Test the recent comments block.
+   * Tests the recent comments block.
    */
   function testRecentNodeBlock() {
     $this->drupalLogin($this->admin_user);
@@ -1837,7 +1918,7 @@ class NodeBlockFunctionalTest extends DrupalWebTestCase {
       'blocks[node_recent][region]' => 'sidebar_first',
     );
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
-    $this->assertText(t('The block settings have been updated.'), t('Block saved to first sidebar region.'));
+    $this->assertText(t('The block settings have been updated.'), 'Block saved to first sidebar region.');
 
     // Set block title and variables.
     $block = array(
@@ -1845,11 +1926,11 @@ class NodeBlockFunctionalTest extends DrupalWebTestCase {
       'node_recent_block_count' => 2,
     );
     $this->drupalPost('admin/structure/block/manage/node/recent/configure', $block, t('Save block'));
-    $this->assertText(t('The block configuration has been saved.'), t('Block saved.'));
+    $this->assertText(t('The block configuration has been saved.'), 'Block saved.');
 
     // Test that block is not visible without nodes
     $this->drupalGet('');
-    $this->assertText(t('No content available.'), t('Block with "No content available." found.'));
+    $this->assertText(t('No content available.'), 'Block with "No content available." found.');
 
     // Add some test nodes.
     $default_settings = array('uid' => $this->web_user->uid, 'type' => 'article');
@@ -1875,16 +1956,16 @@ class NodeBlockFunctionalTest extends DrupalWebTestCase {
     // see the block.
     $this->drupalLogout();
     $this->drupalGet('');
-    $this->assertNoText($block['title'], t('Block was not found.'));
+    $this->assertNoText($block['title'], 'Block was not found.');
 
     // Test that only the 2 latest nodes are shown.
     $this->drupalLogin($this->web_user);
-    $this->assertNoText($node1->title, t('Node not found in block.'));
-    $this->assertText($node2->title, t('Node found in block.'));
-    $this->assertText($node3->title, t('Node found in block.'));
+    $this->assertNoText($node1->title, 'Node not found in block.');
+    $this->assertText($node2->title, 'Node found in block.');
+    $this->assertText($node3->title, 'Node found in block.');
 
     // Check to make sure nodes are in the right order.
-    $this->assertTrue($this->xpath('//div[@id="block-node-recent"]/div/table/tbody/tr[position() = 1]/td/div/a[text() = "' . $node3->title . '"]'), t('Nodes were ordered correctly in block.'));
+    $this->assertTrue($this->xpath('//div[@id="block-node-recent"]/div/table/tbody/tr[position() = 1]/td/div/a[text() = "' . $node3->title . '"]'), 'Nodes were ordered correctly in block.');
 
     // Set the number of recent nodes to show to 10.
     $this->drupalLogout();
@@ -1893,17 +1974,17 @@ class NodeBlockFunctionalTest extends DrupalWebTestCase {
       'node_recent_block_count' => 10,
     );
     $this->drupalPost('admin/structure/block/manage/node/recent/configure', $block, t('Save block'));
-    $this->assertText(t('The block configuration has been saved.'), t('Block saved.'));
+    $this->assertText(t('The block configuration has been saved.'), 'Block saved.');
 
     // Post an additional node.
     $node4 = $this->drupalCreateNode($default_settings);
 
     // Test that all four nodes are shown.
     $this->drupalGet('');
-    $this->assertText($node1->title, t('Node found in block.'));
-    $this->assertText($node2->title, t('Node found in block.'));
-    $this->assertText($node3->title, t('Node found in block.'));
-    $this->assertText($node4->title, t('Node found in block.'));
+    $this->assertText($node1->title, 'Node found in block.');
+    $this->assertText($node2->title, 'Node found in block.');
+    $this->assertText($node3->title, 'Node found in block.');
+    $this->assertText($node4->title, 'Node found in block.');
 
     // Create the custom block.
     $custom_block = array();
@@ -1918,24 +1999,24 @@ class NodeBlockFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/structure/block/add', $custom_block, t('Save block'));
 
     $bid = db_query("SELECT bid FROM {block_custom} WHERE info = :info", array(':info' => $custom_block['info']))->fetchField();
-    $this->assertTrue($bid, t('Custom block with visibility rule was created.'));
+    $this->assertTrue($bid, 'Custom block with visibility rule was created.');
 
     // Verify visibility rules.
     $this->drupalGet('');
-    $this->assertNoText($custom_block['title'], t('Block was displayed on the front page.'));
+    $this->assertNoText($custom_block['title'], 'Block was displayed on the front page.');
     $this->drupalGet('node/add/article');
-    $this->assertText($custom_block['title'], t('Block was displayed on the node/add/article page.'));
+    $this->assertText($custom_block['title'], 'Block was displayed on the node/add/article page.');
     $this->drupalGet('node/' . $node1->nid);
-    $this->assertText($custom_block['title'], t('Block was displayed on the node/N.'));
+    $this->assertText($custom_block['title'], 'Block was displayed on the node/N.');
 
     // Delete the created custom block & verify that it's been deleted.
     $this->drupalPost('admin/structure/block/manage/block/' . $bid . '/delete', array(), t('Delete'));
     $bid = db_query("SELECT 1 FROM {block_node_type} WHERE module = 'block' AND delta = :delta", array(':delta' => $bid))->fetchField();
-    $this->assertFalse($bid, t('Custom block was deleted.'));
+    $this->assertFalse($bid, 'Custom block was deleted.');
   }
 }
 /**
- * Test multistep node forms basic options.
+ * Tests basic options of multi-step node forms.
  */
 class MultiStepNodeFormBasicOptionsTest extends DrupalWebTestCase {
   public static function getInfo() {
@@ -1953,7 +2034,7 @@ class MultiStepNodeFormBasicOptionsTest extends DrupalWebTestCase {
   }
 
   /**
-   * Change the default values of basic options to ensure they persist.
+   * Tests changing the default values of basic options to ensure they persist.
    */
   function testMultiStepNodeFormBasicOptions() {
     $edit = array(
@@ -1985,7 +2066,7 @@ class NodeBuildContent extends DrupalWebTestCase {
   }
 
  /**
-  * Test to ensure that a node's content array is rebuilt on every call to node_build_content().
+  * Ensures that content array is rebuilt on every call to node_build_content().
   */
   function testNodeRebuildContent() {
     $node = $this->drupalCreateNode();
@@ -1995,7 +2076,7 @@ class NodeBuildContent extends DrupalWebTestCase {
     $content = node_build_content($node);
 
     // If the property doesn't exist it means the node->content was rebuilt.
-    $this->assertFalse(isset($content['test_content_property']), t('Node content was emptied prior to being built.'));
+    $this->assertFalse(isset($content['test_content_property']), 'Node content was emptied prior to being built.');
   }
 }
 
@@ -2014,11 +2095,15 @@ class NodeQueryAlter extends DrupalWebTestCase {
 
   /**
    * User with permission to view content.
+   *
+   * @var object
    */
   protected $accessUser;
 
   /**
    * User without permission to view content.
+   *
+   * @var object
    */
   protected $noAccessUser;
 
@@ -2065,10 +2150,10 @@ class NodeQueryAlter extends DrupalWebTestCase {
   }
 
   /**
-   * Lower-level test of 'node_access' query alter, for user with access.
+   * Tests 'node_access' query alter, for user with access.
    *
-   * Verifies that a non-standard table alias can be used, and that a
-   * user with node access can view the nodes.
+   * Verifies that a non-standard table alias can be used, and that a user with
+   * node access can view the nodes.
    */
   function testNodeQueryAlterLowLevelWithAccess() {
     // User with access should be able to view 4 nodes.
@@ -2080,7 +2165,7 @@ class NodeQueryAlter extends DrupalWebTestCase {
       $query->addMetaData('account', $this->accessUser);
 
       $result = $query->execute()->fetchAll();
-      $this->assertEqual(count($result), 4, t('User with access can see correct nodes'));
+      $this->assertEqual(count($result), 4, 'User with access can see correct nodes');
     }
     catch (Exception $e) {
       $this->fail(t('Altered query is malformed'));
@@ -2088,10 +2173,10 @@ class NodeQueryAlter extends DrupalWebTestCase {
   }
 
   /**
-   * Lower-level test of 'node_access' query alter, for user without access.
+   * Tests 'node_access' query alter, for user without access.
    *
-   * Verifies that a non-standard table alias can be used, and that a
-   * user without node access cannot view the nodes.
+   * Verifies that a non-standard table alias can be used, and that a user
+   * without node access cannot view the nodes.
    */
   function testNodeQueryAlterLowLevelNoAccess() {
     // User without access should be able to view 0 nodes.
@@ -2103,7 +2188,7 @@ class NodeQueryAlter extends DrupalWebTestCase {
       $query->addMetaData('account', $this->noAccessUser);
 
       $result = $query->execute()->fetchAll();
-      $this->assertEqual(count($result), 0, t('User with no access cannot see nodes'));
+      $this->assertEqual(count($result), 0, 'User with no access cannot see nodes');
     }
     catch (Exception $e) {
       $this->fail(t('Altered query is malformed'));
@@ -2111,10 +2196,10 @@ class NodeQueryAlter extends DrupalWebTestCase {
   }
 
   /**
-   * Lower-level test of 'node_access' query alter, for edit access.
+   * Tests 'node_access' query alter, for edit access.
    *
-   * Verifies that a non-standard table alias can be used, and that a
-   * user with view-only node access cannot edit the nodes.
+   * Verifies that a non-standard table alias can be used, and that a user with
+   * view-only node access cannot edit the nodes.
    */
   function testNodeQueryAlterLowLevelEditAccess() {
     // User with view-only access should not be able to edit nodes.
@@ -2126,7 +2211,7 @@ class NodeQueryAlter extends DrupalWebTestCase {
       $query->addMetaData('account', $this->accessUser);
 
       $result = $query->execute()->fetchAll();
-      $this->assertEqual(count($result), 0, t('User with view-only access cannot edit nodes'));
+      $this->assertEqual(count($result), 0, 'User with view-only access cannot edit nodes');
     }
     catch (Exception $e) {
       $this->fail($e->getMessage());
@@ -2136,13 +2221,13 @@ class NodeQueryAlter extends DrupalWebTestCase {
   }
 
   /**
-   * Lower-level test of 'node_access' query alter override.
+   * Tests 'node_access' query alter override.
    *
    * Verifies that node_access_view_all_nodes() is called from
-   * node_query_node_access_alter().  We do this by checking that
-   * a user which normally would not have view privileges is able
-   * to view the nodes when we add a record to {node_access} paired
-   * with a corresponding privilege in hook_node_grants().
+   * node_query_node_access_alter(). We do this by checking that a user who
+   * normally would not have view privileges is able to view the nodes when we
+   * add a record to {node_access} paired with a corresponding privilege in
+   * hook_node_grants().
    */
   function testNodeQueryAlterOverride() {
     $record = array(
@@ -2166,7 +2251,7 @@ class NodeQueryAlter extends DrupalWebTestCase {
       $query->addMetaData('account', $this->noAccessUser);
 
       $result = $query->execute()->fetchAll();
-      $this->assertEqual(count($result), 0, t('User view privileges are not overridden'));
+      $this->assertEqual(count($result), 0, 'User view privileges are not overridden');
     }
     catch (Exception $e) {
       $this->fail(t('Altered query is malformed'));
@@ -2188,7 +2273,7 @@ class NodeQueryAlter extends DrupalWebTestCase {
       $query->addMetaData('account', $this->noAccessUser);
 
       $result = $query->execute()->fetchAll();
-      $this->assertEqual(count($result), 4, t('User view privileges are overridden'));
+      $this->assertEqual(count($result), 4, 'User view privileges are overridden');
     }
     catch (Exception $e) {
       $this->fail(t('Altered query is malformed'));
@@ -2213,11 +2298,15 @@ class NodeEntityFieldQueryAlter extends DrupalWebTestCase {
 
   /**
    * User with permission to view content.
+   *
+   * @var object
    */
   protected $accessUser;
 
   /**
    * User without permission to view content.
+   *
+   * @var object
    */
   protected $noAccessUser;
 
@@ -2319,11 +2408,11 @@ class NodeTokenReplaceTestCase extends DrupalWebTestCase {
     $tests['[node:changed:since]'] = format_interval(REQUEST_TIME - $node->changed, 2, $language->language);
 
     // Test to make sure that we generated something for each token.
-    $this->assertFalse(in_array(0, array_map('strlen', $tests)), t('No empty tokens generated.'));
+    $this->assertFalse(in_array(0, array_map('strlen', $tests)), 'No empty tokens generated.');
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('node' => $node), array('language' => $language));
-      $this->assertEqual($output, $expected, t('Sanitized node token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Sanitized node token %token replaced.', array('%token' => $input)));
     }
 
     // Generate and test unsanitized tokens.
@@ -2335,7 +2424,7 @@ class NodeTokenReplaceTestCase extends DrupalWebTestCase {
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('node' => $node), array('language' => $language, 'sanitize' => FALSE));
-      $this->assertEqual($output, $expected, t('Unsanitized node token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Unsanitized node token %token replaced.', array('%token' => $input)));
     }
   }
 }
@@ -2344,10 +2433,26 @@ class NodeTokenReplaceTestCase extends DrupalWebTestCase {
  * Tests user permissions for node revisions.
  */
 class NodeRevisionPermissionsTestCase extends DrupalWebTestCase {
+
+  /**
+   * Nodes used by the test.
+   *
+   * @var array
+   */
   protected $node_revisions = array();
+
+  /**
+   * Users with different revision permission used by the test.
+   *
+   * @var array
+   */
   protected $accounts = array();
 
-  // Map revision permission names to node revision access ops.
+  /**
+   * Map revision permission names to node revision access ops.
+   *
+   * @var array
+   */
   protected $map = array(
     'view' => 'view revisions',
     'update' => 'revert revisions',
diff --git a/modules/node/tests/node_access_test.module b/modules/node/tests/node_access_test.module
index 813bf92..ec35c41 100644
--- a/modules/node/tests/node_access_test.module
+++ b/modules/node/tests/node_access_test.module
@@ -2,7 +2,9 @@
 
 /**
  * @file
- * Dummy module implementing node access related hooks to test API interaction
+ * A dummy module implementing node access related hooks for testing purposes.
+ *
+ * A dummy module implementing node access related hooks to test API interaction
  * with the Node module. This module restricts view permission to those with
  * a special 'node test view' permission.
  */
@@ -140,6 +142,8 @@ function node_access_test_page() {
  * database query is shown, and a list of the node IDs, for debugging purposes.
  * And if there is a query exception, the page says "Exception" and gives the
  * error.
+ *
+ * @see node_access_test_menu()
  */
 function node_access_entity_test_page() {
   $output = '';
diff --git a/modules/node/tests/node_test.module b/modules/node/tests/node_test.module
index a52c1fa..fb66785 100644
--- a/modules/node/tests/node_test.module
+++ b/modules/node/tests/node_test.module
@@ -2,8 +2,10 @@
 
 /**
  * @file
- * Dummy module implementing node related hooks to test API interaction with
- * the Node module.
+ * A dummy module for testing node related hooks.
+ *
+ * This is a dummy module that implements node related hooks to test API
+ * interaction with the Node module.
  */
 
 /**
diff --git a/modules/node/tests/node_test_exception.module b/modules/node/tests/node_test_exception.module
index 0fe9f35..66bc717 100644
--- a/modules/node/tests/node_test_exception.module
+++ b/modules/node/tests/node_test_exception.module
@@ -2,8 +2,7 @@
 
 /**
  * @file
- * Dummy module implementing node related hooks to test API interaction with
- * the Node module.
+ * A module implementing node related hooks to test API interaction.
  */
 
 /**
diff --git a/modules/openid/openid.module b/modules/openid/openid.module
index a3f4fc8..1f764e0 100644
--- a/modules/openid/openid.module
+++ b/modules/openid/openid.module
@@ -787,7 +787,21 @@ function openid_authentication_request($claimed_id, $identity, $return_to = '',
 
   $request = array_merge($request, module_invoke_all('openid', 'request', $request));
 
-  return $request;
+  // module_invoke_all() uses array_merge_recursive() which might return nested
+  // arrays if two or more modules alter a given parameter, resulting in an
+  // invalid request format. To ensure this doesn't happen, we flatten the returned
+  // value by taking the last entry in the array if an array is returned.
+  $flattened_request = array();
+  foreach ($request as $key => $value) {
+    if (is_array($value)) {
+      $flattened_request[$key] = end($value);
+    }
+    else {
+      $flattened_request[$key] = $value;
+    }
+  }
+
+  return $flattened_request;
 }
 
 /**
diff --git a/modules/overlay/overlay-parent.js b/modules/overlay/overlay-parent.js
index 4134759..7452a51 100644
--- a/modules/overlay/overlay-parent.js
+++ b/modules/overlay/overlay-parent.js
@@ -630,8 +630,11 @@ Drupal.overlay.eventhandlerOverrideLink = function (event) {
           $target.attr('href', $.param.querystring(href, { destination: fragmentizedDestination }));
         }
 
-        // Make the link open in the immediate parent of the frame.
-        $target.attr('target', '_parent');
+        // Make the link open in the immediate parent of the frame, unless the
+        // link already has a different target.
+        if (!$target.attr('target')) {
+          $target.attr('target', '_parent');
+        }
       }
     }
   }
diff --git a/modules/overlay/overlay.module b/modules/overlay/overlay.module
index c07cc6c..7281986 100644
--- a/modules/overlay/overlay.module
+++ b/modules/overlay/overlay.module
@@ -704,7 +704,7 @@ function overlay_overlay_child_initialize() {
 }
 
 /**
- * Requests that the overlay overlay closes when the page is displayed.
+ * Requests that the overlay closes when the page is displayed.
  *
  * @param $redirect
  *   (optional) The path that should open in the parent window after the
diff --git a/modules/path/path.test b/modules/path/path.test
index f5c303c..edecff5 100644
--- a/modules/path/path.test
+++ b/modules/path/path.test
@@ -42,12 +42,12 @@ class PathTestCase extends DrupalWebTestCase {
     // created.
     cache_clear_all('*', 'cache_path', TRUE);
     $this->drupalGet($edit['source']);
-    $this->assertTrue(cache_get($edit['source'], 'cache_path'), t('Cache entry was created.'));
+    $this->assertTrue(cache_get($edit['source'], 'cache_path'), 'Cache entry was created.');
 
     // Visit the alias for the node and confirm a cache entry is created.
     cache_clear_all('*', 'cache_path', TRUE);
     $this->drupalGet($edit['alias']);
-    $this->assertTrue(cache_get($edit['source'], 'cache_path'), t('Cache entry was created.'));
+    $this->assertTrue(cache_get($edit['source'], 'cache_path'), 'Cache entry was created.');
   }
 
   /**
@@ -334,7 +334,7 @@ class PathLanguageTestCase extends DrupalWebTestCase {
     drupal_static_reset('locale_url_outbound_alter');
     $languages = language_list();
     $url = url('node/' . $french_node->nid, array('language' => $languages[$french_node->language]));
-    $this->assertTrue(strpos($url, $edit['path[alias]']), t('URL contains the path alias.'));
+    $this->assertTrue(strpos($url, $edit['path[alias]']), 'URL contains the path alias.');
 
     // Confirm that the alias works even when changing language negotiation
     // options. Enable User language detection and selection over URL one.
@@ -378,23 +378,23 @@ class PathLanguageTestCase extends DrupalWebTestCase {
     // situation only aliases in the default language and language neutral ones
     // should keep working.
     $this->drupalGet($french_alias);
-    $this->assertResponse(404, t('Alias for French translation is unavailable when URL language negotiation is disabled.'));
+    $this->assertResponse(404, 'Alias for French translation is unavailable when URL language negotiation is disabled.');
 
     // drupal_lookup_path() has an internal static cache. Check to see that
     // it has the appropriate contents at this point.
     drupal_lookup_path('wipe');
     $french_node_path = drupal_lookup_path('source', $french_alias, $french_node->language);
-    $this->assertEqual($french_node_path, 'node/' . $french_node->nid, t('Normal path works.'));
+    $this->assertEqual($french_node_path, 'node/' . $french_node->nid, 'Normal path works.');
     // Second call should return the same path.
     $french_node_path = drupal_lookup_path('source', $french_alias, $french_node->language);
-    $this->assertEqual($french_node_path, 'node/' . $french_node->nid, t('Normal path is the same.'));
+    $this->assertEqual($french_node_path, 'node/' . $french_node->nid, 'Normal path is the same.');
 
     // Confirm that the alias works.
     $french_node_alias = drupal_lookup_path('alias', 'node/' . $french_node->nid, $french_node->language);
-    $this->assertEqual($french_node_alias, $french_alias, t('Alias works.'));
+    $this->assertEqual($french_node_alias, $french_alias, 'Alias works.');
     // Second call should return the same alias.
     $french_node_alias = drupal_lookup_path('alias', 'node/' . $french_node->nid, $french_node->language);
-    $this->assertEqual($french_node_alias, $french_alias, t('Alias is the same.'));
+    $this->assertEqual($french_node_alias, $french_alias, 'Alias is the same.');
   }
 }
 
@@ -508,8 +508,8 @@ class PathMonolingualTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/config/regional/language', $edit, t('Save configuration'));
 
     // Verify that French is the only language.
-    $this->assertFalse(drupal_multilingual(), t('Site is mono-lingual'));
-    $this->assertEqual(language_default('language'), 'fr', t('French is the default language'));
+    $this->assertFalse(drupal_multilingual(), 'Site is mono-lingual');
+    $this->assertEqual(language_default('language'), 'fr', 'French is the default language');
 
     // Set language detection to URL.
     $edit = array('language[enabled][locale-url]' => TRUE);
diff --git a/modules/php/php.module b/modules/php/php.module
index 996f746..da9d01d 100644
--- a/modules/php/php.module
+++ b/modules/php/php.module
@@ -47,7 +47,7 @@ function php_permission() {
  * overwrite any variables in the calling code, unlike a regular eval() call.
  *
  * This function is also used as an implementation of
- * hook_filter_FILTER_process().
+ * callback_filter_process().
  *
  * @param $code
  *   The code to evaluate.
@@ -88,7 +88,7 @@ function php_eval($code) {
 }
 
 /**
- * Implements hook_filter_FILTER_tips().
+ * Implements callback_filter_tips().
  *
  * @see php_filter_info()
  */
@@ -122,7 +122,7 @@ else {
   print t(\'Welcome visitor! Thank you for visiting.\');
 }
 </pre>') . '</li></ul>';
-    $output .= '<p>' . t('<a href="@drupal">Drupal.org</a> offers <a href="@php-snippets">some example PHP snippets</a>, or you can create your own with some PHP experience and knowledge of the Drupal system.', array('@drupal' => url('http://drupal.org'), '@php-snippets' => url('http://http://drupal.org/documentation/customization/php-snippets'))) . '</p>';
+    $output .= '<p>' . t('<a href="@drupal">Drupal.org</a> offers <a href="@php-snippets">some example PHP snippets</a>, or you can create your own with some PHP experience and knowledge of the Drupal system.', array('@drupal' => url('http://drupal.org'), '@php-snippets' => url('http://drupal.org/documentation/customization/php-snippets'))) . '</p>';
     return $output;
   }
   else {
diff --git a/modules/php/php.test b/modules/php/php.test
index b68bd50..3b11b48 100644
--- a/modules/php/php.test
+++ b/modules/php/php.test
@@ -21,20 +21,20 @@ class PHPTestCase extends DrupalWebTestCase {
     // Verify that the PHP code text format was inserted.
     $php_format_id = 'php_code';
     $this->php_code_format = filter_format_load($php_format_id);
-    $this->assertEqual($this->php_code_format->name, 'PHP code', t('PHP code text format was created.'));
+    $this->assertEqual($this->php_code_format->name, 'PHP code', 'PHP code text format was created.');
 
     // Verify that the format has the PHP code filter enabled.
     $filters = filter_list_format($php_format_id);
-    $this->assertTrue($filters['php_code']->status, t('PHP code filter is enabled.'));
+    $this->assertTrue($filters['php_code']->status, 'PHP code filter is enabled.');
 
     // Verify that the format exists on the administration page.
     $this->drupalGet('admin/config/content/formats');
-    $this->assertText('PHP code', t('PHP code text format was created.'));
+    $this->assertText('PHP code', 'PHP code text format was created.');
 
     // Verify that anonymous and authenticated user roles do not have access.
     $this->drupalGet('admin/config/content/formats/' . $php_format_id);
-    $this->assertFieldByName('roles[' . DRUPAL_ANONYMOUS_RID . ']', FALSE, t('Anonymous users do not have access to PHP code format.'));
-    $this->assertFieldByName('roles[' . DRUPAL_AUTHENTICATED_RID . ']', FALSE, t('Authenticated users do not have access to PHP code format.'));
+    $this->assertFieldByName('roles[' . DRUPAL_ANONYMOUS_RID . ']', FALSE, 'Anonymous users do not have access to PHP code format.');
+    $this->assertFieldByName('roles[' . DRUPAL_AUTHENTICATED_RID . ']', FALSE, 'Authenticated users do not have access to PHP code format.');
   }
 
   /**
@@ -73,18 +73,18 @@ class PHPFilterTestCase extends PHPTestCase {
 
     // Make sure that the PHP code shows up as text.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText('print "SimpleTest PHP was executed!"', t('PHP code is displayed.'));
+    $this->assertText('print "SimpleTest PHP was executed!"', 'PHP code is displayed.');
 
     // Change filter to PHP filter and see that PHP code is evaluated.
     $edit = array();
     $langcode = LANGUAGE_NONE;
     $edit["body[$langcode][0][format]"] = $this->php_code_format->format;
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
-    $this->assertRaw(t('Basic page %title has been updated.', array('%title' => $node->title)), t('PHP code filter turned on.'));
+    $this->assertRaw(t('Basic page %title has been updated.', array('%title' => $node->title)), 'PHP code filter turned on.');
 
     // Make sure that the PHP code shows up as text.
-    $this->assertNoText('print "SimpleTest PHP was executed!"', t("PHP code isn't displayed."));
-    $this->assertText('SimpleTest PHP was executed!', t('PHP code has been evaluated.'));
+    $this->assertNoText('print "SimpleTest PHP was executed!"', "PHP code isn't displayed.");
+    $this->assertText('SimpleTest PHP was executed!', 'PHP code has been evaluated.');
   }
 }
 
@@ -111,10 +111,10 @@ class PHPAccessTestCase extends PHPTestCase {
 
     // Make sure that the PHP code shows up as text.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText('print', t('PHP code was not evaluated.'));
+    $this->assertText('print', 'PHP code was not evaluated.');
 
     // Make sure that user doesn't have access to filter.
     $this->drupalGet('node/' . $node->nid . '/edit');
-    $this->assertNoRaw('<option value="' . $this->php_code_format->format . '">', t('PHP code format not available.'));
+    $this->assertNoRaw('<option value="' . $this->php_code_format->format . '">', 'PHP code format not available.');
   }
 }
diff --git a/modules/rdf/rdf.module b/modules/rdf/rdf.module
index e491c31..e22d5a9 100644
--- a/modules/rdf/rdf.module
+++ b/modules/rdf/rdf.module
@@ -646,10 +646,12 @@ function rdf_preprocess_username(&$variables) {
   if (!empty($rdf_mapping['rdftype'])) {
     $attributes['typeof'] = $rdf_mapping['rdftype'];
   }
-  // Annotate the user name in RDFa. The property attribute is used here
-  // because the user name is a literal.
+  // Annotate the username in RDFa. A property attribute is used with an empty
+  // datatype attribute to ensure the username is parsed as a plain literal
+  // in RDFa 1.0 and 1.1.
   if (!empty($rdf_mapping['name'])) {
     $attributes['property'] = $rdf_mapping['name']['predicates'];
+    $attributes['datatype'] = '';
   }
   // Add the homepage RDFa markup if present.
   if (!empty($variables['homepage']) && !empty($rdf_mapping['homepage'])) {
@@ -757,7 +759,10 @@ function rdf_field_attach_view_alter(&$output, $context) {
             $element[$delta]['#options']['attributes']['typeof'] = $term->rdf_mapping['rdftype'];
           }
           if (!empty($term->rdf_mapping['name']['predicates'])) {
+            // A property attribute is used with an empty datatype attribute so
+            // the term name is parsed as a plain literal in RDFa 1.0 and 1.1.
             $element[$delta]['#options']['attributes']['property'] = $term->rdf_mapping['name']['predicates'];
+            $element[$delta]['#options']['attributes']['datatype'] = '';
           }
         }
       }
diff --git a/modules/rdf/rdf.test b/modules/rdf/rdf.test
index b8aeb90..4d73377 100644
--- a/modules/rdf/rdf.test
+++ b/modules/rdf/rdf.test
@@ -24,17 +24,17 @@ class RdfMappingHookTestCase extends DrupalWebTestCase {
   function testMapping() {
     // Test that the mapping is returned correctly by the hook.
     $mapping = rdf_mapping_load('test_entity', 'test_bundle');
-    $this->assertIdentical($mapping['rdftype'], array('sioc:Post'), t('Mapping for rdftype is sioc:Post.'));
-    $this->assertIdentical($mapping['title'], array('predicates' => array('dc:title')), t('Mapping for title is dc:title.'));
+    $this->assertIdentical($mapping['rdftype'], array('sioc:Post'), 'Mapping for rdftype is sioc:Post.');
+    $this->assertIdentical($mapping['title'], array('predicates' => array('dc:title')), 'Mapping for title is dc:title.');
     $this->assertIdentical($mapping['created'], array(
       'predicates' => array('dc:created'),
       'datatype' => 'xsd:dateTime',
       'callback' => 'date_iso8601',
     ), t('Mapping for created is dc:created with datatype xsd:dateTime and callback date_iso8601.'));
-    $this->assertIdentical($mapping['uid'], array('predicates' => array('sioc:has_creator', 'dc:creator'), 'type' => 'rel'), t('Mapping for uid is sioc:has_creator and dc:creator, and type is rel.'));
+    $this->assertIdentical($mapping['uid'], array('predicates' => array('sioc:has_creator', 'dc:creator'), 'type' => 'rel'), 'Mapping for uid is sioc:has_creator and dc:creator, and type is rel.');
 
     $mapping = rdf_mapping_load('test_entity', 'test_bundle_no_mapping');
-    $this->assertEqual($mapping, array(), t('Empty array returned when an entity type, bundle pair has no mapping.'));
+    $this->assertEqual($mapping, array(), 'Empty array returned when an entity type, bundle pair has no mapping.');
   }
 }
 
@@ -179,13 +179,13 @@ class RdfRdfaMarkupTestCase extends DrupalWebTestCase {
     $file_rel = $this->xpath('//div[contains(@about, :node-uri)]//div[contains(@rel, "rdfs:seeAlso") and contains(@resource, ".txt")]', array(
       ':node-uri' => 'node/' . $nid,
     ));
-    $this->assertTrue(!empty($file_rel), t('Attribute \'rel\' set on file field. Attribute \'resource\' is also set.'));
+    $this->assertTrue(!empty($file_rel), "Attribute 'rel' set on file field. Attribute 'resource' is also set.");
     $image_rel = $this->xpath('//div[contains(@about, :node-uri)]//div[contains(@rel, "rdfs:seeAlso") and contains(@resource, :image)]//img[contains(@typeof, "foaf:Image")]', array(
       ':node-uri' => 'node/' . $nid,
       ':image' => $image_filename,
     ));
 
-    $this->assertTrue(!empty($image_rel), t('Attribute \'rel\' set on image field. Attribute \'resource\' is also set.'));
+    $this->assertTrue(!empty($image_rel), "Attribute 'rel' set on image field. Attribute 'resource' is also set.");
 
     // Edits the node to add tags.
     $tag1 = $this->randomName(8);
@@ -195,16 +195,16 @@ class RdfRdfaMarkupTestCase extends DrupalWebTestCase {
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
     // Ensures the RDFa markup for the relationship between the node and its
     // tags is correct.
-    $term_rdfa_meta = $this->xpath('//div[@about=:node-url and contains(@typeof, "sioc:Item") and contains(@typeof, "foaf:Document")]//ul[@class="links"]/li[@rel="dc:subject"]/a[@typeof="skos:Concept" and text()=:term-name]', array(
+    $term_rdfa_meta = $this->xpath('//div[@about=:node-url and contains(@typeof, "sioc:Item") and contains(@typeof, "foaf:Document")]//ul[@class="links"]/li[@rel="dc:subject"]/a[@typeof="skos:Concept" and @datatype="" and text()=:term-name]', array(
       ':node-url' => url('node/' . $node->nid),
       ':term-name' => $tag1,
     ));
-    $this->assertTrue(!empty($term_rdfa_meta), t('Property dc:subject is present for the tag1 field item.'));
-    $term_rdfa_meta = $this->xpath('//div[@about=:node-url and contains(@typeof, "sioc:Item") and contains(@typeof, "foaf:Document")]//ul[@class="links"]/li[@rel="dc:subject"]/a[@typeof="skos:Concept" and text()=:term-name]', array(
+    $this->assertTrue(!empty($term_rdfa_meta), 'Property dc:subject is present for the tag1 field item.');
+    $term_rdfa_meta = $this->xpath('//div[@about=:node-url and contains(@typeof, "sioc:Item") and contains(@typeof, "foaf:Document")]//ul[@class="links"]/li[@rel="dc:subject"]/a[@typeof="skos:Concept" and @datatype="" and text()=:term-name]', array(
       ':node-url' => url('node/' . $node->nid),
       ':term-name' => $tag2,
     ));
-    $this->assertTrue(!empty($term_rdfa_meta), t('Property dc:subject is present for the tag2 field item.'));
+    $this->assertTrue(!empty($term_rdfa_meta), 'Property dc:subject is present for the tag2 field item.');
   }
 }
 
@@ -227,7 +227,7 @@ class RdfCrudTestCase extends DrupalWebTestCase {
   function testCRUD() {
     // Verify loading of a default mapping.
     $mapping = _rdf_mapping_load('test_entity', 'test_bundle');
-    $this->assertTrue(count($mapping), t('Default mapping was found.'));
+    $this->assertTrue(count($mapping), 'Default mapping was found.');
 
     // Verify saving a mapping.
     $mapping = array(
@@ -244,35 +244,35 @@ class RdfCrudTestCase extends DrupalWebTestCase {
         ),
       ),
     );
-    $this->assertTrue(rdf_mapping_save($mapping) === SAVED_NEW, t('Mapping was saved.'));
+    $this->assertTrue(rdf_mapping_save($mapping) === SAVED_NEW, 'Mapping was saved.');
 
     // Read the raw record from the {rdf_mapping} table.
     $result = db_query('SELECT * FROM {rdf_mapping} WHERE type = :type AND bundle = :bundle', array(':type' => $mapping['type'], ':bundle' => $mapping['bundle']));
     $stored_mapping = $result->fetchAssoc();
     $stored_mapping['mapping'] = unserialize($stored_mapping['mapping']);
-    $this->assertEqual($mapping, $stored_mapping, t('Mapping was stored properly in the {rdf_mapping} table.'));
+    $this->assertEqual($mapping, $stored_mapping, 'Mapping was stored properly in the {rdf_mapping} table.');
 
     // Verify loading of saved mapping.
-    $this->assertEqual($mapping['mapping'], _rdf_mapping_load($mapping['type'], $mapping['bundle']), t('Saved mapping loaded successfully.'));
+    $this->assertEqual($mapping['mapping'], _rdf_mapping_load($mapping['type'], $mapping['bundle']), 'Saved mapping loaded successfully.');
 
     // Verify updating of mapping.
     $mapping['mapping']['title'] = array(
       'predicates' => array('dc2:bar2'),
     );
-    $this->assertTrue(rdf_mapping_save($mapping) === SAVED_UPDATED, t('Mapping was updated.'));
+    $this->assertTrue(rdf_mapping_save($mapping) === SAVED_UPDATED, 'Mapping was updated.');
 
     // Read the raw record from the {rdf_mapping} table.
     $result = db_query('SELECT * FROM {rdf_mapping} WHERE type = :type AND bundle = :bundle', array(':type' => $mapping['type'], ':bundle' => $mapping['bundle']));
     $stored_mapping = $result->fetchAssoc();
     $stored_mapping['mapping'] = unserialize($stored_mapping['mapping']);
-    $this->assertEqual($mapping, $stored_mapping, t('Updated mapping was stored properly in the {rdf_mapping} table.'));
+    $this->assertEqual($mapping, $stored_mapping, 'Updated mapping was stored properly in the {rdf_mapping} table.');
 
     // Verify loading of saved mapping.
-    $this->assertEqual($mapping['mapping'], _rdf_mapping_load($mapping['type'], $mapping['bundle']), t('Saved mapping loaded successfully.'));
+    $this->assertEqual($mapping['mapping'], _rdf_mapping_load($mapping['type'], $mapping['bundle']), 'Saved mapping loaded successfully.');
 
     // Verify deleting of mapping.
-    $this->assertTrue(rdf_mapping_delete($mapping['type'], $mapping['bundle']), t('Mapping was deleted.'));
-    $this->assertFalse(_rdf_mapping_load($mapping['type'], $mapping['bundle']), t('Deleted mapping is no longer found in the database.'));
+    $this->assertTrue(rdf_mapping_delete($mapping['type'], $mapping['bundle']), 'Mapping was deleted.');
+    $this->assertFalse(_rdf_mapping_load($mapping['type'], $mapping['bundle']), 'Deleted mapping is no longer found in the database.');
   }
 }
 
@@ -303,8 +303,8 @@ class RdfMappingDefinitionTestCase extends TaxonomyWebTestCase {
     // from the node default bundle definition.
     $blog_title = $this->xpath("//meta[@property='dc:title' and @content='$node->title']");
     $blog_meta = $this->xpath("//div[(@about='$url') and (@typeof='sioct:Weblog')]//span[contains(@property, 'dc:date') and contains(@property, 'dc:created') and @datatype='xsd:dateTime' and @content='$isoDate']");
-    $this->assertTrue(!empty($blog_title), t('Property dc:title is present in meta tag.'));
-    $this->assertTrue(!empty($blog_meta), t('RDF type is present on post. Properties dc:date and dc:created are present on post date.'));
+    $this->assertTrue(!empty($blog_title), 'Property dc:title is present in meta tag.');
+    $this->assertTrue(!empty($blog_meta), 'RDF type is present on post. Properties dc:date and dc:created are present on post date.');
   }
 
   /**
@@ -321,8 +321,8 @@ class RdfMappingDefinitionTestCase extends TaxonomyWebTestCase {
     // Ensure the mapping defined in rdf_module.test is used.
     $test_bundle_title = $this->xpath("//meta[@property='dc:title' and @content='$node->title']");
     $test_bundle_meta = $this->xpath("//div[(@about='$url') and contains(@typeof, 'foo:mapping_install1') and contains(@typeof, 'bar:mapping_install2')]//span[contains(@property, 'dc:date') and contains(@property, 'dc:created') and @datatype='xsd:dateTime' and @content='$isoDate']");
-    $this->assertTrue(!empty($test_bundle_title), t('Property dc:title is present in meta tag.'));
-    $this->assertTrue(!empty($test_bundle_meta), t('RDF type is present on post. Properties dc:date and dc:created are present on post date.'));
+    $this->assertTrue(!empty($test_bundle_title), 'Property dc:title is present in meta tag.');
+    $this->assertTrue(!empty($test_bundle_meta), 'RDF type is present on post. Properties dc:date and dc:created are present on post date.');
   }
 
   /**
@@ -340,8 +340,8 @@ class RdfMappingDefinitionTestCase extends TaxonomyWebTestCase {
     // from the node default bundle definition.
     $random_bundle_title = $this->xpath("//meta[@property='dc:title' and @content='$node->title']");
     $random_bundle_meta = $this->xpath("//div[(@about='$url') and contains(@typeof, 'sioc:Item') and contains(@typeof, 'foaf:Document')]//span[contains(@property, 'dc:date') and contains(@property, 'dc:created') and @datatype='xsd:dateTime' and @content='$isoDate']");
-    $this->assertTrue(!empty($random_bundle_title), t('Property dc:title is present in meta tag.'));
-    $this->assertTrue(!empty($random_bundle_meta), t('RDF type is present on post. Properties dc:date and dc:created are present on post date.'));
+    $this->assertTrue(!empty($random_bundle_title), 'Property dc:title is present in meta tag.');
+    $this->assertTrue(!empty($random_bundle_meta), 'RDF type is present on post. Properties dc:date and dc:created are present on post date.');
   }
 
   /**
@@ -363,19 +363,19 @@ class RdfMappingDefinitionTestCase extends TaxonomyWebTestCase {
     $user2_profile_about = $this->xpath('//div[@class="profile" and @typeof="sioc:UserAccount" and @about=:account-uri]', array(
       ':account-uri' => $account_uri,
     ));
-    $this->assertTrue(!empty($user2_profile_about), t('RDFa markup found on user profile page'));
+    $this->assertTrue(!empty($user2_profile_about), 'RDFa markup found on user profile page');
 
     $user_account_holder = $this->xpath('//meta[contains(@typeof, "foaf:Person") and @about=:person-uri and @resource=:account-uri and contains(@rel, "foaf:account")]', array(
       ':person-uri' => $person_uri,
       ':account-uri' => $account_uri,
     ));
-    $this->assertTrue(!empty($user_account_holder), t('URI created for account holder and username set on sioc:UserAccount.'));
+    $this->assertTrue(!empty($user_account_holder), 'URI created for account holder and username set on sioc:UserAccount.');
 
     $user_username = $this->xpath('//meta[@about=:account-uri and contains(@property, "foaf:name") and @content=:username]', array(
       ':account-uri' => $account_uri,
       ':username' => $username,
     ));
-    $this->assertTrue(!empty($user_username), t('foaf:name set on username.'));
+    $this->assertTrue(!empty($user_username), 'foaf:name set on username.');
 
     // User 2 creates node.
     $this->drupalLogin($user2);
@@ -384,10 +384,10 @@ class RdfMappingDefinitionTestCase extends TaxonomyWebTestCase {
     $this->drupalGet('node/' . $node->nid);
     // Ensures the default bundle mapping for user is used on the Authored By
     // information on the node.
-    $author_about = $this->xpath('//a[@typeof="sioc:UserAccount" and @about=:account-uri and @property="foaf:name" and contains(@xml:lang, "")]', array(
+    $author_about = $this->xpath('//a[@typeof="sioc:UserAccount" and @about=:account-uri and @property="foaf:name" and @datatype="" and contains(@xml:lang, "")]', array(
       ':account-uri' => $account_uri,
     ));
-    $this->assertTrue(!empty($author_about), t('RDFa markup found on author information on post. xml:lang on username is set to empty string.'));
+    $this->assertTrue(!empty($author_about), 'RDFa markup found on author information on post. xml:lang on username is set to empty string.');
   }
 
   /**
@@ -405,7 +405,7 @@ class RdfMappingDefinitionTestCase extends TaxonomyWebTestCase {
       ':term-url' => $term_url,
       ':term-name' => $term_name,
     ));
-    $this->assertTrue(!empty($term_rdfa_meta), t('RDFa markup found on term page.'));
+    $this->assertTrue(!empty($term_rdfa_meta), 'RDFa markup found on term page.');
   }
 }
 
@@ -457,15 +457,15 @@ class RdfCommentAttributesTestCase extends CommentHelperCase {
     // Tests number of comments in teaser view.
     $this->drupalGet('node');
     $comment_count_teaser = $this->xpath('//div[contains(@typeof, "sioc:Item")]//li[contains(@class, "comment-comments")]/a[contains(@property, "sioc:num_replies") and contains(@content, "2") and @datatype="xsd:integer"]');
-    $this->assertTrue(!empty($comment_count_teaser), t('RDFa markup for the number of comments found on teaser view.'));
+    $this->assertTrue(!empty($comment_count_teaser), 'RDFa markup for the number of comments found on teaser view.');
     $comment_count_link = $this->xpath('//div[@about=:url]//a[contains(@property, "sioc:num_replies") and @rel=""]', array(':url' => url("node/{$this->node1->nid}")));
-    $this->assertTrue(!empty($comment_count_link), t('Empty rel attribute found in comment count link.'));
+    $this->assertTrue(!empty($comment_count_link), 'Empty rel attribute found in comment count link.');
 
     // Tests number of comments in full node view.
     $this->drupalGet('node/' . $this->node1->nid);
     $node_url = url('node/' . $this->node1->nid);
     $comment_count_teaser = $this->xpath('/html/head/meta[@about=:node-url and @property="sioc:num_replies" and @content="2" and @datatype="xsd:integer"]', array(':node-url' => $node_url));
-    $this->assertTrue(!empty($comment_count_teaser), t('RDFa markup for the number of comments found on full node view.'));
+    $this->assertTrue(!empty($comment_count_teaser), 'RDFa markup for the number of comments found on full node view.');
   }
 
   /**
@@ -502,22 +502,22 @@ class RdfCommentAttributesTestCase extends CommentHelperCase {
     // Tests comment #2 as anonymous user.
     $this->_testBasicCommentRdfaMarkup($comment2, $anonymous_user);
     // Tests the RDFa markup for the homepage (specific to anonymous comments).
-    $comment_homepage = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/a[contains(@class, "username") and @typeof="sioc:UserAccount" and @property="foaf:name" and @href="http://example.org/" and contains(@rel, "foaf:page")]');
-    $this->assertTrue(!empty($comment_homepage), t('RDFa markup for the homepage of anonymous user found.'));
+    $comment_homepage = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/a[contains(@class, "username") and @typeof="sioc:UserAccount" and @property="foaf:name" and @datatype="" and @href="http://example.org/" and contains(@rel, "foaf:page")]');
+    $this->assertTrue(!empty($comment_homepage), 'RDFa markup for the homepage of anonymous user found.');
     // There should be no about attribute on anonymous comments.
     $comment_homepage = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/a[@about]');
-    $this->assertTrue(empty($comment_homepage), t('No about attribute is present on anonymous user comment.'));
+    $this->assertTrue(empty($comment_homepage), 'No about attribute is present on anonymous user comment.');
 
     // Tests comment #2 as logged in user.
     $this->drupalLogin($this->web_user);
     $this->drupalGet('node/' . $this->node2->nid);
     $this->_testBasicCommentRdfaMarkup($comment2, $anonymous_user);
     // Tests the RDFa markup for the homepage (specific to anonymous comments).
-    $comment_homepage = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/a[contains(@class, "username") and @typeof="sioc:UserAccount" and @property="foaf:name" and @href="http://example.org/" and contains(@rel, "foaf:page")]');
-    $this->assertTrue(!empty($comment_homepage), t("RDFa markup for the homepage of anonymous user found."));
+    $comment_homepage = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/a[contains(@class, "username") and @typeof="sioc:UserAccount" and @property="foaf:name" and @datatype="" and @href="http://example.org/" and contains(@rel, "foaf:page")]');
+    $this->assertTrue(!empty($comment_homepage), "RDFa markup for the homepage of anonymous user found.");
     // There should be no about attribute on anonymous comments.
     $comment_homepage = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/a[@about]');
-    $this->assertTrue(empty($comment_homepage), t("No about attribute is present on anonymous user comment."));
+    $this->assertTrue(empty($comment_homepage), "No about attribute is present on anonymous user comment.");
   }
 
   /**
@@ -530,9 +530,9 @@ class RdfCommentAttributesTestCase extends CommentHelperCase {
 
     // Tests the reply_of relationship of a first level comment.
     $result = $this->xpath("(id('comments')//div[contains(@class,'comment ')])[position()=1]//span[@rel='sioc:reply_of' and @resource=:node]", array(':node' => url("node/{$this->node1->nid}")));
-    $this->assertEqual(1, count($result), t('RDFa markup referring to the node is present.'));
+    $this->assertEqual(1, count($result), 'RDFa markup referring to the node is present.');
     $result = $this->xpath("(id('comments')//div[contains(@class,'comment ')])[position()=1]//span[@rel='sioc:reply_of' and @resource=:comment]", array(':comment' => url('comment/1#comment-1')));
-    $this->assertFalse($result, t('No RDFa markup referring to the comment itself is present.'));
+    $this->assertFalse($result, 'No RDFa markup referring to the comment itself is present.');
 
     // Posts a reply to the first comment.
     $this->drupalGet('comment/reply/' . $this->node1->nid . '/' . $comments[0]->id);
@@ -540,9 +540,9 @@ class RdfCommentAttributesTestCase extends CommentHelperCase {
 
     // Tests the reply_of relationship of a second level comment.
     $result = $this->xpath("(id('comments')//div[contains(@class,'comment ')])[position()=2]//span[@rel='sioc:reply_of' and @resource=:node]", array(':node' => url("node/{$this->node1->nid}")));
-    $this->assertEqual(1, count($result), t('RDFa markup referring to the node is present.'));
+    $this->assertEqual(1, count($result), 'RDFa markup referring to the node is present.');
     $result = $this->xpath("(id('comments')//div[contains(@class,'comment ')])[position()=2]//span[@rel='sioc:reply_of' and @resource=:comment]", array(':comment' => url('comment/1', array('fragment' => 'comment-1'))));
-    $this->assertEqual(1, count($result), t('RDFa markup referring to the parent comment is present.'));
+    $this->assertEqual(1, count($result), 'RDFa markup referring to the parent comment is present.');
     $comments = $this->xpath("(id('comments')//div[contains(@class,'comment ')])[position()=2]");
   }
 
@@ -558,17 +558,17 @@ class RdfCommentAttributesTestCase extends CommentHelperCase {
    */
   function _testBasicCommentRdfaMarkup($comment, $account = array()) {
     $comment_container = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]');
-    $this->assertTrue(!empty($comment_container), t("Comment RDF type for comment found."));
+    $this->assertTrue(!empty($comment_container), "Comment RDF type for comment found.");
     $comment_title = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//h3[@property="dc:title"]');
-    $this->assertEqual((string)$comment_title[0]->a, $comment->subject, t("RDFa markup for the comment title found."));
+    $this->assertEqual((string)$comment_title[0]->a, $comment->subject, "RDFa markup for the comment title found.");
     $comment_date = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//*[contains(@property, "dc:date") and contains(@property, "dc:created")]');
-    $this->assertTrue(!empty($comment_date), t("RDFa markup for the date of the comment found."));
+    $this->assertTrue(!empty($comment_date), "RDFa markup for the date of the comment found.");
     // The author tag can be either a or span
-    $comment_author = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/*[contains(@class, "username") and @typeof="sioc:UserAccount" and @property="foaf:name"]');
+    $comment_author = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//span[@rel="sioc:has_creator"]/*[contains(@class, "username") and @typeof="sioc:UserAccount" and @property="foaf:name" and @datatype=""]');
     $name = empty($account["name"]) ? $this->web_user->name : $account["name"] . " (not verified)";
-    $this->assertEqual((string)$comment_author[0], $name, t("RDFa markup for the comment author found."));
+    $this->assertEqual((string)$comment_author[0], $name, "RDFa markup for the comment author found.");
     $comment_body = $this->xpath('//div[contains(@class, "comment") and contains(@typeof, "sioct:Comment")]//div[@class="content"]//div[contains(@class, "comment-body")]//div[@property="content:encoded"]');
-    $this->assertEqual((string)$comment_body[0]->p, $comment->comment, t("RDFa markup for the comment body found."));
+    $this->assertEqual((string)$comment_body[0]->p, $comment->comment, "RDFa markup for the comment body found.");
   }
 }
 
@@ -629,35 +629,35 @@ class RdfTrackerAttributesTestCase extends DrupalWebTestCase {
     // success of the following tests, but making it explicit will make
     // debugging easier in case of failure.
     $tracker_about = $this->xpath('//tr[@about=:url]', array(':url' => $url));
-    $this->assertTrue(!empty($tracker_about), t('About attribute found on table row for @user content.', array('@user'=> $user)));
+    $this->assertTrue(!empty($tracker_about), format_string('About attribute found on table row for @user content.', array('@user'=> $user)));
 
     // Tests whether the title has the correct property attribute.
     $tracker_title = $this->xpath('//tr[@about=:url]/td[@property="dc:title" and @datatype=""]', array(':url' => $url));
-    $this->assertTrue(!empty($tracker_title), t('Title property attribute found on @user content.', array('@user'=> $user)));
+    $this->assertTrue(!empty($tracker_title), format_string('Title property attribute found on @user content.', array('@user'=> $user)));
 
     // Tests whether the relationship between the content and user has been set.
     $tracker_user = $this->xpath('//tr[@about=:url]//td[contains(@rel, "sioc:has_creator")]//*[contains(@typeof, "sioc:UserAccount") and contains(@property, "foaf:name")]', array(':url' => $url));
-    $this->assertTrue(!empty($tracker_user), t('Typeof and name property attributes found on @user.', array('@user'=> $user)));
+    $this->assertTrue(!empty($tracker_user), format_string('Typeof and name property attributes found on @user.', array('@user'=> $user)));
     // There should be an about attribute on logged in users and no about
     // attribute for anonymous users.
     $tracker_user = $this->xpath('//tr[@about=:url]//td[@rel="sioc:has_creator"]/*[@about]', array(':url' => $url));
     if ($node->uid == 0) {
-      $this->assertTrue(empty($tracker_user), t('No about attribute is present on @user.', array('@user'=> $user)));
+      $this->assertTrue(empty($tracker_user), format_string('No about attribute is present on @user.', array('@user'=> $user)));
     }
     elseif ($node->uid > 0) {
-      $this->assertTrue(!empty($tracker_user), t('About attribute is present on @user.', array('@user'=> $user)));
+      $this->assertTrue(!empty($tracker_user), format_string('About attribute is present on @user.', array('@user'=> $user)));
     }
 
     // Tests whether the property has been set for number of comments.
     $tracker_replies = $this->xpath('//tr[@about=:url]//td[contains(@property, "sioc:num_replies") and contains(@content, "0") and @datatype="xsd:integer"]', array(':url' => $url));
-    $this->assertTrue($tracker_replies, t('Num replies property and content attributes found on @user content.', array('@user'=> $user)));
+    $this->assertTrue($tracker_replies, format_string('Num replies property and content attributes found on @user content.', array('@user'=> $user)));
 
     // Tests that the appropriate RDFa markup to annotate the latest activity
     // date has been added to the tracker output before comments have been
     // posted, meaning the latest activity reflects changes to the node itself.
     $isoDate = date('c', $node->changed);
     $tracker_activity = $this->xpath('//tr[@about=:url]//td[contains(@property, "dc:modified") and contains(@property, "sioc:last_activity_date") and contains(@datatype, "xsd:dateTime") and @content=:date]', array(':url' => $url, ':date' => $isoDate));
-    $this->assertTrue(!empty($tracker_activity), t('Latest activity date and changed properties found when there are no comments on @user content. Latest activity date content is correct.', array('@user'=> $user)));
+    $this->assertTrue(!empty($tracker_activity), format_string('Latest activity date and changed properties found when there are no comments on @user content. Latest activity date content is correct.', array('@user'=> $user)));
 
     // Tests that the appropriate RDFa markup to annotate the latest activity
     // date has been added to the tracker output after a comment is posted.
@@ -670,7 +670,7 @@ class RdfTrackerAttributesTestCase extends DrupalWebTestCase {
 
     // Tests whether the property has been set for number of comments.
     $tracker_replies = $this->xpath('//tr[@about=:url]//td[contains(@property, "sioc:num_replies") and contains(@content, "1") and @datatype="xsd:integer"]', array(':url' => $url));
-    $this->assertTrue($tracker_replies, t('Num replies property and content attributes found on @user content.', array('@user'=> $user)));
+    $this->assertTrue($tracker_replies, format_string('Num replies property and content attributes found on @user content.', array('@user'=> $user)));
 
     // Need to query database directly to obtain last_activity_date because
     // it cannot be accessed via node_load().
@@ -680,7 +680,7 @@ class RdfTrackerAttributesTestCase extends DrupalWebTestCase {
     }
     $isoDate = date('c', $expected_last_activity_date);
     $tracker_activity = $this->xpath('//tr[@about=:url]//td[@property="sioc:last_activity_date" and @datatype="xsd:dateTime" and @content=:date]', array(':url' => $url, ':date' => $isoDate));
-    $this->assertTrue(!empty($tracker_activity), t('Latest activity date found when there are comments on @user content. Latest activity date content is correct.', array('@user'=> $user)));
+    $this->assertTrue(!empty($tracker_activity), format_string('Latest activity date found when there are comments on @user content. Latest activity date content is correct.', array('@user'=> $user)));
   }
 }
 
@@ -707,9 +707,9 @@ class RdfGetRdfNamespacesTestCase extends DrupalWebTestCase {
     // Get all RDF namespaces.
     $ns = rdf_get_namespaces();
 
-    $this->assertEqual($ns['rdfs'], 'http://www.w3.org/2000/01/rdf-schema#', t('A prefix declared once is included.'));
-    $this->assertEqual($ns['foaf'], 'http://xmlns.com/foaf/0.1/', t('The same prefix declared in several implementations of hook_rdf_namespaces() is valid as long as all the namespaces are the same.'));
-    $this->assertEqual($ns['foaf1'], 'http://xmlns.com/foaf/0.1/', t('Two prefixes can be assigned the same namespace.'));
-    $this->assertTrue(!isset($ns['dc']), t('A prefix with conflicting namespaces is discarded.'));
+    $this->assertEqual($ns['rdfs'], 'http://www.w3.org/2000/01/rdf-schema#', 'A prefix declared once is included.');
+    $this->assertEqual($ns['foaf'], 'http://xmlns.com/foaf/0.1/', 'The same prefix declared in several implementations of hook_rdf_namespaces() is valid as long as all the namespaces are the same.');
+    $this->assertEqual($ns['foaf1'], 'http://xmlns.com/foaf/0.1/', 'Two prefixes can be assigned the same namespace.');
+    $this->assertTrue(!isset($ns['dc']), 'A prefix with conflicting namespaces is discarded.');
   }
 }
diff --git a/modules/search/search.api.php b/modules/search/search.api.php
index 534c1e8..62d53b8 100644
--- a/modules/search/search.api.php
+++ b/modules/search/search.api.php
@@ -30,15 +30,11 @@
  *
  * @return
  *   Array with optional keys:
- *   - 'title': Title for the tab on the search page for this module. Defaults
+ *   - title: Title for the tab on the search page for this module. Defaults
  *     to the module name if not given.
- *   - 'path': Path component after 'search/' for searching with this module.
+ *   - path: Path component after 'search/' for searching with this module.
  *     Defaults to the module name if not given.
- *   - 'conditions_callback': Name of a callback function that is invoked by
- *     search_view() to get an array of additional search conditions to pass to
- *     search_data(). For example, a search module may get additional keywords,
- *     filters, or modifiers for the search from the query string. Sample
- *     callback function: sample_search_conditions_callback().
+ *   - conditions_callback: An implementation of callback_search_conditions().
  *
  * @ingroup search
  */
@@ -46,36 +42,11 @@ function hook_search_info() {
   return array(
     'title' => 'Content',
     'path' => 'node',
-    'conditions_callback' => 'sample_search_conditions_callback',
+    'conditions_callback' => 'callback_search_conditions',
   );
 }
 
 /**
- * An example conditions callback function for search.
- *
- * This example pulls additional search keywords out of the $_REQUEST variable,
- * (i.e. from the query string of the request). The conditions may also be
- * generated internally - for example based on a module's settings.
- *
- * @see hook_search_info()
- * @ingroup search
- */
-function sample_search_conditions_callback($keys) {
-  $conditions = array();
-
-  if (!empty($_REQUEST['keys'])) {
-    $conditions['keys'] = $_REQUEST['keys'];
-  }
-  if (!empty($_REQUEST['sample_search_keys'])) {
-    $conditions['sample_search_keys'] = $_REQUEST['sample_search_keys'];
-  }
-  if ($force_keys = variable_get('sample_search_force_keywords', '')) {
-    $conditions['sample_search_force_keywords'] = $force_keys;
-  }
-  return $conditions;
-}
-
-/**
  * Define access to a custom search routine.
  *
  * This hook allows a module to define permissions for a search tab.
@@ -252,22 +223,23 @@ function hook_search_execute($keys = NULL, $conditions = NULL) {
 /**
  * Override the rendering of search results.
  *
- * A module that implements hook_search_info() to define a type of search
- * may implement this hook in order to override the default theming of
- * its search results, which is otherwise themed using theme('search_results').
+ * A module that implements hook_search_info() to define a type of search may
+ * implement this hook in order to override the default theming of its search
+ * results, which is otherwise themed using theme('search_results').
  *
  * Note that by default, theme('search_results') and theme('search_result')
  * work together to create an ordered list (OL). So your hook_search_page()
  * implementation should probably do this as well.
  *
- * @see search-result.tpl.php, search-results.tpl.php
- *
  * @param $results
  *   An array of search results.
  *
  * @return
- *   A renderable array, which will render the formatted search results with
- *   a pager included.
+ *   A renderable array, which will render the formatted search results with a
+ *   pager included.
+ *
+ * @see search-result.tpl.php
+ * @see search-results.tpl.php
  */
 function hook_search_page($results) {
   $output['prefix']['#markup'] = '<ol class="search-results">';
@@ -364,3 +336,41 @@ function hook_update_index() {
 /**
  * @} End of "addtogroup hooks".
  */
+
+/**
+ * Provide search query conditions.
+ *
+ * Callback for hook_search_info().
+ *
+ * This callback is invoked by search_view() to get an array of additional
+ * search conditions to pass to search_data(). For example, a search module
+ * may get additional keywords, filters, or modifiers for the search from
+ * the query string.
+ *
+ * This example pulls additional search keywords out of the $_REQUEST variable,
+ * (i.e. from the query string of the request). The conditions may also be
+ * generated internally - for example based on a module's settings.
+ *
+ * @param $keys
+ *   The search keywords string.
+ *
+ * @return
+ *   An array of additional conditions, such as filters.
+ *
+ * @ingroup callbacks
+ * @ingroup search
+ */
+function callback_search_conditions($keys) {
+  $conditions = array();
+
+  if (!empty($_REQUEST['keys'])) {
+    $conditions['keys'] = $_REQUEST['keys'];
+  }
+  if (!empty($_REQUEST['sample_search_keys'])) {
+    $conditions['sample_search_keys'] = $_REQUEST['sample_search_keys'];
+  }
+  if ($force_keys = config('sample_search.settings')->get('force_keywords')) {
+    $conditions['sample_search_force_keywords'] = $force_keys;
+  }
+  return $conditions;
+}
diff --git a/modules/search/search.module b/modules/search/search.module
index 910cb65..7542f98 100644
--- a/modules/search/search.module
+++ b/modules/search/search.module
@@ -1067,7 +1067,7 @@ function template_preprocess_search_block_form(&$variables) {
   $hidden = array();
   // Provide variables named after form keys so themers can print each element independently.
   foreach (element_children($variables['form']) as $key) {
-    $type = $variables['form'][$key]['#type'];
+    $type = isset($variables['form'][$key]['#type']) ? $variables['form'][$key]['#type'] : '';
     if ($type == 'hidden' || $type == 'token') {
       $hidden[] = drupal_render($variables['form'][$key]);
     }
diff --git a/modules/search/search.pages.inc b/modules/search/search.pages.inc
index b748473..9dd00a6 100644
--- a/modules/search/search.pages.inc
+++ b/modules/search/search.pages.inc
@@ -15,7 +15,6 @@
  */
 function search_view($module = NULL, $keys = '') {
   $info = FALSE;
-  $redirect = FALSE;
   $keys = trim($keys);
   // Also try to pull search keywords out of the $_REQUEST variable to
   // support old GET format of searches for existing links.
diff --git a/modules/search/search.test b/modules/search/search.test
index eeb6bf2..2892600 100644
--- a/modules/search/search.test
+++ b/modules/search/search.test
@@ -275,7 +275,7 @@ class SearchPageText extends DrupalWebTestCase {
     $edit = array();
     $edit['keys'] = 'bike shed ' . $this->randomName();
     $this->drupalPost('search/node', $edit, t('Search'));
-    $this->assertText(t('Consider loosening your query with OR. bike OR shed will often show more results than bike shed.'), t('Help text is displayed when search returns no results.'));
+    $this->assertText(t('Consider loosening your query with OR. bike OR shed will often show more results than bike shed.'), 'Help text is displayed when search returns no results.');
     $this->assertText(t('Search'));
     $this->assertTitle($title, 'Search page title is correct');
 
@@ -342,31 +342,31 @@ class SearchAdvancedSearchForm extends DrupalWebTestCase {
    * Test using the advanced search form to limit search to nodes of type "Basic page".
    */
   function testNodeType() {
-    $this->assertTrue($this->node->type == 'page', t('Node type is Basic page.'));
+    $this->assertTrue($this->node->type == 'page', 'Node type is Basic page.');
 
     // Assert that the dummy title doesn't equal the real title.
     $dummy_title = 'Lorem ipsum';
-    $this->assertNotEqual($dummy_title, $this->node->title, t("Dummy title doesn't equal node title"));
+    $this->assertNotEqual($dummy_title, $this->node->title, "Dummy title doesn't equal node title");
 
     // Search for the dummy title with a GET query.
     $this->drupalGet('search/node/' . $dummy_title);
-    $this->assertNoText($this->node->title, t('Basic page node is not found with dummy title.'));
+    $this->assertNoText($this->node->title, 'Basic page node is not found with dummy title.');
 
     // Search for the title of the node with a GET query.
     $this->drupalGet('search/node/' . $this->node->title);
-    $this->assertText($this->node->title, t('Basic page node is found with GET query.'));
+    $this->assertText($this->node->title, 'Basic page node is found with GET query.');
 
     // Search for the title of the node with a POST query.
     $edit = array('or' => $this->node->title);
     $this->drupalPost('search/node', $edit, t('Advanced search'));
-    $this->assertText($this->node->title, t('Basic page node is found with POST query.'));
+    $this->assertText($this->node->title, 'Basic page node is found with POST query.');
 
     // Advanced search type option.
     $this->drupalPost('search/node', array_merge($edit, array('type[page]' => 'page')), t('Advanced search'));
-    $this->assertText($this->node->title, t('Basic page node is found with POST query and type:page.'));
+    $this->assertText($this->node->title, 'Basic page node is found with POST query and type:page.');
 
     $this->drupalPost('search/node', array_merge($edit, array('type[article]' => 'article')), t('Advanced search'));
-    $this->assertText('bike shed', t('Article node is not found with POST query and type:article.'));
+    $this->assertText('bike shed', 'Article node is not found with POST query and type:article.');
   }
 }
 
@@ -464,7 +464,7 @@ class SearchRankingTestCase extends DrupalWebTestCase {
   function testHTMLRankings() {
     // Login with sufficient privileges.
     $this->drupalLogin($this->drupalCreateUser(array('create page content')));
-    
+
     // Test HTML tags with different weights.
     $sorted_tags = array('h1', 'h2', 'h3', 'h4', 'a', 'h5', 'h6', 'notag');
     $shuffled_tags = $sorted_tags;
@@ -496,7 +496,7 @@ class SearchRankingTestCase extends DrupalWebTestCase {
 
     // Refresh variables after the treatment.
     $this->refreshVariables();
-    
+
     // Disable all other rankings.
     $node_ranks = array('sticky', 'promote', 'recent', 'comments', 'views');
     foreach ($node_ranks as $node_rank) {
@@ -534,7 +534,7 @@ class SearchRankingTestCase extends DrupalWebTestCase {
 
       // Assert the results.
       $this->assertEqual($set[0]['node']->nid, $node->nid, 'Search tag ranking for "&lt;' . $tag . '&gt;" order.');
-      
+
       // Delete node so it doesn't show up in subsequent search results.
       node_delete($node->nid);
     }
@@ -600,13 +600,13 @@ class SearchBlockTestCase extends DrupalWebTestCase {
   function testSearchFormBlock() {
     // Set block title to confirm that the interface is available.
     $this->drupalPost('admin/structure/block/manage/search/form/configure', array('title' => $this->randomName(8)), t('Save block'));
-    $this->assertText(t('The block configuration has been saved.'), t('Block configuration set.'));
+    $this->assertText(t('The block configuration has been saved.'), 'Block configuration set.');
 
     // Set the block to a region to confirm block is available.
     $edit = array();
     $edit['blocks[search_form][region]'] = 'footer';
     $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
-    $this->assertText(t('The block settings have been updated.'), t('Block successfully move to footer region.'));
+    $this->assertText(t('The block settings have been updated.'), 'Block successfully move to footer region.');
   }
 
   /**
@@ -640,7 +640,7 @@ class SearchBlockTestCase extends DrupalWebTestCase {
     $this->assertEqual(
       $this->getUrl(),
       url('search/node/' . $terms['search_block_form'], array('absolute' => TRUE)),
-      t('Redirected to correct url.')
+      'Redirected to correct url.'
     );
 
     // Test an empty search via the block form, from the front page.
@@ -652,7 +652,7 @@ class SearchBlockTestCase extends DrupalWebTestCase {
     $this->assertEqual(
       $this->getUrl(),
       url('search/node/', array('absolute' => TRUE)),
-      t('Redirected to correct url.')
+      'Redirected to correct url.'
     );
   }
 }
@@ -790,20 +790,20 @@ class SearchCommentTestCase extends DrupalWebTestCase {
       'search_block_form' => "'" . $edit_comment['subject'] . "'",
     );
     $this->drupalPost('', $edit, t('Search'));
-    $this->assertText($node->title, t('Node found in search results.'));
-    $this->assertText($edit_comment['subject'], t('Comment subject found in search results.'));
+    $this->assertText($node->title, 'Node found in search results.');
+    $this->assertText($edit_comment['subject'], 'Comment subject found in search results.');
 
     // Search for the comment body.
     $edit = array(
       'search_block_form' => "'" . $comment_body . "'",
     );
     $this->drupalPost('', $edit, t('Search'));
-    $this->assertText($node->title, t('Node found in search results.'));
+    $this->assertText($node->title, 'Node found in search results.');
 
     // Verify that comment is rendered using proper format.
-    $this->assertText($comment_body, t('Comment body text found in search results.'));
-    $this->assertNoRaw(t('n/a'), t('HTML in comment body is not hidden.'));
-    $this->assertNoRaw(check_plain($edit_comment['comment_body[' . LANGUAGE_NONE . '][0][value]']), t('HTML in comment body is not escaped.'));
+    $this->assertText($comment_body, 'Comment body text found in search results.');
+    $this->assertNoRaw(t('n/a'), 'HTML in comment body is not hidden.');
+    $this->assertNoRaw(check_plain($edit_comment['comment_body[' . LANGUAGE_NONE . '][0][value]']), 'HTML in comment body is not escaped.');
 
     // Hide comments.
     $this->drupalLogin($this->admin_user);
@@ -816,7 +816,7 @@ class SearchCommentTestCase extends DrupalWebTestCase {
 
     // Search for $title.
     $this->drupalPost('', $edit, t('Search'));
-    $this->assertNoText($comment_body, t('Comment body text not found in search results.'));
+    $this->assertNoText($comment_body, 'Comment body text not found in search results.');
   }
 
   /**
@@ -875,7 +875,7 @@ class SearchCommentTestCase extends DrupalWebTestCase {
     $this->setRolePermissions(DRUPAL_AUTHENTICATED_RID, TRUE, TRUE);
     $this->setRolePermissions($this->admin_role, TRUE, FALSE);
     $this->checkCommentAccess('Admin user has access comments permission and no search permission, but comments should be indexed because admin user inherits authenticated user\'s permission to search', TRUE);
-    
+
   }
 
   /**
@@ -926,7 +926,7 @@ class SearchCommentTestCase extends DrupalWebTestCase {
     // Verify that if you view the node on its own page, 'add new comment'
     // is there.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertText(t('Add new comment'), t('Add new comment appears on node page'));
+    $this->assertText(t('Add new comment'), 'Add new comment appears on node page');
 
     // Run cron to index this page.
     $this->drupalLogout();
@@ -935,13 +935,13 @@ class SearchCommentTestCase extends DrupalWebTestCase {
     // Search for 'comment'. Should be no results.
     $this->drupalLogin($user);
     $this->drupalPost('search/node', array('keys' => 'comment'), t('Search'));
-    $this->assertText(t('Your search yielded no results'), t('No results searching for the word comment'));
+    $this->assertText(t('Your search yielded no results'), 'No results searching for the word comment');
 
     // Search for the node title. Should be found, and 'Add new comment' should
     // not be part of the search snippet.
     $this->drupalPost('search/node', array('keys' => 'short'), t('Search'));
-    $this->assertText($node->title, t('Search for keyword worked'));
-    $this->assertNoText(t('Add new comment'), t('Add new comment does not appear on search results page'));
+    $this->assertText($node->title, 'Search for keyword worked');
+    $this->assertNoText(t('Add new comment'), 'Add new comment does not appear on search results page');
   }
 
 }
@@ -1074,8 +1074,8 @@ class SearchCommentCountToggleTestCase extends DrupalWebTestCase {
 
     // Test comment count display for nodes with comment status set to Open
     $this->drupalPost('', $edit, t('Search'));
-    $this->assertText(t('0 comments'), t('Empty comment count displays for nodes with comment status set to Open'));
-    $this->assertText(t('1 comment'), t('Non-empty comment count displays for nodes with comment status set to Open'));
+    $this->assertText(t('0 comments'), 'Empty comment count displays for nodes with comment status set to Open');
+    $this->assertText(t('1 comment'), 'Non-empty comment count displays for nodes with comment status set to Open');
 
     // Test comment count display for nodes with comment status set to Closed
     $this->searchable_nodes['0 comments']->comment = COMMENT_NODE_CLOSED;
@@ -1084,8 +1084,8 @@ class SearchCommentCountToggleTestCase extends DrupalWebTestCase {
     node_save($this->searchable_nodes['1 comment']);
 
     $this->drupalPost('', $edit, t('Search'));
-    $this->assertNoText(t('0 comments'), t('Empty comment count does not display for nodes with comment status set to Closed'));
-    $this->assertText(t('1 comment'), t('Non-empty comment count displays for nodes with comment status set to Closed'));
+    $this->assertNoText(t('0 comments'), 'Empty comment count does not display for nodes with comment status set to Closed');
+    $this->assertText(t('1 comment'), 'Non-empty comment count displays for nodes with comment status set to Closed');
 
     // Test comment count display for nodes with comment status set to Hidden
     $this->searchable_nodes['0 comments']->comment = COMMENT_NODE_HIDDEN;
@@ -1094,8 +1094,8 @@ class SearchCommentCountToggleTestCase extends DrupalWebTestCase {
     node_save($this->searchable_nodes['1 comment']);
 
     $this->drupalPost('', $edit, t('Search'));
-    $this->assertNoText(t('0 comments'), t('Empty comment count does not display for nodes with comment status set to Hidden'));
-    $this->assertNoText(t('1 comment'), t('Non-empty comment count does not display for nodes with comment status set to Hidden'));
+    $this->assertNoText(t('0 comments'), 'Empty comment count does not display for nodes with comment status set to Hidden');
+    $this->assertNoText(t('1 comment'), 'Non-empty comment count does not display for nodes with comment status set to Hidden');
   }
 }
 
@@ -1160,7 +1160,7 @@ class SearchSimplifyTestCase extends DrupalWebTestCase {
     for ($i = 0; $i < 32; $i++) {
       $string .= chr($i);
     }
-    $this->assertIdentical(' ', search_simplify($string), t('Search simplify works for ASCII control characters.'));
+    $this->assertIdentical(' ', search_simplify($string), 'Search simplify works for ASCII control characters.');
   }
 
   /**
@@ -1316,7 +1316,7 @@ class SearchNumbersTestCase extends DrupalWebTestCase {
       $this->drupalPost('search/node',
         array('keys' => $number),
         t('Search'));
-      $this->assertText($node->title, $type . ': node title shown (search found the node) in search for number ' . $number);
+      $this->assertText($node->title, format_string('%type: node title shown (search found the node) in search for number %number.', array('%type' => $type, '%number' => $number)));
     }
   }
 }
@@ -1384,7 +1384,7 @@ class SearchNumberMatchingTestCase extends DrupalWebTestCase {
       $this->drupalPost('search/node',
         array('keys' => 'foo'),
         t('Search'));
-      $this->assertNoText($node->title, $i . ': node title not shown in dummy search');
+      $this->assertNoText($node->title, format_string('%number: node title not shown in dummy search', array('%number' => $i)));
 
       // Now verify that we can find node i by searching for any of the
       // numbers.
@@ -1397,7 +1397,7 @@ class SearchNumberMatchingTestCase extends DrupalWebTestCase {
         $this->drupalPost('search/node',
           array('keys' => $number),
           t('Search'));
-        $this->assertText($node->title, $i . ': node title shown (search found the node) in search for number ' . $number);
+        $this->assertText($node->title, format_string('%i: node title shown (search found the node) in search for number %number', array('%i' => $i, '%number' => $number)));
       }
     }
 
@@ -1558,7 +1558,7 @@ class SearchConfigSettingsForm extends DrupalWebTestCase {
       $this->drupalGet($path);
       foreach ($modules as $module) {
         $title = $module_info[$module]['title'];
-        $this->assertText($title, $title . ' search tab is shown');
+        $this->assertText($title, format_string('%title search tab is shown', array('%title' => $title)));
       }
     }
   }
@@ -1955,42 +1955,42 @@ class SearchLanguageTestCase extends DrupalWebTestCase {
   function testLanguages() {
     // Check that there are initially no languages displayed.
     $this->drupalGet('search/node');
-    $this->assertNoText(t('Languages'), t('No languages to choose from.'));
+    $this->assertNoText(t('Languages'), 'No languages to choose from.');
 
     // Add predefined language.
     $edit = array('langcode' => 'fr');
     $this->drupalPost('admin/config/regional/language/add', $edit, t('Add language'));
-    $this->assertText('fr', t('Language added successfully.'));
+    $this->assertText('fr', 'Language added successfully.');
 
     // Now we should have languages displayed.
     $this->drupalGet('search/node');
-    $this->assertText(t('Languages'), t('Languages displayed to choose from.'));
-    $this->assertText(t('English'), t('English is a possible choice.'));
-    $this->assertText(t('French'), t('French is a possible choice.'));
+    $this->assertText(t('Languages'), 'Languages displayed to choose from.');
+    $this->assertText(t('English'), 'English is a possible choice.');
+    $this->assertText(t('French'), 'French is a possible choice.');
 
     // Ensure selecting no language does not make the query different.
     $this->drupalPost('search/node', array(), t('Advanced search'));
-    $this->assertEqual($this->getUrl(), url('search/node/', array('absolute' => TRUE)), t('Correct page redirection, no language filtering.'));
+    $this->assertEqual($this->getUrl(), url('search/node/', array('absolute' => TRUE)), 'Correct page redirection, no language filtering.');
 
     // Pick French and ensure it is selected.
     $edit = array('language[fr]' => TRUE);
     $this->drupalPost('search/node', $edit, t('Advanced search'));
-    $this->assertFieldByXPath('//input[@name="keys"]', 'language:fr', t('Language filter added to query.'));
+    $this->assertFieldByXPath('//input[@name="keys"]', 'language:fr', 'Language filter added to query.');
 
     // Change the default language and disable English.
     $path = 'admin/config/regional/language';
     $this->drupalGet($path);
-    $this->assertFieldChecked('edit-site-default-en', t('English is the default language.'));
+    $this->assertFieldChecked('edit-site-default-en', 'English is the default language.');
     $edit = array('site_default' => 'fr');
     $this->drupalPost(NULL, $edit, t('Save configuration'));
-    $this->assertNoFieldChecked('edit-site-default-en', t('Default language updated.'));
+    $this->assertNoFieldChecked('edit-site-default-en', 'Default language updated.');
     $edit = array('enabled[en]' => FALSE);
     $this->drupalPost('admin/config/regional/language', $edit, t('Save configuration'));
-    $this->assertNoFieldChecked('edit-enabled-en', t('Language disabled.'));
+    $this->assertNoFieldChecked('edit-enabled-en', 'Language disabled.');
 
     // Check that there are again no languages displayed.
     $this->drupalGet('search/node');
-    $this->assertNoText(t('Languages'), t('No languages to choose from.'));
+    $this->assertNoText(t('Languages'), 'No languages to choose from.');
   }
 }
 
diff --git a/modules/shortcut/shortcut.test b/modules/shortcut/shortcut.test
index 801d585..2bd9605 100644
--- a/modules/shortcut/shortcut.test
+++ b/modules/shortcut/shortcut.test
@@ -211,16 +211,16 @@ class ShortcutLinksTestCase extends ShortcutTestCase {
     variable_set('theme_default', 'seven');
 
     $this->drupalGet('page-that-does-not-exist');
-    $this->assertNoRaw('add-shortcut', t('Add to shortcuts link was not shown on a page not found.'));
+    $this->assertNoRaw('add-shortcut', 'Add to shortcuts link was not shown on a page not found.');
 
     // The user does not have access to this path.
     $this->drupalGet('admin/modules');
-    $this->assertNoRaw('add-shortcut', t('Add to shortcuts link was not shown on a page the user does not have access to.'));
+    $this->assertNoRaw('add-shortcut', 'Add to shortcuts link was not shown on a page the user does not have access to.');
 
     // Verify that the testing mechanism works by verifying the shortcut
     // link appears on admin/content/node.
     $this->drupalGet('admin/content/node');
-    $this->assertRaw('add-shortcut', t('Add to shortcuts link was shown on a page the user does have access to.'));
+    $this->assertRaw('add-shortcut', 'Add to shortcuts link was shown on a page the user does have access to.');
   }
 }
 
@@ -334,7 +334,7 @@ class ShortcutSetsTestCase extends ShortcutTestCase {
     $this->drupalPost('admin/config/user-interface/shortcut/' . $set->set_name . '/edit', array('title' => $existing_title), t('Save'));
     $this->assertRaw(t('The shortcut set %name already exists. Choose another name.', array('%name' => $existing_title)));
     $set = shortcut_set_load($set->set_name);
-    $this->assertNotEqual($set->title, $existing_title, t('The shortcut set %title cannot be renamed to %new-title because a shortcut set with that title already exists.', array('%title' => $set->title, '%new-title' => $existing_title)));
+    $this->assertNotEqual($set->title, $existing_title, format_string('The shortcut set %title cannot be renamed to %new-title because a shortcut set with that title already exists.', array('%title' => $set->title, '%new-title' => $existing_title)));
   }
 
   /**
diff --git a/modules/simpletest/drupal_web_test_case.php b/modules/simpletest/drupal_web_test_case.php
index e3cab62..0853c7d 100644
--- a/modules/simpletest/drupal_web_test_case.php
+++ b/modules/simpletest/drupal_web_test_case.php
@@ -447,7 +447,8 @@ abstract class DrupalTestCase {
    */
   protected function verbose($message) {
     if ($id = simpletest_verbose($message)) {
-      $url = file_create_url($this->originalFileDirectory . '/simpletest/verbose/' . get_class($this) . '-' . $id . '.html');
+      $class_safe = str_replace('\\', '_', get_class($this));
+      $url = file_create_url($this->originalFileDirectory . '/simpletest/verbose/' . $class_safe . '-' . $id . '.html');
       $this->error(l(t('Verbose message'), $url, array('attributes' => array('target' => '_blank'))), 'User notice');
     }
   }
@@ -466,7 +467,8 @@ abstract class DrupalTestCase {
    */
   public function run(array $methods = array()) {
     // Initialize verbose debugging.
-    simpletest_verbose(NULL, variable_get('file_public_path', conf_path() . '/files'), get_class($this));
+    $class = get_class($this);
+    simpletest_verbose(NULL, variable_get('file_public_path', conf_path() . '/files'), str_replace('\\', '_', $class));
 
     // HTTP auth settings (<username>:<password>) for the simpletest browser
     // when sending requests to the test site.
@@ -478,7 +480,6 @@ abstract class DrupalTestCase {
     }
 
     set_error_handler(array($this, 'errorHandler'));
-    $class = get_class($this);
     // Iterate through all the methods in this class, unless a specific list of
     // methods to run was passed.
     $class_methods = get_class_methods($class);
@@ -1217,28 +1218,28 @@ class DrupalWebTestCase extends DrupalTestCase {
    *   $account->pass_raw = $pass_raw;
    * @endcode
    *
-   * @param $user
+   * @param $account
    *   User object representing the user to log in.
    *
    * @see drupalCreateUser()
    */
-  protected function drupalLogin(stdClass $user) {
+  protected function drupalLogin(stdClass $account) {
     if ($this->loggedInUser) {
       $this->drupalLogout();
     }
 
     $edit = array(
-      'name' => $user->name,
-      'pass' => $user->pass_raw
+      'name' => $account->name,
+      'pass' => $account->pass_raw
     );
     $this->drupalPost('user', $edit, t('Log in'));
 
     // If a "log out" link appears on the page, it is almost certainly because
     // the login was successful.
-    $pass = $this->assertLink(t('Log out'), 0, t('User %name successfully logged in.', array('%name' => $user->name)), t('User login'));
+    $pass = $this->assertLink(t('Log out'), 0, t('User %name successfully logged in.', array('%name' => $account->name)), t('User login'));
 
     if ($pass) {
-      $this->loggedInUser = $user;
+      $this->loggedInUser = $account;
     }
   }
 
@@ -2646,10 +2647,9 @@ class DrupalWebTestCase extends DrupalTestCase {
   /**
    * Follows a link by name.
    *
-   * Will click the first link found with this link text by default, or a
-   * later one if an index is given. Match is case insensitive with
-   * normalized space. The label is translated label. There is an assert
-   * for successful click.
+   * Will click the first link found with this link text by default, or a later
+   * one if an index is given. Match is case sensitive with normalized space.
+   * The label is translated label. There is an assert for successful click.
    *
    * @param $label
    *   Text between the anchor tags.
@@ -3149,6 +3149,42 @@ class DrupalWebTestCase extends DrupalTestCase {
   }
 
   /**
+   * Asserts themed output.
+   *
+   * @param $callback
+   *   The name of the theme function to invoke; e.g. 'links' for theme_links().
+   * @param $variables
+   *   An array of variables to pass to the theme function.
+   * @param $expected
+   *   The expected themed output string.
+   * @param $message
+   *   (optional) A message to display with the assertion. Do not translate
+   *   messages: use format_string() to embed variables in the message text, not
+   *   t(). If left blank, a default message will be displayed.
+   * @param $group
+   *   (optional) The group this message is in, which is displayed in a column
+   *   in test output. Use 'Debug' to indicate this is debugging output. Do not
+   *   translate this string. Defaults to 'Other'; most tests do not override
+   *   this default.
+   *
+   * @return
+   *   TRUE on pass, FALSE on fail.
+   */
+  protected function assertThemeOutput($callback, array $variables = array(), $expected, $message = '', $group = 'Other') {
+    $output = theme($callback, $variables);
+    $this->verbose('Variables:' . '<pre>' .  check_plain(var_export($variables, TRUE)) . '</pre>'
+      . '<hr />' . 'Result:' . '<pre>' .  check_plain(var_export($output, TRUE)) . '</pre>'
+      . '<hr />' . 'Expected:' . '<pre>' .  check_plain(var_export($expected, TRUE)) . '</pre>'
+      . '<hr />' . $output
+    );
+    if (!$message) {
+      $message = '%callback rendered correctly.';
+    }
+    $message = format_string($message, array('%callback' => 'theme_' . $callback . '()'));
+    return $this->assertIdentical($output, $expected, $message, $group);
+  }
+
+  /**
    * Asserts that a field exists in the current page by the given XPath.
    *
    * @param $xpath
diff --git a/modules/simpletest/lib/Drupal/simpletest/Tests/PSR0WebTest.php b/modules/simpletest/lib/Drupal/simpletest/Tests/PSR0WebTest.php
new file mode 100644
index 0000000..0292956
--- /dev/null
+++ b/modules/simpletest/lib/Drupal/simpletest/Tests/PSR0WebTest.php
@@ -0,0 +1,18 @@
+<?php
+
+namespace Drupal\simpletest\Tests;
+
+class PSR0WebTest extends \DrupalWebTestCase {
+
+  public static function getInfo() {
+    return array(
+      'name' => 'PSR0 web test',
+      'description' => 'We want to assert that this PSR-0 test case is being discovered.',
+      'group' => 'SimpleTest',
+    );
+  }
+
+  function testArithmetics() {
+    $this->assert(1 + 1 == 2, '1 + 1 == 2');
+  }
+}
diff --git a/modules/simpletest/simpletest.install b/modules/simpletest/simpletest.install
index ea847f4..6c6f569 100644
--- a/modules/simpletest/simpletest.install
+++ b/modules/simpletest/simpletest.install
@@ -63,7 +63,7 @@ function simpletest_requirements($phase) {
   // Check the current memory limit. If it is set too low, SimpleTest will fail
   // to load all tests and throw a fatal error.
   $memory_limit = ini_get('memory_limit');
-  if ($memory_limit && $memory_limit != -1 && parse_size($memory_limit) < parse_size(SIMPLETEST_MINIMUM_PHP_MEMORY_LIMIT)) {
+  if (!drupal_check_memory_limit(SIMPLETEST_MINIMUM_PHP_MEMORY_LIMIT, $memory_limit)) {
     $requirements['php_memory_limit']['severity'] = REQUIREMENT_ERROR;
     $requirements['php_memory_limit']['description'] = $t('The testing framework requires the PHP memory limit to be at least %memory_minimum_limit. The current value is %memory_limit. <a href="@url">Follow these steps to continue</a>.', array('%memory_limit' => $memory_limit, '%memory_minimum_limit' => SIMPLETEST_MINIMUM_PHP_MEMORY_LIMIT, '@url' => 'http://drupal.org/node/207036'));
   }
diff --git a/modules/simpletest/simpletest.module b/modules/simpletest/simpletest.module
index f825755..3103af0 100644
--- a/modules/simpletest/simpletest.module
+++ b/modules/simpletest/simpletest.module
@@ -157,6 +157,7 @@ function simpletest_run_tests($test_list, $reporter = 'drupal') {
  * Batch operation callback.
  */
 function _simpletest_batch_operation($test_list_init, $test_id, &$context) {
+  simpletest_classloader_register();
   // Get working values.
   if (!isset($context['sandbox']['max'])) {
     // First iteration: initialize working values.
@@ -289,6 +290,9 @@ function simpletest_log_read($test_id, $prefix, $test_class, $during_test = FALS
  * a static variable. In order to list tests provided by disabled modules
  * hook_registry_files_alter() is used to forcefully add them to the registry.
  *
+ * PSR-0 classes are found by searching the designated directory for each module
+ * for files matching the PSR-0 standard.
+ *
  * @return
  *   An array of tests keyed with the groups specified in each of the tests
  *   getInfo() method and then keyed by the test class. An example of the array
@@ -309,6 +313,9 @@ function simpletest_test_get_all() {
   $groups = &drupal_static(__FUNCTION__);
 
   if (!$groups) {
+    // Register a simple class loader for PSR-0 test classes.
+    simpletest_classloader_register();
+
     // Load test information from cache if available, otherwise retrieve the
     // information from each tests getInfo() method.
     if ($cache = cache_get('simpletest', 'cache')) {
@@ -318,6 +325,34 @@ function simpletest_test_get_all() {
       // Select all clases in files ending with .test.
       $classes = db_query("SELECT name FROM {registry} WHERE type = :type AND filename LIKE :name", array(':type' => 'class', ':name' => '%.test'))->fetchCol();
 
+      // Also discover PSR-0 test classes, if the PHP version allows it.
+      if (version_compare(PHP_VERSION, '5.3') > 0) {
+
+        // Select all PSR-0 classes in the Tests namespace of all modules.
+        $system_list = db_query("SELECT name, filename FROM {system}")->fetchAllKeyed();
+
+        foreach ($system_list as $name => $filename) {
+          // Build directory in which the test files would reside.
+          $tests_dir = DRUPAL_ROOT . '/' . dirname($filename) . '/lib/Drupal/' . $name . '/Tests';
+          // Scan it for test files if it exists.
+          if (is_dir($tests_dir)) {
+            $files = file_scan_directory($tests_dir, '/.*\.php/');
+            if (!empty($files)) {
+              $basedir = DRUPAL_ROOT . '/' . dirname($filename) . '/lib/';
+              foreach ($files as $file) {
+                // Convert the file name into the namespaced class name.
+                $replacements = array(
+                  '/' => '\\',
+                  $basedir => '',
+                  '.php' => '',
+                );
+                $classes[] = strtr($file->uri, $replacements);
+              }
+            }
+          }
+        }
+      }
+
       // Check that each class has a getInfo() method and store the information
       // in an array keyed with the group specified in the test information.
       $groups = array();
@@ -353,6 +388,78 @@ function simpletest_test_get_all() {
   return $groups;
 }
 
+/*
+ * Register a simple class loader that can find D8-style PSR-0 test classes.
+ *
+ * Other PSR-0 class loading can happen in contrib, but those contrib class
+ * loader modules will not be enabled when testbot runs. So we need to do this
+ * one in core.
+ */
+function simpletest_classloader_register() {
+
+  // Prevent duplicate classloader registration.
+  static $first_run = TRUE;
+  if (!$first_run) {
+    return;
+  }
+  $first_run = FALSE;
+
+  // Only register PSR-0 class loading if we are on PHP 5.3 or higher.
+  if (version_compare(PHP_VERSION, '5.3') > 0) {
+    spl_autoload_register('_simpletest_autoload_psr0');
+  }
+}
+
+/**
+ * Autoload callback to find PSR-0 test classes.
+ *
+ * This will only work on classes where the namespace is of the pattern
+ *   "Drupal\$extension\Tests\.."
+ */
+function _simpletest_autoload_psr0($class) {
+
+  // Static cache for extension paths.
+  // This cache is lazily filled as soon as it is needed.
+  static $extensions;
+
+  // Check that the first namespace fragment is "Drupal\"
+  if (substr($class, 0, 7) === 'Drupal\\') {
+    // Find the position of the second namespace separator.
+    $pos = strpos($class, '\\', 7);
+    // Check that the third namespace fragment is "\Tests\".
+    if (substr($class, $pos, 7) === '\\Tests\\') {
+
+      // Extract the second namespace fragment, which we expect to be the
+      // extension name.
+      $extension = substr($class, 7, $pos - 7);
+
+      // Lazy-load the extension paths, both enabled and disabled.
+      if (!isset($extensions)) {
+        $extensions = db_query("SELECT name, filename FROM {system}")->fetchAllKeyed();
+      }
+
+      // Check if the second namespace fragment is a known extension name.
+      if (isset($extensions[$extension])) {
+
+        // Split the class into namespace and classname.
+        $nspos = strrpos($class, '\\');
+        $namespace = substr($class, 0, $nspos);
+        $classname = substr($class, $nspos + 1);
+
+        // Build the filepath where we expect the class to be defined.
+        $path = dirname($extensions[$extension]) . '/lib/' .
+          str_replace('\\', '/', $namespace) . '/' .
+          str_replace('_', '/', $classname) . '.php';
+
+        // Include the file, if it does exist.
+        if (file_exists($path)) {
+          include $path;
+        }
+      }
+    }
+  }
+}
+
 /**
  * Implements hook_registry_files_alter().
  *
diff --git a/modules/simpletest/simpletest.pages.inc b/modules/simpletest/simpletest.pages.inc
index d1a7e4a..3127459 100644
--- a/modules/simpletest/simpletest.pages.inc
+++ b/modules/simpletest/simpletest.pages.inc
@@ -181,6 +181,7 @@ function theme_simpletest_test_table($variables) {
  * Run selected tests.
  */
 function simpletest_test_form_submit($form, &$form_state) {
+  simpletest_classloader_register();
   // Get list of tests.
   $tests_list = array();
   foreach ($form_state['values'] as $class_name => $value) {
@@ -233,6 +234,8 @@ function simpletest_result_form($form, &$form_state, $test_id) {
     '#debug' => 0,
   );
 
+  simpletest_classloader_register();
+
   // Cycle through each test group.
   $header = array(t('Message'), t('Group'), t('Filename'), t('Line'), t('Function'), array('colspan' => 2, 'data' => t('Status')));
   $form['result']['results'] = array();
diff --git a/modules/simpletest/simpletest.test b/modules/simpletest/simpletest.test
index c67b004..dde162e 100644
--- a/modules/simpletest/simpletest.test
+++ b/modules/simpletest/simpletest.test
@@ -45,9 +45,9 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
     global $conf;
     if (!$this->inCURL()) {
       $this->drupalGet('node');
-      $this->assertTrue($this->drupalGetHeader('Date'), t('An HTTP header was received.'));
-      $this->assertTitle(t('Welcome to @site-name | @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), t('Site title matches.'));
-      $this->assertNoTitle('Foo', t('Site title does not match.'));
+      $this->assertTrue($this->drupalGetHeader('Date'), 'An HTTP header was received.');
+      $this->assertTitle(t('Welcome to @site-name | @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), 'Site title matches.');
+      $this->assertNoTitle('Foo', 'Site title does not match.');
       // Make sure that we are locked out of the installer when prefixing
       // using the user-agent header. This is an important security check.
       global $base_url;
@@ -58,12 +58,12 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
       $user = $this->drupalCreateUser();
       $this->drupalLogin($user);
       $headers = $this->drupalGetHeaders(TRUE);
-      $this->assertEqual(count($headers), 2, t('There was one intermediate request.'));
-      $this->assertTrue(strpos($headers[0][':status'], '302') !== FALSE, t('Intermediate response code was 302.'));
-      $this->assertFalse(empty($headers[0]['location']), t('Intermediate request contained a Location header.'));
-      $this->assertEqual($this->getUrl(), $headers[0]['location'], t('HTTP redirect was followed'));
-      $this->assertFalse($this->drupalGetHeader('Location'), t('Headers from intermediate request were reset.'));
-      $this->assertResponse(200, t('Response code from intermediate request was reset.'));
+      $this->assertEqual(count($headers), 2, 'There was one intermediate request.');
+      $this->assertTrue(strpos($headers[0][':status'], '302') !== FALSE, 'Intermediate response code was 302.');
+      $this->assertFalse(empty($headers[0]['location']), 'Intermediate request contained a Location header.');
+      $this->assertEqual($this->getUrl(), $headers[0]['location'], 'HTTP redirect was followed');
+      $this->assertFalse($this->drupalGetHeader('Location'), 'Headers from intermediate request were reset.');
+      $this->assertResponse(200, 'Response code from intermediate request was reset.');
 
       // Test the maximum redirection option.
       $this->drupalLogout();
@@ -74,7 +74,7 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
       variable_set('simpletest_maximum_redirects', 1);
       $this->drupalPost('user?destination=user/logout', $edit, t('Log in'));
       $headers = $this->drupalGetHeaders(TRUE);
-      $this->assertEqual(count($headers), 2, t('Simpletest stopped following redirects after the first one.'));
+      $this->assertEqual(count($headers), 2, 'Simpletest stopped following redirects after the first one.');
     }
   }
 
@@ -88,30 +88,30 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
       $HTTP_path = $simpletest_path .'/tests/http.php?q=node';
       $https_path = $simpletest_path .'/tests/https.php?q=node';
       // Generate a valid simpletest User-Agent to pass validation.
-      $this->assertTrue(preg_match('/simpletest\d+/', $this->databasePrefix, $matches), t('Database prefix contains simpletest prefix.'));
+      $this->assertTrue(preg_match('/simpletest\d+/', $this->databasePrefix, $matches), 'Database prefix contains simpletest prefix.');
       $test_ua = drupal_generate_test_ua($matches[0]);
       $this->additionalCurlOptions = array(CURLOPT_USERAGENT => $test_ua);
 
       // Test pages only available for testing.
       $this->drupalGet($HTTP_path);
-      $this->assertResponse(200, t('Requesting http.php with a legitimate simpletest User-Agent returns OK.'));
+      $this->assertResponse(200, 'Requesting http.php with a legitimate simpletest User-Agent returns OK.');
       $this->drupalGet($https_path);
-      $this->assertResponse(200, t('Requesting https.php with a legitimate simpletest User-Agent returns OK.'));
+      $this->assertResponse(200, 'Requesting https.php with a legitimate simpletest User-Agent returns OK.');
 
       // Now slightly modify the HMAC on the header, which should not validate.
       $this->additionalCurlOptions = array(CURLOPT_USERAGENT => $test_ua . 'X');
       $this->drupalGet($HTTP_path);
-      $this->assertResponse(403, t('Requesting http.php with a bad simpletest User-Agent fails.'));
+      $this->assertResponse(403, 'Requesting http.php with a bad simpletest User-Agent fails.');
       $this->drupalGet($https_path);
-      $this->assertResponse(403, t('Requesting https.php with a bad simpletest User-Agent fails.'));
+      $this->assertResponse(403, 'Requesting https.php with a bad simpletest User-Agent fails.');
 
       // Use a real User-Agent and verify that the special files http.php and
       // https.php can't be accessed.
       $this->additionalCurlOptions = array(CURLOPT_USERAGENT => 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12');
       $this->drupalGet($HTTP_path);
-      $this->assertResponse(403, t('Requesting http.php with a normal User-Agent fails.'));
+      $this->assertResponse(403, 'Requesting http.php with a normal User-Agent fails.');
       $this->drupalGet($https_path);
-      $this->assertResponse(403, t('Requesting https.php with a normal User-Agent fails.'));
+      $this->assertResponse(403, 'Requesting https.php with a normal User-Agent fails.');
     }
   }
 
@@ -147,7 +147,7 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
 
       // Regression test for #290316.
       // Check that test_id is incrementing.
-      $this->assertTrue($this->test_ids[0] != $this->test_ids[1], t('Test ID is incrementing.'));
+      $this->assertTrue($this->test_ids[0] != $this->test_ids[1], 'Test ID is incrementing.');
     }
   }
 
@@ -210,7 +210,7 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
     $this->assertEqual('6 passes, 5 fails, 2 exceptions, and 1 debug message', $this->childTestResults['summary'], 'Stub test summary is correct');
 
     $this->test_ids[] = $test_id = $this->getTestIdFromResults();
-    $this->assertTrue($test_id, t('Found test ID in results.'));
+    $this->assertTrue($test_id, 'Found test ID in results.');
   }
 
   /**
@@ -249,7 +249,7 @@ class SimpleTestFunctionalTest extends DrupalWebTestCase {
         break;
       }
     }
-    return $this->assertTrue($found, t('Found assertion {"@message", "@type", "@status", "@file", "@function"}.', array('@message' => $message, '@type' => $type, '@status' => $status, "@file" => $file, "@function" => $function)));
+    return $this->assertTrue($found, format_string('Found assertion {"@message", "@type", "@status", "@file", "@function"}.', array('@message' => $message, '@type' => $type, '@status' => $status, "@file" => $file, "@function" => $function)));
   }
 
   /**
@@ -345,18 +345,18 @@ class SimpleTestBrowserTestCase extends DrupalWebTestCase {
 
     $this->drupalGet($url);
     $absolute = url($url, array('absolute' => TRUE));
-    $this->assertEqual($absolute, $this->url, t('Passed and requested URL are equal.'));
-    $this->assertEqual($this->url, $this->getAbsoluteUrl($this->url), t('Requested and returned absolute URL are equal.'));
+    $this->assertEqual($absolute, $this->url, 'Passed and requested URL are equal.');
+    $this->assertEqual($this->url, $this->getAbsoluteUrl($this->url), 'Requested and returned absolute URL are equal.');
 
     $this->drupalPost(NULL, array(), t('Log in'));
-    $this->assertEqual($absolute, $this->url, t('Passed and requested URL are equal.'));
-    $this->assertEqual($this->url, $this->getAbsoluteUrl($this->url), t('Requested and returned absolute URL are equal.'));
+    $this->assertEqual($absolute, $this->url, 'Passed and requested URL are equal.');
+    $this->assertEqual($this->url, $this->getAbsoluteUrl($this->url), 'Requested and returned absolute URL are equal.');
 
     $this->clickLink('Create new account');
     $url = 'user/register';
     $absolute = url($url, array('absolute' => TRUE));
-    $this->assertEqual($absolute, $this->url, t('Passed and requested URL are equal.'));
-    $this->assertEqual($this->url, $this->getAbsoluteUrl($this->url), t('Requested and returned absolute URL are equal.'));
+    $this->assertEqual($absolute, $this->url, 'Passed and requested URL are equal.');
+    $this->assertEqual($this->url, $this->getAbsoluteUrl($this->url), 'Requested and returned absolute URL are equal.');
   }
 
   /**
@@ -411,19 +411,19 @@ class SimpleTestMailCaptureTestCase extends DrupalWebTestCase {
 
     // Before we send the e-mail, drupalGetMails should return an empty array.
     $captured_emails = $this->drupalGetMails();
-    $this->assertEqual(count($captured_emails), 0, t('The captured e-mails queue is empty.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 0, 'The captured e-mails queue is empty.', 'E-mail');
 
     // Send the e-mail.
     $response = drupal_mail_system('simpletest', 'drupal_mail_test')->mail($message);
 
     // Ensure that there is one e-mail in the captured e-mails array.
     $captured_emails = $this->drupalGetMails();
-    $this->assertEqual(count($captured_emails), 1, t('One e-mail was captured.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 1, 'One e-mail was captured.', 'E-mail');
 
     // Assert that the e-mail was sent by iterating over the message properties
     // and ensuring that they are captured intact.
     foreach ($message as $field => $value) {
-      $this->assertMail($field, $value, t('The e-mail was sent and the value for property @field is intact.', array('@field' => $field)), t('E-mail'));
+      $this->assertMail($field, $value, format_string('The e-mail was sent and the value for property @field is intact.', array('@field' => $field)), 'E-mail');
     }
 
     // Send additional e-mails so more than one e-mail is captured.
@@ -440,21 +440,21 @@ class SimpleTestMailCaptureTestCase extends DrupalWebTestCase {
 
     // There should now be 6 e-mails captured.
     $captured_emails = $this->drupalGetMails();
-    $this->assertEqual(count($captured_emails), 6, t('All e-mails were captured.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 6, 'All e-mails were captured.', 'E-mail');
 
     // Test different ways of getting filtered e-mails via drupalGetMails().
     $captured_emails = $this->drupalGetMails(array('id' => 'drupal_mail_test'));
-    $this->assertEqual(count($captured_emails), 1, t('Only one e-mail is returned when filtering by id.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 1, 'Only one e-mail is returned when filtering by id.', 'E-mail');
     $captured_emails = $this->drupalGetMails(array('id' => 'drupal_mail_test', 'subject' => $subject));
-    $this->assertEqual(count($captured_emails), 1, t('Only one e-mail is returned when filtering by id and subject.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 1, 'Only one e-mail is returned when filtering by id and subject.', 'E-mail');
     $captured_emails = $this->drupalGetMails(array('id' => 'drupal_mail_test', 'subject' => $subject, 'from' => 'this_was_not_used@example.com'));
-    $this->assertEqual(count($captured_emails), 0, t('No e-mails are returned when querying with an unused from address.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 0, 'No e-mails are returned when querying with an unused from address.', 'E-mail');
 
     // Send the last e-mail again, so we can confirm that the drupalGetMails-filter
     // correctly returns all e-mails with a given property/value.
     drupal_mail_system('drupal_mail_test', $index)->mail($message);
     $captured_emails = $this->drupalGetMails(array('id' => 'drupal_mail_test_4'));
-    $this->assertEqual(count($captured_emails), 2, t('All e-mails with the same id are returned when filtering by id.'), t('E-mail'));
+    $this->assertEqual(count($captured_emails), 2, 'All e-mails with the same id are returned when filtering by id.', 'E-mail');
   }
 }
 
@@ -476,7 +476,7 @@ class SimpleTestFolderTestCase extends DrupalWebTestCase {
 
   function testFolderSetup() {
     $directory = file_default_scheme() . '://styles';
-    $this->assertTrue(file_prepare_directory($directory, FALSE), "Directory created.");
+    $this->assertTrue(file_prepare_directory($directory, FALSE), 'Directory created.');
   }
 }
 
@@ -655,3 +655,92 @@ class SimpleTestOtherInstallationProfileModuleTestsTestCase extends DrupalWebTes
     $this->assertNoText('Installation profile module tests helper');
   }
 }
+
+/**
+ * Verifies that tests in other installation profiles are not found.
+ *
+ * @see SimpleTestInstallationProfileModuleTestsTestCase
+ */
+class SimpleTestDiscoveryTestCase extends DrupalWebTestCase {
+  /**
+   * Use the Testing profile.
+   *
+   * The Testing profile contains drupal_system_listing_compatible_test.test,
+   * which attempts to:
+   * - run tests using the Minimal profile (which does not contain the
+   *   drupal_system_listing_compatible_test.module)
+   * - but still install the drupal_system_listing_compatible_test.module
+   *   contained in the Testing profile.
+   *
+   * @see DrupalSystemListingCompatibleTestCase
+   */
+  protected $profile = 'testing';
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Discovery of test classes',
+      'description' => 'Verifies that tests classes are discovered and can be autoloaded (class_exists).',
+      'group' => 'SimpleTest',
+    );
+  }
+
+  function setUp() {
+    parent::setUp(array('simpletest'));
+
+    $this->admin_user = $this->drupalCreateUser(array('administer unit tests'));
+    $this->drupalLogin($this->admin_user);
+  }
+
+  /**
+   * Test discovery of PSR-0 test classes.
+   */
+  function testDiscoveryFunctions() {
+    if (version_compare(PHP_VERSION, '5.3') < 0) {
+      // Don't expect PSR-0 tests to be discovered on older PHP versions.
+      return;
+    }
+    // TODO: What if we have cached values? Do we need to force a cache refresh?
+    $classes_all = simpletest_test_get_all();
+    foreach (array(
+      'Drupal\\simpletest\\Tests\\PSR0WebTest',
+      'Drupal\\psr_0_test\\Tests\\ExampleTest',
+    ) as $class) {
+      $this->assert(!empty($classes_all['SimpleTest'][$class]), t('Class @class must be discovered by simpletest_test_get_all().', array('@class' => $class)));
+    }
+  }
+
+  /**
+   * Tests existence of test cases.
+   */
+  function testDiscovery() {
+    $this->drupalGet('admin/config/development/testing');
+    // Tests within enabled modules.
+    // (without these, this test wouldn't happen in the first place, so this is
+    // a bit pointless. We still run it for proof-of-concept.)
+    // This one is defined in system module.
+    $this->assertText('Drupal error handlers');
+    // This one is defined in simpletest module.
+    $this->assertText('Discovery of test classes');
+    // Tests within disabled modules.
+    if (version_compare(PHP_VERSION, '5.3') < 0) {
+      // Don't expect PSR-0 tests to be discovered on older PHP versions.
+      return;
+    }
+    // This one is provided by simpletest itself via PSR-0.
+    $this->assertText('PSR0 web test');
+    $this->assertText('PSR0 example test: PSR-0 in disabled modules.');
+    $this->assertText('PSR0 example test: PSR-0 in nested subfolders.');
+
+    // Test each test individually.
+    foreach (array(
+      'Drupal\\psr_0_test\\Tests\\ExampleTest',
+      'Drupal\\psr_0_test\\Tests\\Nested\\NestedExampleTest',
+    ) as $class) {
+      $this->drupalGet('admin/config/development/testing');
+      $edit = array($class => TRUE);
+      $this->drupalPost(NULL, $edit, t('Run tests'));
+      $this->assertText('The test run finished', t('Test @class must finish.', array('@class' => $class)));
+      $this->assertText('1 pass, 0 fails, and 0 exceptions', t('Test @class must pass.', array('@class' => $class)));
+    }
+  }
+}
diff --git a/modules/simpletest/tests/ajax.test b/modules/simpletest/tests/ajax.test
index 014a350..664d520 100644
--- a/modules/simpletest/tests/ajax.test
+++ b/modules/simpletest/tests/ajax.test
@@ -524,7 +524,7 @@ class AJAXElementValidation extends AJAXTestCase {
     // Post with 'drivertext' as the triggering element.
     $post_result = $this->drupalPostAJAX('ajax_validation_test', $edit, 'drivertext');
     // Look for a validation failure in the resultant JSON.
-    $this->assertNoText(t('Error message'), t("No error message in resultant JSON"));
-    $this->assertText('ajax_forms_test_validation_form_callback invoked', t('The correct callback was invoked'));
+    $this->assertNoText(t('Error message'), "No error message in resultant JSON");
+    $this->assertText('ajax_forms_test_validation_form_callback invoked', 'The correct callback was invoked');
   }
 }
diff --git a/modules/simpletest/tests/bootstrap.test b/modules/simpletest/tests/bootstrap.test
index 014fc94..87b5960 100644
--- a/modules/simpletest/tests/bootstrap.test
+++ b/modules/simpletest/tests/bootstrap.test
@@ -42,14 +42,14 @@ class BootstrapIPAddressTestCase extends DrupalWebTestCase {
     // Test the normal IP address.
     $this->assertTrue(
       ip_address() == $this->remote_ip,
-      t('Got remote IP address.')
+      'Got remote IP address.'
     );
 
     // Proxy forwarding on but no proxy addresses defined.
     variable_set('reverse_proxy', 1);
     $this->assertTrue(
       ip_address() == $this->remote_ip,
-      t('Proxy forwarding without trusted proxies got remote IP address.')
+      'Proxy forwarding without trusted proxies got remote IP address.'
     );
 
     // Proxy forwarding on and proxy address not trusted.
@@ -58,7 +58,7 @@ class BootstrapIPAddressTestCase extends DrupalWebTestCase {
     $_SERVER['REMOTE_ADDR'] = $this->untrusted_ip;
     $this->assertTrue(
       ip_address() == $this->untrusted_ip,
-      t('Proxy forwarding with untrusted proxy got remote IP address.')
+      'Proxy forwarding with untrusted proxy got remote IP address.'
     );
 
     // Proxy forwarding on and proxy address trusted.
@@ -67,7 +67,7 @@ class BootstrapIPAddressTestCase extends DrupalWebTestCase {
     drupal_static_reset('ip_address');
     $this->assertTrue(
       ip_address() == $this->forwarded_ip,
-      t('Proxy forwarding with trusted proxy got forwarded IP address.')
+      'Proxy forwarding with trusted proxy got forwarded IP address.'
     );
 
     // Multi-tier architecture with comma separated values in header.
@@ -76,7 +76,7 @@ class BootstrapIPAddressTestCase extends DrupalWebTestCase {
     drupal_static_reset('ip_address');
     $this->assertTrue(
       ip_address() == $this->forwarded_ip,
-      t('Proxy forwarding with trusted 2-tier proxy got forwarded IP address.')
+      'Proxy forwarding with trusted 2-tier proxy got forwarded IP address.'
     );
 
     // Custom client-IP header.
@@ -85,16 +85,16 @@ class BootstrapIPAddressTestCase extends DrupalWebTestCase {
     drupal_static_reset('ip_address');
     $this->assertTrue(
       ip_address() == $this->cluster_ip,
-      t('Cluster environment got cluster client IP.')
+      'Cluster environment got cluster client IP.'
     );
 
     // Verifies that drupal_valid_http_host() prevents invalid characters.
-    $this->assertFalse(drupal_valid_http_host('security/.drupal.org:80'), t('HTTP_HOST with / is invalid'));
-    $this->assertFalse(drupal_valid_http_host('security\\.drupal.org:80'), t('HTTP_HOST with \\ is invalid'));
-    $this->assertFalse(drupal_valid_http_host('security<.drupal.org:80'), t('HTTP_HOST with &lt; is invalid'));
-    $this->assertFalse(drupal_valid_http_host('security..drupal.org:80'), t('HTTP_HOST with .. is invalid'));
+    $this->assertFalse(drupal_valid_http_host('security/.drupal.org:80'), 'HTTP_HOST with / is invalid');
+    $this->assertFalse(drupal_valid_http_host('security\\.drupal.org:80'), 'HTTP_HOST with \\ is invalid');
+    $this->assertFalse(drupal_valid_http_host('security<.drupal.org:80'), 'HTTP_HOST with &lt; is invalid');
+    $this->assertFalse(drupal_valid_http_host('security..drupal.org:80'), 'HTTP_HOST with .. is invalid');
     // IPv6 loopback address
-    $this->assertTrue(drupal_valid_http_host('[::1]:80'), t('HTTP_HOST containing IPv6 loopback is valid'));
+    $this->assertTrue(drupal_valid_http_host('[::1]:80'), 'HTTP_HOST containing IPv6 loopback is valid');
   }
 }
 
@@ -122,32 +122,32 @@ class BootstrapPageCacheTestCase extends DrupalWebTestCase {
     $this->drupalGet('');
 
     $this->drupalHead('');
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
     $etag = $this->drupalGetHeader('ETag');
     $last_modified = $this->drupalGetHeader('Last-Modified');
 
     $this->drupalGet('', array(), array('If-Modified-Since: ' . $last_modified, 'If-None-Match: ' . $etag));
-    $this->assertResponse(304, t('Conditional request returned 304 Not Modified.'));
+    $this->assertResponse(304, 'Conditional request returned 304 Not Modified.');
 
     $this->drupalGet('', array(), array('If-Modified-Since: ' . gmdate(DATE_RFC822, strtotime($last_modified)), 'If-None-Match: ' . $etag));
-    $this->assertResponse(304, t('Conditional request with obsolete If-Modified-Since date returned 304 Not Modified.'));
+    $this->assertResponse(304, 'Conditional request with obsolete If-Modified-Since date returned 304 Not Modified.');
 
     $this->drupalGet('', array(), array('If-Modified-Since: ' . gmdate(DATE_RFC850, strtotime($last_modified)), 'If-None-Match: ' . $etag));
-    $this->assertResponse(304, t('Conditional request with obsolete If-Modified-Since date returned 304 Not Modified.'));
+    $this->assertResponse(304, 'Conditional request with obsolete If-Modified-Since date returned 304 Not Modified.');
 
     $this->drupalGet('', array(), array('If-Modified-Since: ' . $last_modified));
-    $this->assertResponse(200, t('Conditional request without If-None-Match returned 200 OK.'));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
+    $this->assertResponse(200, 'Conditional request without If-None-Match returned 200 OK.');
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
 
     $this->drupalGet('', array(), array('If-Modified-Since: ' . gmdate(DATE_RFC1123, strtotime($last_modified) + 1), 'If-None-Match: ' . $etag));
-    $this->assertResponse(200, t('Conditional request with new a If-Modified-Since date newer than Last-Modified returned 200 OK.'));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
+    $this->assertResponse(200, 'Conditional request with new a If-Modified-Since date newer than Last-Modified returned 200 OK.');
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
 
     $user = $this->drupalCreateUser();
     $this->drupalLogin($user);
     $this->drupalGet('', array(), array('If-Modified-Since: ' . $last_modified, 'If-None-Match: ' . $etag));
-    $this->assertResponse(200, t('Conditional request returned 200 OK for authenticated user.'));
-    $this->assertFalse($this->drupalGetHeader('X-Drupal-Cache'), t('Absense of Page was not cached.'));
+    $this->assertResponse(200, 'Conditional request returned 200 OK for authenticated user.');
+    $this->assertFalse($this->drupalGetHeader('X-Drupal-Cache'), 'Absense of Page was not cached.');
   }
 
   /**
@@ -158,35 +158,35 @@ class BootstrapPageCacheTestCase extends DrupalWebTestCase {
 
     // Fill the cache.
     $this->drupalGet('system-test/set-header', array('query' => array('name' => 'Foo', 'value' => 'bar')));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'MISS', t('Page was not cached.'));
-    $this->assertEqual($this->drupalGetHeader('Vary'), 'Cookie,Accept-Encoding', t('Vary header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'public, max-age=0', t('Cache-Control header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', t('Expires header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Foo'), 'bar', t('Custom header was sent.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'MISS', 'Page was not cached.');
+    $this->assertEqual($this->drupalGetHeader('Vary'), 'Cookie,Accept-Encoding', 'Vary header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'public, max-age=0', 'Cache-Control header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', 'Expires header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Foo'), 'bar', 'Custom header was sent.');
 
     // Check cache.
     $this->drupalGet('system-test/set-header', array('query' => array('name' => 'Foo', 'value' => 'bar')));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
-    $this->assertEqual($this->drupalGetHeader('Vary'), 'Cookie,Accept-Encoding', t('Vary: Cookie header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'public, max-age=0', t('Cache-Control header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', t('Expires header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Foo'), 'bar', t('Custom header was sent.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
+    $this->assertEqual($this->drupalGetHeader('Vary'), 'Cookie,Accept-Encoding', 'Vary: Cookie header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'public, max-age=0', 'Cache-Control header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', 'Expires header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Foo'), 'bar', 'Custom header was sent.');
 
     // Check replacing default headers.
     $this->drupalGet('system-test/set-header', array('query' => array('name' => 'Expires', 'value' => 'Fri, 19 Nov 2008 05:00:00 GMT')));
-    $this->assertEqual($this->drupalGetHeader('Expires'), 'Fri, 19 Nov 2008 05:00:00 GMT', t('Default header was replaced.'));
+    $this->assertEqual($this->drupalGetHeader('Expires'), 'Fri, 19 Nov 2008 05:00:00 GMT', 'Default header was replaced.');
     $this->drupalGet('system-test/set-header', array('query' => array('name' => 'Vary', 'value' => 'User-Agent')));
-    $this->assertEqual($this->drupalGetHeader('Vary'), 'User-Agent,Accept-Encoding', t('Default header was replaced.'));
+    $this->assertEqual($this->drupalGetHeader('Vary'), 'User-Agent,Accept-Encoding', 'Default header was replaced.');
 
     // Check that authenticated users bypass the cache.
     $user = $this->drupalCreateUser();
     $this->drupalLogin($user);
     $this->drupalGet('system-test/set-header', array('query' => array('name' => 'Foo', 'value' => 'bar')));
-    $this->assertFalse($this->drupalGetHeader('X-Drupal-Cache'), t('Caching was bypassed.'));
-    $this->assertTrue(strpos($this->drupalGetHeader('Vary'), 'Cookie') === FALSE, t('Vary: Cookie header was not sent.'));
-    $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'no-cache, must-revalidate, post-check=0, pre-check=0', t('Cache-Control header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', t('Expires header was sent.'));
-    $this->assertEqual($this->drupalGetHeader('Foo'), 'bar', t('Custom header was sent.'));
+    $this->assertFalse($this->drupalGetHeader('X-Drupal-Cache'), 'Caching was bypassed.');
+    $this->assertTrue(strpos($this->drupalGetHeader('Vary'), 'Cookie') === FALSE, 'Vary: Cookie header was not sent.');
+    $this->assertEqual($this->drupalGetHeader('Cache-Control'), 'no-cache, must-revalidate, post-check=0, pre-check=0', 'Cache-Control header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Expires'), 'Sun, 19 Nov 1978 05:00:00 GMT', 'Expires header was sent.');
+    $this->assertEqual($this->drupalGetHeader('Foo'), 'bar', 'Custom header was sent.');
 
   }
 
@@ -202,23 +202,23 @@ class BootstrapPageCacheTestCase extends DrupalWebTestCase {
 
     // Fill the cache and verify that output is compressed.
     $this->drupalGet('', array(), array('Accept-Encoding: gzip,deflate'));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'MISS', t('Page was not cached.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'MISS', 'Page was not cached.');
     $this->drupalSetContent(gzinflate(substr($this->drupalGetContent(), 10, -8)));
-    $this->assertRaw('</html>', t('Page was gzip compressed.'));
+    $this->assertRaw('</html>', 'Page was gzip compressed.');
 
     // Verify that cached output is compressed.
     $this->drupalGet('', array(), array('Accept-Encoding: gzip,deflate'));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
-    $this->assertEqual($this->drupalGetHeader('Content-Encoding'), 'gzip', t('A Content-Encoding header was sent.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
+    $this->assertEqual($this->drupalGetHeader('Content-Encoding'), 'gzip', 'A Content-Encoding header was sent.');
     $this->drupalSetContent(gzinflate(substr($this->drupalGetContent(), 10, -8)));
-    $this->assertRaw('</html>', t('Page was gzip compressed.'));
+    $this->assertRaw('</html>', 'Page was gzip compressed.');
 
     // Verify that a client without compression support gets an uncompressed page.
     $this->drupalGet('');
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
-    $this->assertFalse($this->drupalGetHeader('Content-Encoding'), t('A Content-Encoding header was not sent.'));
-    $this->assertTitle(t('Welcome to @site-name | @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), t('Site title matches.'));
-    $this->assertRaw('</html>', t('Page was not compressed.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
+    $this->assertFalse($this->drupalGetHeader('Content-Encoding'), 'A Content-Encoding header was not sent.');
+    $this->assertTitle(t('Welcome to @site-name | @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), 'Site title matches.');
+    $this->assertRaw('</html>', 'Page was not compressed.');
   }
 }
 
@@ -243,17 +243,17 @@ class BootstrapVariableTestCase extends DrupalWebTestCase {
     // Setting and retrieving values.
     $variable = $this->randomName();
     variable_set('simpletest_bootstrap_variable_test', $variable);
-    $this->assertIdentical($variable, variable_get('simpletest_bootstrap_variable_test'), t('Setting and retrieving values'));
+    $this->assertIdentical($variable, variable_get('simpletest_bootstrap_variable_test'), 'Setting and retrieving values');
 
     // Make sure the variable persists across multiple requests.
     $this->drupalGet('system-test/variable-get');
-    $this->assertText($variable, t('Variable persists across multiple requests'));
+    $this->assertText($variable, 'Variable persists across multiple requests');
 
     // Deleting variables.
     $default_value = $this->randomName();
     variable_del('simpletest_bootstrap_variable_test');
     $variable = variable_get('simpletest_bootstrap_variable_test', $default_value);
-    $this->assertIdentical($variable, $default_value, t('Deleting variables'));
+    $this->assertIdentical($variable, $default_value, 'Deleting variables');
   }
 
   /**
@@ -261,10 +261,10 @@ class BootstrapVariableTestCase extends DrupalWebTestCase {
    */
   function testVariableDefaults() {
     // Tests passing nothing through to the default.
-    $this->assertIdentical(NULL, variable_get('simpletest_bootstrap_variable_test'), t('Variables are correctly defaulting to NULL.'));
+    $this->assertIdentical(NULL, variable_get('simpletest_bootstrap_variable_test'), 'Variables are correctly defaulting to NULL.');
 
     // Tests passing 5 to the default parameter.
-    $this->assertIdentical(5, variable_get('simpletest_bootstrap_variable_test', 5), t('The default variable parameter is passed through correctly.'));
+    $this->assertIdentical(5, variable_get('simpletest_bootstrap_variable_test', 5), 'The default variable parameter is passed through correctly.');
   }
 
 }
@@ -383,17 +383,17 @@ class BootstrapTimerTestCase extends DrupalUnitTestCase {
   function testTimer() {
     timer_start('test');
     sleep(1);
-    $this->assertTrue(timer_read('test') >= 1000, t('Timer measured 1 second of sleeping while running.'));
+    $this->assertTrue(timer_read('test') >= 1000, 'Timer measured 1 second of sleeping while running.');
     sleep(1);
     timer_stop('test');
-    $this->assertTrue(timer_read('test') >= 2000, t('Timer measured 2 seconds of sleeping after being stopped.'));
+    $this->assertTrue(timer_read('test') >= 2000, 'Timer measured 2 seconds of sleeping after being stopped.');
     timer_start('test');
     sleep(1);
-    $this->assertTrue(timer_read('test') >= 3000, t('Timer measured 3 seconds of sleeping after being restarted.'));
+    $this->assertTrue(timer_read('test') >= 3000, 'Timer measured 3 seconds of sleeping after being restarted.');
     sleep(1);
     $timer = timer_stop('test');
-    $this->assertTrue(timer_read('test') >= 4000, t('Timer measured 4 seconds of sleeping after being stopped for a second time.'));
-    $this->assertEqual($timer['count'], 2, t('Timer counted 2 instances of being started.'));
+    $this->assertTrue(timer_read('test') >= 4000, 'Timer measured 4 seconds of sleeping after being stopped for a second time.');
+    $this->assertEqual($timer['count'], 2, 'Timer counted 2 instances of being started.');
   }
 }
 
@@ -417,22 +417,22 @@ class BootstrapResettableStaticTestCase extends DrupalUnitTestCase {
   function testDrupalStatic() {
     $name = __CLASS__ . '_' . __METHOD__;
     $var = &drupal_static($name, 'foo');
-    $this->assertEqual($var, 'foo', t('Variable returned by drupal_static() was set to its default.'));
+    $this->assertEqual($var, 'foo', 'Variable returned by drupal_static() was set to its default.');
 
     // Call the specific reset and the global reset each twice to ensure that
     // multiple resets can be issued without odd side effects.
     $var = 'bar';
     drupal_static_reset($name);
-    $this->assertEqual($var, 'foo', t('Variable was reset after first invocation of name-specific reset.'));
+    $this->assertEqual($var, 'foo', 'Variable was reset after first invocation of name-specific reset.');
     $var = 'bar';
     drupal_static_reset($name);
-    $this->assertEqual($var, 'foo', t('Variable was reset after second invocation of name-specific reset.'));
+    $this->assertEqual($var, 'foo', 'Variable was reset after second invocation of name-specific reset.');
     $var = 'bar';
     drupal_static_reset();
-    $this->assertEqual($var, 'foo', t('Variable was reset after first invocation of global reset.'));
+    $this->assertEqual($var, 'foo', 'Variable was reset after first invocation of global reset.');
     $var = 'bar';
     drupal_static_reset();
-    $this->assertEqual($var, 'foo', t('Variable was reset after second invocation of global reset.'));
+    $this->assertEqual($var, 'foo', 'Variable was reset after second invocation of global reset.');
   }
 }
 
@@ -457,7 +457,30 @@ class BootstrapMiscTestCase extends DrupalUnitTestCase {
     $link_options_1 = array('fragment' => 'x', 'attributes' => array('title' => 'X', 'class' => array('a', 'b')), 'language' => 'en');
     $link_options_2 = array('fragment' => 'y', 'attributes' => array('title' => 'Y', 'class' => array('c', 'd')), 'html' => TRUE);
     $expected = array('fragment' => 'y', 'attributes' => array('title' => 'Y', 'class' => array('a', 'b', 'c', 'd')), 'language' => 'en', 'html' => TRUE);
-    $this->assertIdentical(drupal_array_merge_deep($link_options_1, $link_options_2), $expected, t('drupal_array_merge_deep() returned a properly merged array.'));
+    $this->assertIdentical(drupal_array_merge_deep($link_options_1, $link_options_2), $expected, 'drupal_array_merge_deep() returned a properly merged array.');
+  }
+
+  /**
+   * Tests that the drupal_check_memory_limit() function works as expected.
+   */
+  function testCheckMemoryLimit() {
+    $memory_limit = ini_get('memory_limit');
+    // Test that a very reasonable amount of memory is available.
+    $this->assertTrue(drupal_check_memory_limit('30MB'), '30MB of memory tested available.');
+
+    // Get the available memory and multiply it by two to make it unreasonably
+    // high.
+    $twice_avail_memory = ($memory_limit * 2) . 'MB';
+
+    // The function should always return true if the memory limit is set to -1.
+    $this->assertTrue(drupal_check_memory_limit($twice_avail_memory, -1), 'drupal_check_memory_limit() returns TRUE when a limit of -1 (none) is supplied');
+
+    // Test that even though we have 30MB of memory available - the function
+    // returns FALSE when given an upper limit for how much memory can be used.
+    $this->assertFalse(drupal_check_memory_limit('30MB', '16MB'), 'drupal_check_memory_limit() returns FALSE with a 16MB upper limit on a 30MB requirement.');
+
+    // Test that an equal amount of memory to the amount requested returns TRUE.
+    $this->assertTrue(drupal_check_memory_limit('30MB', '30MB'), 'drupal_check_memory_limit() returns TRUE when requesting 30MB on a 30MB requirement.');
   }
 }
 
@@ -506,4 +529,3 @@ class BootstrapOverrideServerVariablesTestCase extends DrupalUnitTestCase {
     }
   }
 }
-
diff --git a/modules/simpletest/tests/cache.test b/modules/simpletest/tests/cache.test
index 47f2df3..b42de36 100644
--- a/modules/simpletest/tests/cache.test
+++ b/modules/simpletest/tests/cache.test
@@ -148,7 +148,7 @@ class CacheSavingCase extends CacheTestCase {
 
     cache_set('test_object', $test_object, 'cache');
     $cache = cache_get('test_object', 'cache');
-    $this->assertTrue(isset($cache->data) && $cache->data == $test_object, t('Object is saved and restored properly.'));
+    $this->assertTrue(isset($cache->data) && $cache->data == $test_object, 'Object is saved and restored properly.');
   }
 
   /**
@@ -157,7 +157,7 @@ class CacheSavingCase extends CacheTestCase {
   function checkVariable($var) {
     cache_set('test_var', $var, 'cache');
     $cache = cache_get('test_var', 'cache');
-    $this->assertTrue(isset($cache->data) && $cache->data === $var, t('@type is saved and restored properly.', array('@type' => ucfirst(gettype($var)))));
+    $this->assertTrue(isset($cache->data) && $cache->data === $var, format_string('@type is saved and restored properly.', array('@type' => ucfirst(gettype($var)))));
   }
 
   /**
@@ -165,7 +165,7 @@ class CacheSavingCase extends CacheTestCase {
    */
   function testNoEmptyCids() {
     $this->drupalGet('user/register');
-    $this->assertFalse(cache_get(''), t('No cache entry is written with an empty cid.'));
+    $this->assertFalse(cache_get(''), 'No cache entry is written with an empty cid.');
   }
 }
 
@@ -195,14 +195,14 @@ class CacheGetMultipleUnitTest extends CacheTestCase {
     $item2 = $this->randomName(10);
     cache_set('item1', $item1, $this->default_bin);
     cache_set('item2', $item2, $this->default_bin);
-    $this->assertTrue($this->checkCacheExists('item1', $item1), t('Item 1 is cached.'));
-    $this->assertTrue($this->checkCacheExists('item2', $item2), t('Item 2 is cached.'));
+    $this->assertTrue($this->checkCacheExists('item1', $item1), 'Item 1 is cached.');
+    $this->assertTrue($this->checkCacheExists('item2', $item2), 'Item 2 is cached.');
 
     // Fetch both records from the database with cache_get_multiple().
     $item_ids = array('item1', 'item2');
     $items = cache_get_multiple($item_ids, $this->default_bin);
-    $this->assertEqual($items['item1']->data, $item1, t('Item was returned from cache successfully.'));
-    $this->assertEqual($items['item2']->data, $item2, t('Item was returned from cache successfully.'));
+    $this->assertEqual($items['item1']->data, $item1, 'Item was returned from cache successfully.');
+    $this->assertEqual($items['item2']->data, $item2, 'Item was returned from cache successfully.');
 
     // Remove one item from the cache.
     cache_clear_all('item2', $this->default_bin);
@@ -210,9 +210,9 @@ class CacheGetMultipleUnitTest extends CacheTestCase {
     // Confirm that only one item is returned by cache_get_multiple().
     $item_ids = array('item1', 'item2');
     $items = cache_get_multiple($item_ids, $this->default_bin);
-    $this->assertEqual($items['item1']->data, $item1, t('Item was returned from cache successfully.'));
-    $this->assertFalse(isset($items['item2']), t('Item was not returned from the cache.'));
-    $this->assertTrue(count($items) == 1, t('Only valid cache entries returned.'));
+    $this->assertEqual($items['item1']->data, $item1, 'Item was returned from cache successfully.');
+    $this->assertFalse(isset($items['item2']), 'Item was not returned from the cache.');
+    $this->assertTrue(count($items) == 1, 'Only valid cache entries returned.');
   }
 }
 
@@ -250,11 +250,11 @@ class CacheClearCase extends CacheTestCase {
     cache_set('test_cid_clear2', $this->default_value, $this->default_bin);
     $this->assertTrue($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two caches were created for checking cid "*" with wildcard false.'));
+                      'Two caches were created for checking cid "*" with wildcard false.');
     cache_clear_all('*', $this->default_bin);
     $this->assertTrue($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two caches still exists after clearing cid "*" with wildcard false.'));
+                      'Two caches still exists after clearing cid "*" with wildcard false.');
   }
 
   /**
@@ -265,21 +265,21 @@ class CacheClearCase extends CacheTestCase {
     cache_set('test_cid_clear2', $this->default_value, $this->default_bin);
     $this->assertTrue($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two caches were created for checking cid "*" with wildcard true.'));
+                      'Two caches were created for checking cid "*" with wildcard true.');
     cache_clear_all('*', $this->default_bin, TRUE);
     $this->assertFalse($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       || $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two caches removed after clearing cid "*" with wildcard true.'));
+                      'Two caches removed after clearing cid "*" with wildcard true.');
 
     cache_set('test_cid_clear1', $this->default_value, $this->default_bin);
     cache_set('test_cid_clear2', $this->default_value, $this->default_bin);
     $this->assertTrue($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two caches were created for checking cid substring with wildcard true.'));
+                      'Two caches were created for checking cid substring with wildcard true.');
     cache_clear_all('test_', $this->default_bin, TRUE);
     $this->assertFalse($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       || $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two caches removed after clearing cid substring with wildcard true.'));
+                      'Two caches removed after clearing cid substring with wildcard true.');
   }
 
   /**
@@ -293,16 +293,16 @@ class CacheClearCase extends CacheTestCase {
     $this->assertTrue($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear2', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear3', $this->default_value),
-                      t('Three cache entries were created.'));
+                      'Three cache entries were created.');
 
     // Clear two entries using an array.
     cache_clear_all(array('test_cid_clear1', 'test_cid_clear2'), $this->default_bin);
     $this->assertFalse($this->checkCacheExists('test_cid_clear1', $this->default_value)
                        || $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                       t('Two cache entries removed after clearing with an array.'));
+                       'Two cache entries removed after clearing with an array.');
 
     $this->assertTrue($this->checkCacheExists('test_cid_clear3', $this->default_value),
-                      t('Entry was not cleared from the cache'));
+                      'Entry was not cleared from the cache');
 
     // Set the cache clear threshold to 2 to confirm that the full bin is cleared
     // when the threshold is exceeded.
@@ -311,12 +311,12 @@ class CacheClearCase extends CacheTestCase {
     cache_set('test_cid_clear2', $this->default_value, $this->default_bin);
     $this->assertTrue($this->checkCacheExists('test_cid_clear1', $this->default_value)
                       && $this->checkCacheExists('test_cid_clear2', $this->default_value),
-                      t('Two cache entries were created.'));
+                      'Two cache entries were created.');
     cache_clear_all(array('test_cid_clear1', 'test_cid_clear2', 'test_cid_clear3'), $this->default_bin);
     $this->assertFalse($this->checkCacheExists('test_cid_clear1', $this->default_value)
                        || $this->checkCacheExists('test_cid_clear2', $this->default_value)
                        || $this->checkCacheExists('test_cid_clear3', $this->default_value),
-                       t('All cache entries removed when the array exceeded the cache clear threshold.'));
+                       'All cache entries removed when the array exceeded the cache clear threshold.');
   }
 
   /**
@@ -336,7 +336,31 @@ class CacheClearCase extends CacheTestCase {
 
     foreach ($bins as $id => $bin) {
       $id = 'test_cid_clear' . $id;
-      $this->assertFalse($this->checkCacheExists($id, $this->default_value, $bin), t('All cache entries removed from @bin.', array('@bin' => $bin)));
+      $this->assertFalse($this->checkCacheExists($id, $this->default_value, $bin), format_string('All cache entries removed from @bin.', array('@bin' => $bin)));
+    }
+  }
+
+  /**
+   * Test DrupalDatabaseCache::isValidBin().
+   */
+  function testIsValidBin() {
+    // Retrieve existing cache bins.
+    $valid_bins = array('cache', 'cache_filter', 'cache_page', 'cache_boostrap', 'cache_path');
+    $valid_bins = array_merge(module_invoke_all('flush_caches'), $valid_bins);
+    foreach ($valid_bins as $id => $bin) {
+      $cache = _cache_get_object($bin);
+      if ($cache instanceof DrupalDatabaseCache) {
+        $this->assertTrue($cache->isValidBin(), format_string('Cache bin @bin is valid.', array('@bin' => $bin)));
+      }
+    }
+
+    // Check for non-cache tables and invalid bins.
+    $invalid_bins = array('block', 'filter', 'missing_table', $this->randomName());
+    foreach ($invalid_bins as $id => $bin) {
+      $cache = _cache_get_object($bin);
+      if ($cache instanceof DrupalDatabaseCache) {
+        $this->assertFalse($cache->isValidBin(), format_string('Cache bin @bin is not valid.', array('@bin' => $bin)));
+      }
     }
   }
 
@@ -400,14 +424,14 @@ class CacheIsEmptyCase extends CacheTestCase {
   function testIsEmpty() {
     // Clear the cache bin.
     cache_clear_all('*', $this->default_bin);
-    $this->assertTrue(cache_is_empty($this->default_bin), t('The cache bin is empty'));
+    $this->assertTrue(cache_is_empty($this->default_bin), 'The cache bin is empty');
     // Add some data to the cache bin.
     cache_set($this->default_cid, $this->default_value, $this->default_bin);
     $this->assertCacheExists(t('Cache was set.'), $this->default_value, $this->default_cid);
-    $this->assertFalse(cache_is_empty($this->default_bin), t('The cache bin is not empty'));
+    $this->assertFalse(cache_is_empty($this->default_bin), 'The cache bin is not empty');
     // Remove the cached data.
     cache_clear_all($this->default_cid, $this->default_bin);
     $this->assertCacheRemoved(t('Cache was removed.'), $this->default_cid);
-    $this->assertTrue(cache_is_empty($this->default_bin), t('The cache bin is empty'));
+    $this->assertTrue(cache_is_empty($this->default_bin), 'The cache bin is empty');
   }
 }
diff --git a/modules/simpletest/tests/common.test b/modules/simpletest/tests/common.test
index e8e4033..8694ff3 100644
--- a/modules/simpletest/tests/common.test
+++ b/modules/simpletest/tests/common.test
@@ -36,13 +36,13 @@ class DrupalAlterTestCase extends DrupalWebTestCase {
     $array_copy = $array;
     $array_expected = array('foo' => 'Drupal theme');
     drupal_alter('drupal_alter', $array_copy);
-    $this->assertEqual($array_copy, $array_expected, t('Single array was altered.'));
+    $this->assertEqual($array_copy, $array_expected, 'Single array was altered.');
 
     $entity_copy = clone $entity;
     $entity_expected = clone $entity;
     $entity_expected->foo = 'Drupal theme';
     drupal_alter('drupal_alter', $entity_copy);
-    $this->assertEqual($entity_copy, $entity_expected, t('Single object was altered.'));
+    $this->assertEqual($entity_copy, $entity_expected, 'Single object was altered.');
 
     // Verify alteration of multiple arguments.
     $array_copy = $array;
@@ -53,9 +53,9 @@ class DrupalAlterTestCase extends DrupalWebTestCase {
     $array2_copy = $array;
     $array2_expected = array('foo' => 'Drupal theme');
     drupal_alter('drupal_alter', $array_copy, $entity_copy, $array2_copy);
-    $this->assertEqual($array_copy, $array_expected, t('First argument to drupal_alter() was altered.'));
-    $this->assertEqual($entity_copy, $entity_expected, t('Second argument to drupal_alter() was altered.'));
-    $this->assertEqual($array2_copy, $array2_expected, t('Third argument to drupal_alter() was altered.'));
+    $this->assertEqual($array_copy, $array_expected, 'First argument to drupal_alter() was altered.');
+    $this->assertEqual($entity_copy, $entity_expected, 'Second argument to drupal_alter() was altered.');
+    $this->assertEqual($array2_copy, $array2_expected, 'Third argument to drupal_alter() was altered.');
 
     // Verify alteration order when passing an array of types to drupal_alter().
     // common_test_module_implements_alter() places 'block' implementation after
@@ -63,7 +63,7 @@ class DrupalAlterTestCase extends DrupalWebTestCase {
     $array_copy = $array;
     $array_expected = array('foo' => 'Drupal block theme');
     drupal_alter(array('drupal_alter', 'drupal_alter_foo'), $array_copy);
-    $this->assertEqual($array_copy, $array_expected, t('hook_TYPE_alter() implementations ran in correct order.'));
+    $this->assertEqual($array_copy, $array_expected, 'hook_TYPE_alter() implementations ran in correct order.');
   }
 }
 
@@ -90,7 +90,7 @@ class CommonURLUnitTest extends DrupalWebTestCase {
     $path = "<SCRIPT>alert('XSS')</SCRIPT>";
     $link = l($text, $path);
     $sanitized_path = check_url(url($path));
-    $this->assertTrue(strpos($link, $sanitized_path) !== FALSE, t('XSS attack @path was filtered', array('@path' => $path)));
+    $this->assertTrue(strpos($link, $sanitized_path) !== FALSE, format_string('XSS attack @path was filtered', array('@path' => $path)));
   }
 
   /*
@@ -98,7 +98,7 @@ class CommonURLUnitTest extends DrupalWebTestCase {
    */
   function testLActiveClass() {
     $link = l($this->randomName(), $_GET['q']);
-    $this->assertTrue($this->hasClass($link, 'active'), t('Class @class is present on link to the current page', array('@class' => 'active')));
+    $this->assertTrue($this->hasClass($link, 'active'), format_string('Class @class is present on link to the current page', array('@class' => 'active')));
   }
 
   /**
@@ -107,8 +107,8 @@ class CommonURLUnitTest extends DrupalWebTestCase {
   function testLCustomClass() {
     $class = $this->randomName();
     $link = l($this->randomName(), $_GET['q'], array('attributes' => array('class' => array($class))));
-    $this->assertTrue($this->hasClass($link, $class), t('Custom class @class is present on link when requested', array('@class' => $class)));
-    $this->assertTrue($this->hasClass($link, 'active'), t('Class @class is present on link to the current page', array('@class' => 'active')));
+    $this->assertTrue($this->hasClass($link, $class), format_string('Custom class @class is present on link when requested', array('@class' => $class)));
+    $this->assertTrue($this->hasClass($link, 'active'), format_string('Class @class is present on link to the current page', array('@class' => 'active')));
   }
 
   private function hasClass($link, $class) {
@@ -134,42 +134,42 @@ class CommonURLUnitTest extends DrupalWebTestCase {
     // Default arguments.
     $result = $_GET;
     unset($result['q']);
-    $this->assertEqual(drupal_get_query_parameters(), $result, t("\$_GET['q'] was removed."));
+    $this->assertEqual(drupal_get_query_parameters(), $result, "\$_GET['q'] was removed.");
 
     // Default exclusion.
     $result = $original;
     unset($result['q']);
-    $this->assertEqual(drupal_get_query_parameters($original), $result, t("'q' was removed."));
+    $this->assertEqual(drupal_get_query_parameters($original), $result, "'q' was removed.");
 
     // First-level exclusion.
     $result = $original;
     unset($result['b']);
-    $this->assertEqual(drupal_get_query_parameters($original, array('b')), $result, t("'b' was removed."));
+    $this->assertEqual(drupal_get_query_parameters($original, array('b')), $result, "'b' was removed.");
 
     // Second-level exclusion.
     $result = $original;
     unset($result['b']['d']);
-    $this->assertEqual(drupal_get_query_parameters($original, array('b[d]')), $result, t("'b[d]' was removed."));
+    $this->assertEqual(drupal_get_query_parameters($original, array('b[d]')), $result, "'b[d]' was removed.");
 
     // Third-level exclusion.
     $result = $original;
     unset($result['b']['e']['f']);
-    $this->assertEqual(drupal_get_query_parameters($original, array('b[e][f]')), $result, t("'b[e][f]' was removed."));
+    $this->assertEqual(drupal_get_query_parameters($original, array('b[e][f]')), $result, "'b[e][f]' was removed.");
 
     // Multiple exclusions.
     $result = $original;
     unset($result['a'], $result['b']['e'], $result['c']);
-    $this->assertEqual(drupal_get_query_parameters($original, array('a', 'b[e]', 'c')), $result, t("'a', 'b[e]', 'c' were removed."));
+    $this->assertEqual(drupal_get_query_parameters($original, array('a', 'b[e]', 'c')), $result, "'a', 'b[e]', 'c' were removed.");
   }
 
   /**
    * Test drupal_http_build_query().
    */
   function testDrupalHttpBuildQuery() {
-    $this->assertEqual(drupal_http_build_query(array('a' => ' &#//+%20@۞')), 'a=%20%26%23//%2B%2520%40%DB%9E', t('Value was properly encoded.'));
-    $this->assertEqual(drupal_http_build_query(array(' &#//+%20@۞' => 'a')), '%20%26%23%2F%2F%2B%2520%40%DB%9E=a', t('Key was properly encoded.'));
-    $this->assertEqual(drupal_http_build_query(array('a' => '1', 'b' => '2', 'c' => '3')), 'a=1&b=2&c=3', t('Multiple values were properly concatenated.'));
-    $this->assertEqual(drupal_http_build_query(array('a' => array('b' => '2', 'c' => '3'), 'd' => 'foo')), 'a[b]=2&a[c]=3&d=foo', t('Nested array was properly encoded.'));
+    $this->assertEqual(drupal_http_build_query(array('a' => ' &#//+%20@۞')), 'a=%20%26%23//%2B%2520%40%DB%9E', 'Value was properly encoded.');
+    $this->assertEqual(drupal_http_build_query(array(' &#//+%20@۞' => 'a')), '%20%26%23%2F%2F%2B%2520%40%DB%9E=a', 'Key was properly encoded.');
+    $this->assertEqual(drupal_http_build_query(array('a' => '1', 'b' => '2', 'c' => '3')), 'a=1&b=2&c=3', 'Multiple values were properly concatenated.');
+    $this->assertEqual(drupal_http_build_query(array('a' => array('b' => '2', 'c' => '3'), 'd' => 'foo')), 'a[b]=2&a[c]=3&d=foo', 'Nested array was properly encoded.');
   }
 
   /**
@@ -183,7 +183,7 @@ class CommonURLUnitTest extends DrupalWebTestCase {
       'query' => array('foo' => 'bar', 'bar' => 'baz', 'baz' => ''),
       'fragment' => 'foo',
     );
-    $this->assertEqual(drupal_parse_url($url), $result, t('Relative URL parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'Relative URL parsed correctly.');
 
     // Relative URL that is known to confuse parse_url().
     $url = 'foo/bar:1';
@@ -192,7 +192,7 @@ class CommonURLUnitTest extends DrupalWebTestCase {
       'query' => array(),
       'fragment' => '',
     );
-    $this->assertEqual(drupal_parse_url($url), $result, t('Relative URL parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'Relative URL parsed correctly.');
 
     // Absolute URL.
     $url = '/foo/bar?foo=bar&bar=baz&baz#foo';
@@ -201,13 +201,13 @@ class CommonURLUnitTest extends DrupalWebTestCase {
       'query' => array('foo' => 'bar', 'bar' => 'baz', 'baz' => ''),
       'fragment' => 'foo',
     );
-    $this->assertEqual(drupal_parse_url($url), $result, t('Absolute URL parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'Absolute URL parsed correctly.');
 
     // External URL testing.
     $url = 'http://drupal.org/foo/bar?foo=bar&bar=baz&baz#foo';
 
     // Test that drupal can recognize an absolute URL. Used to prevent attack vectors.
-    $this->assertTrue(url_is_external($url), t('Correctly identified an external URL.'));
+    $this->assertTrue(url_is_external($url), 'Correctly identified an external URL.');
 
     // Test the parsing of absolute URLs.
     $result = array(
@@ -215,7 +215,7 @@ class CommonURLUnitTest extends DrupalWebTestCase {
       'query' => array('foo' => 'bar', 'bar' => 'baz', 'baz' => ''),
       'fragment' => 'foo',
     );
-    $this->assertEqual(drupal_parse_url($url), $result, t('External URL parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'External URL parsed correctly.');
 
     // Verify proper parsing of URLs when clean URLs are disabled.
     $result = array(
@@ -225,19 +225,19 @@ class CommonURLUnitTest extends DrupalWebTestCase {
     );
     // Non-clean URLs #1: Absolute URL generated by url().
     $url = $GLOBALS['base_url'] . '/?q=foo/bar&bar=baz#foo';
-    $this->assertEqual(drupal_parse_url($url), $result, t('Absolute URL with clean URLs disabled parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'Absolute URL with clean URLs disabled parsed correctly.');
 
     // Non-clean URLs #2: Relative URL generated by url().
     $url = '?q=foo/bar&bar=baz#foo';
-    $this->assertEqual(drupal_parse_url($url), $result, t('Relative URL with clean URLs disabled parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'Relative URL with clean URLs disabled parsed correctly.');
 
     // Non-clean URLs #3: URL generated by url() on non-Apache webserver.
     $url = 'index.php?q=foo/bar&bar=baz#foo';
-    $this->assertEqual(drupal_parse_url($url), $result, t('Relative URL on non-Apache webserver with clean URLs disabled parsed correctly.'));
+    $this->assertEqual(drupal_parse_url($url), $result, 'Relative URL on non-Apache webserver with clean URLs disabled parsed correctly.');
 
     // Test that drupal_parse_url() does not allow spoofing a URL to force a malicious redirect.
     $parts = drupal_parse_url('forged:http://cwe.mitre.org/data/definitions/601.html');
-    $this->assertFalse(valid_url($parts['path'], TRUE), t('drupal_parse_url() correctly parsed a forged URL.'));
+    $this->assertFalse(valid_url($parts['path'], TRUE), 'drupal_parse_url() correctly parsed a forged URL.');
   }
 
   /**
@@ -325,30 +325,30 @@ class CommonURLUnitTest extends DrupalWebTestCase {
     // Verify external URL can contain a fragment.
     $url = $test_url . '#drupal';
     $result = url($url);
-    $this->assertEqual($url, $result, t('External URL with fragment works without a fragment in $options.'));
+    $this->assertEqual($url, $result, 'External URL with fragment works without a fragment in $options.');
 
     // Verify fragment can be overidden in an external URL.
     $url = $test_url . '#drupal';
     $fragment = $this->randomName(10);
     $result = url($url, array('fragment' => $fragment));
-    $this->assertEqual($test_url . '#' . $fragment, $result, t('External URL fragment is overidden with a custom fragment in $options.'));
+    $this->assertEqual($test_url . '#' . $fragment, $result, 'External URL fragment is overidden with a custom fragment in $options.');
 
     // Verify external URL can contain a query string.
     $url = $test_url . '?drupal=awesome';
     $result = url($url);
-    $this->assertEqual($url, $result, t('External URL with query string works without a query string in $options.'));
+    $this->assertEqual($url, $result, 'External URL with query string works without a query string in $options.');
 
     // Verify external URL can be extended with a query string.
     $url = $test_url;
     $query = array($this->randomName(5) => $this->randomName(5));
     $result = url($url, array('query' => $query));
-    $this->assertEqual($url . '?' . http_build_query($query, '', '&'), $result, t('External URL can be extended with a query string in $options.'));
+    $this->assertEqual($url . '?' . http_build_query($query, '', '&'), $result, 'External URL can be extended with a query string in $options.');
 
     // Verify query string can be extended in an external URL.
     $url = $test_url . '?drupal=awesome';
     $query = array($this->randomName(5) => $this->randomName(5));
     $result = url($url, array('query' => $query));
-    $this->assertEqual($url . '&' . http_build_query($query, '', '&'), $result, t('External URL query string can be extended with a custom query string in $options.'));
+    $this->assertEqual($url . '&' . http_build_query($query, '', '&'), $result, 'External URL query string can be extended with a custom query string in $options.');
   }
 }
 
@@ -419,8 +419,8 @@ class CommonXssUnitTest extends DrupalUnitTestCase {
     $url = 'javascript:http://www.example.com/?x=1&y=2';
     $expected_plain = 'http://www.example.com/?x=1&y=2';
     $expected_html = 'http://www.example.com/?x=1&amp;y=2';
-    $this->assertIdentical(check_url($url), $expected_html, t('check_url() filters a URL and encodes it for HTML.'));
-    $this->assertIdentical(drupal_strip_dangerous_protocols($url), $expected_plain, t('drupal_strip_dangerous_protocols() filters a URL and returns plain text.'));
+    $this->assertIdentical(check_url($url), $expected_html, 'check_url() filters a URL and encodes it for HTML.');
+    $this->assertIdentical(drupal_strip_dangerous_protocols($url), $expected_plain, 'drupal_strip_dangerous_protocols() filters a URL and returns plain text.');
   }
 }
 
@@ -572,11 +572,11 @@ class DrupalTagsHandlingTestCase extends DrupalUnitTestCase {
     $original = $this->validTags;
     foreach ($tags as $tag) {
       $key = array_search($tag, $original);
-      $this->assertTrue($key, t('Make sure tag %tag shows up in the final tags array (originally %original)', array('%tag' => $tag, '%original' => $key)));
+      $this->assertTrue($key, format_string('Make sure tag %tag shows up in the final tags array (originally %original)', array('%tag' => $tag, '%original' => $key)));
       unset($original[$key]);
     }
     foreach ($original as $leftover) {
-      $this->fail(t('Leftover tag %leftover was left over.', array('%leftover' => $leftover)));
+      $this->fail(format_string('Leftover tag %leftover was left over.', array('%leftover' => $leftover)));
     }
   }
 }
@@ -603,7 +603,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
    * Check default stylesheets as empty.
    */
   function testDefault() {
-    $this->assertEqual(array(), drupal_add_css(), t('Default CSS is empty.'));
+    $this->assertEqual(array(), drupal_add_css(), 'Default CSS is empty.');
   }
 
   /**
@@ -633,7 +633,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
   function testAddFile() {
     $path = drupal_get_path('module', 'simpletest') . '/simpletest.css';
     $css = drupal_add_css($path);
-    $this->assertEqual($css[$path]['data'], $path, t('Adding a CSS file caches it properly.'));
+    $this->assertEqual($css[$path]['data'], $path, 'Adding a CSS file caches it properly.');
   }
 
   /**
@@ -642,7 +642,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
   function testAddExternal() {
     $path = 'http://example.com/style.css';
     $css = drupal_add_css($path, 'external');
-    $this->assertEqual($css[$path]['type'], 'external', t('Adding an external CSS file caches it properly.'));
+    $this->assertEqual($css[$path]['type'], 'external', 'Adding an external CSS file caches it properly.');
   }
 
   /**
@@ -650,7 +650,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
    */
   function testReset() {
     drupal_static_reset('drupal_add_css');
-    $this->assertEqual(array(), drupal_add_css(), t('Resetting the CSS empties the cache.'));
+    $this->assertEqual(array(), drupal_add_css(), 'Resetting the CSS empties the cache.');
   }
 
   /**
@@ -660,7 +660,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
     $css = drupal_get_path('module', 'simpletest') . '/simpletest.css';
     drupal_add_css($css);
     $styles = drupal_get_css();
-    $this->assertTrue(strpos($styles, $css) > 0, t('Rendered CSS includes the added stylesheet.'));
+    $this->assertTrue(strpos($styles, $css) > 0, 'Rendered CSS includes the added stylesheet.');
   }
 
   /**
@@ -672,7 +672,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
     $styles = drupal_get_css();
     // Stylesheet URL may be the href of a LINK tag or in an @import statement
     // of a STYLE tag.
-    $this->assertTrue(strpos($styles, 'href="' . $css) > 0 || strpos($styles, '@import url("' . $css . '")') > 0, t('Rendering an external CSS file.'));
+    $this->assertTrue(strpos($styles, 'href="' . $css) > 0 || strpos($styles, '@import url("' . $css . '")') > 0, 'Rendering an external CSS file.');
   }
 
   /**
@@ -683,7 +683,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
     $css_preprocessed = '<style type="text/css" media="all">' . "\n<!--/*--><![CDATA[/*><!--*/\n" . drupal_load_stylesheet_content($css, TRUE) . "\n/*]]>*/-->\n" . '</style>';
     drupal_add_css($css, array('type' => 'inline'));
     $styles = drupal_get_css();
-    $this->assertEqual(trim($styles), $css_preprocessed, t('Rendering preprocessed inline CSS adds it to the page.'));
+    $this->assertEqual(trim($styles), $css_preprocessed, 'Rendering preprocessed inline CSS adds it to the page.');
   }
 
   /**
@@ -693,7 +693,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
     $css = 'body { padding: 0px; }';
     drupal_add_css($css, array('type' => 'inline', 'preprocess' => FALSE));
     $styles = drupal_get_css();
-    $this->assertTrue(strpos($styles, $css) > 0, t('Rendering non-preprocessed inline CSS adds it to the page.'));
+    $this->assertTrue(strpos($styles, $css) > 0, 'Rendering non-preprocessed inline CSS adds it to the page.');
   }
 
   /**
@@ -723,7 +723,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
 
     // Fetch the page.
     $this->drupalGet('node/' . $node->nid);
-    $this->assertRaw($expected, t('Inline stylesheets appear in the full page rendering.'));
+    $this->assertRaw($expected, 'Inline stylesheets appear in the full page rendering.');
   }
 
   /**
@@ -756,7 +756,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
       $result = array();
     }
 
-    $this->assertIdentical($result, $expected, t('The CSS files are in the expected order.'));
+    $this->assertIdentical($result, $expected, 'The CSS files are in the expected order.');
   }
 
   /**
@@ -771,16 +771,16 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
 
     // The dummy stylesheet should be the only one included.
     $styles = drupal_get_css();
-    $this->assert(strpos($styles, $simpletest . '/tests/system.base.css') !== FALSE, t('The overriding CSS file is output.'));
-    $this->assert(strpos($styles, $system . '/system.base.css') === FALSE, t('The overridden CSS file is not output.'));
+    $this->assert(strpos($styles, $simpletest . '/tests/system.base.css') !== FALSE, 'The overriding CSS file is output.');
+    $this->assert(strpos($styles, $system . '/system.base.css') === FALSE, 'The overridden CSS file is not output.');
 
     drupal_add_css($simpletest . '/tests/system.base.css');
     drupal_add_css($system . '/system.base.css');
 
     // The standard stylesheet should be the only one included.
     $styles = drupal_get_css();
-    $this->assert(strpos($styles, $system . '/system.base.css') !== FALSE, t('The overriding CSS file is output.'));
-    $this->assert(strpos($styles, $simpletest . '/tests/system.base.css') === FALSE, t('The overridden CSS file is not output.'));
+    $this->assert(strpos($styles, $system . '/system.base.css') !== FALSE, 'The overriding CSS file is output.');
+    $this->assert(strpos($styles, $simpletest . '/tests/system.base.css') === FALSE, 'The overridden CSS file is not output.');
   }
 
   /**
@@ -795,7 +795,7 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
 
     // Check to see if system.base-rtl.css was also added.
     $styles = drupal_get_css();
-    $this->assert(strpos($styles, $path . '/system.base-rtl.css') !== FALSE, t('CSS is alterable as right to left overrides are added.'));
+    $this->assert(strpos($styles, $path . '/system.base-rtl.css') !== FALSE, 'CSS is alterable as right to left overrides are added.');
 
     // Change the language back to left to right.
     $language->direction = LANGUAGE_LTR;
@@ -808,8 +808,8 @@ class CascadingStylesheetsTestCase extends DrupalWebTestCase {
   function testAddCssFileWithQueryString() {
     $this->drupalGet('common-test/query-string');
     $query_string = variable_get('css_js_query_string', '0');
-    $this->assertRaw(drupal_get_path('module', 'node') . '/node.css?' . $query_string, t('Query string was appended correctly to css.'));
-    $this->assertRaw(drupal_get_path('module', 'node') . '/node-fake.css?arg1=value1&amp;arg2=value2', t('Query string not escaped on a URI.'));
+    $this->assertRaw(drupal_get_path('module', 'node') . '/node.css?' . $query_string, 'Query string was appended correctly to css.');
+    $this->assertRaw(drupal_get_path('module', 'node') . '/node-fake.css?arg1=value1&amp;arg2=value2', 'Query string not escaped on a URI.');
   }
 }
 
@@ -831,14 +831,14 @@ class DrupalHTMLIdentifierTestCase extends DrupalUnitTestCase {
   function testDrupalCleanCSSIdentifier() {
     // Verify that no valid ASCII characters are stripped from the identifier.
     $identifier = 'abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ-0123456789';
-    $this->assertIdentical(drupal_clean_css_identifier($identifier, array()), $identifier, t('Verify valid ASCII characters pass through.'));
+    $this->assertIdentical(drupal_clean_css_identifier($identifier, array()), $identifier, 'Verify valid ASCII characters pass through.');
 
     // Verify that valid UTF-8 characters are not stripped from the identifier.
     $identifier = '¡¢£¤¥';
-    $this->assertIdentical(drupal_clean_css_identifier($identifier, array()), $identifier, t('Verify valid UTF-8 characters pass through.'));
+    $this->assertIdentical(drupal_clean_css_identifier($identifier, array()), $identifier, 'Verify valid UTF-8 characters pass through.');
 
     // Verify that invalid characters (including non-breaking space) are stripped from the identifier.
-    $this->assertIdentical(drupal_clean_css_identifier('invalid !"#$%&\'()*+,./:;<=>?@[\\]^`{|}~ identifier', array()), 'invalididentifier', t('Strip invalid characters.'));
+    $this->assertIdentical(drupal_clean_css_identifier('invalid !"#$%&\'()*+,./:;<=>?@[\\]^`{|}~ identifier', array()), 'invalididentifier', 'Strip invalid characters.');
   }
 
   /**
@@ -846,7 +846,7 @@ class DrupalHTMLIdentifierTestCase extends DrupalUnitTestCase {
    */
   function testDrupalHTMLClass() {
     // Verify Drupal coding standards are enforced.
-    $this->assertIdentical(drupal_html_class('CLASS NAME_[Ü]'), 'class-name--ü', t('Enforce Drupal coding standards.'));
+    $this->assertIdentical(drupal_html_class('CLASS NAME_[Ü]'), 'class-name--ü', 'Enforce Drupal coding standards.');
   }
 
   /**
@@ -855,21 +855,21 @@ class DrupalHTMLIdentifierTestCase extends DrupalUnitTestCase {
   function testDrupalHTMLId() {
     // Verify that letters, digits, and hyphens are not stripped from the ID.
     $id = 'abcdefghijklmnopqrstuvwxyz-0123456789';
-    $this->assertIdentical(drupal_html_id($id), $id, t('Verify valid characters pass through.'));
+    $this->assertIdentical(drupal_html_id($id), $id, 'Verify valid characters pass through.');
 
     // Verify that invalid characters are stripped from the ID.
-    $this->assertIdentical(drupal_html_id('invalid,./:@\\^`{Üidentifier'), 'invalididentifier', t('Strip invalid characters.'));
+    $this->assertIdentical(drupal_html_id('invalid,./:@\\^`{Üidentifier'), 'invalididentifier', 'Strip invalid characters.');
 
     // Verify Drupal coding standards are enforced.
-    $this->assertIdentical(drupal_html_id('ID NAME_[1]'), 'id-name-1', t('Enforce Drupal coding standards.'));
+    $this->assertIdentical(drupal_html_id('ID NAME_[1]'), 'id-name-1', 'Enforce Drupal coding standards.');
 
     // Reset the static cache so we can ensure the unique id count is at zero.
     drupal_static_reset('drupal_html_id');
 
     // Clean up IDs with invalid starting characters.
-    $this->assertIdentical(drupal_html_id('test-unique-id'), 'test-unique-id', t('Test the uniqueness of IDs #1.'));
-    $this->assertIdentical(drupal_html_id('test-unique-id'), 'test-unique-id--2', t('Test the uniqueness of IDs #2.'));
-    $this->assertIdentical(drupal_html_id('test-unique-id'), 'test-unique-id--3', t('Test the uniqueness of IDs #3.'));
+    $this->assertIdentical(drupal_html_id('test-unique-id'), 'test-unique-id', 'Test the uniqueness of IDs #1.');
+    $this->assertIdentical(drupal_html_id('test-unique-id'), 'test-unique-id--2', 'Test the uniqueness of IDs #2.');
+    $this->assertIdentical(drupal_html_id('test-unique-id'), 'test-unique-id--3', 'Test the uniqueness of IDs #3.');
   }
 }
 
@@ -907,20 +907,20 @@ class CascadingStylesheetsUnitTest extends DrupalUnitTestCase {
     foreach ($testfiles as $file) {
       $expected = file_get_contents("$path/$file.unoptimized.css");
       $unoptimized_output = drupal_load_stylesheet("$path/$file.unoptimized.css", FALSE);
-      $this->assertEqual($unoptimized_output, $expected, t('Unoptimized CSS file has expected contents (@file)', array('@file' => $file)));
+      $this->assertEqual($unoptimized_output, $expected, format_string('Unoptimized CSS file has expected contents (@file)', array('@file' => $file)));
 
       $expected = file_get_contents("$path/$file.optimized.css");
       $optimized_output = drupal_load_stylesheet("$path/$file", TRUE);
-      $this->assertEqual($optimized_output, $expected, t('Optimized CSS file has expected contents (@file)', array('@file' => $file)));
+      $this->assertEqual($optimized_output, $expected, format_string('Optimized CSS file has expected contents (@file)', array('@file' => $file)));
 
       // Repeat the tests by accessing the stylesheets by URL.
       $expected = file_get_contents("$path/$file.unoptimized.css");
       $unoptimized_output_url = drupal_load_stylesheet($GLOBALS['base_url'] . "/$path/$file.unoptimized.css", FALSE);
-      $this->assertEqual($unoptimized_output, $expected, t('Unoptimized CSS file (loaded from an URL) has expected contents (@file)', array('@file' => $file)));
+      $this->assertEqual($unoptimized_output, $expected, format_string('Unoptimized CSS file (loaded from an URL) has expected contents (@file)', array('@file' => $file)));
 
       $expected = file_get_contents("$path/$file.optimized.css");
       $optimized_output = drupal_load_stylesheet($GLOBALS['base_url'] . "/$path/$file", TRUE);
-      $this->assertEqual($optimized_output, $expected, t('Optimized CSS file (loaded from an URL) has expected contents (@file)', array('@file' => $file)));
+      $this->assertEqual($optimized_output, $expected, format_string('Optimized CSS file (loaded from an URL) has expected contents (@file)', array('@file' => $file)));
     }
   }
 }
@@ -946,24 +946,24 @@ class DrupalHTTPRequestTestCase extends DrupalWebTestCase {
 
     // Parse URL schema.
     $missing_scheme = drupal_http_request('example.com/path');
-    $this->assertEqual($missing_scheme->code, -1002, t('Returned with "-1002" error code.'));
-    $this->assertEqual($missing_scheme->error, 'missing schema', t('Returned with "missing schema" error message.'));
+    $this->assertEqual($missing_scheme->code, -1002, 'Returned with "-1002" error code.');
+    $this->assertEqual($missing_scheme->error, 'missing schema', 'Returned with "missing schema" error message.');
 
     $unable_to_parse = drupal_http_request('http:///path');
-    $this->assertEqual($unable_to_parse->code, -1001, t('Returned with "-1001" error code.'));
-    $this->assertEqual($unable_to_parse->error, 'unable to parse URL', t('Returned with "unable to parse URL" error message.'));
+    $this->assertEqual($unable_to_parse->code, -1001, 'Returned with "-1001" error code.');
+    $this->assertEqual($unable_to_parse->error, 'unable to parse URL', 'Returned with "unable to parse URL" error message.');
 
     // Fetch page.
     $result = drupal_http_request(url('node', array('absolute' => TRUE)));
-    $this->assertEqual($result->code, 200, t('Fetched page successfully.'));
+    $this->assertEqual($result->code, 200, 'Fetched page successfully.');
     $this->drupalSetContent($result->data);
-    $this->assertTitle(t('Welcome to @site-name | @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), t('Site title matches.'));
+    $this->assertTitle(t('Welcome to @site-name | @site-name', array('@site-name' => variable_get('site_name', 'Drupal'))), 'Site title matches.');
 
     // Test that code and status message is returned.
     $result = drupal_http_request(url('pagedoesnotexist', array('absolute' => TRUE)));
-    $this->assertTrue(!empty($result->protocol),  t('Result protocol is returned.'));
-    $this->assertEqual($result->code, '404', t('Result code is 404'));
-    $this->assertEqual($result->status_message, 'Not Found', t('Result status message is "Not Found"'));
+    $this->assertTrue(!empty($result->protocol),  'Result protocol is returned.');
+    $this->assertEqual($result->code, '404', 'Result code is 404');
+    $this->assertEqual($result->status_message, 'Not Found', 'Result status message is "Not Found"');
 
     // Skip the timeout tests when the testing environment is HTTPS because
     // stream_set_timeout() does not work for SSL connections.
@@ -978,9 +978,9 @@ class DrupalHTTPRequestTestCase extends DrupalWebTestCase {
       timer_start(__METHOD__);
       $result = drupal_http_request(url('system-test/sleep/10', array('absolute' => TRUE)), array('timeout' => 2));
       $time = timer_read(__METHOD__) / 1000;
-      $this->assertTrue(1.8 < $time && $time < 5, t('Request timed out (%time seconds).', array('%time' => $time)));
-      $this->assertTrue($result->error, t('An error message was returned.'));
-      $this->assertEqual($result->code, HTTP_REQUEST_TIMEOUT, t('Proper error code was returned.'));
+      $this->assertTrue(1.8 < $time && $time < 5, format_string('Request timed out (%time seconds).', array('%time' => $time)));
+      $this->assertTrue($result->error, 'An error message was returned.');
+      $this->assertEqual($result->code, HTTP_REQUEST_TIMEOUT, 'Proper error code was returned.');
     }
   }
 
@@ -993,47 +993,47 @@ class DrupalHTTPRequestTestCase extends DrupalWebTestCase {
     $result = drupal_http_request($auth);
 
     $this->drupalSetContent($result->data);
-    $this->assertRaw($username, t('$_SERVER["PHP_AUTH_USER"] is passed correctly.'));
-    $this->assertRaw($password, t('$_SERVER["PHP_AUTH_PW"] is passed correctly.'));
+    $this->assertRaw($username, '$_SERVER["PHP_AUTH_USER"] is passed correctly.');
+    $this->assertRaw($password, '$_SERVER["PHP_AUTH_PW"] is passed correctly.');
   }
 
   function testDrupalHTTPRequestRedirect() {
     $redirect_301 = drupal_http_request(url('system-test/redirect/301', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($redirect_301->redirect_code, 301, t('drupal_http_request follows the 301 redirect.'));
+    $this->assertEqual($redirect_301->redirect_code, 301, 'drupal_http_request follows the 301 redirect.');
 
     $redirect_301 = drupal_http_request(url('system-test/redirect/301', array('absolute' => TRUE)), array('max_redirects' => 0));
-    $this->assertFalse(isset($redirect_301->redirect_code), t('drupal_http_request does not follow 301 redirect if max_redirects = 0.'));
+    $this->assertFalse(isset($redirect_301->redirect_code), 'drupal_http_request does not follow 301 redirect if max_redirects = 0.');
 
     $redirect_invalid = drupal_http_request(url('system-test/redirect-noscheme', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($redirect_invalid->code, -1002, t('301 redirect to invalid URL returned with error code !error.', array('!error' => $redirect_invalid->error)));
-    $this->assertEqual($redirect_invalid->error, 'missing schema', t('301 redirect to invalid URL returned with error message "!error".', array('!error' => $redirect_invalid->error)));
+    $this->assertEqual($redirect_invalid->code, -1002, format_string('301 redirect to invalid URL returned with error code !error.', array('!error' => $redirect_invalid->error)));
+    $this->assertEqual($redirect_invalid->error, 'missing schema', format_string('301 redirect to invalid URL returned with error message "!error".', array('!error' => $redirect_invalid->error)));
 
     $redirect_invalid = drupal_http_request(url('system-test/redirect-noparse', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($redirect_invalid->code, -1001, t('301 redirect to invalid URL returned with error message code "!error".', array('!error' => $redirect_invalid->error)));
-    $this->assertEqual($redirect_invalid->error, 'unable to parse URL', t('301 redirect to invalid URL returned with error message "!error".', array('!error' => $redirect_invalid->error)));
+    $this->assertEqual($redirect_invalid->code, -1001, format_string('301 redirect to invalid URL returned with error message code "!error".', array('!error' => $redirect_invalid->error)));
+    $this->assertEqual($redirect_invalid->error, 'unable to parse URL', format_string('301 redirect to invalid URL returned with error message "!error".', array('!error' => $redirect_invalid->error)));
 
     $redirect_invalid = drupal_http_request(url('system-test/redirect-invalid-scheme', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($redirect_invalid->code, -1003, t('301 redirect to invalid URL returned with error code !error.', array('!error' => $redirect_invalid->error)));
-    $this->assertEqual($redirect_invalid->error, 'invalid schema ftp', t('301 redirect to invalid URL returned with error message "!error".', array('!error' => $redirect_invalid->error)));
+    $this->assertEqual($redirect_invalid->code, -1003, format_string('301 redirect to invalid URL returned with error code !error.', array('!error' => $redirect_invalid->error)));
+    $this->assertEqual($redirect_invalid->error, 'invalid schema ftp', format_string('301 redirect to invalid URL returned with error message "!error".', array('!error' => $redirect_invalid->error)));
 
     $redirect_302 = drupal_http_request(url('system-test/redirect/302', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($redirect_302->redirect_code, 302, t('drupal_http_request follows the 302 redirect.'));
+    $this->assertEqual($redirect_302->redirect_code, 302, 'drupal_http_request follows the 302 redirect.');
 
     $redirect_302 = drupal_http_request(url('system-test/redirect/302', array('absolute' => TRUE)), array('max_redirects' => 0));
-    $this->assertFalse(isset($redirect_302->redirect_code), t('drupal_http_request does not follow 302 redirect if $retry = 0.'));
+    $this->assertFalse(isset($redirect_302->redirect_code), 'drupal_http_request does not follow 302 redirect if $retry = 0.');
 
     $redirect_307 = drupal_http_request(url('system-test/redirect/307', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($redirect_307->redirect_code, 307, t('drupal_http_request follows the 307 redirect.'));
+    $this->assertEqual($redirect_307->redirect_code, 307, 'drupal_http_request follows the 307 redirect.');
 
     $redirect_307 = drupal_http_request(url('system-test/redirect/307', array('absolute' => TRUE)), array('max_redirects' => 0));
-    $this->assertFalse(isset($redirect_307->redirect_code), t('drupal_http_request does not follow 307 redirect if max_redirects = 0.'));
+    $this->assertFalse(isset($redirect_307->redirect_code), 'drupal_http_request does not follow 307 redirect if max_redirects = 0.');
 
     $multiple_redirect_final_url = url('system-test/multiple-redirects/0', array('absolute' => TRUE));
     $multiple_redirect_1 = drupal_http_request(url('system-test/multiple-redirects/1', array('absolute' => TRUE)), array('max_redirects' => 1));
-    $this->assertEqual($multiple_redirect_1->redirect_url, $multiple_redirect_final_url, t('redirect_url contains the final redirection location after 1 redirect.'));
+    $this->assertEqual($multiple_redirect_1->redirect_url, $multiple_redirect_final_url, 'redirect_url contains the final redirection location after 1 redirect.');
 
     $multiple_redirect_3 = drupal_http_request(url('system-test/multiple-redirects/3', array('absolute' => TRUE)), array('max_redirects' => 3));
-    $this->assertEqual($multiple_redirect_3->redirect_url, $multiple_redirect_final_url, t('redirect_url contains the final redirection location after 3 redirects.'));
+    $this->assertEqual($multiple_redirect_3->redirect_url, $multiple_redirect_final_url, 'redirect_url contains the final redirection location after 3 redirects.');
   }
 
   /**
@@ -1088,13 +1088,13 @@ class DrupalSetContentTestCase extends DrupalWebTestCase {
     // Ensure drupal_get_region_content returns expected results when fetching all regions.
     $content = drupal_get_region_content(NULL, $delimiter);
     foreach ($content as $region => $region_content) {
-      $this->assertEqual($region_content, $values[$region], t('@region region text verified when fetching all regions', array('@region' => $region)));
+      $this->assertEqual($region_content, $values[$region], format_string('@region region text verified when fetching all regions', array('@region' => $region)));
     }
 
     // Ensure drupal_get_region_content returns expected results when fetching a single region.
     foreach ($block_regions as $region) {
       $region_content = drupal_get_region_content($region, $delimiter);
-      $this->assertEqual($region_content, $values[$region], t('@region region text verified when fetching single region.', array('@region' => $region)));
+      $this->assertEqual($region_content, $values[$region], format_string('@region region text verified when fetching single region.', array('@region' => $region)));
     }
   }
 }
@@ -1122,23 +1122,23 @@ class DrupalGotoTest extends DrupalWebTestCase {
     $this->drupalGet('common-test/drupal_goto/redirect');
     $headers = $this->drupalGetHeaders(TRUE);
     list(, $status) = explode(' ', $headers[0][':status'], 3);
-    $this->assertEqual($status, 302, t('Expected response code was sent.'));
-    $this->assertText('drupal_goto', t('Drupal goto redirect succeeded.'));
-    $this->assertEqual($this->getUrl(), url('common-test/drupal_goto', array('absolute' => TRUE)), t('Drupal goto redirected to expected URL.'));
+    $this->assertEqual($status, 302, 'Expected response code was sent.');
+    $this->assertText('drupal_goto', 'Drupal goto redirect succeeded.');
+    $this->assertEqual($this->getUrl(), url('common-test/drupal_goto', array('absolute' => TRUE)), 'Drupal goto redirected to expected URL.');
 
     $this->drupalGet('common-test/drupal_goto/redirect_advanced');
     $headers = $this->drupalGetHeaders(TRUE);
     list(, $status) = explode(' ', $headers[0][':status'], 3);
-    $this->assertEqual($status, 301, t('Expected response code was sent.'));
-    $this->assertText('drupal_goto', t('Drupal goto redirect succeeded.'));
-    $this->assertEqual($this->getUrl(), url('common-test/drupal_goto', array('query' => array('foo' => '123'), 'absolute' => TRUE)), t('Drupal goto redirected to expected URL.'));
+    $this->assertEqual($status, 301, 'Expected response code was sent.');
+    $this->assertText('drupal_goto', 'Drupal goto redirect succeeded.');
+    $this->assertEqual($this->getUrl(), url('common-test/drupal_goto', array('query' => array('foo' => '123'), 'absolute' => TRUE)), 'Drupal goto redirected to expected URL.');
 
     // Test that drupal_goto() respects ?destination=xxx. Use an complicated URL
     // to test that the path is encoded and decoded properly.
     $destination = 'common-test/drupal_goto/destination?foo=%2525&bar=123';
     $this->drupalGet('common-test/drupal_goto/redirect', array('query' => array('destination' => $destination)));
-    $this->assertText('drupal_goto', t('Drupal goto redirect with destination succeeded.'));
-    $this->assertEqual($this->getUrl(), url('common-test/drupal_goto/destination', array('query' => array('foo' => '%25', 'bar' => '123'), 'absolute' => TRUE)), t('Drupal goto redirected to given query string destination.'));
+    $this->assertText('drupal_goto', 'Drupal goto redirect with destination succeeded.');
+    $this->assertEqual($this->getUrl(), url('common-test/drupal_goto/destination', array('query' => array('foo' => '%25', 'bar' => '123'), 'absolute' => TRUE)), 'Drupal goto redirected to given query string destination.');
   }
 
   /**
@@ -1147,8 +1147,8 @@ class DrupalGotoTest extends DrupalWebTestCase {
   function testDrupalGotoAlter() {
     $this->drupalGet('common-test/drupal_goto/redirect_fail');
 
-    $this->assertNoText(t("Drupal goto failed to stop program"), t("Drupal goto stopped program."));
-    $this->assertNoText('drupal_goto_fail', t("Drupal goto redirect failed."));
+    $this->assertNoText(t("Drupal goto failed to stop program"), "Drupal goto stopped program.");
+    $this->assertNoText('drupal_goto_fail', "Drupal goto redirect failed.");
   }
 
   /**
@@ -1159,12 +1159,12 @@ class DrupalGotoTest extends DrupalWebTestCase {
 
     // Verify that a 'destination' query string is used as destination.
     $this->drupalGet('common-test/destination', array('query' => array('destination' => $query)));
-    $this->assertText('The destination: ' . $query, t('The given query string destination is determined as destination.'));
+    $this->assertText('The destination: ' . $query, 'The given query string destination is determined as destination.');
 
     // Verify that the current path is used as destination.
     $this->drupalGet('common-test/destination', array('query' => array($query => NULL)));
     $url = 'common-test/destination?' . $query;
-    $this->assertText('The destination: ' . $url, t('The current path is determined as destination.'));
+    $this->assertText('The destination: ' . $url, 'The current path is determined as destination.');
   }
 }
 
@@ -1208,7 +1208,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    * Test default JavaScript is empty.
    */
   function testDefault() {
-    $this->assertEqual(array(), drupal_add_js(), t('Default JavaScript is empty.'));
+    $this->assertEqual(array(), drupal_add_js(), 'Default JavaScript is empty.');
   }
 
   /**
@@ -1216,12 +1216,12 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testAddFile() {
     $javascript = drupal_add_js('misc/collapse.js');
-    $this->assertTrue(array_key_exists('misc/jquery.js', $javascript), t('jQuery is added when a file is added.'));
-    $this->assertTrue(array_key_exists('misc/drupal.js', $javascript), t('Drupal.js is added when file is added.'));
-    $this->assertTrue(array_key_exists('misc/collapse.js', $javascript), t('JavaScript files are correctly added.'));
-    $this->assertEqual(base_path(), $javascript['settings']['data'][0]['basePath'], t('Base path JavaScript setting is correctly set.'));
+    $this->assertTrue(array_key_exists('misc/jquery.js', $javascript), 'jQuery is added when a file is added.');
+    $this->assertTrue(array_key_exists('misc/drupal.js', $javascript), 'Drupal.js is added when file is added.');
+    $this->assertTrue(array_key_exists('misc/collapse.js', $javascript), 'JavaScript files are correctly added.');
+    $this->assertEqual(base_path(), $javascript['settings']['data'][0]['basePath'], 'Base path JavaScript setting is correctly set.');
     url('', array('prefix' => &$prefix));
-    $this->assertEqual(empty($prefix) ? '' : $prefix, $javascript['settings']['data'][1]['pathPrefix'], t('Path prefix JavaScript setting is correctly set.'));
+    $this->assertEqual(empty($prefix) ? '' : $prefix, $javascript['settings']['data'][1]['pathPrefix'], 'Path prefix JavaScript setting is correctly set.');
   }
 
   /**
@@ -1229,8 +1229,8 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testAddSetting() {
     $javascript = drupal_add_js(array('drupal' => 'rocks', 'dries' => 280342800), 'setting');
-    $this->assertEqual(280342800, $javascript['settings']['data'][2]['dries'], t('JavaScript setting is set correctly.'));
-    $this->assertEqual('rocks', $javascript['settings']['data'][2]['drupal'], t('The other JavaScript setting is set correctly.'));
+    $this->assertEqual(280342800, $javascript['settings']['data'][2]['dries'], 'JavaScript setting is set correctly.');
+    $this->assertEqual('rocks', $javascript['settings']['data'][2]['drupal'], 'The other JavaScript setting is set correctly.');
   }
 
   /**
@@ -1239,7 +1239,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
   function testAddExternal() {
     $path = 'http://example.com/script.js';
     $javascript = drupal_add_js($path, 'external');
-    $this->assertTrue(array_key_exists('http://example.com/script.js', $javascript), t('Added an external JavaScript file.'));
+    $this->assertTrue(array_key_exists('http://example.com/script.js', $javascript), 'Added an external JavaScript file.');
   }
 
   /**
@@ -1258,23 +1258,23 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     drupal_add_js(array('commonTestArray' => array('key' => 'commonTestNewValue')), 'setting');
 
     $javascript = drupal_get_js('header');
-    $this->assertTrue(strpos($javascript, 'basePath') > 0, t('Rendered JavaScript header returns basePath setting.'));
-    $this->assertTrue(strpos($javascript, 'misc/jquery.js') > 0, t('Rendered JavaScript header includes jQuery.'));
-    $this->assertTrue(strpos($javascript, 'pathPrefix') > 0, t('Rendered JavaScript header returns pathPrefix setting.'));
+    $this->assertTrue(strpos($javascript, 'basePath') > 0, 'Rendered JavaScript header returns basePath setting.');
+    $this->assertTrue(strpos($javascript, 'misc/jquery.js') > 0, 'Rendered JavaScript header includes jQuery.');
+    $this->assertTrue(strpos($javascript, 'pathPrefix') > 0, 'Rendered JavaScript header returns pathPrefix setting.');
 
     // Test whether drupal_add_js can be used to override a previous setting.
-    $this->assertTrue(strpos($javascript, 'commonTestShouldAppear') > 0, t('Rendered JavaScript header returns custom setting.'));
-    $this->assertTrue(strpos($javascript, 'commonTestShouldNotAppear') === FALSE, t('drupal_add_js() correctly overrides a custom setting.'));
+    $this->assertTrue(strpos($javascript, 'commonTestShouldAppear') > 0, 'Rendered JavaScript header returns custom setting.');
+    $this->assertTrue(strpos($javascript, 'commonTestShouldNotAppear') === FALSE, 'drupal_add_js() correctly overrides a custom setting.');
 
     // Test whether drupal_add_js can be used to add numerically indexed values
     // to an array.
     $array_values_appear = strpos($javascript, 'commonTestValue0') > 0 && strpos($javascript, 'commonTestValue1') > 0 && strpos($javascript, 'commonTestValue2') > 0;
-    $this->assertTrue($array_values_appear, t('drupal_add_js() correctly adds settings to the end of an indexed array.'));
+    $this->assertTrue($array_values_appear, 'drupal_add_js() correctly adds settings to the end of an indexed array.');
 
     // Test whether drupal_add_js can be used to override the entry for an
     // existing key in an associative array.
     $associative_array_override = strpos($javascript, 'commonTestNewValue') > 0 && strpos($javascript, 'commonTestOldValue') === FALSE;
-    $this->assertTrue($associative_array_override, t('drupal_add_js() correctly overrides settings within an associative array.'));
+    $this->assertTrue($associative_array_override, 'drupal_add_js() correctly overrides settings within an associative array.');
   }
 
   /**
@@ -1283,7 +1283,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
   function testReset() {
     drupal_add_js('misc/collapse.js');
     drupal_static_reset('drupal_add_js');
-    $this->assertEqual(array(), drupal_add_js(), t('Resetting the JavaScript correctly empties the cache.'));
+    $this->assertEqual(array(), drupal_add_js(), 'Resetting the JavaScript correctly empties the cache.');
   }
 
   /**
@@ -1292,9 +1292,9 @@ class JavaScriptTestCase extends DrupalWebTestCase {
   function testAddInline() {
     $inline = 'jQuery(function () { });';
     $javascript = drupal_add_js($inline, array('type' => 'inline', 'scope' => 'footer'));
-    $this->assertTrue(array_key_exists('misc/jquery.js', $javascript), t('jQuery is added when inline scripts are added.'));
+    $this->assertTrue(array_key_exists('misc/jquery.js', $javascript), 'jQuery is added when inline scripts are added.');
     $data = end($javascript);
-    $this->assertEqual($inline, $data['data'], t('Inline JavaScript is correctly added to the footer.'));
+    $this->assertEqual($inline, $data['data'], 'Inline JavaScript is correctly added to the footer.');
   }
 
   /**
@@ -1305,7 +1305,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     drupal_add_js($external, 'external');
     $javascript = drupal_get_js();
     // Local files have a base_path() prefix, external files should not.
-    $this->assertTrue(strpos($javascript, 'src="' . $external) > 0, t('Rendering an external JavaScript file.'));
+    $this->assertTrue(strpos($javascript, 'src="' . $external) > 0, 'Rendering an external JavaScript file.');
   }
 
   /**
@@ -1315,7 +1315,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     $inline = 'jQuery(function () { });';
     drupal_add_js($inline, array('type' => 'inline', 'scope' => 'footer'));
     $javascript = drupal_get_js('footer');
-    $this->assertTrue(strpos($javascript, $inline) > 0, t('Rendered JavaScript footer returns the inline code.'));
+    $this->assertTrue(strpos($javascript, $inline) > 0, 'Rendered JavaScript footer returns the inline code.');
   }
 
   /**
@@ -1323,7 +1323,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testNoCache() {
     $javascript = drupal_add_js('misc/collapse.js', array('cache' => FALSE));
-    $this->assertFalse($javascript['misc/collapse.js']['preprocess'], t('Setting cache to FALSE sets proprocess to FALSE when adding JavaScript.'));
+    $this->assertFalse($javascript['misc/collapse.js']['preprocess'], 'Setting cache to FALSE sets proprocess to FALSE when adding JavaScript.');
   }
 
   /**
@@ -1331,7 +1331,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testDifferentGroup() {
     $javascript = drupal_add_js('misc/collapse.js', array('group' => JS_THEME));
-    $this->assertEqual($javascript['misc/collapse.js']['group'], JS_THEME, t('Adding a JavaScript file with a different group caches the given group.'));
+    $this->assertEqual($javascript['misc/collapse.js']['group'], JS_THEME, 'Adding a JavaScript file with a different group caches the given group.');
   }
 
   /**
@@ -1339,7 +1339,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testDifferentWeight() {
     $javascript = drupal_add_js('misc/collapse.js', array('weight' => 2));
-    $this->assertEqual($javascript['misc/collapse.js']['weight'], 2, t('Adding a JavaScript file with a different weight caches the given weight.'));
+    $this->assertEqual($javascript['misc/collapse.js']['weight'], 2, 'Adding a JavaScript file with a different weight caches the given weight.');
   }
 
   /**
@@ -1423,7 +1423,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     else {
       $result = array();
     }
-    $this->assertIdentical($result, $expected, t('JavaScript is added in the expected weight order.'));
+    $this->assertIdentical($result, $expected, 'JavaScript is added in the expected weight order.');
   }
 
   /**
@@ -1435,7 +1435,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     // weight, we need the other two options to be the same.
     drupal_add_js('misc/collapse.js', array('group' => JS_LIBRARY, 'every_page' => TRUE, 'weight' => -21));
     $javascript = drupal_get_js();
-    $this->assertTrue(strpos($javascript, 'misc/collapse.js') < strpos($javascript, 'misc/jquery.js'), t('Rendering a JavaScript file above jQuery.'));
+    $this->assertTrue(strpos($javascript, 'misc/collapse.js') < strpos($javascript, 'misc/jquery.js'), 'Rendering a JavaScript file above jQuery.');
   }
 
   /**
@@ -1452,7 +1452,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     // tableselect.js. See simpletest_js_alter() to see where this alteration
     // takes place.
     $javascript = drupal_get_js();
-    $this->assertTrue(strpos($javascript, 'simpletest.js') < strpos($javascript, 'misc/tableselect.js'), t('Altering JavaScript weight through the alter hook.'));
+    $this->assertTrue(strpos($javascript, 'simpletest.js') < strpos($javascript, 'misc/tableselect.js'), 'Altering JavaScript weight through the alter hook.');
   }
 
   /**
@@ -1460,11 +1460,11 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testLibraryRender() {
     $result = drupal_add_library('system', 'farbtastic');
-    $this->assertTrue($result !== FALSE, t('Library was added without errors.'));
+    $this->assertTrue($result !== FALSE, 'Library was added without errors.');
     $scripts = drupal_get_js();
     $styles = drupal_get_css();
-    $this->assertTrue(strpos($scripts, 'misc/farbtastic/farbtastic.js'), t('JavaScript of library was added to the page.'));
-    $this->assertTrue(strpos($styles, 'misc/farbtastic/farbtastic.css'), t('Stylesheet of library was added to the page.'));
+    $this->assertTrue(strpos($scripts, 'misc/farbtastic/farbtastic.js'), 'JavaScript of library was added to the page.');
+    $this->assertTrue(strpos($styles, 'misc/farbtastic/farbtastic.css'), 'Stylesheet of library was added to the page.');
   }
 
   /**
@@ -1475,12 +1475,12 @@ class JavaScriptTestCase extends DrupalWebTestCase {
   function testLibraryAlter() {
     // Verify that common_test altered the title of Farbtastic.
     $library = drupal_get_library('system', 'farbtastic');
-    $this->assertEqual($library['title'], 'Farbtastic: Altered Library', t('Registered libraries were altered.'));
+    $this->assertEqual($library['title'], 'Farbtastic: Altered Library', 'Registered libraries were altered.');
 
     // common_test_library_alter() also added a dependency on jQuery Form.
     drupal_add_library('system', 'farbtastic');
     $scripts = drupal_get_js();
-    $this->assertTrue(strpos($scripts, 'misc/jquery.form.js'), t('Altered library dependencies are added to the page.'));
+    $this->assertTrue(strpos($scripts, 'misc/jquery.form.js'), 'Altered library dependencies are added to the page.');
   }
 
   /**
@@ -1490,7 +1490,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testLibraryNameConflicts() {
     $farbtastic = drupal_get_library('common_test', 'farbtastic');
-    $this->assertEqual($farbtastic['title'], 'Custom Farbtastic Library', t('Alternative libraries can be added to the page.'));
+    $this->assertEqual($farbtastic['title'], 'Custom Farbtastic Library', 'Alternative libraries can be added to the page.');
   }
 
   /**
@@ -1498,13 +1498,13 @@ class JavaScriptTestCase extends DrupalWebTestCase {
    */
   function testLibraryUnknown() {
     $result = drupal_get_library('unknown', 'unknown');
-    $this->assertFalse($result, t('Unknown library returned FALSE.'));
+    $this->assertFalse($result, 'Unknown library returned FALSE.');
     drupal_static_reset('drupal_get_library');
 
     $result = drupal_add_library('unknown', 'unknown');
-    $this->assertFalse($result, t('Unknown library returned FALSE.'));
+    $this->assertFalse($result, 'Unknown library returned FALSE.');
     $scripts = drupal_get_js();
-    $this->assertTrue(strpos($scripts, 'unknown') === FALSE, t('Unknown library was not added to the page.'));
+    $this->assertTrue(strpos($scripts, 'unknown') === FALSE, 'Unknown library was not added to the page.');
   }
 
   /**
@@ -1514,7 +1514,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
     $element['#attached']['library'][] = array('system', 'farbtastic');
     drupal_render($element);
     $scripts = drupal_get_js();
-    $this->assertTrue(strpos($scripts, 'misc/farbtastic/farbtastic.js'), t('The attached_library property adds the additional libraries.'));
+    $this->assertTrue(strpos($scripts, 'misc/farbtastic/farbtastic.js'), 'The attached_library property adds the additional libraries.');
   }
 
   /**
@@ -1523,18 +1523,18 @@ class JavaScriptTestCase extends DrupalWebTestCase {
   function testGetLibrary() {
     // Retrieve all libraries registered by a module.
     $libraries = drupal_get_library('common_test');
-    $this->assertTrue(isset($libraries['farbtastic']), t('Retrieved all module libraries.'));
+    $this->assertTrue(isset($libraries['farbtastic']), 'Retrieved all module libraries.');
     // Retrieve all libraries for a module not implementing hook_library().
     // Note: This test installs Locale module.
     $libraries = drupal_get_library('locale');
-    $this->assertEqual($libraries, array(), t('Retrieving libraries from a module not implementing hook_library() returns an emtpy array.'));
+    $this->assertEqual($libraries, array(), 'Retrieving libraries from a module not implementing hook_library() returns an emtpy array.');
 
     // Retrieve a specific library by module and name.
     $farbtastic = drupal_get_library('common_test', 'farbtastic');
-    $this->assertEqual($farbtastic['version'], '5.3', t('Retrieved a single library.'));
+    $this->assertEqual($farbtastic['version'], '5.3', 'Retrieved a single library.');
     // Retrieve a non-existing library by module and name.
     $farbtastic = drupal_get_library('common_test', 'foo');
-    $this->assertIdentical($farbtastic, FALSE, t('Retrieving a non-existing library returns FALSE.'));
+    $this->assertIdentical($farbtastic, FALSE, 'Retrieving a non-existing library returns FALSE.');
   }
 
   /**
@@ -1544,7 +1544,7 @@ class JavaScriptTestCase extends DrupalWebTestCase {
   function testAddJsFileWithQueryString() {
     $this->drupalGet('common-test/query-string');
     $query_string = variable_get('css_js_query_string', '0');
-    $this->assertRaw(drupal_get_path('module', 'node') . '/node.js?' . $query_string, t('Query string was appended correctly to js.'));
+    $this->assertRaw(drupal_get_path('module', 'node') . '/node.js?' . $query_string, 'Query string was appended correctly to js.');
   }
 }
 
@@ -1565,6 +1565,60 @@ class DrupalRenderTestCase extends DrupalWebTestCase {
   }
 
   /**
+   * Tests the output drupal_render() for some elementary input values.
+   */
+  function testDrupalRenderBasics() {
+    $types = array(
+      array(
+        'name' => 'null',
+        'value' => NULL,
+        'expected' => '',
+      ),
+      array(
+        'name' => 'no value',
+        'expected' => '',
+      ),
+      array(
+        'name' => 'empty string',
+        'value' => '',
+        'expected' => '',
+      ),
+      array(
+        'name' => 'no access',
+        'value' => array(
+          '#markup' => 'foo',
+          '#access' => FALSE,
+        ),
+        'expected' => '',
+      ),
+      array(
+        'name' => 'previously printed',
+        'value' => array(
+          '#markup' => 'foo',
+          '#printed' => TRUE,
+        ),
+        'expected' => '',
+      ),
+      array(
+        'name' => 'printed in prerender',
+        'value' => array(
+          '#markup' => 'foo',
+          '#pre_render' => array('common_test_drupal_render_printing_pre_render'),
+        ),
+        'expected' => '',
+      ),
+      array(
+        'name' => 'basic renderable array',
+        'value' => array('#markup' => 'foo'),
+        'expected' => 'foo',
+      ),
+    );
+    foreach($types as $type) {
+      $this->assertIdentical(drupal_render($type['value']), $type['expected'], '"' . $type['name'] . '" input rendered correctly by drupal_render().');
+    }
+  }
+
+  /**
    * Test sorting by weight.
    */
   function testDrupalRenderSorting() {
@@ -1584,17 +1638,17 @@ class DrupalRenderTestCase extends DrupalWebTestCase {
     $output = drupal_render($elements);
 
     // The lowest weight element should appear last in $output.
-    $this->assertTrue(strpos($output, $second) > strpos($output, $first), t('Elements were sorted correctly by weight.'));
+    $this->assertTrue(strpos($output, $second) > strpos($output, $first), 'Elements were sorted correctly by weight.');
 
     // Confirm that the $elements array has '#sorted' set to TRUE.
-    $this->assertTrue($elements['#sorted'], t("'#sorted' => TRUE was added to the array"));
+    $this->assertTrue($elements['#sorted'], "'#sorted' => TRUE was added to the array");
 
     // Pass $elements through element_children() and ensure it remains
     // sorted in the correct order. drupal_render() will return an empty string
     // if used on the same array in the same request.
     $children = element_children($elements);
-    $this->assertTrue(array_shift($children) == 'first', t('Child found in the correct order.'));
-    $this->assertTrue(array_shift($children) == 'second', t('Child found in the correct order.'));
+    $this->assertTrue(array_shift($children) == 'first', 'Child found in the correct order.');
+    $this->assertTrue(array_shift($children) == 'second', 'Child found in the correct order.');
 
 
     // The same array structure again, but with #sorted set to TRUE.
@@ -1612,7 +1666,7 @@ class DrupalRenderTestCase extends DrupalWebTestCase {
     $output = drupal_render($elements);
 
     // The elements should appear in output in the same order as the array.
-    $this->assertTrue(strpos($output, $second) < strpos($output, $first), t('Elements were not sorted.'));
+    $this->assertTrue(strpos($output, $second) < strpos($output, $first), 'Elements were not sorted.');
   }
 
   /**
@@ -1649,18 +1703,18 @@ class DrupalRenderTestCase extends DrupalWebTestCase {
     // Render the element and verify the presence of #attached JavaScript.
     drupal_render($element);
     $scripts = drupal_get_js();
-    $this->assertTrue(strpos($scripts, $parent_js), t('The element #attached JavaScript was included.'));
-    $this->assertTrue(strpos($scripts, $child_js), t('The child #attached JavaScript was included.'));
-    $this->assertTrue(strpos($scripts, $subchild_js), t('The subchild #attached JavaScript was included.'));
+    $this->assertTrue(strpos($scripts, $parent_js), 'The element #attached JavaScript was included.');
+    $this->assertTrue(strpos($scripts, $child_js), 'The child #attached JavaScript was included.');
+    $this->assertTrue(strpos($scripts, $subchild_js), 'The subchild #attached JavaScript was included.');
 
     // Load the element from cache and verify the presence of the #attached
     // JavaScript.
     drupal_static_reset('drupal_add_js');
-    $this->assertTrue(drupal_render_cache_get($element), t('The element was retrieved from cache.'));
+    $this->assertTrue(drupal_render_cache_get($element), 'The element was retrieved from cache.');
     $scripts = drupal_get_js();
-    $this->assertTrue(strpos($scripts, $parent_js), t('The element #attached JavaScript was included when loading from cache.'));
-    $this->assertTrue(strpos($scripts, $child_js), t('The child #attached JavaScript was included when loading from cache.'));
-    $this->assertTrue(strpos($scripts, $subchild_js), t('The subchild #attached JavaScript was included when loading from cache.'));
+    $this->assertTrue(strpos($scripts, $parent_js), 'The element #attached JavaScript was included when loading from cache.');
+    $this->assertTrue(strpos($scripts, $child_js), 'The child #attached JavaScript was included when loading from cache.');
+    $this->assertTrue(strpos($scripts, $subchild_js), 'The subchild #attached JavaScript was included when loading from cache.');
 
     $_SERVER['REQUEST_METHOD'] = $request_method;
   }
@@ -1804,7 +1858,7 @@ class DrupalRenderTestCase extends DrupalWebTestCase {
     // @see DrupalWebTestCase::xpath()
     $xpath = $this->buildXPathQuery($xpath, $xpath_args);
     $element += array('#value' => NULL);
-    $this->assertFieldByXPath($xpath, $element['#value'], t('#type @type was properly rendered.', array(
+    $this->assertFieldByXPath($xpath, $element['#value'], format_string('#type @type was properly rendered.', array(
       '@type' => var_export($element['#type'], TRUE),
     )));
   }
@@ -1828,13 +1882,13 @@ class DrupalRenderTestCase extends DrupalWebTestCase {
     // process (which will set $element['#printed']).
     $element = $test_element;
     drupal_render($element);
-    $this->assertTrue(isset($element['#printed']), t('No cache hit'));
+    $this->assertTrue(isset($element['#printed']), 'No cache hit');
 
     // Render the element again and confirm that it is retrieved from the cache
     // instead (so $element['#printed'] will not be set).
     $element = $test_element;
     drupal_render($element);
-    $this->assertFalse(isset($element['#printed']), t('Cache hit'));
+    $this->assertFalse(isset($element['#printed']), 'Cache hit');
 
     // Restore the previous request method.
     $_SERVER['REQUEST_METHOD'] = $request_method;
@@ -1883,7 +1937,7 @@ class ValidUrlTestCase extends DrupalUnitTestCase {
       foreach ($valid_absolute_urls as $url) {
         $test_url = $scheme . '://' . $url;
         $valid_url = valid_url($test_url, TRUE);
-        $this->assertTrue($valid_url, t('@url is a valid url.', array('@url' => $test_url)));
+        $this->assertTrue($valid_url, format_string('@url is a valid url.', array('@url' => $test_url)));
       }
     }
   }
@@ -1903,7 +1957,7 @@ class ValidUrlTestCase extends DrupalUnitTestCase {
       foreach ($invalid_ablosule_urls as $url) {
         $test_url = $scheme . '://' . $url;
         $valid_url = valid_url($test_url, TRUE);
-        $this->assertFalse($valid_url, t('@url is NOT a valid url.', array('@url' => $test_url)));
+        $this->assertFalse($valid_url, format_string('@url is NOT a valid url.', array('@url' => $test_url)));
       }
     }
   }
@@ -1924,7 +1978,7 @@ class ValidUrlTestCase extends DrupalUnitTestCase {
       foreach ($valid_relative_urls as $url) {
         $test_url = $front . $url;
         $valid_url = valid_url($test_url);
-        $this->assertTrue($valid_url, t('@url is a valid url.', array('@url' => $test_url)));
+        $this->assertTrue($valid_url, format_string('@url is a valid url.', array('@url' => $test_url)));
       }
     }
   }
@@ -1943,7 +1997,7 @@ class ValidUrlTestCase extends DrupalUnitTestCase {
       foreach ($invalid_relative_urls as $url) {
         $test_url = $front . $url;
         $valid_url = valid_url($test_url);
-        $this->assertFALSE($valid_url, t('@url is NOT a valid url.', array('@url' => $test_url)));
+        $this->assertFALSE($valid_url, format_string('@url is NOT a valid url.', array('@url' => $test_url)));
       }
     }
   }
@@ -1974,30 +2028,30 @@ class DrupalDataApiTest extends DrupalWebTestCase {
     $person->name = 'John';
     $person->unknown_column = 123;
     $insert_result = drupal_write_record('test', $person);
-    $this->assertTrue($insert_result == SAVED_NEW, t('Correct value returned when a record is inserted with drupal_write_record() for a table with a single-field primary key.'));
-    $this->assertTrue(isset($person->id), t('Primary key is set on record created with drupal_write_record().'));
-    $this->assertIdentical($person->age, 0, t('Age field set to default value.'));
-    $this->assertIdentical($person->job, 'Undefined', t('Job field set to default value.'));
+    $this->assertTrue($insert_result == SAVED_NEW, 'Correct value returned when a record is inserted with drupal_write_record() for a table with a single-field primary key.');
+    $this->assertTrue(isset($person->id), 'Primary key is set on record created with drupal_write_record().');
+    $this->assertIdentical($person->age, 0, 'Age field set to default value.');
+    $this->assertIdentical($person->job, 'Undefined', 'Job field set to default value.');
 
     // Verify that the record was inserted.
     $result = db_query("SELECT * FROM {test} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'John', t('Name field set.'));
-    $this->assertIdentical($result->age, '0', t('Age field set to default value.'));
-    $this->assertIdentical($result->job, 'Undefined', t('Job field set to default value.'));
-    $this->assertFalse(isset($result->unknown_column), t('Unknown column was ignored.'));
+    $this->assertIdentical($result->name, 'John', 'Name field set.');
+    $this->assertIdentical($result->age, '0', 'Age field set to default value.');
+    $this->assertIdentical($result->job, 'Undefined', 'Job field set to default value.');
+    $this->assertFalse(isset($result->unknown_column), 'Unknown column was ignored.');
 
     // Update the newly created record.
     $person->name = 'Peter';
     $person->age = 27;
     $person->job = NULL;
     $update_result = drupal_write_record('test', $person, array('id'));
-    $this->assertTrue($update_result == SAVED_UPDATED, t('Correct value returned when a record updated with drupal_write_record() for table with single-field primary key.'));
+    $this->assertTrue($update_result == SAVED_UPDATED, 'Correct value returned when a record updated with drupal_write_record() for table with single-field primary key.');
 
     // Verify that the record was updated.
     $result = db_query("SELECT * FROM {test} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'Peter', t('Name field set.'));
-    $this->assertIdentical($result->age, '27', t('Age field set.'));
-    $this->assertIdentical($result->job, '', t('Job field set and cast to string.'));
+    $this->assertIdentical($result->name, 'Peter', 'Name field set.');
+    $this->assertIdentical($result->age, '27', 'Age field set.');
+    $this->assertIdentical($result->job, '', 'Job field set and cast to string.');
 
     // Try to insert NULL in columns that does not allow this.
     $person = new stdClass();
@@ -2005,65 +2059,65 @@ class DrupalDataApiTest extends DrupalWebTestCase {
     $person->age = NULL;
     $person->job = NULL;
     $insert_result = drupal_write_record('test', $person);
-    $this->assertTrue(isset($person->id), t('Primary key is set on record created with drupal_write_record().'));
+    $this->assertTrue(isset($person->id), 'Primary key is set on record created with drupal_write_record().');
     $result = db_query("SELECT * FROM {test} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'Ringo', t('Name field set.'));
-    $this->assertIdentical($result->age, '0', t('Age field set.'));
-    $this->assertIdentical($result->job, '', t('Job field set.'));
+    $this->assertIdentical($result->name, 'Ringo', 'Name field set.');
+    $this->assertIdentical($result->age, '0', 'Age field set.');
+    $this->assertIdentical($result->job, '', 'Job field set.');
 
     // Insert a record - the "age" column allows NULL.
     $person = new stdClass();
     $person->name = 'Paul';
     $person->age = NULL;
     $insert_result = drupal_write_record('test_null', $person);
-    $this->assertTrue(isset($person->id), t('Primary key is set on record created with drupal_write_record().'));
+    $this->assertTrue(isset($person->id), 'Primary key is set on record created with drupal_write_record().');
     $result = db_query("SELECT * FROM {test_null} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'Paul', t('Name field set.'));
-    $this->assertIdentical($result->age, NULL, t('Age field set.'));
+    $this->assertIdentical($result->name, 'Paul', 'Name field set.');
+    $this->assertIdentical($result->age, NULL, 'Age field set.');
 
     // Insert a record - do not specify the value of a column that allows NULL.
     $person = new stdClass();
     $person->name = 'Meredith';
     $insert_result = drupal_write_record('test_null', $person);
-    $this->assertTrue(isset($person->id), t('Primary key is set on record created with drupal_write_record().'));
-    $this->assertIdentical($person->age, 0, t('Age field set to default value.'));
+    $this->assertTrue(isset($person->id), 'Primary key is set on record created with drupal_write_record().');
+    $this->assertIdentical($person->age, 0, 'Age field set to default value.');
     $result = db_query("SELECT * FROM {test_null} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'Meredith', t('Name field set.'));
-    $this->assertIdentical($result->age, '0', t('Age field set to default value.'));
+    $this->assertIdentical($result->name, 'Meredith', 'Name field set.');
+    $this->assertIdentical($result->age, '0', 'Age field set to default value.');
 
     // Update the newly created record.
     $person->name = 'Mary';
     $person->age = NULL;
     $update_result = drupal_write_record('test_null', $person, array('id'));
     $result = db_query("SELECT * FROM {test_null} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'Mary', t('Name field set.'));
-    $this->assertIdentical($result->age, NULL, t('Age field set.'));
+    $this->assertIdentical($result->name, 'Mary', 'Name field set.');
+    $this->assertIdentical($result->age, NULL, 'Age field set.');
 
     // Insert a record - the "data" column should be serialized.
     $person = new stdClass();
     $person->name = 'Dave';
     $update_result = drupal_write_record('test_serialized', $person);
     $result = db_query("SELECT * FROM {test_serialized} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical($result->name, 'Dave', t('Name field set.'));
-    $this->assertIdentical($result->info, NULL, t('Info field set.'));
+    $this->assertIdentical($result->name, 'Dave', 'Name field set.');
+    $this->assertIdentical($result->info, NULL, 'Info field set.');
 
     $person->info = array();
     $update_result = drupal_write_record('test_serialized', $person, array('id'));
     $result = db_query("SELECT * FROM {test_serialized} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical(unserialize($result->info), array(), t('Info field updated.'));
+    $this->assertIdentical(unserialize($result->info), array(), 'Info field updated.');
 
     // Update the serialized record.
     $data = array('foo' => 'bar', 1 => 2, 'empty' => '', 'null' => NULL);
     $person->info = $data;
     $update_result = drupal_write_record('test_serialized', $person, array('id'));
     $result = db_query("SELECT * FROM {test_serialized} WHERE id = :id", array(':id' => $person->id))->fetchObject();
-    $this->assertIdentical(unserialize($result->info), $data, t('Info field updated.'));
+    $this->assertIdentical(unserialize($result->info), $data, 'Info field updated.');
 
     // Run an update query where no field values are changed. The database
     // layer should return zero for number of affected rows, but
     // db_write_record() should still return SAVED_UPDATED.
     $update_result = drupal_write_record('test_null', $person, array('id'));
-    $this->assertTrue($update_result == SAVED_UPDATED, t('Correct value returned when a valid update is run without changing any values.'));
+    $this->assertTrue($update_result == SAVED_UPDATED, 'Correct value returned when a valid update is run without changing any values.');
 
     // Insert an object record for a table with a multi-field primary key.
     $node_access = new stdClass();
@@ -2071,11 +2125,11 @@ class DrupalDataApiTest extends DrupalWebTestCase {
     $node_access->gid = mt_rand();
     $node_access->realm = $this->randomName();
     $insert_result = drupal_write_record('node_access', $node_access);
-    $this->assertTrue($insert_result == SAVED_NEW, t('Correct value returned when a record is inserted with drupal_write_record() for a table with a multi-field primary key.'));
+    $this->assertTrue($insert_result == SAVED_NEW, 'Correct value returned when a record is inserted with drupal_write_record() for a table with a multi-field primary key.');
 
     // Update the record.
     $update_result = drupal_write_record('node_access', $node_access, array('nid', 'gid', 'realm'));
-    $this->assertTrue($update_result == SAVED_UPDATED, t('Correct value returned when a record is updated with drupal_write_record() for a table with a multi-field primary key.'));
+    $this->assertTrue($update_result == SAVED_UPDATED, 'Correct value returned when a record is updated with drupal_write_record() for a table with a multi-field primary key.');
   }
 
 }
@@ -2113,7 +2167,7 @@ class DrupalErrorCollectionUnitTest extends DrupalWebTestCase {
   function testErrorCollect() {
     $this->collectedErrors = array();
     $this->drupalGet('error-test/generate-warnings-with-report');
-    $this->assertEqual(count($this->collectedErrors), 3, t('Three errors were collected'));
+    $this->assertEqual(count($this->collectedErrors), 3, 'Three errors were collected');
 
     if (count($this->collectedErrors) == 3) {
       $this->assertError($this->collectedErrors[0], 'Notice', 'error_test_generate_warnings()', 'error_test.module', 'Undefined variable: bananas');
@@ -2162,11 +2216,11 @@ class DrupalErrorCollectionUnitTest extends DrupalWebTestCase {
    * Assert that a collected error matches what we are expecting.
    */
   function assertError($error, $group, $function, $file, $message = NULL) {
-    $this->assertEqual($error['group'], $group, t("Group was %group", array('%group' => $group)));
-    $this->assertEqual($error['caller']['function'], $function, t("Function was %function", array('%function' => $function)));
-    $this->assertEqual(drupal_basename($error['caller']['file']), $file, t("File was %file", array('%file' => $file)));
+    $this->assertEqual($error['group'], $group, format_string("Group was %group", array('%group' => $group)));
+    $this->assertEqual($error['caller']['function'], $function, format_string("Function was %function", array('%function' => $function)));
+    $this->assertEqual(drupal_basename($error['caller']['file']), $file, format_string("File was %file", array('%file' => $file)));
     if (isset($message)) {
-      $this->assertEqual($error['message'], $message, t("Message was %message", array('%message' => $message)));
+      $this->assertEqual($error['message'], $message, format_string("Message was %message", array('%message' => $message)));
     }
   }
 }
@@ -2188,9 +2242,9 @@ class ParseInfoFilesTestCase extends DrupalUnitTestCase {
    */
   function testParseInfoFile() {
     $info_values = drupal_parse_info_file(drupal_get_path('module', 'simpletest') . '/tests/common_test_info.txt');
-    $this->assertEqual($info_values['simple_string'], 'A simple string', t('Simple string value was parsed correctly.'), t('System'));
-    $this->assertEqual($info_values['simple_constant'], WATCHDOG_INFO, t('Constant value was parsed correctly.'), t('System'));
-    $this->assertEqual($info_values['double_colon'], 'dummyClassName::', t('Value containing double-colon was parsed correctly.'), t('System'));
+    $this->assertEqual($info_values['simple_string'], 'A simple string', 'Simple string value was parsed correctly.', 'System');
+    $this->assertEqual($info_values['simple_constant'], WATCHDOG_INFO, 'Constant value was parsed correctly.', 'System');
+    $this->assertEqual($info_values['double_colon'], 'dummyClassName::', 'Value containing double-colon was parsed correctly.', 'System');
   }
 }
 
@@ -2239,7 +2293,7 @@ class DrupalSystemListingTestCase extends DrupalWebTestCase {
     foreach ($expected_directories as $module => $directories) {
       foreach ($directories as $directory) {
         $filename = "$directory/$module/$module.module";
-        $this->assertTrue(file_exists(DRUPAL_ROOT . '/' . $filename), t('@filename exists.', array('@filename' => $filename)));
+        $this->assertTrue(file_exists(DRUPAL_ROOT . '/' . $filename), format_string('@filename exists.', array('@filename' => $filename)));
       }
     }
 
@@ -2249,7 +2303,7 @@ class DrupalSystemListingTestCase extends DrupalWebTestCase {
     foreach ($expected_directories as $module => $directories) {
       $expected_directory = array_shift($directories);
       $expected_filename = "$expected_directory/$module/$module.module";
-      $this->assertEqual($files[$module]->uri, $expected_filename, t('Module @module was found at @filename.', array('@module' => $module, '@filename' => $expected_filename)));
+      $this->assertEqual($files[$module]->uri, $expected_filename, format_string('Module @module was found at @filename.', array('@module' => $module, '@filename' => $expected_filename)));
     }
   }
 }
@@ -2296,7 +2350,13 @@ class FormatDateUnitTest extends DrupalWebTestCase {
     // Add new date format.
     $admin_date_format = 'j M y';
     $edit = array('date_format' => $admin_date_format);
+    $this->drupalPost('admin/config/regional/date-time/formats/add', $edit, 'Add format');
+
+    // Add a new date format which just differs in the case.
+    $admin_date_format_uppercase = 'j M Y';
+    $edit = array('date_format' => $admin_date_format_uppercase);
     $this->drupalPost('admin/config/regional/date-time/formats/add', $edit, t('Add format'));
+    $this->assertText(t('Custom date format added.'));
 
     // Add new date type.
     $edit = array(
@@ -2304,11 +2364,21 @@ class FormatDateUnitTest extends DrupalWebTestCase {
       'machine_name' => 'example_style',
       'date_format' => $admin_date_format,
     );
+    $this->drupalPost('admin/config/regional/date-time/types/add', $edit, 'Add date type');
+
+   // Add a second date format with a different case than the first.
+    $edit = array(
+      'machine_name' => 'example_style_uppercase',
+      'date_type' => 'Example Style Uppercase',
+      'date_format' => $admin_date_format_uppercase,
+    );
     $this->drupalPost('admin/config/regional/date-time/types/add', $edit, t('Add date type'));
+    $this->assertText(t('New date type added successfully.'));
 
     $timestamp = strtotime('2007-03-10T00:00:00+00:00');
-    $this->assertIdentical(format_date($timestamp, 'example_style', '', 'America/Los_Angeles'), '9 Mar 07', t('Test format_date() using an admin-defined date type.'));
-    $this->assertIdentical(format_date($timestamp, 'undefined_style'), format_date($timestamp, 'medium'), t('Test format_date() defaulting to medium when $type not found.'));
+    $this->assertIdentical(format_date($timestamp, 'example_style', '', 'America/Los_Angeles'), '9 Mar 07', 'Test format_date() using an admin-defined date type.');
+    $this->assertIdentical(format_date($timestamp, 'example_style_uppercase', '', 'America/Los_Angeles'), '9 Mar 2007', 'Test format_date() using an admin-defined date type with different case.');
+    $this->assertIdentical(format_date($timestamp, 'undefined_style'), format_date($timestamp, 'medium'), 'Test format_date() defaulting to medium when $type not found.');
   }
 
   /**
@@ -2318,12 +2388,12 @@ class FormatDateUnitTest extends DrupalWebTestCase {
     global $user, $language;
 
     $timestamp = strtotime('2007-03-26T00:00:00+00:00');
-    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'America/Los_Angeles', 'en'), 'Sunday, 25-Mar-07 17:00:00 PDT', t('Test all parameters.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), 'domingo, 25-Mar-07 17:00:00 PDT', t('Test translated format.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', '\\l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), 'l, 25-Mar-07 17:00:00 PDT', t('Test an escaped format string.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', '\\\\l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), '\\domingo, 25-Mar-07 17:00:00 PDT', t('Test format containing backslash character.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', '\\\\\\l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), '\\l, 25-Mar-07 17:00:00 PDT', t('Test format containing backslash followed by escaped format string.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'Europe/London', 'en'), 'Monday, 26-Mar-07 01:00:00 BST', t('Test a different time zone.'));
+    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'America/Los_Angeles', 'en'), 'Sunday, 25-Mar-07 17:00:00 PDT', 'Test all parameters.');
+    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), 'domingo, 25-Mar-07 17:00:00 PDT', 'Test translated format.');
+    $this->assertIdentical(format_date($timestamp, 'custom', '\\l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), 'l, 25-Mar-07 17:00:00 PDT', 'Test an escaped format string.');
+    $this->assertIdentical(format_date($timestamp, 'custom', '\\\\l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), '\\domingo, 25-Mar-07 17:00:00 PDT', 'Test format containing backslash character.');
+    $this->assertIdentical(format_date($timestamp, 'custom', '\\\\\\l, d-M-y H:i:s T', 'America/Los_Angeles', self::LANGCODE), '\\l, 25-Mar-07 17:00:00 PDT', 'Test format containing backslash followed by escaped format string.');
+    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'Europe/London', 'en'), 'Monday, 26-Mar-07 01:00:00 BST', 'Test a different time zone.');
 
     // Create an admin user and add Spanish language.
     $admin_user = $this->drupalCreateUser(array('administer languages'));
@@ -2353,13 +2423,13 @@ class FormatDateUnitTest extends DrupalWebTestCase {
     // Simulate a Drupal bootstrap with the logged-in user.
     date_default_timezone_set(drupal_get_user_timezone());
 
-    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'America/Los_Angeles', 'en'), 'Sunday, 25-Mar-07 17:00:00 PDT', t('Test a different language.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'Europe/London'), 'Monday, 26-Mar-07 01:00:00 BST', t('Test a different time zone.'));
-    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T'), 'domingo, 25-Mar-07 17:00:00 PDT', t('Test custom date format.'));
-    $this->assertIdentical(format_date($timestamp, 'long'), 'domingo, 25. marzo 2007 - 17:00', t('Test long date format.'));
-    $this->assertIdentical(format_date($timestamp, 'medium'), '25. marzo 2007 - 17:00', t('Test medium date format.'));
-    $this->assertIdentical(format_date($timestamp, 'short'), '2007 Mar 25 - 5:00pm', t('Test short date format.'));
-    $this->assertIdentical(format_date($timestamp), '25. marzo 2007 - 17:00', t('Test default date format.'));
+    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'America/Los_Angeles', 'en'), 'Sunday, 25-Mar-07 17:00:00 PDT', 'Test a different language.');
+    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T', 'Europe/London'), 'Monday, 26-Mar-07 01:00:00 BST', 'Test a different time zone.');
+    $this->assertIdentical(format_date($timestamp, 'custom', 'l, d-M-y H:i:s T'), 'domingo, 25-Mar-07 17:00:00 PDT', 'Test custom date format.');
+    $this->assertIdentical(format_date($timestamp, 'long'), 'domingo, 25. marzo 2007 - 17:00', 'Test long date format.');
+    $this->assertIdentical(format_date($timestamp, 'medium'), '25. marzo 2007 - 17:00', 'Test medium date format.');
+    $this->assertIdentical(format_date($timestamp, 'short'), '2007 Mar 25 - 5:00pm', 'Test short date format.');
+    $this->assertIdentical(format_date($timestamp), '25. marzo 2007 - 17:00', 'Test default date format.');
 
     // Restore the original user and language, and enable session saving.
     $user = $real_user;
@@ -2387,15 +2457,15 @@ class DrupalAttributesUnitTest extends DrupalUnitTestCase {
    */
   function testDrupalAttributes() {
     // Verify that special characters are HTML encoded.
-    $this->assertIdentical(drupal_attributes(array('title' => '&"\'<>')), ' title="&amp;&quot;&#039;&lt;&gt;"', t('HTML encode attribute values.'));
+    $this->assertIdentical(drupal_attributes(array('title' => '&"\'<>')), ' title="&amp;&quot;&#039;&lt;&gt;"', 'HTML encode attribute values.');
 
     // Verify multi-value attributes are concatenated with spaces.
     $attributes = array('class' => array('first', 'last'));
-    $this->assertIdentical(drupal_attributes(array('class' => array('first', 'last'))), ' class="first last"', t('Concatenate multi-value attributes.'));
+    $this->assertIdentical(drupal_attributes(array('class' => array('first', 'last'))), ' class="first last"', 'Concatenate multi-value attributes.');
 
     // Verify empty attribute values are rendered.
-    $this->assertIdentical(drupal_attributes(array('alt' => '')), ' alt=""', t('Empty attribute value #1.'));
-    $this->assertIdentical(drupal_attributes(array('alt' => NULL)), ' alt=""', t('Empty attribute value #2.'));
+    $this->assertIdentical(drupal_attributes(array('alt' => '')), ' alt=""', 'Empty attribute value #1.');
+    $this->assertIdentical(drupal_attributes(array('alt' => NULL)), ' alt=""', 'Empty attribute value #2.');
 
     // Verify multiple attributes are rendered.
     $attributes = array(
@@ -2403,10 +2473,10 @@ class DrupalAttributesUnitTest extends DrupalUnitTestCase {
       'class' => array('first', 'last'),
       'alt' => 'Alternate',
     );
-    $this->assertIdentical(drupal_attributes($attributes), ' id="id-test" class="first last" alt="Alternate"', t('Multiple attributes.'));
+    $this->assertIdentical(drupal_attributes($attributes), ' id="id-test" class="first last" alt="Alternate"', 'Multiple attributes.');
 
     // Verify empty attributes array is rendered.
-    $this->assertIdentical(drupal_attributes(array()), '', t('Empty attributes array.'));
+    $this->assertIdentical(drupal_attributes(array()), '', 'Empty attributes array.');
   }
 }
 
@@ -2439,38 +2509,38 @@ class DrupalJSONTest extends DrupalUnitTestCase {
     $html_unsafe_escaped = array('\u003C', '\u003E', '\u0027', '\u0026', '\u0022');
 
     // Verify there aren't character encoding problems with the source string.
-    $this->assertIdentical(strlen($str), 128, t('A string with the full ASCII table has the correct length.'));
+    $this->assertIdentical(strlen($str), 128, 'A string with the full ASCII table has the correct length.');
     foreach ($html_unsafe as $char) {
-      $this->assertTrue(strpos($str, $char) > 0, t('A string with the full ASCII table includes @s.', array('@s' => $char)));
+      $this->assertTrue(strpos($str, $char) > 0, format_string('A string with the full ASCII table includes @s.', array('@s' => $char)));
     }
 
     // Verify that JSON encoding produces a string with all of the characters.
     $json = drupal_json_encode($str);
-    $this->assertTrue(strlen($json) > strlen($str), t('A JSON encoded string is larger than the source string.'));
+    $this->assertTrue(strlen($json) > strlen($str), 'A JSON encoded string is larger than the source string.');
 
     // The first and last characters should be ", and no others.
-    $this->assertTrue($json[0] == '"', t('A JSON encoded string begins with ".'));
-    $this->assertTrue($json[strlen($json) - 1] == '"', t('A JSON encoded string ends with ".'));
-    $this->assertTrue(substr_count($json, '"') == 2, t('A JSON encoded string contains exactly two ".'));
+    $this->assertTrue($json[0] == '"', 'A JSON encoded string begins with ".');
+    $this->assertTrue($json[strlen($json) - 1] == '"', 'A JSON encoded string ends with ".');
+    $this->assertTrue(substr_count($json, '"') == 2, 'A JSON encoded string contains exactly two ".');
 
     // Verify that encoding/decoding is reversible.
     $json_decoded = drupal_json_decode($json);
-    $this->assertIdentical($str, $json_decoded, t('Encoding a string to JSON and decoding back results in the original string.'));
+    $this->assertIdentical($str, $json_decoded, 'Encoding a string to JSON and decoding back results in the original string.');
 
     // Verify reversibility for structured data. Also verify that necessary
     // characters are escaped.
     $source = array(TRUE, FALSE, 0, 1, '0', '1', $str, array('key1' => $str, 'key2' => array('nested' => TRUE)));
     $json = drupal_json_encode($source);
     foreach ($html_unsafe as $char) {
-      $this->assertTrue(strpos($json, $char) === FALSE, t('A JSON encoded string does not contain @s.', array('@s' => $char)));
+      $this->assertTrue(strpos($json, $char) === FALSE, format_string('A JSON encoded string does not contain @s.', array('@s' => $char)));
     }
     // Verify that JSON encoding escapes the HTML unsafe characters
     foreach ($html_unsafe_escaped as $char) {
-      $this->assertTrue(strpos($json, $char) > 0, t('A JSON encoded string contains @s.', array('@s' => $char)));
+      $this->assertTrue(strpos($json, $char) > 0, format_string('A JSON encoded string contains @s.', array('@s' => $char)));
     }
     $json_decoded = drupal_json_decode($json);
-    $this->assertNotIdentical($source, $json, t('An array encoded in JSON is not identical to the source.'));
-    $this->assertIdentical($source, $json_decoded, t('Encoding structured data to JSON and decoding back results in the original data.'));
+    $this->assertNotIdentical($source, $json, 'An array encoded in JSON is not identical to the source.');
+    $this->assertIdentical($source, $json_decoded, 'Encoding structured data to JSON and decoding back results in the original data.');
   }
 }
 
@@ -2499,10 +2569,10 @@ class DrupalGetRdfNamespacesTestCase extends DrupalWebTestCase {
     $xml = new SimpleXMLElement($this->content);
     $ns = $xml->getDocNamespaces();
 
-    $this->assertEqual($ns['rdfs'], 'http://www.w3.org/2000/01/rdf-schema#', t('A prefix declared once is displayed.'));
-    $this->assertEqual($ns['foaf'], 'http://xmlns.com/foaf/0.1/', t('The same prefix declared in several implementations of hook_rdf_namespaces() is valid as long as all the namespaces are the same.'));
-    $this->assertEqual($ns['foaf1'], 'http://xmlns.com/foaf/0.1/', t('Two prefixes can be assigned the same namespace.'));
-    $this->assertTrue(!isset($ns['dc']), t('A prefix with conflicting namespaces is discarded.'));
+    $this->assertEqual($ns['rdfs'], 'http://www.w3.org/2000/01/rdf-schema#', 'A prefix declared once is displayed.');
+    $this->assertEqual($ns['foaf'], 'http://xmlns.com/foaf/0.1/', 'The same prefix declared in several implementations of hook_rdf_namespaces() is valid as long as all the namespaces are the same.');
+    $this->assertEqual($ns['foaf1'], 'http://xmlns.com/foaf/0.1/', 'Two prefixes can be assigned the same namespace.');
+    $this->assertTrue(!isset($ns['dc']), 'A prefix with conflicting namespaces is discarded.');
   }
 }
 
@@ -2573,7 +2643,7 @@ class DrupalAddFeedTestCase extends DrupalWebTestCase {
 
     $this->drupalSetContent(drupal_get_html_head());
     foreach ($urls as $description => $feed_info) {
-      $this->assertPattern($this->urlToRSSLinkPattern($feed_info['output_url'], $feed_info['title']), t('Found correct feed header for %description', array('%description' => $description)));
+      $this->assertPattern($this->urlToRSSLinkPattern($feed_info['output_url'], $feed_info['title']), format_string('Found correct feed header for %description', array('%description' => $description)));
     }
   }
 
@@ -2614,3 +2684,75 @@ class FeedIconTest extends DrupalWebTestCase {
   }
 
 }
+
+/**
+ * Test array diff functions.
+ */
+class ArrayDiffUnitTest extends DrupalUnitTestCase {
+
+  /**
+   * Array to use for testing.
+   *
+   * @var array
+   */
+  protected $array1;
+
+  /**
+   * Array to use for testing.
+   *
+   * @var array
+   */
+  protected $array2;
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Array differences',
+      'description' => 'Performs tests on drupal_array_diff_assoc_recursive().',
+      'group' => 'System',
+    );
+  }
+
+  function setUp() {
+    parent::setUp();
+
+    $this->array1 = array(
+      'same' => 'yes',
+      'different' => 'no',
+      'array_empty_diff' => array(),
+      'null' => NULL,
+      'int_diff' => 1,
+      'array_diff' => array('same' => 'same', 'array' => array('same' => 'same')),
+      'array_compared_to_string' => array('value'),
+      'string_compared_to_array' => 'value',
+      'new' => 'new',
+    );
+    $this->array2 = array(
+      'same' => 'yes',
+      'different' => 'yes',
+      'array_empty_diff' => array(),
+      'null' => NULL,
+      'int_diff' => '1',
+      'array_diff' => array('same' => 'different', 'array' => array('same' => 'same')),
+      'array_compared_to_string' => 'value',
+      'string_compared_to_array' => array('value'),
+    );
+  }
+
+
+  /**
+   * Tests drupal_array_diff_assoc_recursive().
+   */
+  public function testArrayDiffAssocRecursive() {
+    $expected = array(
+      'different' => 'no',
+      'int_diff' => 1,
+      // The 'array' key should not be returned, as it's the same.
+      'array_diff' => array('same' => 'same'),
+      'array_compared_to_string' => array('value'),
+      'string_compared_to_array' => 'value',
+      'new' => 'new',
+    );
+
+    $this->assertIdentical(drupal_array_diff_assoc_recursive($this->array1, $this->array2), $expected);
+  }
+}
diff --git a/modules/simpletest/tests/common_test.module b/modules/simpletest/tests/common_test.module
index e75b452..674a494 100644
--- a/modules/simpletest/tests/common_test.module
+++ b/modules/simpletest/tests/common_test.module
@@ -101,6 +101,14 @@ function common_test_destination() {
 }
 
 /**
+ * Applies #printed to an element to help test #pre_render.
+ */
+function common_test_drupal_render_printing_pre_render($elements) {
+  $elements['#printed'] = TRUE;
+  return $elements;
+}
+
+/**
  * Implements hook_TYPE_alter().
  */
 function common_test_drupal_alter_alter(&$data, &$arg2 = NULL, &$arg3 = NULL) {
diff --git a/modules/simpletest/tests/database_test.test b/modules/simpletest/tests/database_test.test
index 6e1d159..b58578e 100644
--- a/modules/simpletest/tests/database_test.test
+++ b/modules/simpletest/tests/database_test.test
@@ -48,7 +48,7 @@ class DatabaseTestCase extends DrupalWebTestCase {
     }
 
     foreach ($schema as $name => $data) {
-      $this->assertTrue(db_table_exists($name), t('Table @name created successfully.', array('@name' => $name)));
+      $this->assertTrue(db_table_exists($name), format_string('Table @name created successfully.', array('@name' => $name)));
     }
   }
 
@@ -191,25 +191,25 @@ class DatabaseConnectionTestCase extends DatabaseTestCase {
     $db1 = Database::getConnection('default', 'default');
     $db2 = Database::getConnection('slave', 'default');
 
-    $this->assertNotNull($db1, t('default connection is a real connection object.'));
-    $this->assertNotNull($db2, t('slave connection is a real connection object.'));
-    $this->assertNotIdentical($db1, $db2, t('Each target refers to a different connection.'));
+    $this->assertNotNull($db1, 'default connection is a real connection object.');
+    $this->assertNotNull($db2, 'slave connection is a real connection object.');
+    $this->assertNotIdentical($db1, $db2, 'Each target refers to a different connection.');
 
     // Try to open those targets another time, that should return the same objects.
     $db1b = Database::getConnection('default', 'default');
     $db2b = Database::getConnection('slave', 'default');
-    $this->assertIdentical($db1, $db1b, t('A second call to getConnection() returns the same object.'));
-    $this->assertIdentical($db2, $db2b, t('A second call to getConnection() returns the same object.'));
+    $this->assertIdentical($db1, $db1b, 'A second call to getConnection() returns the same object.');
+    $this->assertIdentical($db2, $db2b, 'A second call to getConnection() returns the same object.');
 
     // Try to open an unknown target.
     $unknown_target = $this->randomName();
     $db3 = Database::getConnection($unknown_target, 'default');
-    $this->assertNotNull($db3, t('Opening an unknown target returns a real connection object.'));
-    $this->assertIdentical($db1, $db3, t('An unknown target opens the default connection.'));
+    $this->assertNotNull($db3, 'Opening an unknown target returns a real connection object.');
+    $this->assertIdentical($db1, $db3, 'An unknown target opens the default connection.');
 
     // Try to open that unknown target another time, that should return the same object.
     $db3b = Database::getConnection($unknown_target, 'default');
-    $this->assertIdentical($db3, $db3b, t('A second call to getConnection() returns the same object.'));
+    $this->assertIdentical($db3, $db3b, 'A second call to getConnection() returns the same object.');
   }
 
   /**
@@ -227,7 +227,7 @@ class DatabaseConnectionTestCase extends DatabaseTestCase {
     $db1 = Database::getConnection('default', 'default');
     $db2 = Database::getConnection('slave', 'default');
 
-    $this->assertIdentical($db1, $db2, t('Both targets refer to the same connection.'));
+    $this->assertIdentical($db1, $db2, 'Both targets refer to the same connection.');
   }
 
   /**
@@ -242,7 +242,7 @@ class DatabaseConnectionTestCase extends DatabaseTestCase {
     $db2 = Database::getConnection('default', 'default');
 
     // Opening a connection after closing it should yield an object different than the original.
-    $this->assertNotIdentical($db1, $db2, t('Opening the default connection after it is closed returns a new object.'));
+    $this->assertNotIdentical($db1, $db2, 'Opening the default connection after it is closed returns a new object.');
   }
 
   /**
@@ -257,8 +257,8 @@ class DatabaseConnectionTestCase extends DatabaseTestCase {
 
     // In the MySQL driver, the port can be different, so check individual
     // options.
-    $this->assertEqual($connection_info['default']['driver'], $connectionOptions['driver'], t('The default connection info driver matches the current connection options driver.'));
-    $this->assertEqual($connection_info['default']['database'], $connectionOptions['database'], t('The default connection info database matches the current connection options database.'));
+    $this->assertEqual($connection_info['default']['driver'], $connectionOptions['driver'], 'The default connection info driver matches the current connection options driver.');
+    $this->assertEqual($connection_info['default']['database'], $connectionOptions['database'], 'The default connection info database matches the current connection options database.');
 
     // Set up identical slave and confirm connection options are identical.
     Database::addConnectionInfo('default', 'slave', $connection_info['default']);
@@ -267,7 +267,7 @@ class DatabaseConnectionTestCase extends DatabaseTestCase {
 
     // Get a fresh copy of the default connection options.
     $connectionOptions = $db->getConnectionOptions();
-    $this->assertIdentical($connectionOptions, $connectionOptions2, t('The default and slave connection options are identical.'));
+    $this->assertIdentical($connectionOptions, $connectionOptions2, 'The default and slave connection options are identical.');
 
     // Set up a new connection with different connection info.
     $test = $connection_info['default'];
@@ -277,7 +277,46 @@ class DatabaseConnectionTestCase extends DatabaseTestCase {
 
     // Get a fresh copy of the default connection options.
     $connectionOptions = $db->getConnectionOptions();
-    $this->assertNotEqual($connection_info['default']['database'], $connectionOptions['database'], t('The test connection info database does not match the current connection options database.'));
+    $this->assertNotEqual($connection_info['default']['database'], $connectionOptions['database'], 'The test connection info database does not match the current connection options database.');
+  }
+}
+
+/**
+ * Test cloning Select queries.
+ */
+class DatabaseSelectCloneTest extends DatabaseTestCase {
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Select tests, cloning',
+      'description' => 'Test cloning Select queries.',
+      'group' => 'Database',
+    );
+  }
+
+  /**
+   * Test that subqueries as value within conditions are cloned properly.
+   */
+  function testSelectConditionSubQueryCloning() {
+    $subquery = db_select('test', 't');
+    $subquery->addField('t', 'id', 'id');
+    $subquery->condition('age', 28, '<');
+
+    $query = db_select('test', 't');
+    $query->addField('t', 'name', 'name');
+    $query->condition('id', $subquery, 'IN');
+
+    $clone = clone $query;
+    // Cloned query should not be altered by the following modification
+    // happening on original query.
+    $subquery->condition('age', 25, '>');
+
+    $clone_result = $clone->countQuery()->execute()->fetchField();
+    $query_result = $query->countQuery()->execute()->fetchField();
+
+    // Make sure the cloned query has not been modified
+    $this->assertEqual(3, $clone_result, 'The cloned query returns the expected number of rows');
+    $this->assertEqual(2, $query_result, 'The query returns the expected number of rows');
   }
 }
 
@@ -302,14 +341,14 @@ class DatabaseFetchTestCase extends DatabaseTestCase {
   function testQueryFetchDefault() {
     $records = array();
     $result = db_query('SELECT name FROM {test} WHERE age = :age', array(':age' => 25));
-    $this->assertTrue($result instanceof DatabaseStatementInterface, t('Result set is a Drupal statement object.'));
+    $this->assertTrue($result instanceof DatabaseStatementInterface, 'Result set is a Drupal statement object.');
     foreach ($result as $record) {
       $records[] = $record;
-      $this->assertTrue(is_object($record), t('Record is an object.'));
-      $this->assertIdentical($record->name, 'John', t('25 year old is John.'));
+      $this->assertTrue(is_object($record), 'Record is an object.');
+      $this->assertIdentical($record->name, 'John', '25 year old is John.');
     }
 
-    $this->assertIdentical(count($records), 1, t('There is only one record.'));
+    $this->assertIdentical(count($records), 1, 'There is only one record.');
   }
 
   /**
@@ -320,11 +359,11 @@ class DatabaseFetchTestCase extends DatabaseTestCase {
     $result = db_query('SELECT name FROM {test} WHERE age = :age', array(':age' => 25), array('fetch' => PDO::FETCH_OBJ));
     foreach ($result as $record) {
       $records[] = $record;
-      $this->assertTrue(is_object($record), t('Record is an object.'));
-      $this->assertIdentical($record->name, 'John', t('25 year old is John.'));
+      $this->assertTrue(is_object($record), 'Record is an object.');
+      $this->assertIdentical($record->name, 'John', '25 year old is John.');
     }
 
-    $this->assertIdentical(count($records), 1, t('There is only one record.'));
+    $this->assertIdentical(count($records), 1, 'There is only one record.');
   }
 
   /**
@@ -335,12 +374,12 @@ class DatabaseFetchTestCase extends DatabaseTestCase {
     $result = db_query('SELECT name FROM {test} WHERE age = :age', array(':age' => 25), array('fetch' => PDO::FETCH_ASSOC));
     foreach ($result as $record) {
       $records[] = $record;
-      if ($this->assertTrue(is_array($record), t('Record is an array.'))) {
-        $this->assertIdentical($record['name'], 'John', t('Record can be accessed associatively.'));
+      if ($this->assertTrue(is_array($record), 'Record is an array.')) {
+        $this->assertIdentical($record['name'], 'John', 'Record can be accessed associatively.');
       }
     }
 
-    $this->assertIdentical(count($records), 1, t('There is only one record.'));
+    $this->assertIdentical(count($records), 1, 'There is only one record.');
   }
 
   /**
@@ -353,12 +392,12 @@ class DatabaseFetchTestCase extends DatabaseTestCase {
     $result = db_query('SELECT name FROM {test} WHERE age = :age', array(':age' => 25), array('fetch' => 'FakeRecord'));
     foreach ($result as $record) {
       $records[] = $record;
-      if ($this->assertTrue($record instanceof FakeRecord, t('Record is an object of class FakeRecord.'))) {
-        $this->assertIdentical($record->name, 'John', t('25 year old is John.'));
+      if ($this->assertTrue($record instanceof FakeRecord, 'Record is an object of class FakeRecord.')) {
+        $this->assertIdentical($record->name, 'John', '25 year old is John.');
       }
     }
 
-    $this->assertIdentical(count($records), 1, t('There is only one record.'));
+    $this->assertIdentical(count($records), 1, 'There is only one record.');
   }
 }
 
@@ -387,8 +426,8 @@ class DatabaseFetch2TestCase extends DatabaseTestCase {
     $result = db_query('SELECT name FROM {test} WHERE age = :age', array(':age' => 25), array('fetch' => PDO::FETCH_NUM));
     foreach ($result as $record) {
       $records[] = $record;
-      if ($this->assertTrue(is_array($record), t('Record is an array.'))) {
-        $this->assertIdentical($record[0], 'John', t('Record can be accessed numerically.'));
+      if ($this->assertTrue(is_array($record), 'Record is an array.')) {
+        $this->assertIdentical($record[0], 'John', 'Record can be accessed numerically.');
       }
     }
 
@@ -403,13 +442,13 @@ class DatabaseFetch2TestCase extends DatabaseTestCase {
     $result = db_query('SELECT name FROM {test} WHERE age = :age', array(':age' => 25), array('fetch' => PDO::FETCH_BOTH));
     foreach ($result as $record) {
       $records[] = $record;
-      if ($this->assertTrue(is_array($record), t('Record is an array.'))) {
-        $this->assertIdentical($record[0], 'John', t('Record can be accessed numerically.'));
-        $this->assertIdentical($record['name'], 'John', t('Record can be accessed associatively.'));
+      if ($this->assertTrue(is_array($record), 'Record is an array.')) {
+        $this->assertIdentical($record[0], 'John', 'Record can be accessed numerically.');
+        $this->assertIdentical($record['name'], 'John', 'Record can be accessed associatively.');
       }
     }
 
-    $this->assertIdentical(count($records), 1, t('There is only one record.'));
+    $this->assertIdentical(count($records), 1, 'There is only one record.');
   }
 
   /**
@@ -419,12 +458,12 @@ class DatabaseFetch2TestCase extends DatabaseTestCase {
     $records = array();
     $result = db_query('SELECT name FROM {test} WHERE age > :age', array(':age' => 25));
     $column = $result->fetchCol();
-    $this->assertIdentical(count($column), 3, t('fetchCol() returns the right number of records.'));
+    $this->assertIdentical(count($column), 3, 'fetchCol() returns the right number of records.');
 
     $result = db_query('SELECT name FROM {test} WHERE age > :age', array(':age' => 25));
     $i = 0;
     foreach ($result as $record) {
-      $this->assertIdentical($record->name, $column[$i++], t('Column matches direct accesss.'));
+      $this->assertIdentical($record->name, $column[$i++], 'Column matches direct accesss.');
     }
   }
 }
@@ -456,9 +495,9 @@ class DatabaseInsertTestCase extends DatabaseTestCase {
     $query->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test}')->fetchField();
-    $this->assertIdentical($num_records_before + 1, (int) $num_records_after, t('Record inserts correctly.'));
+    $this->assertIdentical($num_records_before + 1, (int) $num_records_after, 'Record inserts correctly.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Yoko'))->fetchField();
-    $this->assertIdentical($saved_age, '29', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '29', 'Can retrieve after inserting.');
   }
 
   /**
@@ -485,13 +524,13 @@ class DatabaseInsertTestCase extends DatabaseTestCase {
     $query->execute();
 
     $num_records_after = (int) db_query('SELECT COUNT(*) FROM {test}')->fetchField();
-    $this->assertIdentical($num_records_before + 3, $num_records_after, t('Record inserts correctly.'));
+    $this->assertIdentical($num_records_before + 3, $num_records_after, 'Record inserts correctly.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Larry'))->fetchField();
-    $this->assertIdentical($saved_age, '30', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '30', 'Can retrieve after inserting.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Curly'))->fetchField();
-    $this->assertIdentical($saved_age, '31', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '31', 'Can retrieve after inserting.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Moe'))->fetchField();
-    $this->assertIdentical($saved_age, '32', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '32', 'Can retrieve after inserting.');
   }
 
   /**
@@ -520,13 +559,13 @@ class DatabaseInsertTestCase extends DatabaseTestCase {
     $query->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test}')->fetchField();
-    $this->assertIdentical((int) $num_records_before + 3, (int) $num_records_after, t('Record inserts correctly.'));
+    $this->assertIdentical((int) $num_records_before + 3, (int) $num_records_after, 'Record inserts correctly.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Larry'))->fetchField();
-    $this->assertIdentical($saved_age, '30', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '30', 'Can retrieve after inserting.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Curly'))->fetchField();
-    $this->assertIdentical($saved_age, '31', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '31', 'Can retrieve after inserting.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Moe'))->fetchField();
-    $this->assertIdentical($saved_age, '32', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '32', 'Can retrieve after inserting.');
   }
 
   /**
@@ -542,11 +581,11 @@ class DatabaseInsertTestCase extends DatabaseTestCase {
       ->values(array('Moe', '32'))
       ->execute();
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Larry'))->fetchField();
-    $this->assertIdentical($saved_age, '30', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '30', 'Can retrieve after inserting.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Curly'))->fetchField();
-    $this->assertIdentical($saved_age, '31', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '31', 'Can retrieve after inserting.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Moe'))->fetchField();
-    $this->assertIdentical($saved_age, '32', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '32', 'Can retrieve after inserting.');
   }
 
   /**
@@ -560,7 +599,7 @@ class DatabaseInsertTestCase extends DatabaseTestCase {
       ))
       ->execute();
 
-    $this->assertIdentical($id, '5', t('Auto-increment ID returned successfully.'));
+    $this->assertIdentical($id, '5', 'Auto-increment ID returned successfully.');
   }
 
   /**
@@ -586,7 +625,7 @@ class DatabaseInsertTestCase extends DatabaseTestCase {
       ->execute();
 
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Meredith'))->fetchField();
-    $this->assertIdentical($saved_age, '30', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '30', 'Can retrieve after inserting.');
   }
 }
 
@@ -608,12 +647,12 @@ class DatabaseInsertLOBTestCase extends DatabaseTestCase {
    */
   function testInsertOneBlob() {
     $data = "This is\000a test.";
-    $this->assertTrue(strlen($data) === 15, t('Test data contains a NULL.'));
+    $this->assertTrue(strlen($data) === 15, 'Test data contains a NULL.');
     $id = db_insert('test_one_blob')
       ->fields(array('blob1' => $data))
       ->execute();
     $r = db_query('SELECT * FROM {test_one_blob} WHERE id = :id', array(':id' => $id))->fetchAssoc();
-    $this->assertTrue($r['blob1'] === $data, t('Can insert a blob: id @id, @data.', array('@id' => $id, '@data' => serialize($r))));
+    $this->assertTrue($r['blob1'] === $data, format_string('Can insert a blob: id @id, @data.', array('@id' => $id, '@data' => serialize($r))));
   }
 
   /**
@@ -627,7 +666,7 @@ class DatabaseInsertLOBTestCase extends DatabaseTestCase {
       ))
       ->execute();
     $r = db_query('SELECT * FROM {test_two_blobs} WHERE id = :id', array(':id' => $id))->fetchAssoc();
-    $this->assertTrue($r['blob1'] === 'This is' && $r['blob2'] === 'a test', t('Can insert multiple blobs per row.'));
+    $this->assertTrue($r['blob1'] === 'This is' && $r['blob2'] === 'a test', 'Can insert multiple blobs per row.');
   }
 }
 
@@ -654,7 +693,7 @@ class DatabaseInsertDefaultsTestCase extends DatabaseTestCase {
     $schema = drupal_get_schema('test');
 
     $job = db_query('SELECT job FROM {test} WHERE id = :id', array(':id' => $id))->fetchField();
-    $this->assertEqual($job, $schema['fields']['job']['default'], t('Default field value is set.'));
+    $this->assertEqual($job, $schema['fields']['job']['default'], 'Default field value is set.');
   }
 
   /**
@@ -666,13 +705,13 @@ class DatabaseInsertDefaultsTestCase extends DatabaseTestCase {
     try {
       $result = db_insert('test')->execute();
       // This is only executed if no exception has been thrown.
-      $this->fail(t('Expected exception NoFieldsException has not been thrown.'));
+      $this->fail('Expected exception NoFieldsException has not been thrown.');
     } catch (NoFieldsException $e) {
-      $this->pass(t('Expected exception NoFieldsException has been thrown.'));
+      $this->pass('Expected exception NoFieldsException has been thrown.');
     }
 
     $num_records_after = (int) db_query('SELECT COUNT(*) FROM {test}')->fetchField();
-    $this->assertIdentical($num_records_before, $num_records_after, t('Do nothing as no fields are specified.'));
+    $this->assertIdentical($num_records_before, $num_records_after, 'Do nothing as no fields are specified.');
   }
 
   /**
@@ -687,7 +726,7 @@ class DatabaseInsertDefaultsTestCase extends DatabaseTestCase {
     $schema = drupal_get_schema('test');
 
     $job = db_query('SELECT job FROM {test} WHERE id = :id', array(':id' => $id))->fetchField();
-    $this->assertEqual($job, $schema['fields']['job']['default'], t('Default field value is set.'));
+    $this->assertEqual($job, $schema['fields']['job']['default'], 'Default field value is set.');
   }
 }
 
@@ -712,10 +751,10 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
       ->fields(array('name' => 'Tiffany'))
       ->condition('id', 1)
       ->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $saved_name = db_query('SELECT name FROM {test} WHERE id = :id', array(':id' => 1))->fetchField();
-    $this->assertIdentical($saved_name, 'Tiffany', t('Updated name successfully.'));
+    $this->assertIdentical($saved_name, 'Tiffany', 'Updated name successfully.');
   }
 
   /**
@@ -727,10 +766,10 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
       ->fields(array('age' => NULL))
       ->condition('name', 'Kermit')
       ->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $saved_age = db_query('SELECT age FROM {test_null} WHERE name = :name', array(':name' => 'Kermit'))->fetchField();
-    $this->assertNull($saved_age, t('Updated name successfully.'));
+    $this->assertNull($saved_age, 'Updated name successfully.');
   }
 
   /**
@@ -741,10 +780,10 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->condition('job', 'Singer')
       ->execute();
-    $this->assertIdentical($num_updated, 2, t('Updated 2 records.'));
+    $this->assertIdentical($num_updated, 2, 'Updated 2 records.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '2', 'Updated fields successfully.');
   }
 
   /**
@@ -755,10 +794,10 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->condition('age', 26, '>')
       ->execute();
-    $this->assertIdentical($num_updated, 2, t('Updated 2 records.'));
+    $this->assertIdentical($num_updated, 2, 'Updated 2 records.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '2', 'Updated fields successfully.');
   }
 
   /**
@@ -769,10 +808,10 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->where('age > :age', array(':age' => 26))
       ->execute();
-    $this->assertIdentical($num_updated, 2, t('Updated 2 records.'));
+    $this->assertIdentical($num_updated, 2, 'Updated 2 records.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '2', 'Updated fields successfully.');
   }
 
   /**
@@ -784,10 +823,10 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
       ->where('age > :age', array(':age' => 26))
       ->condition('name', 'Ringo');
     $num_updated = $update->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '1', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '1', 'Updated fields successfully.');
   }
 
   /**
@@ -807,7 +846,21 @@ class DatabaseUpdateTestCase extends DatabaseTestCase {
     $num_rows = db_update('test')
       ->expression('age', 'age * age')
       ->execute();
-    $this->assertIdentical($num_rows, 3, t('Number of affected rows are returned.'));
+    $this->assertIdentical($num_rows, 3, 'Number of affected rows are returned.');
+  }
+
+  /**
+   * Confirm that we can update the primary key of a record successfully.
+   */
+  function testPrimaryKeyUpdate() {
+    $num_updated = db_update('test')
+      ->fields(array('id' => 42, 'name' => 'John'))
+      ->condition('id', 1)
+      ->execute();
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
+
+    $saved_name= db_query('SELECT name FROM {test} WHERE id = :id', array(':id' => 42))->fetchField();
+    $this->assertIdentical($saved_name, 'John', 'Updated primary key successfully.');
   }
 }
 
@@ -835,10 +888,10 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
         ->condition('name', 'Paul')
       );
     $num_updated = $update->execute();
-    $this->assertIdentical($num_updated, 2, t('Updated 2 records.'));
+    $this->assertIdentical($num_updated, 2, 'Updated 2 records.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '2', 'Updated fields successfully.');
   }
 
   /**
@@ -849,10 +902,10 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->condition('name', array('John', 'Paul'), 'IN')
       ->execute();
-    $this->assertIdentical($num_updated, 2, t('Updated 2 records.'));
+    $this->assertIdentical($num_updated, 2, 'Updated 2 records.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '2', 'Updated fields successfully.');
   }
 
   /**
@@ -865,10 +918,10 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->condition('name', array('John', 'Paul', 'George'), 'NoT IN')
       ->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '1', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '1', 'Updated fields successfully.');
   }
 
   /**
@@ -879,10 +932,10 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->condition('age', array(25, 26), 'BETWEEN')
       ->execute();
-    $this->assertIdentical($num_updated, 2, t('Updated 2 records.'));
+    $this->assertIdentical($num_updated, 2, 'Updated 2 records.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '2', 'Updated fields successfully.');
   }
 
   /**
@@ -893,10 +946,10 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->condition('name', '%ge%', 'LIKE')
       ->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '1', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '1', 'Updated fields successfully.');
   }
 
   /**
@@ -910,15 +963,15 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
       ->fields(array('job' => 'Musician'))
       ->expression('age', 'age + :age', array(':age' => 4))
       ->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $num_matches = db_query('SELECT COUNT(*) FROM {test} WHERE job = :job', array(':job' => 'Musician'))->fetchField();
-    $this->assertIdentical($num_matches, '1', t('Updated fields successfully.'));
+    $this->assertIdentical($num_matches, '1', 'Updated fields successfully.');
 
     $person = db_query('SELECT * FROM {test} WHERE name = :name', array(':name' => 'Ringo'))->fetch();
-    $this->assertEqual($person->name, 'Ringo', t('Name set correctly.'));
-    $this->assertEqual($person->age, $before_age + 4, t('Age set correctly.'));
-    $this->assertEqual($person->job, 'Musician', t('Job set correctly.'));
+    $this->assertEqual($person->name, 'Ringo', 'Name set correctly.');
+    $this->assertEqual($person->age, $before_age + 4, 'Age set correctly.');
+    $this->assertEqual($person->job, 'Musician', 'Job set correctly.');
     $GLOBALS['larry_test'] = 0;
   }
 
@@ -931,10 +984,10 @@ class DatabaseUpdateComplexTestCase extends DatabaseTestCase {
       ->condition('name', 'Ringo')
       ->expression('age', 'age + :age', array(':age' => 4))
       ->execute();
-    $this->assertIdentical($num_updated, 1, t('Updated 1 record.'));
+    $this->assertIdentical($num_updated, 1, 'Updated 1 record.');
 
     $after_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'Ringo'))->fetchField();
-    $this->assertEqual($before_age + 4, $after_age, t('Age updated correctly'));
+    $this->assertEqual($before_age + 4, $after_age, 'Age updated correctly');
   }
 }
 
@@ -956,7 +1009,7 @@ class DatabaseUpdateLOBTestCase extends DatabaseTestCase {
    */
   function testUpdateOneBlob() {
     $data = "This is\000a test.";
-    $this->assertTrue(strlen($data) === 15, t('Test data contains a NULL.'));
+    $this->assertTrue(strlen($data) === 15, 'Test data contains a NULL.');
     $id = db_insert('test_one_blob')
       ->fields(array('blob1' => $data))
       ->execute();
@@ -968,7 +1021,7 @@ class DatabaseUpdateLOBTestCase extends DatabaseTestCase {
       ->execute();
 
     $r = db_query('SELECT * FROM {test_one_blob} WHERE id = :id', array(':id' => $id))->fetchAssoc();
-    $this->assertTrue($r['blob1'] === $data, t('Can update a blob: id @id, @data.', array('@id' => $id, '@data' => serialize($r))));
+    $this->assertTrue($r['blob1'] === $data, format_string('Can update a blob: id @id, @data.', array('@id' => $id, '@data' => serialize($r))));
   }
 
   /**
@@ -988,7 +1041,7 @@ class DatabaseUpdateLOBTestCase extends DatabaseTestCase {
       ->execute();
 
     $r = db_query('SELECT * FROM {test_two_blobs} WHERE id = :id', array(':id' => $id))->fetchAssoc();
-    $this->assertTrue($r['blob1'] === 'and so' && $r['blob2'] === 'is this', t('Can update multiple blobs per row.'));
+    $this->assertTrue($r['blob1'] === 'and so' && $r['blob2'] === 'is this', 'Can update multiple blobs per row.');
   }
 }
 
@@ -1028,10 +1081,10 @@ class DatabaseDeleteTruncateTestCase extends DatabaseTestCase {
       ->condition('pid', $subquery, 'IN');
 
     $num_deleted = $delete->execute();
-    $this->assertEqual($num_deleted, 1, t("Deleted 1 record."));
+    $this->assertEqual($num_deleted, 1, "Deleted 1 record.");
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_task}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after + $num_deleted, t('Deletion adds up.'));
+    $this->assertEqual($num_records_before, $num_records_after + $num_deleted, 'Deletion adds up.');
   }
 
   /**
@@ -1043,10 +1096,10 @@ class DatabaseDeleteTruncateTestCase extends DatabaseTestCase {
     $num_deleted = db_delete('test')
       ->condition('id', 1)
       ->execute();
-    $this->assertIdentical($num_deleted, 1, t('Deleted 1 record.'));
+    $this->assertIdentical($num_deleted, 1, 'Deleted 1 record.');
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after + $num_deleted, t('Deletion adds up.'));
+    $this->assertEqual($num_records_before, $num_records_after + $num_deleted, 'Deletion adds up.');
   }
 
   /**
@@ -1058,7 +1111,7 @@ class DatabaseDeleteTruncateTestCase extends DatabaseTestCase {
     db_truncate('test')->execute();
 
     $num_records_after = db_query("SELECT COUNT(*) FROM {test}")->fetchField();
-    $this->assertEqual(0, $num_records_after, t('Truncate really deletes everything.'));
+    $this->assertEqual(0, $num_records_after, 'Truncate really deletes everything.');
   }
 }
 
@@ -1089,15 +1142,15 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ))
       ->execute();
 
-    $this->assertEqual($result, MergeQuery::STATUS_INSERT, t('Insert status returned.'));
+    $this->assertEqual($result, MergeQuery::STATUS_INSERT, 'Insert status returned.');
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before + 1, $num_records_after, t('Merge inserted properly.'));
+    $this->assertEqual($num_records_before + 1, $num_records_after, 'Merge inserted properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Presenter'))->fetch();
-    $this->assertEqual($person->name, 'Tiffany', t('Name set correctly.'));
-    $this->assertEqual($person->age, 31, t('Age set correctly.'));
-    $this->assertEqual($person->job, 'Presenter', t('Job set correctly.'));
+    $this->assertEqual($person->name, 'Tiffany', 'Name set correctly.');
+    $this->assertEqual($person->age, 31, 'Age set correctly.');
+    $this->assertEqual($person->job, 'Presenter', 'Job set correctly.');
   }
 
   /**
@@ -1114,15 +1167,15 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ))
       ->execute();
 
-    $this->assertEqual($result, MergeQuery::STATUS_UPDATE, t('Update status returned.'));
+    $this->assertEqual($result, MergeQuery::STATUS_UPDATE, 'Update status returned.');
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after, t('Merge updated properly.'));
+    $this->assertEqual($num_records_before, $num_records_after, 'Merge updated properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Speaker'))->fetch();
-    $this->assertEqual($person->name, 'Tiffany', t('Name set correctly.'));
-    $this->assertEqual($person->age, 31, t('Age set correctly.'));
-    $this->assertEqual($person->job, 'Speaker', t('Job set correctly.'));
+    $this->assertEqual($person->name, 'Tiffany', 'Name set correctly.');
+    $this->assertEqual($person->age, 31, 'Age set correctly.');
+    $this->assertEqual($person->job, 'Speaker', 'Job set correctly.');
   }
 
   /**
@@ -1138,12 +1191,12 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after, t('Merge updated properly.'));
+    $this->assertEqual($num_records_before, $num_records_after, 'Merge updated properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Speaker'))->fetch();
-    $this->assertEqual($person->name, 'Tiffany', t('Name set correctly.'));
-    $this->assertEqual($person->age, 30, t('Age skipped correctly.'));
-    $this->assertEqual($person->job, 'Speaker', t('Job set correctly.'));
+    $this->assertEqual($person->name, 'Tiffany', 'Name set correctly.');
+    $this->assertEqual($person->age, 30, 'Age skipped correctly.');
+    $this->assertEqual($person->job, 'Speaker', 'Job set correctly.');
   }
 
   /**
@@ -1164,12 +1217,12 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after, t('Merge updated properly.'));
+    $this->assertEqual($num_records_before, $num_records_after, 'Merge updated properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Speaker'))->fetch();
-    $this->assertEqual($person->name, 'Joe', t('Name set correctly.'));
-    $this->assertEqual($person->age, 30, t('Age skipped correctly.'));
-    $this->assertEqual($person->job, 'Speaker', t('Job set correctly.'));
+    $this->assertEqual($person->name, 'Joe', 'Name set correctly.');
+    $this->assertEqual($person->age, 30, 'Age skipped correctly.');
+    $this->assertEqual($person->job, 'Speaker', 'Job set correctly.');
   }
 
   /**
@@ -1193,12 +1246,12 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after, t('Merge updated properly.'));
+    $this->assertEqual($num_records_before, $num_records_after, 'Merge updated properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Speaker'))->fetch();
-    $this->assertEqual($person->name, 'Tiffany', t('Name set correctly.'));
-    $this->assertEqual($person->age, $age_before + 4, t('Age updated correctly.'));
-    $this->assertEqual($person->job, 'Speaker', t('Job set correctly.'));
+    $this->assertEqual($person->name, 'Tiffany', 'Name set correctly.');
+    $this->assertEqual($person->age, $age_before + 4, 'Age updated correctly.');
+    $this->assertEqual($person->job, 'Speaker', 'Job set correctly.');
   }
 
   /**
@@ -1212,12 +1265,12 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before + 1, $num_records_after, t('Merge inserted properly.'));
+    $this->assertEqual($num_records_before + 1, $num_records_after, 'Merge inserted properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Presenter'))->fetch();
-    $this->assertEqual($person->name, '', t('Name set correctly.'));
-    $this->assertEqual($person->age, 0, t('Age set correctly.'));
-    $this->assertEqual($person->job, 'Presenter', t('Job set correctly.'));
+    $this->assertEqual($person->name, '', 'Name set correctly.');
+    $this->assertEqual($person->age, 0, 'Age set correctly.');
+    $this->assertEqual($person->job, 'Presenter', 'Job set correctly.');
   }
 
   /**
@@ -1231,12 +1284,12 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after, t('Merge skipped properly.'));
+    $this->assertEqual($num_records_before, $num_records_after, 'Merge skipped properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Speaker'))->fetch();
-    $this->assertEqual($person->name, 'Meredith', t('Name skipped correctly.'));
-    $this->assertEqual($person->age, 30, t('Age skipped correctly.'));
-    $this->assertEqual($person->job, 'Speaker', t('Job skipped correctly.'));
+    $this->assertEqual($person->name, 'Meredith', 'Name skipped correctly.');
+    $this->assertEqual($person->age, 30, 'Age skipped correctly.');
+    $this->assertEqual($person->job, 'Speaker', 'Job skipped correctly.');
 
     db_merge('test_people')
       ->key(array('job' => 'Speaker'))
@@ -1244,12 +1297,12 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test_people}')->fetchField();
-    $this->assertEqual($num_records_before, $num_records_after, t('Merge skipped properly.'));
+    $this->assertEqual($num_records_before, $num_records_after, 'Merge skipped properly.');
 
     $person = db_query('SELECT * FROM {test_people} WHERE job = :job', array(':job' => 'Speaker'))->fetch();
-    $this->assertEqual($person->name, 'Meredith', t('Name skipped correctly.'));
-    $this->assertEqual($person->age, 30, t('Age skipped correctly.'));
-    $this->assertEqual($person->job, 'Speaker', t('Job skipped correctly.'));
+    $this->assertEqual($person->name, 'Meredith', 'Name skipped correctly.');
+    $this->assertEqual($person->age, 30, 'Age skipped correctly.');
+    $this->assertEqual($person->job, 'Speaker', 'Job skipped correctly.');
   }
 
   /**
@@ -1266,10 +1319,10 @@ class DatabaseMergeTestCase extends DatabaseTestCase {
         ->execute();
     }
     catch (InvalidMergeQueryException $e) {
-      $this->pass(t('InvalidMergeQueryException thrown for invalid query.'));
+      $this->pass('InvalidMergeQueryException thrown for invalid query.');
       return;
     }
-    $this->fail(t('No InvalidMergeQueryException thrown'));
+    $this->fail('No InvalidMergeQueryException thrown');
   }
 }
 
@@ -1300,7 +1353,7 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       $num_records++;
     }
 
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1320,8 +1373,8 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $query = (string)$query;
     $expected = "/* Testing query comments */ SELECT test.name AS name, test.age AS age\nFROM \n{test} test";
 
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
-    $this->assertEqual($query, $expected, t('The flattened query contains the comment string.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
+    $this->assertEqual($query, $expected, 'The flattened query contains the comment string.');
   }
 
   /**
@@ -1341,8 +1394,8 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $query = (string)$query;
     $expected = "/* Testing query comments SELECT nid FROM {node}; -- */ SELECT test.name AS name, test.age AS age\nFROM \n{test} test";
 
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
-    $this->assertEqual($query, $expected, t('The flattened query contains the sanitised comment string.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
+    $this->assertEqual($query, $expected, 'The flattened query contains the sanitised comment string.');
   }
 
   /**
@@ -1356,13 +1409,13 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $result = $query->execute();
 
     // Check that the aliases are being created the way we want.
-    $this->assertEqual($name_field, 'name', t('Name field alias is correct.'));
-    $this->assertEqual($age_field, 'age', t('Age field alias is correct.'));
+    $this->assertEqual($name_field, 'name', 'Name field alias is correct.');
+    $this->assertEqual($age_field, 'age', 'Age field alias is correct.');
 
     // Ensure that we got the right record.
     $record = $result->fetch();
-    $this->assertEqual($record->$name_field, 'George', t('Fetched name is correct.'));
-    $this->assertEqual($record->$age_field, 27, t('Fetched age is correct.'));
+    $this->assertEqual($record->$name_field, 'George', 'Fetched name is correct.');
+    $this->assertEqual($record->$age_field, 27, 'Fetched age is correct.');
   }
 
   /**
@@ -1376,13 +1429,13 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $result = $query->execute();
 
     // Check that the aliases are being created the way we want.
-    $this->assertEqual($name_field, 'name', t('Name field alias is correct.'));
-    $this->assertEqual($age_field, 'double_age', t('Age field alias is correct.'));
+    $this->assertEqual($name_field, 'name', 'Name field alias is correct.');
+    $this->assertEqual($age_field, 'double_age', 'Age field alias is correct.');
 
     // Ensure that we got the right record.
     $record = $result->fetch();
-    $this->assertEqual($record->$name_field, 'George', t('Fetched name is correct.'));
-    $this->assertEqual($record->$age_field, 27*2, t('Fetched age expression is correct.'));
+    $this->assertEqual($record->$name_field, 'George', 'Fetched name is correct.');
+    $this->assertEqual($record->$age_field, 27*2, 'Fetched age expression is correct.');
   }
 
   /**
@@ -1397,14 +1450,14 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $result = $query->execute();
 
     // Check that the aliases are being created the way we want.
-    $this->assertEqual($age_double_field, 'expression', t('Double age field alias is correct.'));
-    $this->assertEqual($age_triple_field, 'expression_2', t('Triple age field alias is correct.'));
+    $this->assertEqual($age_double_field, 'expression', 'Double age field alias is correct.');
+    $this->assertEqual($age_triple_field, 'expression_2', 'Triple age field alias is correct.');
 
     // Ensure that we got the right record.
     $record = $result->fetch();
-    $this->assertEqual($record->$name_field, 'George', t('Fetched name is correct.'));
-    $this->assertEqual($record->$age_double_field, 27*2, t('Fetched double age expression is correct.'));
-    $this->assertEqual($record->$age_triple_field, 27*3, t('Fetched triple age expression is correct.'));
+    $this->assertEqual($record->$name_field, 'George', 'Fetched name is correct.');
+    $this->assertEqual($record->$age_double_field, 27*2, 'Fetched double age expression is correct.');
+    $this->assertEqual($record->$age_triple_field, 27*3, 'Fetched triple age expression is correct.');
   }
 
   /**
@@ -1417,17 +1470,17 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->execute()->fetchObject();
 
     // Check that all fields we asked for are present.
-    $this->assertNotNull($record->id, t('ID field is present.'));
-    $this->assertNotNull($record->name, t('Name field is present.'));
-    $this->assertNotNull($record->age, t('Age field is present.'));
-    $this->assertNotNull($record->job, t('Job field is present.'));
+    $this->assertNotNull($record->id, 'ID field is present.');
+    $this->assertNotNull($record->name, 'Name field is present.');
+    $this->assertNotNull($record->age, 'Age field is present.');
+    $this->assertNotNull($record->job, 'Job field is present.');
 
     // Ensure that we got the right record.
     // Check that all fields we asked for are present.
-    $this->assertEqual($record->id, 2, t('ID field has the correct value.'));
-    $this->assertEqual($record->name, 'George', t('Name field has the correct value.'));
-    $this->assertEqual($record->age, 27, t('Age field has the correct value.'));
-    $this->assertEqual($record->job, 'Singer', t('Job field has the correct value.'));
+    $this->assertEqual($record->id, 2, 'ID field has the correct value.');
+    $this->assertEqual($record->name, 'George', 'Name field has the correct value.');
+    $this->assertEqual($record->age, 27, 'Age field has the correct value.');
+    $this->assertEqual($record->job, 'Singer', 'Job field has the correct value.');
   }
 
   /**
@@ -1440,17 +1493,17 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->execute()->fetchObject();
 
     // Check that all fields we asked for are present.
-    $this->assertNotNull($record->id, t('ID field is present.'));
-    $this->assertNotNull($record->name, t('Name field is present.'));
-    $this->assertNotNull($record->age, t('Age field is present.'));
-    $this->assertNotNull($record->job, t('Job field is present.'));
+    $this->assertNotNull($record->id, 'ID field is present.');
+    $this->assertNotNull($record->name, 'Name field is present.');
+    $this->assertNotNull($record->age, 'Age field is present.');
+    $this->assertNotNull($record->job, 'Job field is present.');
 
     // Ensure that we got the right record.
     // Check that all fields we asked for are present.
-    $this->assertEqual($record->id, 2, t('ID field has the correct value.'));
-    $this->assertEqual($record->name, 'George', t('Name field has the correct value.'));
-    $this->assertEqual($record->age, 27, t('Age field has the correct value.'));
-    $this->assertEqual($record->job, 'Singer', t('Job field has the correct value.'));
+    $this->assertEqual($record->id, 2, 'ID field has the correct value.');
+    $this->assertEqual($record->name, 'George', 'Name field has the correct value.');
+    $this->assertEqual($record->age, 27, 'Age field has the correct value.');
+    $this->assertEqual($record->job, 'Singer', 'Job field has the correct value.');
   }
 
   /**
@@ -1464,8 +1517,8 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->isNull('age')
       ->execute()->fetchCol();
 
-    $this->assertEqual(count($names), 1, t('Correct number of records found with NULL age.'));
-    $this->assertEqual($names[0], 'Fozzie', t('Correct record returned for NULL age.'));
+    $this->assertEqual(count($names), 1, 'Correct number of records found with NULL age.');
+    $this->assertEqual($names[0], 'Fozzie', 'Correct record returned for NULL age.');
   }
 
   /**
@@ -1480,9 +1533,9 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->orderBy('name')
       ->execute()->fetchCol();
 
-    $this->assertEqual(count($names), 2, t('Correct number of records found withNOT NULL age.'));
-    $this->assertEqual($names[0], 'Gonzo', t('Correct record returned for NOT NULL age.'));
-    $this->assertEqual($names[1], 'Kermit', t('Correct record returned for NOT NULL age.'));
+    $this->assertEqual(count($names), 2, 'Correct number of records found withNOT NULL age.');
+    $this->assertEqual($names[0], 'Gonzo', 'Correct record returned for NOT NULL age.');
+    $this->assertEqual($names[1], 'Kermit', 'Correct record returned for NOT NULL age.');
   }
 
   /**
@@ -1503,10 +1556,10 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $names = $query_1->execute()->fetchCol();
 
     // Ensure we only get 2 records.
-    $this->assertEqual(count($names), 2, t('UNION correctly discarded duplicates.'));
+    $this->assertEqual(count($names), 2, 'UNION correctly discarded duplicates.');
 
-    $this->assertEqual($names[0], 'George', t('First query returned correct name.'));
-    $this->assertEqual($names[1], 'Ringo', t('Second query returned correct name.'));
+    $this->assertEqual($names[0], 'George', 'First query returned correct name.');
+    $this->assertEqual($names[1], 'Ringo', 'Second query returned correct name.');
   }
 
   /**
@@ -1526,11 +1579,11 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
     $names = $query_1->execute()->fetchCol();
 
     // Ensure we get all 3 records.
-    $this->assertEqual(count($names), 3, t('UNION ALL correctly preserved duplicates.'));
+    $this->assertEqual(count($names), 3, 'UNION ALL correctly preserved duplicates.');
 
-    $this->assertEqual($names[0], 'George', t('First query returned correct first name.'));
-    $this->assertEqual($names[1], 'Ringo', t('Second query returned correct second name.'));
-    $this->assertEqual($names[2], 'Ringo', t('Third query returned correct name.'));
+    $this->assertEqual($names[0], 'George', 'First query returned correct first name.');
+    $this->assertEqual($names[1], 'Ringo', 'Second query returned correct second name.');
+    $this->assertEqual($names[2], 'Ringo', 'Third query returned correct name.');
   }
 
   /**
@@ -1565,7 +1618,7 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->orderBy('id')
       ->execute()
       ->fetchCol();
-    $this->assertEqual($ordered_ids, $expected_ids, t('A query without random ordering returns IDs in the correct order.'));
+    $this->assertEqual($ordered_ids, $expected_ids, 'A query without random ordering returns IDs in the correct order.');
 
     // Now perform the same query, but instead choose a random ordering. We
     // expect this to contain a differently ordered version of the original
@@ -1576,10 +1629,10 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->orderRandom()
       ->execute()
       ->fetchCol();
-    $this->assertNotEqual($randomized_ids, $ordered_ids, t('A query with random ordering returns an unordered set of IDs.'));
+    $this->assertNotEqual($randomized_ids, $ordered_ids, 'A query with random ordering returns an unordered set of IDs.');
     $sorted_ids = $randomized_ids;
     sort($sorted_ids);
-    $this->assertEqual($sorted_ids, $ordered_ids, t('After sorting the random list, the result matches the original query.'));
+    $this->assertEqual($sorted_ids, $ordered_ids, 'After sorting the random list, the result matches the original query.');
 
     // Now perform the exact same query again, and make sure the order is
     // different.
@@ -1589,10 +1642,10 @@ class DatabaseSelectTestCase extends DatabaseTestCase {
       ->orderRandom()
       ->execute()
       ->fetchCol();
-    $this->assertNotEqual($randomized_ids_second_set, $randomized_ids, t('Performing the query with random ordering a second time returns IDs in a different order.'));
+    $this->assertNotEqual($randomized_ids_second_set, $randomized_ids, 'Performing the query with random ordering a second time returns IDs in a different order.');
     $sorted_ids_second_set = $randomized_ids_second_set;
     sort($sorted_ids_second_set);
-    $this->assertEqual($sorted_ids_second_set, $sorted_ids, t('After sorting the second random list, the result matches the sorted version of the first random list.'));
+    $this->assertEqual($sorted_ids_second_set, $sorted_ids, 'After sorting the second random list, the result matches the sorted version of the first random list.');
   }
 
   /**
@@ -1649,7 +1702,7 @@ class DatabaseSelectSubqueryTestCase extends DatabaseTestCase {
       // WHERE tt.task = 'code'
       $people = $select->execute()->fetchCol();
 
-      $this->assertEqual(count($people), 1, t('Returned the correct number of rows.'));
+      $this->assertEqual(count($people), 1, 'Returned the correct number of rows.');
     }
   }
 
@@ -1676,7 +1729,7 @@ class DatabaseSelectSubqueryTestCase extends DatabaseTestCase {
     //   INNER JOIN test t ON t.id=tt.pid
     $people = $select->execute()->fetchCol();
 
-    $this->assertEqual(count($people), 1, t('Returned the correct number of rows.'));
+    $this->assertEqual(count($people), 1, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1699,7 +1752,7 @@ class DatabaseSelectSubqueryTestCase extends DatabaseTestCase {
     // FROM test tt2
     // WHERE tt2.pid IN (SELECT tt.pid AS pid FROM test_task tt WHERE tt.priority=1)
     $people = $select->execute()->fetchCol();
-    $this->assertEqual(count($people), 5, t('Returned the correct number of rows.'));
+    $this->assertEqual(count($people), 5, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1723,7 +1776,7 @@ class DatabaseSelectSubqueryTestCase extends DatabaseTestCase {
     //   INNER JOIN (SELECT tt.pid AS pid FROM test_task tt WHERE priority=1) tt ON t.id=tt.pid
     $people = $select->execute()->fetchCol();
 
-    $this->assertEqual(count($people), 2, t('Returned the correct number of rows.'));
+    $this->assertEqual(count($people), 2, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1753,7 +1806,7 @@ class DatabaseSelectSubqueryTestCase extends DatabaseTestCase {
 
     // Ensure that we got the right record.
     $record = $result->fetch();
-    $this->assertEqual($record->name, 'George', t('Fetched name is correct using EXISTS query.'));
+    $this->assertEqual($record->name, 'George', 'Fetched name is correct using EXISTS query.');
   }
 
   /**
@@ -1783,7 +1836,7 @@ class DatabaseSelectSubqueryTestCase extends DatabaseTestCase {
 
     // Ensure that we got the right number of records.
     $people = $query->execute()->fetchCol();
-    $this->assertEqual(count($people), 3, t('NOT EXISTS query returned the correct results.'));
+    $this->assertEqual(count($people), 3, 'NOT EXISTS query returned the correct results.');
   }
 }
 
@@ -1814,11 +1867,11 @@ class DatabaseSelectOrderedTestCase extends DatabaseTestCase {
     $last_age = 0;
     foreach ($result as $record) {
       $num_records++;
-      $this->assertTrue($record->age >= $last_age, t('Results returned in correct order.'));
+      $this->assertTrue($record->age >= $last_age, 'Results returned in correct order.');
       $last_age = $record->age;
     }
 
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1845,11 +1898,11 @@ class DatabaseSelectOrderedTestCase extends DatabaseTestCase {
       $num_records++;
       foreach ($record as $kk => $col) {
         if ($expected[$k][$kk] != $results[$k][$kk]) {
-          $this->assertTrue(FALSE, t('Results returned in correct order.'));
+          $this->assertTrue(FALSE, 'Results returned in correct order.');
         }
       }
     }
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1866,11 +1919,11 @@ class DatabaseSelectOrderedTestCase extends DatabaseTestCase {
     $last_age = 100000000;
     foreach ($result as $record) {
       $num_records++;
-      $this->assertTrue($record->age <= $last_age, t('Results returned in correct order.'));
+      $this->assertTrue($record->age <= $last_age, 'Results returned in correct order.');
       $last_age = $record->age;
     }
 
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
   }
 }
 
@@ -1904,12 +1957,12 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     $last_priority = 0;
     foreach ($result as $record) {
       $num_records++;
-      $this->assertTrue($record->$priority_field >= $last_priority, t('Results returned in correct order.'));
-      $this->assertNotEqual($record->$name_field, 'Ringo', t('Taskless person not selected.'));
+      $this->assertTrue($record->$priority_field >= $last_priority, 'Results returned in correct order.');
+      $this->assertNotEqual($record->$name_field, 'Ringo', 'Taskless person not selected.');
       $last_priority = $record->$priority_field;
     }
 
-    $this->assertEqual($num_records, 7, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 7, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1930,11 +1983,11 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
 
     foreach ($result as $record) {
       $num_records++;
-      $this->assertTrue(strcmp($record->$name_field, $last_name) >= 0, t('Results returned in correct order.'));
+      $this->assertTrue(strcmp($record->$name_field, $last_name) >= 0, 'Results returned in correct order.');
       $last_priority = $record->$name_field;
     }
 
-    $this->assertEqual($num_records, 8, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 8, 'Returned the correct number of rows.');
   }
 
   /**
@@ -1953,7 +2006,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     $records = array();
     foreach ($result as $record) {
       $num_records++;
-      $this->assertTrue($record->$count_field >= $last_count, t('Results returned in correct order.'));
+      $this->assertTrue($record->$count_field >= $last_count, 'Results returned in correct order.');
       $last_count = $record->$count_field;
       $records[$record->$task_field] = $record->$count_field;
     }
@@ -1967,10 +2020,10 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     );
 
     foreach ($correct_results as $task => $count) {
-      $this->assertEqual($records[$task], $count, t("Correct number of '@task' records found.", array('@task' => $task)));
+      $this->assertEqual($records[$task], $count, format_string("Correct number of '@task' records found.", array('@task' => $task)));
     }
 
-    $this->assertEqual($num_records, 6, t('Returned the correct number of total rows.'));
+    $this->assertEqual($num_records, 6, 'Returned the correct number of total rows.');
   }
 
   /**
@@ -1990,8 +2043,8 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     $records = array();
     foreach ($result as $record) {
       $num_records++;
-      $this->assertTrue($record->$count_field >= 2, t('Record has the minimum count.'));
-      $this->assertTrue($record->$count_field >= $last_count, t('Results returned in correct order.'));
+      $this->assertTrue($record->$count_field >= 2, 'Record has the minimum count.');
+      $this->assertTrue($record->$count_field >= $last_count, 'Results returned in correct order.');
       $last_count = $record->$count_field;
       $records[$record->$task_field] = $record->$count_field;
     }
@@ -2001,10 +2054,10 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     );
 
     foreach ($correct_results as $task => $count) {
-      $this->assertEqual($records[$task], $count, t("Correct number of '@task' records found.", array('@task' => $task)));
+      $this->assertEqual($records[$task], $count, format_string("Correct number of '@task' records found.", array('@task' => $task)));
     }
 
-    $this->assertEqual($num_records, 1, t('Returned the correct number of total rows.'));
+    $this->assertEqual($num_records, 1, 'Returned the correct number of total rows.');
   }
 
   /**
@@ -2022,7 +2075,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
       $num_records++;
     }
 
-    $this->assertEqual($num_records, 2, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 2, 'Returned the correct number of rows.');
   }
 
   /**
@@ -2039,7 +2092,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
       $num_records++;
     }
 
-    $this->assertEqual($num_records, 6, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 6, 'Returned the correct number of rows.');
   }
 
   /**
@@ -2053,13 +2106,13 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
 
     $count = $query->countQuery()->execute()->fetchField();
 
-    $this->assertEqual($count, 4, t('Counted the correct number of records.'));
+    $this->assertEqual($count, 4, 'Counted the correct number of records.');
 
     // Now make sure we didn't break the original query!  We should still have
     // all of the fields we asked for.
     $record = $query->execute()->fetch();
-    $this->assertEqual($record->$name_field, 'George', t('Correct data retrieved.'));
-    $this->assertEqual($record->$age_field, 27, t('Correct data retrieved.'));
+    $this->assertEqual($record->$name_field, 'George', 'Correct data retrieved.');
+    $this->assertEqual($record->$age_field, 27, 'Correct data retrieved.');
   }
 
   function testHavingCountQuery() {
@@ -2070,7 +2123,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     $query->addField('test', 'age');
     $query->addExpression('age + 1');
     $count = count($query->execute()->fetchCol());
-    $this->assertEqual($count, 4, t('Counted the correct number of records.'));
+    $this->assertEqual($count, 4, 'Counted the correct number of records.');
   }
 
   /**
@@ -2085,20 +2138,20 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
 
     // Check that the 'all_fields' statement is handled properly.
     $tables = $query->getTables();
-    $this->assertEqual($tables['test']['all_fields'], 1, t('Query correctly sets \'all_fields\' statement.'));
+    $this->assertEqual($tables['test']['all_fields'], 1, 'Query correctly sets \'all_fields\' statement.');
     $tables = $count->getTables();
-    $this->assertFalse(isset($tables['test']['all_fields']), t('Count query correctly unsets \'all_fields\' statement.'));
+    $this->assertFalse(isset($tables['test']['all_fields']), 'Count query correctly unsets \'all_fields\' statement.');
 
     // Check that the ordering clause is handled properly.
     $orderby = $query->getOrderBy();
-    $this->assertEqual($orderby['name'], 'ASC', t('Query correctly sets ordering clause.'));
+    $this->assertEqual($orderby['name'], 'ASC', 'Query correctly sets ordering clause.');
     $orderby = $count->getOrderBy();
-    $this->assertFalse(isset($orderby['name']), t('Count query correctly unsets ordering caluse.'));
+    $this->assertFalse(isset($orderby['name']), 'Count query correctly unsets ordering caluse.');
 
     // Make sure that the count query works.
     $count = $count->execute()->fetchField();
 
-    $this->assertEqual($count, 4, t('Counted the correct number of records.'));
+    $this->assertEqual($count, 4, 'Counted the correct number of records.');
   }
 
 
@@ -2113,11 +2166,11 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     // records in the {test} table).
     $query = db_select('test');
     $query->fields('test', array('fail'));
-    $this->assertEqual(4, $query->countQuery()->execute()->fetchField(), t('Count Query removed fields'));
+    $this->assertEqual(4, $query->countQuery()->execute()->fetchField(), 'Count Query removed fields');
 
     $query = db_select('test');
     $query->addExpression('fail');
-    $this->assertEqual(4, $query->countQuery()->execute()->fetchField(), t('Count Query removed expressions'));
+    $this->assertEqual(4, $query->countQuery()->execute()->fetchField(), 'Count Query removed expressions');
   }
 
   /**
@@ -2130,7 +2183,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
 
     $count = $query->countQuery()->execute()->fetchField();
 
-    $this->assertEqual($count, 6, t('Counted the correct number of records.'));
+    $this->assertEqual($count, 6, 'Counted the correct number of records.');
   }
 
   /**
@@ -2143,7 +2196,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
 
     $count = $query->countQuery()->execute()->fetchField();
 
-    $this->assertEqual($count, 3, t('Counted the correct number of records.'));
+    $this->assertEqual($count, 3, 'Counted the correct number of records.');
 
     // Use a column alias as, without one, the query can succeed for the wrong
     // reason.
@@ -2155,7 +2208,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
 
     $count = $query->countQuery()->execute()->fetchField();
 
-    $this->assertEqual($count, 3, t('Counted the correct number of records.'));
+    $this->assertEqual($count, 3, 'Counted the correct number of records.');
   }
 
   /**
@@ -2172,7 +2225,7 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     $query->condition(db_or()->condition('age', 26)->condition('age', 27));
 
     $job = $query->execute()->fetchField();
-    $this->assertEqual($job, 'Songwriter', t('Correct data retrieved.'));
+    $this->assertEqual($job, 'Songwriter', 'Correct data retrieved.');
   }
 
   /**
@@ -2185,8 +2238,8 @@ class DatabaseSelectComplexTestCase extends DatabaseTestCase {
     $query->addField($alias, 'job', 'otherjob');
     $query->where("$alias.name <> test.name");
     $crowded_job = $query->execute()->fetch();
-    $this->assertEqual($crowded_job->job, $crowded_job->otherjob, t('Correctly joined same table twice.'));
-    $this->assertNotEqual($crowded_job->name, $crowded_job->othername, t('Correctly joined same table twice.'));
+    $this->assertEqual($crowded_job->job, $crowded_job->otherjob, 'Correctly joined same table twice.');
+    $this->assertNotEqual($crowded_job->name, $crowded_job->othername, 'Correctly joined same table twice.');
   }
 
 }
@@ -2251,7 +2304,7 @@ class DatabaseSelectComplexTestCase2 extends DatabaseTestCase {
     // Verify that the string only has one copy of condition placeholder 0.
     $pos = strpos($str, 'db_condition_placeholder_0', 0);
     $pos2 = strpos($str, 'db_condition_placeholder_0', $pos + 1);
-    $this->assertFalse($pos2, "Condition placeholder is not repeated");
+    $this->assertFalse($pos2, 'Condition placeholder is not repeated.');
   }
 }
 
@@ -2295,7 +2348,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
         $correct_number = $count - ($limit * $page);
       }
 
-      $this->assertEqual(count($data->names), $correct_number, t('Correct number of records returned by pager: @number', array('@number' => $correct_number)));
+      $this->assertEqual(count($data->names), $correct_number, format_string('Correct number of records returned by pager: @number', array('@number' => $correct_number)));
     }
   }
 
@@ -2329,7 +2382,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
         $correct_number = $count - ($limit * $page);
       }
 
-      $this->assertEqual(count($data->names), $correct_number, t('Correct number of records returned by pager: @number', array('@number' => $correct_number)));
+      $this->assertEqual(count($data->names), $correct_number, format_string('Correct number of records returned by pager: @number', array('@number' => $correct_number)));
     }
   }
 
@@ -2351,7 +2404,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
     $ages = $outer_query
       ->execute()
       ->fetchCol();
-    $this->assertEqual($ages, array(25, 26, 27, 28), t('Inner pager query returned the correct ages.'));
+    $this->assertEqual($ages, array(25, 26, 27, 28), 'Inner pager query returned the correct ages.');
   }
 
   /**
@@ -2371,7 +2424,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
     $ages = $query
       ->execute()
       ->fetchCol();
-    $this->assertEqual($ages, array('George', 'Ringo'), t('Pager query with having expression returned the correct ages.'));
+    $this->assertEqual($ages, array('George', 'Ringo'), 'Pager query with having expression returned the correct ages.');
   }
 
   /**
@@ -2387,7 +2440,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
       ->limit(1)
       ->execute()
       ->fetchField();
-    $this->assertEqual($name, 'Paul', t('Pager query #1 with a specified element ID returned the correct results.'));
+    $this->assertEqual($name, 'Paul', 'Pager query #1 with a specified element ID returned the correct results.');
 
     // Setting an element smaller than the previous one
     // should not overwrite the pager $maxElement with a smaller value.
@@ -2398,7 +2451,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
       ->limit(1)
       ->execute()
       ->fetchField();
-    $this->assertEqual($name, 'George', t('Pager query #2 with a specified element ID returned the correct results.'));
+    $this->assertEqual($name, 'George', 'Pager query #2 with a specified element ID returned the correct results.');
 
     $name = db_select('test', 't')->extend('PagerDefault')
       ->fields('t', array('name'))
@@ -2406,7 +2459,7 @@ class DatabaseSelectPagerDefaultTestCase extends DatabaseTestCase {
       ->limit(1)
       ->execute()
       ->fetchField();
-    $this->assertEqual($name, 'John', t('Pager query #3 with a generated element ID returned the correct results.'));
+    $this->assertEqual($name, 'John', 'Pager query #3 with a generated element ID returned the correct results.');
 
     unset($_GET['page']);
   }
@@ -2446,8 +2499,8 @@ class DatabaseSelectTableSortDefaultTestCase extends DatabaseTestCase {
       $first = array_shift($data->tasks);
       $last = array_pop($data->tasks);
 
-      $this->assertEqual($first->task, $sort['first'], t('Items appear in the correct order.'));
-      $this->assertEqual($last->task, $sort['last'], t('Items appear in the correct order.'));
+      $this->assertEqual($first->task, $sort['first'], 'Items appear in the correct order.');
+      $this->assertEqual($last->task, $sort['last'], 'Items appear in the correct order.');
     }
   }
 
@@ -2472,8 +2525,8 @@ class DatabaseSelectTableSortDefaultTestCase extends DatabaseTestCase {
       $first = array_shift($data->tasks);
       $last = array_pop($data->tasks);
 
-      $this->assertEqual($first->task, $sort['first'], t('Items appear in the correct order sorting by @field @sort.', array('@field' => $sort['field'], '@sort' => $sort['sort'])));
-      $this->assertEqual($last->task, $sort['last'], t('Items appear in the correct order sorting by @field @sort.', array('@field' => $sort['field'], '@sort' => $sort['sort'])));
+      $this->assertEqual($first->task, $sort['first'], format_string('Items appear in the correct order sorting by @field @sort.', array('@field' => $sort['field'], '@sort' => $sort['sort'])));
+      $this->assertEqual($last->task, $sort['last'], format_string('Items appear in the correct order sorting by @field @sort.', array('@field' => $sort['field'], '@sort' => $sort['sort'])));
     }
   }
 
@@ -2513,8 +2566,8 @@ class DatabaseTaggingTestCase extends DatabaseTestCase {
 
     $query->addTag('test');
 
-    $this->assertTrue($query->hasTag('test'), t('hasTag() returned true.'));
-    $this->assertFalse($query->hasTag('other'), t('hasTag() returned false.'));
+    $this->assertTrue($query->hasTag('test'), 'hasTag() returned true.');
+    $this->assertFalse($query->hasTag('other'), 'hasTag() returned false.');
   }
 
   /**
@@ -2528,8 +2581,8 @@ class DatabaseTaggingTestCase extends DatabaseTestCase {
     $query->addTag('test');
     $query->addTag('other');
 
-    $this->assertTrue($query->hasAllTags('test', 'other'), t('hasAllTags() returned true.'));
-    $this->assertFalse($query->hasAllTags('test', 'stuff'), t('hasAllTags() returned false.'));
+    $this->assertTrue($query->hasAllTags('test', 'other'), 'hasAllTags() returned true.');
+    $this->assertFalse($query->hasAllTags('test', 'stuff'), 'hasAllTags() returned false.');
   }
 
   /**
@@ -2542,8 +2595,8 @@ class DatabaseTaggingTestCase extends DatabaseTestCase {
 
     $query->addTag('test');
 
-    $this->assertTrue($query->hasAnyTag('test', 'other'), t('hasAnyTag() returned true.'));
-    $this->assertFalse($query->hasAnyTag('other', 'stuff'), t('hasAnyTag() returned false.'));
+    $this->assertTrue($query->hasAnyTag('test', 'other'), 'hasAnyTag() returned true.');
+    $this->assertFalse($query->hasAnyTag('other', 'stuff'), 'hasAnyTag() returned false.');
   }
 
   /**
@@ -2564,10 +2617,10 @@ class DatabaseTaggingTestCase extends DatabaseTestCase {
     $query->addMetaData('test', $data);
 
     $return = $query->getMetaData('test');
-    $this->assertEqual($data, $return, t('Corect metadata returned.'));
+    $this->assertEqual($data, $return, 'Corect metadata returned.');
 
     $return = $query->getMetaData('nothere');
-    $this->assertNull($return, t('Non-existent key returned NULL.'));
+    $this->assertNull($return, 'Non-existent key returned NULL.');
   }
 }
 
@@ -2602,7 +2655,7 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
       $num_records++;
     }
 
-    $this->assertEqual($num_records, 2, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 2, 'Returned the correct number of rows.');
   }
 
   /**
@@ -2619,14 +2672,14 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
 
     $records = $result->fetchAll();
 
-    $this->assertEqual(count($records), 2, t('Returned the correct number of rows.'));
+    $this->assertEqual(count($records), 2, 'Returned the correct number of rows.');
 
-    $this->assertEqual($records[0]->name, 'George', t('Correct data retrieved.'));
-    $this->assertEqual($records[0]->$tid_field, 4, t('Correct data retrieved.'));
-    $this->assertEqual($records[0]->$task_field, 'sing', t('Correct data retrieved.'));
-    $this->assertEqual($records[1]->name, 'George', t('Correct data retrieved.'));
-    $this->assertEqual($records[1]->$tid_field, 5, t('Correct data retrieved.'));
-    $this->assertEqual($records[1]->$task_field, 'sleep', t('Correct data retrieved.'));
+    $this->assertEqual($records[0]->name, 'George', 'Correct data retrieved.');
+    $this->assertEqual($records[0]->$tid_field, 4, 'Correct data retrieved.');
+    $this->assertEqual($records[0]->$task_field, 'sing', 'Correct data retrieved.');
+    $this->assertEqual($records[1]->name, 'George', 'Correct data retrieved.');
+    $this->assertEqual($records[1]->$tid_field, 5, 'Correct data retrieved.');
+    $this->assertEqual($records[1]->$task_field, 'sleep', 'Correct data retrieved.');
   }
 
   /**
@@ -2647,11 +2700,11 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
 
     $records = $result->fetchAll();
 
-    $this->assertEqual(count($records), 1, t('Returned the correct number of rows.'));
-    $this->assertEqual($records[0]->$name_field, 'John', t('Correct data retrieved.'));
-    $this->assertEqual($records[0]->$tid_field, 2, t('Correct data retrieved.'));
-    $this->assertEqual($records[0]->$pid_field, 1, t('Correct data retrieved.'));
-    $this->assertEqual($records[0]->$task_field, 'sleep', t('Correct data retrieved.'));
+    $this->assertEqual(count($records), 1, 'Returned the correct number of rows.');
+    $this->assertEqual($records[0]->$name_field, 'John', 'Correct data retrieved.');
+    $this->assertEqual($records[0]->$tid_field, 2, 'Correct data retrieved.');
+    $this->assertEqual($records[0]->$pid_field, 1, 'Correct data retrieved.');
+    $this->assertEqual($records[0]->$task_field, 'sleep', 'Correct data retrieved.');
   }
 
   /**
@@ -2665,8 +2718,8 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
     $query->addTag('database_test_alter_change_fields');
 
     $record = $query->execute()->fetch();
-    $this->assertEqual($record->$name_field, 'George', t('Correct data retrieved.'));
-    $this->assertFalse(isset($record->$age_field), t('Age field not found, as intended.'));
+    $this->assertEqual($record->$name_field, 'George', 'Correct data retrieved.');
+    $this->assertFalse(isset($record->$age_field), 'Age field not found, as intended.');
   }
 
   /**
@@ -2683,8 +2736,8 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
     // Ensure that we got the right record.
     $record = $result->fetch();
 
-    $this->assertEqual($record->$name_field, 'George', t('Fetched name is correct.'));
-    $this->assertEqual($record->$age_field, 27*3, t('Fetched age expression is correct.'));
+    $this->assertEqual($record->$name_field, 'George', 'Fetched name is correct.');
+    $this->assertEqual($record->$age_field, 27*3, 'Fetched age expression is correct.');
   }
 
   /**
@@ -2699,7 +2752,7 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
 
     $num_records = count($query->execute()->fetchAll());
 
-    $this->assertEqual($num_records, 4, t('Returned the correct number of rows.'));
+    $this->assertEqual($num_records, 4, 'Returned the correct number of rows.');
   }
 
   /**
@@ -2723,8 +2776,8 @@ class DatabaseAlterTestCase extends DatabaseTestCase {
     $name_field = $query->addField('pq', 'name');
 
     $record = $query->execute()->fetch();
-    $this->assertEqual($record->$name_field, 'George', t('Fetched name is correct.'));
-    $this->assertEqual($record->$age_field, 27*3, t('Fetched age expression is correct.'));
+    $this->assertEqual($record->$name_field, 'George', 'Fetched name is correct.');
+    $this->assertEqual($record->$age_field, 27*3, 'Fetched age expression is correct.');
   }
 }
 
@@ -2758,31 +2811,31 @@ class DatabaseRegressionTestCase extends DatabaseTestCase {
       ))->execute();
 
     $from_database = db_query('SELECT name FROM {test} WHERE name = :name', array(':name' => $name))->fetchField();
-    $this->assertIdentical($name, $from_database, t("The database handles UTF-8 characters cleanly."));
+    $this->assertIdentical($name, $from_database, "The database handles UTF-8 characters cleanly.");
   }
 
   /**
    * Test the db_table_exists() function.
    */
   function testDBTableExists() {
-    $this->assertIdentical(TRUE, db_table_exists('node'), t('Returns true for existent table.'));
-    $this->assertIdentical(FALSE, db_table_exists('nosuchtable'), t('Returns false for nonexistent table.'));
+    $this->assertIdentical(TRUE, db_table_exists('node'), 'Returns true for existent table.');
+    $this->assertIdentical(FALSE, db_table_exists('nosuchtable'), 'Returns false for nonexistent table.');
   }
 
   /**
    * Test the db_field_exists() function.
    */
   function testDBFieldExists() {
-    $this->assertIdentical(TRUE, db_field_exists('node', 'nid'), t('Returns true for existent column.'));
-    $this->assertIdentical(FALSE, db_field_exists('node', 'nosuchcolumn'), t('Returns false for nonexistent column.'));
+    $this->assertIdentical(TRUE, db_field_exists('node', 'nid'), 'Returns true for existent column.');
+    $this->assertIdentical(FALSE, db_field_exists('node', 'nosuchcolumn'), 'Returns false for nonexistent column.');
   }
 
   /**
    * Test the db_index_exists() function.
    */
   function testDBIndexExists() {
-    $this->assertIdentical(TRUE, db_index_exists('node', 'node_created'), t('Returns true for existent index.'));
-    $this->assertIdentical(FALSE, db_index_exists('node', 'nosuchindex'), t('Returns false for nonexistent index.'));
+    $this->assertIdentical(TRUE, db_index_exists('node', 'node_created'), 'Returns true for existent index.');
+    $this->assertIdentical(FALSE, db_index_exists('node', 'nosuchindex'), 'Returns false for nonexistent index.');
   }
 }
 
@@ -2813,10 +2866,10 @@ class DatabaseLoggingTestCase extends DatabaseTestCase {
 
     $queries = Database::getLog('testing', 'default');
 
-    $this->assertEqual(count($queries), 3, t('Correct number of queries recorded.'));
+    $this->assertEqual(count($queries), 3, 'Correct number of queries recorded.');
 
     foreach ($queries as $query) {
-      $this->assertEqual($query['caller']['function'], __FUNCTION__, t('Correct function in query log.'));
+      $this->assertEqual($query['caller']['function'], __FUNCTION__, 'Correct function in query log.');
     }
   }
 
@@ -2835,8 +2888,8 @@ class DatabaseLoggingTestCase extends DatabaseTestCase {
     $queries1 = Database::getLog('testing1');
     $queries2 = Database::getLog('testing2');
 
-    $this->assertEqual(count($queries1), 2, t('Correct number of queries recorded for log 1.'));
-    $this->assertEqual(count($queries2), 1, t('Correct number of queries recorded for log 2.'));
+    $this->assertEqual(count($queries1), 2, 'Correct number of queries recorded for log 1.');
+    $this->assertEqual(count($queries2), 1, 'Correct number of queries recorded for log 2.');
   }
 
   /**
@@ -2856,9 +2909,9 @@ class DatabaseLoggingTestCase extends DatabaseTestCase {
 
     $queries1 = Database::getLog('testing1');
 
-    $this->assertEqual(count($queries1), 2, t('Recorded queries from all targets.'));
-    $this->assertEqual($queries1[0]['target'], 'default', t('First query used default target.'));
-    $this->assertEqual($queries1[1]['target'], 'slave', t('Second query used slave target.'));
+    $this->assertEqual(count($queries1), 2, 'Recorded queries from all targets.');
+    $this->assertEqual($queries1[0]['target'], 'default', 'First query used default target.');
+    $this->assertEqual($queries1[1]['target'], 'slave', 'Second query used slave target.');
   }
 
   /**
@@ -2882,9 +2935,9 @@ class DatabaseLoggingTestCase extends DatabaseTestCase {
 
     $queries1 = Database::getLog('testing1');
 
-    $this->assertEqual(count($queries1), 2, t('Recorded queries from all targets.'));
-    $this->assertEqual($queries1[0]['target'], 'default', t('First query used default target.'));
-    $this->assertEqual($queries1[1]['target'], 'default', t('Second query used default target as fallback.'));
+    $this->assertEqual(count($queries1), 2, 'Recorded queries from all targets.');
+    $this->assertEqual($queries1[0]['target'], 'default', 'First query used default target.');
+    $this->assertEqual($queries1[1]['target'], 'default', 'Second query used default target as fallback.');
   }
 
   /**
@@ -2910,8 +2963,8 @@ class DatabaseLoggingTestCase extends DatabaseTestCase {
     $queries1 = Database::getLog('testing1');
     $queries2 = Database::getLog('testing1', 'test2');
 
-    $this->assertEqual(count($queries1), 1, t('Correct number of queries recorded for first connection.'));
-    $this->assertEqual(count($queries2), 1, t('Correct number of queries recorded for second connection.'));
+    $this->assertEqual(count($queries1), 1, 'Correct number of queries recorded for first connection.');
+    $this->assertEqual(count($queries2), 1, 'Correct number of queries recorded for second connection.');
   }
 }
 
@@ -2938,7 +2991,7 @@ class DatabaseSerializeQueryTestCase extends DatabaseTestCase {
     // assertion.
     $query = unserialize(serialize($query));
     $results = $query->execute()->fetchCol();
-    $this->assertEqual($results[0], 28, t('Query properly executed after unserialization.'));
+    $this->assertEqual($results[0], 28, 'Query properly executed after unserialization.');
   }
 }
 
@@ -2964,12 +3017,12 @@ class DatabaseRangeQueryTestCase extends DrupalWebTestCase {
   function testRangeQuery() {
     // Test if return correct number of rows.
     $range_rows = db_query_range("SELECT name FROM {system} ORDER BY name", 2, 3)->fetchAll();
-    $this->assertEqual(count($range_rows), 3, t('Range query work and return correct number of rows.'));
+    $this->assertEqual(count($range_rows), 3, 'Range query work and return correct number of rows.');
 
     // Test if return target data.
     $raw_rows = db_query('SELECT name FROM {system} ORDER BY name')->fetchAll();
     $raw_rows = array_slice($raw_rows, 2, 3);
-    $this->assertEqual($range_rows, $raw_rows, t('Range query work and return target data.'));
+    $this->assertEqual($range_rows, $raw_rows, 'Range query work and return target data.');
   }
 }
 
@@ -3003,19 +3056,19 @@ class DatabaseTemporaryQueryTestCase extends DrupalWebTestCase {
     $this->drupalGet('database_test/db_query_temporary');
     $data = json_decode($this->drupalGetContent());
     if ($data) {
-      $this->assertEqual($this->countTableRows("system"), $data->row_count, t('The temporary table contains the correct amount of rows.'));
-      $this->assertFalse(db_table_exists($data->table_name), t('The temporary table is, indeed, temporary.'));
+      $this->assertEqual($this->countTableRows("system"), $data->row_count, 'The temporary table contains the correct amount of rows.');
+      $this->assertFalse(db_table_exists($data->table_name), 'The temporary table is, indeed, temporary.');
     }
     else {
-      $this->fail(t("The creation of the temporary table failed."));
+      $this->fail("The creation of the temporary table failed.");
     }
 
     // Now try to run two db_query_temporary() in the same request.
     $table_name_system = db_query_temporary('SELECT status FROM {system}', array());
     $table_name_users = db_query_temporary('SELECT uid FROM {users}', array());
 
-    $this->assertEqual($this->countTableRows($table_name_system), $this->countTableRows("system"), t('A temporary table was created successfully in this request.'));
-    $this->assertEqual($this->countTableRows($table_name_users), $this->countTableRows("users"), t('A second temporary table was created successfully in this request.'));
+    $this->assertEqual($this->countTableRows($table_name_system), $this->countTableRows("system"), 'A temporary table was created successfully in this request.');
+    $this->assertEqual($this->countTableRows($table_name_users), $this->countTableRows("users"), 'A second temporary table was created successfully in this request.');
   }
 }
 
@@ -3050,7 +3103,7 @@ class DatabaseBasicSyntaxTestCase extends DatabaseTestCase {
       ':a4' => ' a ',
       ':a5' => 'test.',
     ));
-    $this->assertIdentical($result->fetchField(), 'This is a test.', t('Basic CONCAT works.'));
+    $this->assertIdentical($result->fetchField(), 'This is a test.', 'Basic CONCAT works.');
   }
 
   /**
@@ -3063,7 +3116,7 @@ class DatabaseBasicSyntaxTestCase extends DatabaseTestCase {
       ':a3' => '.',
       ':age' => 25,
     ));
-    $this->assertIdentical($result->fetchField(), 'The age of John is 25.', t('Field CONCAT works.'));
+    $this->assertIdentical($result->fetchField(), 'The age of John is 25.', 'Field CONCAT works.');
   }
 
   /**
@@ -3082,14 +3135,14 @@ class DatabaseBasicSyntaxTestCase extends DatabaseTestCase {
       ->countQuery()
       ->execute()
       ->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Found 2 records.'));
+    $this->assertIdentical($num_matches, '2', 'Found 2 records.');
     // Match only "Ring_" using a LIKE expression with no wildcards.
     $num_matches = db_select('test', 't')
       ->condition('name', db_like('Ring_'), 'LIKE')
       ->countQuery()
       ->execute()
       ->fetchField();
-    $this->assertIdentical($num_matches, '1', t('Found 1 record.'));
+    $this->assertIdentical($num_matches, '1', 'Found 1 record.');
   }
 
   /**
@@ -3113,14 +3166,14 @@ class DatabaseBasicSyntaxTestCase extends DatabaseTestCase {
       ->countQuery()
       ->execute()
       ->fetchField();
-    $this->assertIdentical($num_matches, '2', t('Found 2 records.'));
+    $this->assertIdentical($num_matches, '2', 'Found 2 records.');
     // Match only the former using a LIKE expression with no wildcards.
     $num_matches = db_select('test', 't')
       ->condition('name', db_like('abc%\_'), 'LIKE')
       ->countQuery()
       ->execute()
       ->fetchField();
-    $this->assertIdentical($num_matches, '1', t('Found 1 record.'));
+    $this->assertIdentical($num_matches, '1', 'Found 1 record.');
   }
 }
 
@@ -3151,9 +3204,9 @@ class DatabaseCaseSensitivityTestCase extends DatabaseTestCase {
       ->execute();
 
     $num_records_after = db_query('SELECT COUNT(*) FROM {test}')->fetchField();
-    $this->assertIdentical($num_records_before + 1, (int) $num_records_after, t('Record inserts correctly.'));
+    $this->assertIdentical($num_records_before + 1, (int) $num_records_after, 'Record inserts correctly.');
     $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'john'))->fetchField();
-    $this->assertIdentical($saved_age, '2', t('Can retrieve after inserting.'));
+    $this->assertIdentical($saved_age, '2', 'Can retrieve after inserting.');
   }
 }
 
@@ -3196,7 +3249,7 @@ class DatabaseInvalidDataTestCase extends DatabaseTestCase {
           'job' => 'Singer',
         ))
         ->execute();
-      $this->fail(t('Insert succeedded when it should not have.'));
+      $this->fail('Insert succeedded when it should not have.');
     }
     catch (Exception $e) {
       // Check if the first record was inserted.
@@ -3208,14 +3261,14 @@ class DatabaseInvalidDataTestCase extends DatabaseTestCase {
           // Database engines that don't support transactions can leave partial
           // inserts in place when an error occurs. This is the case for MySQL
           // when running on a MyISAM table.
-          $this->pass(t("The whole transaction has not been rolled-back when a duplicate key insert occurs, this is expected because the database doesn't support transactions"));
+          $this->pass("The whole transaction has not been rolled-back when a duplicate key insert occurs, this is expected because the database doesn't support transactions");
         }
         else {
-          $this->fail(t('The whole transaction is rolled back when a duplicate key insert occurs.'));
+          $this->fail('The whole transaction is rolled back when a duplicate key insert occurs.');
         }
       }
       else {
-        $this->pass(t('The whole transaction is rolled back when a duplicate key insert occurs.'));
+        $this->pass('The whole transaction is rolled back when a duplicate key insert occurs.');
       }
 
       // Ensure the other values were not inserted.
@@ -3224,7 +3277,7 @@ class DatabaseInvalidDataTestCase extends DatabaseTestCase {
         ->condition('age', array(17, 75), 'IN')
         ->execute()->fetchObject();
 
-      $this->assertFalse($record, t('The rest of the insert aborted as expected.'));
+      $this->assertFalse($record, 'The rest of the insert aborted as expected.');
     }
   }
 
@@ -3252,7 +3305,7 @@ class DatabaseQueryTestCase extends DatabaseTestCase {
   function testArraySubstitution() {
     $names = db_query('SELECT name FROM {test} WHERE age IN (:ages) ORDER BY age', array(':ages' => array(25, 26, 27)))->fetchAll();
 
-    $this->assertEqual(count($names), 3, t('Correct number of names returned'));
+    $this->assertEqual(count($names), 3, 'Correct number of names returned');
   }
 }
 
@@ -3320,19 +3373,19 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
       ))
       ->execute();
 
-    $this->assertTrue($connection->inTransaction(), t('In transaction before calling nested transaction.'));
+    $this->assertTrue($connection->inTransaction(), 'In transaction before calling nested transaction.');
 
     // We're already in a transaction, but we call ->transactionInnerLayer
     // to nest another transaction inside the current one.
     $this->transactionInnerLayer($suffix, $rollback, $ddl_statement);
 
-    $this->assertTrue($connection->inTransaction(), t('In transaction after calling nested transaction.'));
+    $this->assertTrue($connection->inTransaction(), 'In transaction after calling nested transaction.');
 
     if ($rollback) {
       // Roll back the transaction, if requested.
       // This rollback should propagate to the last savepoint.
       $txn->rollback();
-      $this->assertTrue(($connection->transactionDepth() == $depth), t('Transaction has rolled back to the last savepoint after calling rollback().'));
+      $this->assertTrue(($connection->transactionDepth() == $depth), 'Transaction has rolled back to the last savepoint after calling rollback().');
     }
   }
 
@@ -3358,7 +3411,7 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
     $txn = db_transaction();
 
     $depth2 = $connection->transactionDepth();
-    $this->assertTrue($depth < $depth2, t('Transaction depth is has increased with new transaction.'));
+    $this->assertTrue($depth < $depth2, 'Transaction depth is has increased with new transaction.');
 
     // Insert a single row into the testing table.
     db_insert('test')
@@ -3368,7 +3421,7 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
       ))
       ->execute();
 
-    $this->assertTrue($connection->inTransaction(), t('In transaction inside nested transaction.'));
+    $this->assertTrue($connection->inTransaction(), 'In transaction inside nested transaction.');
 
     if ($ddl_statement) {
       $table = array(
@@ -3383,14 +3436,14 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
       );
       db_create_table('database_test_1', $table);
 
-      $this->assertTrue($connection->inTransaction(), t('In transaction inside nested transaction.'));
+      $this->assertTrue($connection->inTransaction(), 'In transaction inside nested transaction.');
     }
 
     if ($rollback) {
       // Roll back the transaction, if requested.
       // This rollback should propagate to the last savepoint.
       $txn->rollback();
-      $this->assertTrue(($connection->transactionDepth() == $depth), t('Transaction has rolled back to the last savepoint after calling rollback().'));
+      $this->assertTrue(($connection->transactionDepth() == $depth), 'Transaction has rolled back to the last savepoint after calling rollback().');
     }
   }
 
@@ -3411,9 +3464,9 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
       // Neither of the rows we inserted in the two transaction layers
       // should be present in the tables post-rollback.
       $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'DavidB'))->fetchField();
-      $this->assertNotIdentical($saved_age, '24', t('Cannot retrieve DavidB row after commit.'));
+      $this->assertNotIdentical($saved_age, '24', 'Cannot retrieve DavidB row after commit.');
       $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'DanielB'))->fetchField();
-      $this->assertNotIdentical($saved_age, '19', t('Cannot retrieve DanielB row after commit.'));
+      $this->assertNotIdentical($saved_age, '19', 'Cannot retrieve DanielB row after commit.');
     }
     catch (Exception $e) {
       $this->fail($e->getMessage());
@@ -3437,9 +3490,9 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
       // Because our current database claims to not support transactions,
       // the inserted rows should be present despite the attempt to roll back.
       $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'DavidB'))->fetchField();
-      $this->assertIdentical($saved_age, '24', t('DavidB not rolled back, since transactions are not supported.'));
+      $this->assertIdentical($saved_age, '24', 'DavidB not rolled back, since transactions are not supported.');
       $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'DanielB'))->fetchField();
-      $this->assertIdentical($saved_age, '19', t('DanielB not rolled back, since transactions are not supported.'));
+      $this->assertIdentical($saved_age, '19', 'DanielB not rolled back, since transactions are not supported.');
     }
     catch (Exception $e) {
       $this->fail($e->getMessage());
@@ -3459,9 +3512,9 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
 
       // Because we committed, both of the inserted rows should be present.
       $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'DavidA'))->fetchField();
-      $this->assertIdentical($saved_age, '24', t('Can retrieve DavidA row after commit.'));
+      $this->assertIdentical($saved_age, '24', 'Can retrieve DavidA row after commit.');
       $saved_age = db_query('SELECT age FROM {test} WHERE name = :name', array(':name' => 'DanielA'))->fetchField();
-      $this->assertIdentical($saved_age, '19', t('Can retrieve DanielA row after commit.'));
+      $this->assertIdentical($saved_age, '19', 'Can retrieve DanielA row after commit.');
     }
     catch (Exception $e) {
       $this->fail($e->getMessage());
@@ -3553,7 +3606,7 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
         // $this->fail(t('Rolling back a transaction containing DDL should fail.'));
       }
       catch (DatabaseTransactionNoActiveException $e) {
-        $this->pass(t('Rolling back a transaction containing DDL should fail.'));
+        $this->pass('Rolling back a transaction containing DDL should fail.');
       }
       $this->assertRowPresent('row');
     }
@@ -3606,7 +3659,7 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
    */
   function assertRowPresent($name, $message = NULL) {
     if (!isset($message)) {
-      $message = t('Row %name is present.', array('%name' => $name));
+      $message = format_string('Row %name is present.', array('%name' => $name));
     }
     $present = (boolean) db_query('SELECT 1 FROM {test} WHERE name = :name', array(':name' => $name))->fetchField();
     return $this->assertTrue($present, $message);
@@ -3622,7 +3675,7 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
    */
   function assertRowAbsent($name, $message = NULL) {
     if (!isset($message)) {
-      $message = t('Row %name is absent.', array('%name' => $name));
+      $message = format_string('Row %name is absent.', array('%name' => $name));
     }
     $present = (boolean) db_query('SELECT 1 FROM {test} WHERE name = :name', array(':name' => $name))->fetchField();
     return $this->assertFalse($present, $message);
@@ -3646,10 +3699,10 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
     $this->insertRow('inner');
     // Pop the inner transaction.
     unset($transaction2);
-    $this->assertTrue($database->inTransaction(), t('Still in a transaction after popping the inner transaction'));
+    $this->assertTrue($database->inTransaction(), 'Still in a transaction after popping the inner transaction');
     // Pop the outer transaction.
     unset($transaction);
-    $this->assertFalse($database->inTransaction(), t('Transaction closed after popping the outer transaction'));
+    $this->assertFalse($database->inTransaction(), 'Transaction closed after popping the outer transaction');
     $this->assertRowPresent('outer');
     $this->assertRowPresent('inner');
 
@@ -3662,10 +3715,10 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
     // Pop the outer transaction, nothing should happen.
     unset($transaction);
     $this->insertRow('inner-after-outer-commit');
-    $this->assertTrue($database->inTransaction(), t('Still in a transaction after popping the outer transaction'));
+    $this->assertTrue($database->inTransaction(), 'Still in a transaction after popping the outer transaction');
     // Pop the inner transaction, the whole transaction should commit.
     unset($transaction2);
-    $this->assertFalse($database->inTransaction(), t('Transaction closed after popping the inner transaction'));
+    $this->assertFalse($database->inTransaction(), 'Transaction closed after popping the inner transaction');
     $this->assertRowPresent('outer');
     $this->assertRowPresent('inner');
     $this->assertRowPresent('inner-after-outer-commit');
@@ -3679,11 +3732,11 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
     // Now rollback the inner transaction.
     $transaction2->rollback();
     unset($transaction2);
-    $this->assertTrue($database->inTransaction(), t('Still in a transaction after popping the outer transaction'));
+    $this->assertTrue($database->inTransaction(), 'Still in a transaction after popping the outer transaction');
     // Pop the outer transaction, it should commit.
     $this->insertRow('outer-after-inner-rollback');
     unset($transaction);
-    $this->assertFalse($database->inTransaction(), t('Transaction closed after popping the inner transaction'));
+    $this->assertFalse($database->inTransaction(), 'Transaction closed after popping the inner transaction');
     $this->assertRowPresent('outer');
     $this->assertRowAbsent('inner');
     $this->assertRowPresent('outer-after-inner-rollback');
@@ -3696,11 +3749,11 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
     $this->insertRow('inner');
     // Pop the outer transaction, nothing should happen.
     unset($transaction);
-    $this->assertTrue($database->inTransaction(), t('Still in a transaction after popping the outer transaction'));
+    $this->assertTrue($database->inTransaction(), 'Still in a transaction after popping the outer transaction');
     // Now rollback the inner transaction, it should rollback.
     $transaction2->rollback();
     unset($transaction2);
-    $this->assertFalse($database->inTransaction(), t('Transaction closed after popping the inner transaction'));
+    $this->assertFalse($database->inTransaction(), 'Transaction closed after popping the inner transaction');
     $this->assertRowPresent('outer');
     $this->assertRowAbsent('inner');
 
@@ -3718,23 +3771,23 @@ class DatabaseTransactionTestCase extends DatabaseTestCase {
     try {
       $transaction->rollback();
       unset($transaction);
-      $this->fail(t('Rolling back the outer transaction while the inner transaction is active resulted in an exception.'));
+      $this->fail('Rolling back the outer transaction while the inner transaction is active resulted in an exception.');
     }
     catch (DatabaseTransactionOutOfOrderException $e) {
-      $this->pass(t('Rolling back the outer transaction while the inner transaction is active resulted in an exception.'));
+      $this->pass('Rolling back the outer transaction while the inner transaction is active resulted in an exception.');
     }
-    $this->assertFalse($database->inTransaction(), t('No more in a transaction after rolling back the outer transaction'));
+    $this->assertFalse($database->inTransaction(), 'No more in a transaction after rolling back the outer transaction');
     // Try to commit one inner transaction.
     unset($transaction3);
-    $this->pass(t('Trying to commit an inner transaction resulted in an exception.'));
+    $this->pass('Trying to commit an inner transaction resulted in an exception.');
     // Try to rollback one inner transaction.
     try {
       $transaction->rollback();
       unset($transaction2);
-      $this->fail(t('Trying to commit an inner transaction resulted in an exception.'));
+      $this->fail('Trying to commit an inner transaction resulted in an exception.');
     }
     catch (DatabaseTransactionNoActiveException $e) {
-      $this->pass(t('Trying to commit an inner transaction resulted in an exception.'));
+      $this->pass('Trying to commit an inner transaction resulted in an exception.');
     }
     $this->assertRowAbsent('outer');
     $this->assertRowAbsent('inner');
@@ -3764,9 +3817,9 @@ class DatabaseNextIdCase extends DrupalWebTestCase {
     // We can test for exact increase in here because we know there is no
     // other process operating on these tables -- normally we could only
     // expect $second > $first.
-    $this->assertEqual($first + 1, $second, t('The second call from a sequence provides a number increased by one.'));
+    $this->assertEqual($first + 1, $second, 'The second call from a sequence provides a number increased by one.');
     $result = db_next_id(1000);
-    $this->assertEqual($result, 1001, t('Sequence provides a larger number than the existing ID.'));
+    $this->assertEqual($result, 1001, 'Sequence provides a larger number than the existing ID.');
   }
 }
 
@@ -3788,8 +3841,8 @@ class DatabaseEmptyStatementTestCase extends DrupalWebTestCase {
   function testEmpty() {
     $result = new DatabaseStatementEmpty();
 
-    $this->assertTrue($result instanceof DatabaseStatementInterface, t('Class implements expected interface'));
-    $this->assertNull($result->fetchObject(), t('Null result returned.'));
+    $this->assertTrue($result instanceof DatabaseStatementInterface, 'Class implements expected interface');
+    $this->assertNull($result->fetchObject(), 'Null result returned.');
   }
 
   /**
@@ -3799,11 +3852,11 @@ class DatabaseEmptyStatementTestCase extends DrupalWebTestCase {
     $result = new DatabaseStatementEmpty();
 
     foreach ($result as $record) {
-      $this->fail(t('Iterating empty result set should not iterate.'));
+      $this->fail('Iterating empty result set should not iterate.');
       return;
     }
 
-    $this->pass(t('Iterating empty result set skipped iteration.'));
+    $this->pass('Iterating empty result set skipped iteration.');
   }
 
   /**
@@ -3812,6 +3865,225 @@ class DatabaseEmptyStatementTestCase extends DrupalWebTestCase {
   function testEmptyFetchAll() {
     $result = new DatabaseStatementEmpty();
 
-    $this->assertEqual($result->fetchAll(), array(), t('Empty array returned from empty result set.'));
+    $this->assertEqual($result->fetchAll(), array(), 'Empty array returned from empty result set.');
+  }
+}
+
+/**
+ * Tests management of database connections.
+ */
+class ConnectionUnitTest extends DrupalUnitTestCase {
+
+  protected $key;
+  protected $target;
+
+  protected $monitor;
+  protected $originalCount;
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Connection unit tests',
+      'description' => 'Tests management of database connections.',
+      'group' => 'Database',
+    );
+  }
+
+  function setUp() {
+    parent::setUp();
+
+    $this->key = 'default';
+    $this->originalTarget = 'default';
+    $this->target = 'DatabaseConnectionUnitTest';
+
+    // Determine whether the database driver is MySQL. If it is not, the test
+    // methods will not be executed.
+    // @todo Make this test driver-agnostic, or find a proper way to skip it.
+    // @see http://drupal.org/node/1273478
+    $connection_info = Database::getConnectionInfo('default');
+    $this->skipTest = (bool) $connection_info['default']['driver'] != 'mysql';
+    if ($this->skipTest) {
+      // Insert an assertion to prevent Simpletest from interpreting the test
+      // as failure.
+      $this->pass('This test is only compatible with MySQL.');
+    }
+
+    // Create an additional connection to monitor the connections being opened
+    // and closed in this test.
+    // @see TestBase::changeDatabasePrefix()
+    $connection_info = Database::getConnectionInfo('default');
+    Database::addConnectionInfo('default', 'monitor', $connection_info['default']);
+    global $databases;
+    $databases['default']['monitor'] = $connection_info['default'];
+    $this->monitor = Database::getConnection('monitor');
+  }
+
+  /**
+   * Adds a new database connection info to Database.
+   */
+  protected function addConnection() {
+    // Add a new target to the connection, by cloning the current connection.
+    $connection_info = Database::getConnectionInfo($this->key);
+    Database::addConnectionInfo($this->key, $this->target, $connection_info[$this->originalTarget]);
+
+    // Verify that the new target exists.
+    $info = Database::getConnectionInfo($this->key);
+    // Note: Custom assertion message to not expose database credentials.
+    $this->assertIdentical($info[$this->target], $connection_info[$this->key], 'New connection info found.');
+  }
+
+  /**
+   * Returns the connection ID of the current test connection.
+   *
+   * @return integer
+   */
+  protected function getConnectionID() {
+    return (int) Database::getConnection($this->target, $this->key)->query('SELECT CONNECTION_ID()')->fetchField();
   }
+
+  /**
+   * Asserts that a connection ID exists.
+   *
+   * @param integer $id
+   *   The connection ID to verify.
+   */
+  protected function assertConnection($id) {
+    $list = $this->monitor->query('SHOW PROCESSLIST')->fetchAllKeyed(0, 0);
+    return $this->assertTrue(isset($list[$id]), format_string('Connection ID @id found.', array('@id' => $id)));
+  }
+
+  /**
+   * Asserts that a connection ID does not exist.
+   *
+   * @param integer $id
+   *   The connection ID to verify.
+   */
+  protected function assertNoConnection($id) {
+    $list = $this->monitor->query('SHOW PROCESSLIST')->fetchAllKeyed(0, 0);
+    return $this->assertFalse(isset($list[$id]), format_string('Connection ID @id not found.', array('@id' => $id)));
+  }
+
+  /**
+   * Tests Database::closeConnection() without query.
+   *
+   * @todo getConnectionID() executes a query.
+   */
+  function testOpenClose() {
+    if ($this->skipTest) {
+      return;
+    }
+    // Add and open a new connection.
+    $this->addConnection();
+    $id = $this->getConnectionID();
+    Database::getConnection($this->target, $this->key);
+
+    // Verify that there is a new connection.
+    $this->assertConnection($id);
+
+    // Close the connection.
+    Database::closeConnection($this->target, $this->key);
+    // Wait 20ms to give the database engine sufficient time to react.
+    usleep(20000);
+
+    // Verify that we are back to the original connection count.
+    $this->assertNoConnection($id);
+  }
+
+  /**
+   * Tests Database::closeConnection() with a query.
+   */
+  function testOpenQueryClose() {
+    if ($this->skipTest) {
+      return;
+    }
+    // Add and open a new connection.
+    $this->addConnection();
+    $id = $this->getConnectionID();
+    Database::getConnection($this->target, $this->key);
+
+    // Verify that there is a new connection.
+    $this->assertConnection($id);
+
+    // Execute a query.
+    Database::getConnection($this->target, $this->key)->query('SHOW TABLES');
+
+    // Close the connection.
+    Database::closeConnection($this->target, $this->key);
+    // Wait 20ms to give the database engine sufficient time to react.
+    usleep(20000);
+
+    // Verify that we are back to the original connection count.
+    $this->assertNoConnection($id);
+  }
+
+  /**
+   * Tests Database::closeConnection() with a query and custom prefetch method.
+   */
+  function testOpenQueryPrefetchClose() {
+    if ($this->skipTest) {
+      return;
+    }
+    // Add and open a new connection.
+    $this->addConnection();
+    $id = $this->getConnectionID();
+    Database::getConnection($this->target, $this->key);
+
+    // Verify that there is a new connection.
+    $this->assertConnection($id);
+
+    // Execute a query.
+    Database::getConnection($this->target, $this->key)->query('SHOW TABLES')->fetchCol();
+
+    // Close the connection.
+    Database::closeConnection($this->target, $this->key);
+    // Wait 20ms to give the database engine sufficient time to react.
+    usleep(20000);
+
+    // Verify that we are back to the original connection count.
+    $this->assertNoConnection($id);
+  }
+
+  /**
+   * Tests Database::closeConnection() with a select query.
+   */
+  function testOpenSelectQueryClose() {
+    if ($this->skipTest) {
+      return;
+    }
+    // Add and open a new connection.
+    $this->addConnection();
+    $id = $this->getConnectionID();
+    Database::getConnection($this->target, $this->key);
+
+    // Verify that there is a new connection.
+    $this->assertConnection($id);
+
+    // Create a table.
+    $name = 'foo';
+    Database::getConnection($this->target, $this->key)->schema()->createTable($name, array(
+      'fields' => array(
+        'name' => array(
+          'type' => 'varchar',
+          'length' => 255,
+        ),
+      ),
+    ));
+
+    // Execute a query.
+    Database::getConnection($this->target, $this->key)->select('foo', 'f')
+      ->fields('f', array('name'))
+      ->execute()
+      ->fetchAll();
+
+    // Drop the table.
+    Database::getConnection($this->target, $this->key)->schema()->dropTable($name);
+
+    // Close the connection.
+    Database::closeConnection($this->target, $this->key);
+    // Wait 20ms to give the database engine sufficient time to react.
+    usleep(20000);
+
+    // Verify that we are back to the original connection count.
+    $this->assertNoConnection($id);
+  }
+
 }
diff --git a/modules/simpletest/tests/entity_query.test b/modules/simpletest/tests/entity_query.test
index 6d77c50..9a6cb69 100644
--- a/modules/simpletest/tests/entity_query.test
+++ b/modules/simpletest/tests/entity_query.test
@@ -169,7 +169,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->entityCondition('entity_id', '5');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle', 5),
-    ), t('Test query on an entity type with a generated bundle.'));
+    ), 'Test query on an entity type with a generated bundle.');
 
     // Test entity_type condition.
     $query = new EntityFieldQuery();
@@ -181,7 +181,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test entity entity_type condition.'));
+    ), 'Test entity entity_type condition.');
 
     // Test entity_id condition.
     $query = new EntityFieldQuery();
@@ -190,7 +190,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->entityCondition('entity_id', '3');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 3),
-    ), t('Test entity entity_id condition.'));
+    ), 'Test entity entity_id condition.');
 
     $query = new EntityFieldQuery();
     $query
@@ -198,7 +198,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->propertyCondition('ftid', '3');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 3),
-    ), t('Test entity entity_id condition and entity_id property condition.'));
+    ), 'Test entity entity_id condition and entity_id property condition.');
 
     // Test bundle condition.
     $query = new EntityFieldQuery();
@@ -210,7 +210,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test entity bundle condition: bundle1.'));
+    ), 'Test entity bundle condition: bundle1.');
 
     $query = new EntityFieldQuery();
     $query
@@ -219,7 +219,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test entity bundle condition: bundle2.'));
+    ), 'Test entity bundle condition: bundle2.');
 
     $query = new EntityFieldQuery();
     $query
@@ -228,7 +228,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test entity bundle condition and bundle property condition.'));
+    ), 'Test entity bundle condition and bundle property condition.');
 
     // Test revision_id condition.
     $query = new EntityFieldQuery();
@@ -237,7 +237,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->entityCondition('revision_id', '3');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 3),
-    ), t('Test entity revision_id condition.'));
+    ), 'Test entity revision_id condition.');
 
     $query = new EntityFieldQuery();
     $query
@@ -245,7 +245,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->propertyCondition('ftvid', '3');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 3),
-    ), t('Test entity revision_id condition and revision_id property condition.'));
+    ), 'Test entity revision_id condition and revision_id property condition.');
 
     $query = new EntityFieldQuery();
     $query
@@ -255,7 +255,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
         array('test_entity', 100),
         array('test_entity', 101),
-    ), t('Test revision age.'));
+    ), 'Test revision age.');
 
     // Test that fields attached to the non-revision supporting entity
     // 'test_entity_bundle_key' are reachable in FIELD_LOAD_REVISION.
@@ -274,7 +274,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
         array('test_entity', 2),
         array('test_entity', 3),
         array('test_entity', 4),
-    ), t('Test that fields are reachable from FIELD_LOAD_REVISION even for non-revision entities.'));
+    ), 'Test that fields are reachable from FIELD_LOAD_REVISION even for non-revision entities.');
 
     // Test entity sort by entity_id.
     $query = new EntityFieldQuery();
@@ -288,7 +288,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test sort entity entity_id in ascending order.'), TRUE);
+    ), 'Test sort entity entity_id in ascending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -301,7 +301,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test sort entity entity_id in descending order.'), TRUE);
+    ), 'Test sort entity entity_id in descending order.', TRUE);
 
     // Test entity sort by entity_id, with a field condition.
     $query = new EntityFieldQuery();
@@ -316,7 +316,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test sort entity entity_id in ascending order, with a field condition.'), TRUE);
+    ), 'Test sort entity entity_id in ascending order, with a field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -330,7 +330,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test sort entity entity_id property in descending order, with a field condition.'), TRUE);
+    ), 'Test sort entity entity_id property in descending order, with a field condition.', TRUE);
 
     // Test property sort by entity id.
     $query = new EntityFieldQuery();
@@ -344,7 +344,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test sort entity entity_id property in ascending order.'), TRUE);
+    ), 'Test sort entity entity_id property in ascending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -357,7 +357,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test sort entity entity_id property in descending order.'), TRUE);
+    ), 'Test sort entity entity_id property in descending order.', TRUE);
 
     // Test property sort by entity id, with a field condition.
     $query = new EntityFieldQuery();
@@ -372,7 +372,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test sort entity entity_id property in ascending order, with a field condition.'), TRUE);
+    ), 'Test sort entity entity_id property in ascending order, with a field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -386,7 +386,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test sort entity entity_id property in descending order, with a field condition.'), TRUE);
+    ), 'Test sort entity entity_id property in descending order, with a field condition.', TRUE);
 
     // Test entity sort by bundle.
     $query = new EntityFieldQuery();
@@ -401,7 +401,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 6),
       array('test_entity_bundle_key', 5),
-    ), t('Test sort entity bundle in ascending order, property in descending order.'), TRUE);
+    ), 'Test sort entity bundle in ascending order, property in descending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -415,7 +415,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test sort entity bundle in descending order, property in ascending order.'), TRUE);
+    ), 'Test sort entity bundle in descending order, property in ascending order.', TRUE);
 
     // Test entity sort by bundle, with a field condition.
     $query = new EntityFieldQuery();
@@ -431,7 +431,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 6),
       array('test_entity_bundle_key', 5),
-    ), t('Test sort entity bundle in ascending order, property in descending order, with a field condition.'), TRUE);
+    ), 'Test sort entity bundle in ascending order, property in descending order, with a field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -446,7 +446,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test sort entity bundle in descending order, property in ascending order, with a field condition.'), TRUE);
+    ), 'Test sort entity bundle in descending order, property in ascending order, with a field condition.', TRUE);
 
     // Test entity sort by bundle, field.
     $query = new EntityFieldQuery();
@@ -461,7 +461,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 6),
       array('test_entity_bundle_key', 5),
-    ), t('Test sort entity bundle in ascending order, field in descending order.'), TRUE);
+    ), 'Test sort entity bundle in ascending order, field in descending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -475,7 +475,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test sort entity bundle in descending order, field in ascending order.'), TRUE);
+    ), 'Test sort entity bundle in descending order, field in ascending order.', TRUE);
 
     // Test entity sort by revision_id.
     $query = new EntityFieldQuery();
@@ -487,7 +487,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 2),
       array('test_entity', 3),
       array('test_entity', 4),
-    ), t('Test sort entity revision_id in ascending order.'), TRUE);
+    ), 'Test sort entity revision_id in ascending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -498,7 +498,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 3),
       array('test_entity', 2),
       array('test_entity', 1),
-    ), t('Test sort entity revision_id in descending order.'), TRUE);
+    ), 'Test sort entity revision_id in descending order.', TRUE);
 
     // Test entity sort by revision_id, with a field condition.
     $query = new EntityFieldQuery();
@@ -511,7 +511,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 2),
       array('test_entity', 3),
       array('test_entity', 4),
-    ), t('Test sort entity revision_id in ascending order, with a field condition.'), TRUE);
+    ), 'Test sort entity revision_id in ascending order, with a field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -523,7 +523,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 3),
       array('test_entity', 2),
       array('test_entity', 1),
-    ), t('Test sort entity revision_id in descending order, with a field condition.'), TRUE);
+    ), 'Test sort entity revision_id in descending order, with a field condition.', TRUE);
 
     // Test property sort by revision_id.
     $query = new EntityFieldQuery();
@@ -535,7 +535,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 2),
       array('test_entity', 3),
       array('test_entity', 4),
-    ), t('Test sort entity revision_id property in ascending order.'), TRUE);
+    ), 'Test sort entity revision_id property in ascending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -546,7 +546,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 3),
       array('test_entity', 2),
       array('test_entity', 1),
-    ), t('Test sort entity revision_id property in descending order.'), TRUE);
+    ), 'Test sort entity revision_id property in descending order.', TRUE);
 
     // Test property sort by revision_id, with a field condition.
     $query = new EntityFieldQuery();
@@ -559,7 +559,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 2),
       array('test_entity', 3),
       array('test_entity', 4),
-    ), t('Test sort entity revision_id property in ascending order, with a field condition.'), TRUE);
+    ), 'Test sort entity revision_id property in ascending order, with a field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -571,7 +571,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 3),
       array('test_entity', 2),
       array('test_entity', 1),
-    ), t('Test sort entity revision_id property in descending order, with a field condition.'), TRUE);
+    ), 'Test sort entity revision_id property in descending order, with a field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -584,7 +584,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test sort field in ascending order without field condition.'), TRUE);
+    ), 'Test sort field in ascending order without field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -597,7 +597,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test sort field in descending order without field condition.'), TRUE);
+    ), 'Test sort field in descending order without field condition.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -611,7 +611,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test sort field in ascending order.'), TRUE);
+    ), 'Test sort field in ascending order.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -625,7 +625,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test sort field in descending order.'), TRUE);
+    ), 'Test sort field in descending order.', TRUE);
 
     // Test "in" operation with entity entity_type condition and entity_id
     // property condition.
@@ -637,7 +637,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test "in" operation with entity entity_type condition and entity_id property condition.'));
+    ), 'Test "in" operation with entity entity_type condition and entity_id property condition.');
 
     // Test "in" operation with entity entity_type condition and entity_id
     // property condition. Sort in descending order by entity_id.
@@ -650,7 +650,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 1),
-    ), t('Test "in" operation with entity entity_type condition and entity_id property condition. Sort entity_id in descending order.'), TRUE);
+    ), 'Test "in" operation with entity entity_type condition and entity_id property condition. Sort entity_id in descending order.', TRUE);
 
     // Test query count
     $query = new EntityFieldQuery();
@@ -658,7 +658,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->entityCondition('entity_type', 'test_entity_bundle_key')
       ->count()
       ->execute();
-    $this->assertEqual($query_count, 6, t('Test query count on entity condition.'));
+    $this->assertEqual($query_count, 6, 'Test query count on entity condition.');
 
     $query = new EntityFieldQuery();
     $query_count = $query
@@ -666,7 +666,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->propertyCondition('ftid', '1')
       ->count()
       ->execute();
-    $this->assertEqual($query_count, 1, t('Test query count on entity and property condition.'));
+    $this->assertEqual($query_count, 1, 'Test query count on entity and property condition.');
 
     $query = new EntityFieldQuery();
     $query_count = $query
@@ -674,7 +674,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->propertyCondition('ftid', '4', '>')
       ->count()
       ->execute();
-    $this->assertEqual($query_count, 2, t('Test query count on entity and property condition with operator.'));
+    $this->assertEqual($query_count, 2, 'Test query count on entity and property condition with operator.');
 
     $query = new EntityFieldQuery();
     $query_count = $query
@@ -682,7 +682,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 3, '=')
       ->count()
       ->execute();
-    $this->assertEqual($query_count, 1, t('Test query count on field condition.'));
+    $this->assertEqual($query_count, 1, 'Test query count on field condition.');
 
     // First, test without options.
     $query = new EntityFieldQuery();
@@ -696,13 +696,13 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "contains" operation on a property.'));
+    ), 'Test the "contains" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[1], 'shape', 'uar', 'CONTAINS');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle', 5),
-    ), t('Test the "contains" operation on a field.'));
+    ), 'Test the "contains" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -710,14 +710,14 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->propertyCondition('ftid', 1, '=');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
-    ), t('Test the "equal to" operation on a property.'));
+    ), 'Test the "equal to" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 3, '=');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 3),
       array('test_entity', 3),
-    ), t('Test the "equal to" operation on a field.'));
+    ), 'Test the "equal to" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -729,7 +729,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "not equal to" operation on a property.'));
+    ), 'Test the "not equal to" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 3, '<>');
@@ -742,7 +742,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 1),
       array('test_entity', 2),
       array('test_entity', 4),
-    ), t('Test the "not equal to" operation on a field.'));
+    ), 'Test the "not equal to" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -754,7 +754,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "not equal to" operation on a property.'));
+    ), 'Test the "not equal to" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 3, '!=');
@@ -767,7 +767,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 1),
       array('test_entity', 2),
       array('test_entity', 4),
-    ), t('Test the "not equal to" operation on a field.'));
+    ), 'Test the "not equal to" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -775,14 +775,14 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->propertyCondition('ftid', 2, '<');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
-    ), t('Test the "less than" operation on a property.'));
+    ), 'Test the "less than" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 2, '<');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
       array('test_entity', 1),
-    ), t('Test the "less than" operation on a field.'));
+    ), 'Test the "less than" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -791,7 +791,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 2),
-    ), t('Test the "less than or equal to" operation on a property.'));
+    ), 'Test the "less than or equal to" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 2, '<=');
@@ -800,7 +800,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity', 1),
       array('test_entity', 2),
-    ), t('Test the "less than or equal to" operation on a field.'));
+    ), 'Test the "less than or equal to" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -809,7 +809,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "greater than" operation on a property.'));
+    ), 'Test the "greater than" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 2, '>');
@@ -820,7 +820,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 6),
       array('test_entity', 3),
       array('test_entity', 4),
-    ), t('Test the "greater than" operation on a field.'));
+    ), 'Test the "greater than" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -830,7 +830,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "greater than or equal to" operation on a property.'));
+    ), 'Test the "greater than or equal to" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 3, '>=');
@@ -841,7 +841,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 6),
       array('test_entity', 3),
       array('test_entity', 4),
-    ), t('Test the "greater than or equal to" operation on a field.'));
+    ), 'Test the "greater than or equal to" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -852,7 +852,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "not in" operation on a property.'));
+    ), 'Test the "not in" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', array(3, 4, 100, 101), 'NOT IN');
@@ -863,7 +863,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 6),
       array('test_entity', 1),
       array('test_entity', 2),
-    ), t('Test the "not in" operation on a field.'));
+    ), 'Test the "not in" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -872,7 +872,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test the "in" operation on a property.'));
+    ), 'Test the "in" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', array(2, 3), 'IN');
@@ -881,7 +881,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity', 2),
       array('test_entity', 3),
-    ), t('Test the "in" operation on a field.'));
+    ), 'Test the "in" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -891,7 +891,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
-    ), t('Test the "between" operation on a property.'));
+    ), 'Test the "between" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', array(1, 3), 'BETWEEN');
@@ -902,7 +902,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 1),
       array('test_entity', 2),
       array('test_entity', 3),
-    ), t('Test the "between" operation on a field.'));
+    ), 'Test the "between" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query
@@ -915,20 +915,20 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test the "starts_with" operation on a property.'));
+    ), 'Test the "starts_with" operation on a property.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[1], 'shape', 'squ', 'STARTS_WITH');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle', 5),
-    ), t('Test the "starts_with" operation on a field.'));
+    ), 'Test the "starts_with" operation on a field.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', 3);
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 3),
       array('test_entity', 3),
-    ), t('Test omission of an operator with a single item.'));
+    ), 'Test omission of an operator with a single item.');
 
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', array(2, 3));
@@ -937,7 +937,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity', 2),
       array('test_entity', 3),
-    ), t('Test omission of an operator with multiple items.'));
+    ), 'Test omission of an operator with multiple items.');
 
     $query = new EntityFieldQuery();
     $query
@@ -947,7 +947,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
-    ), t('Test entity, property and field conditions.'));
+    ), 'Test entity, property and field conditions.');
 
     $query = new EntityFieldQuery();
     $query
@@ -957,7 +957,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 4);
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 4),
-    ), t('Test entity condition with "starts_with" operation, and property and field conditions.'));
+    ), 'Test entity condition with "starts_with" operation, and property and field conditions.');
 
     $query = new EntityFieldQuery();
     $query
@@ -967,7 +967,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 2),
-    ), t('Test limit on a property.'), TRUE);
+    ), 'Test limit on a property.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -978,7 +978,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 2),
-    ), t('Test limit on a field.'), TRUE);
+    ), 'Test limit on a field.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -988,7 +988,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test offset on a property.'), TRUE);
+    ), 'Test offset on a property.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -1001,7 +1001,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test offset on a field.'), TRUE);
+    ), 'Test offset on a field.', TRUE);
 
     for ($i = 6; $i < 10; $i++) {
       $entity = new stdClass();
@@ -1023,7 +1023,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity', 4),
       array('test_entity_bundle', 8),
       array('test_entity_bundle', 9),
-    ), t('Select a field across multiple entities.'));
+    ), 'Select a field across multiple entities.');
 
     $query = new EntityFieldQuery();
     $query
@@ -1031,13 +1031,13 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[1], 'color', 'blue');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle', 5),
-    ), t('Test without a delta group.'));
+    ), 'Test without a delta group.');
 
     $query = new EntityFieldQuery();
     $query
       ->fieldCondition($this->fields[1], 'shape', 'square', '=', 'group')
       ->fieldCondition($this->fields[1], 'color', 'blue', '=', 'group');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a delta group.'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a delta group.');
 
     // Test query on a deleted field.
     field_attach_delete_bundle('test_entity_bundle_key', 'bundle1');
@@ -1046,12 +1046,12 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $query->fieldCondition($this->fields[0], 'value', '3');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle', 8),
-    ), t('Test query on a field after deleting field from some entities.'));
+    ), 'Test query on a field after deleting field from some entities.');
 
     field_attach_delete_bundle('test_entity_bundle', 'test_entity_bundle');
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', '3');
-    $this->assertEntityFieldQuery($query, array(), t('Test query on a field after deleting field from all entities.'));
+    $this->assertEntityFieldQuery($query, array(), 'Test query on a field after deleting field from all entities.');
 
     $query = new EntityFieldQuery();
     $query
@@ -1061,7 +1061,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle', 8),
       array('test_entity', 3),
-    ), t('Test query on a deleted field with deleted option set to TRUE.'));
+    ), 'Test query on a deleted field with deleted option set to TRUE.');
 
     $pass = FALSE;
     $query = new EntityFieldQuery();
@@ -1071,7 +1071,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     catch (EntityFieldQueryException $exception) {
       $pass = ($exception->getMessage() == t('For this query an entity type must be specified.'));
     }
-    $this->assertTrue($pass, t("Can't query the universe."));
+    $this->assertTrue($pass, "Can't query the universe.");
   }
 
   /**
@@ -1109,7 +1109,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->count()
       ->execute();
 
-    $this->assertEqual($query_count, 1, t("Count on translatable cardinality one field is correct."));
+    $this->assertEqual($query_count, 1, "Count on translatable cardinality one field is correct.");
   }
 
   /**
@@ -1144,7 +1144,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldDeltaCondition($this->fields[0], 0, '>');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a delta meta condition.'));
+    ), 'Test with a delta meta condition.');
 
     // Test language field meta condition.
     $query = new EntityFieldQuery();
@@ -1153,7 +1153,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '<>');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a language meta condition.'));
+    ), 'Test with a language meta condition.');
 
     // Test language field meta condition.
     $query = new EntityFieldQuery();
@@ -1162,7 +1162,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '!=');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a language meta condition.'));
+    ), 'Test with a language meta condition.');
 
     // Test delta grouping.
     $query = new EntityFieldQuery();
@@ -1172,14 +1172,14 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldDeltaCondition($this->fields[0], 1, '<', 'group');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a grouped delta meta condition.'));
+    ), 'Test with a grouped delta meta condition.');
 
     $query = new EntityFieldQuery();
     $query
       ->entityCondition('entity_type', 'test_entity', '=')
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'group')
       ->fieldDeltaCondition($this->fields[0], 1, '>=', 'group');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta meta condition (empty result set).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta meta condition (empty result set).');
 
     // Test language grouping.
     $query = new EntityFieldQuery();
@@ -1189,7 +1189,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[0], 'en', '<>', NULL, 'group');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a grouped language meta condition.'));
+    ), 'Test with a grouped language meta condition.');
 
     // Test language grouping.
     $query = new EntityFieldQuery();
@@ -1199,21 +1199,21 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[0], 'en', '!=', NULL, 'group');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a grouped language meta condition.'));
+    ), 'Test with a grouped language meta condition.');
 
     $query = new EntityFieldQuery();
     $query
       ->entityCondition('entity_type', 'test_entity', '=')
       ->fieldCondition($this->fields[0], 'value', 0, '=', NULL, 'group')
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '<>', NULL, 'group');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped language meta condition (empty result set).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped language meta condition (empty result set).');
 
     $query = new EntityFieldQuery();
     $query
       ->entityCondition('entity_type', 'test_entity', '=')
       ->fieldCondition($this->fields[0], 'value', 0, '=', NULL, 'group')
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '!=', NULL, 'group');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped language meta condition (empty result set).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped language meta condition (empty result set).');
 
     // Test delta and language grouping.
     $query = new EntityFieldQuery();
@@ -1224,7 +1224,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[0], 'en', '<>', 'delta', 'language');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a grouped delta + language meta condition.'));
+    ), 'Test with a grouped delta + language meta condition.');
 
     // Test delta and language grouping.
     $query = new EntityFieldQuery();
@@ -1235,7 +1235,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[0], 'en', '!=', 'delta', 'language');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity', 1),
-    ), t('Test with a grouped delta + language meta condition.'));
+    ), 'Test with a grouped delta + language meta condition.');
 
     $query = new EntityFieldQuery();
     $query
@@ -1243,7 +1243,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'delta', 'language')
       ->fieldDeltaCondition($this->fields[0], 1, '>=', 'delta', 'language')
       ->fieldLanguageCondition($this->fields[0], 'en', '<>', 'delta', 'language');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta + language meta condition (empty result set, delta condition unsatisifed).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta + language meta condition (empty result set, delta condition unsatisifed).');
 
     $query = new EntityFieldQuery();
     $query
@@ -1251,7 +1251,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'delta', 'language')
       ->fieldDeltaCondition($this->fields[0], 1, '>=', 'delta', 'language')
       ->fieldLanguageCondition($this->fields[0], 'en', '!=', 'delta', 'language');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta + language meta condition (empty result set, delta condition unsatisifed).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta + language meta condition (empty result set, delta condition unsatisifed).');
 
     $query = new EntityFieldQuery();
     $query
@@ -1259,7 +1259,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'delta', 'language')
       ->fieldDeltaCondition($this->fields[0], 1, '<', 'delta', 'language')
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '<>', 'delta', 'language');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta + language meta condition (empty result set, language condition unsatisifed).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta + language meta condition (empty result set, language condition unsatisifed).');
 
     $query = new EntityFieldQuery();
     $query
@@ -1267,7 +1267,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'delta', 'language')
       ->fieldDeltaCondition($this->fields[0], 1, '<', 'delta', 'language')
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '!=', 'delta', 'language');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta + language meta condition (empty result set, language condition unsatisifed).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta + language meta condition (empty result set, language condition unsatisifed).');
 
     $query = new EntityFieldQuery();
     $query
@@ -1275,7 +1275,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'delta', 'language')
       ->fieldDeltaCondition($this->fields[0], 1, '>=', 'delta', 'language')
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '<>', 'delta', 'language');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta + language meta condition (empty result set, both conditions unsatisifed).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta + language meta condition (empty result set, both conditions unsatisifed).');
 
     $query = new EntityFieldQuery();
     $query
@@ -1283,7 +1283,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldCondition($this->fields[0], 'value', 0, '=', 'delta', 'language')
       ->fieldDeltaCondition($this->fields[0], 1, '>=', 'delta', 'language')
       ->fieldLanguageCondition($this->fields[0], LANGUAGE_NONE, '!=', 'delta', 'language');
-    $this->assertEntityFieldQuery($query, array(), t('Test with a grouped delta + language meta condition (empty result set, both conditions unsatisifed).'));
+    $this->assertEntityFieldQuery($query, array(), 'Test with a grouped delta + language meta condition (empty result set, both conditions unsatisifed).');
 
     // Test grouping with another field to ensure that grouping cache is reset
     // properly.
@@ -1296,7 +1296,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       ->fieldLanguageCondition($this->fields[1], LANGUAGE_NONE, '=', 'delta', 'language');
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle', 5),
-    ), t('Test grouping cache.'));
+    ), 'Test grouping cache.');
   }
 
   /**
@@ -1306,19 +1306,19 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     // Entity-only query.
     $query = new EntityFieldQuery();
     $query->entityCondition('entity_type', 'test_entity_bundle_key');
-    $this->assertIdentical($query->queryCallback(), array($query, 'propertyQuery'), t('Entity-only queries are handled by the propertyQuery handler.'));
+    $this->assertIdentical($query->queryCallback(), array($query, 'propertyQuery'), 'Entity-only queries are handled by the propertyQuery handler.');
 
     // Field-only query.
     $query = new EntityFieldQuery();
     $query->fieldCondition($this->fields[0], 'value', '3');
-    $this->assertIdentical($query->queryCallback(), 'field_sql_storage_field_storage_query', t('Pure field queries are handled by the Field storage handler.'));
+    $this->assertIdentical($query->queryCallback(), 'field_sql_storage_field_storage_query', 'Pure field queries are handled by the Field storage handler.');
 
     // Mixed entity and field query.
     $query = new EntityFieldQuery();
     $query
       ->entityCondition('entity_type', 'test_entity_bundle_key')
       ->fieldCondition($this->fields[0], 'value', '3');
-    $this->assertIdentical($query->queryCallback(), 'field_sql_storage_field_storage_query', t('Mixed queries are handled by the Field storage handler.'));
+    $this->assertIdentical($query->queryCallback(), 'field_sql_storage_field_storage_query', 'Mixed queries are handled by the Field storage handler.');
 
     // Overriding with $query->executeCallback.
     $query = new EntityFieldQuery();
@@ -1326,7 +1326,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $query->executeCallback = 'field_test_dummy_field_storage_query';
     $this->assertEntityFieldQuery($query, array(
       array('user', 1),
-    ), t('executeCallback can override the query handler.'));
+    ), 'executeCallback can override the query handler.');
 
     // Overriding with $query->executeCallback via hook_entity_query_alter().
     $query = new EntityFieldQuery();
@@ -1335,7 +1335,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $query->alterMyExecuteCallbackPlease = TRUE;
     $this->assertEntityFieldQuery($query, array(
       array('user', 1),
-    ), t('executeCallback can override the query handler when set in a hook_entity_query_alter().'));
+    ), 'executeCallback can override the query handler when set in a hook_entity_query_alter().');
 
     // Mixed-storage queries.
     $query = new EntityFieldQuery();
@@ -1350,7 +1350,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     catch (EntityFieldQueryException $exception) {
       $pass = ($exception->getMessage() == t("Can't handle more than one field storage engine"));
     }
-    $this->assertTrue($pass, t('Cannot query across field storage engines.'));
+    $this->assertTrue($pass, 'Cannot query across field storage engines.');
   }
 
   /**
@@ -1368,7 +1368,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
-    ), t('Test pager integration in propertyQuery: page 1.'), TRUE);
+    ), 'Test pager integration in propertyQuery: page 1.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -1379,7 +1379,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test pager integration in propertyQuery: page 2.'), TRUE);
+    ), 'Test pager integration in propertyQuery: page 2.', TRUE);
 
     // Test pager in field storage
     $_GET['page'] = '0,1';
@@ -1392,7 +1392,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 2),
-    ), t('Test pager integration in field storage: page 1.'), TRUE);
+    ), 'Test pager integration in field storage: page 1.', TRUE);
 
     $query = new EntityFieldQuery();
     $query
@@ -1403,7 +1403,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
     $this->assertEntityFieldQuery($query, array(
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test pager integration in field storage: page 2.'), TRUE);
+    ), 'Test pager integration in field storage: page 2.', TRUE);
 
     unset($_GET['page']);
   }
@@ -1451,7 +1451,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test TableSort by property: ftid ASC in propertyQuery.'), TRUE);
+    ), 'Test TableSort by property: ftid ASC in propertyQuery.', TRUE);
 
     $_GET['sort'] = 'desc';
     $_GET['order'] = 'Id';
@@ -1466,7 +1466,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test TableSort by property: ftid DESC in propertyQuery.'), TRUE);
+    ), 'Test TableSort by property: ftid DESC in propertyQuery.', TRUE);
 
     $_GET['sort'] = 'asc';
     $_GET['order'] = 'Type';
@@ -1481,7 +1481,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test TableSort by entity: bundle ASC in propertyQuery.'), TRUE);
+    ), 'Test TableSort by entity: bundle ASC in propertyQuery.', TRUE);
 
     $_GET['sort'] = 'desc';
     $_GET['order'] = 'Type';
@@ -1496,7 +1496,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test TableSort by entity: bundle DESC in propertyQuery.'), TRUE);
+    ), 'Test TableSort by entity: bundle DESC in propertyQuery.', TRUE);
 
     // Test TableSort in field storage
     $_GET['sort'] = 'asc';
@@ -1518,7 +1518,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test TableSort by property: ftid ASC in field storage.'), TRUE);
+    ), 'Test TableSort by property: ftid ASC in field storage.', TRUE);
 
     $_GET['sort'] = 'desc';
     $_GET['order'] = 'Id';
@@ -1534,7 +1534,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test TableSort by property: ftid DESC in field storage.'), TRUE);
+    ), 'Test TableSort by property: ftid DESC in field storage.', TRUE);
 
     $_GET['sort'] = 'asc';
     $_GET['order'] = 'Type';
@@ -1551,7 +1551,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 1),
       array('test_entity_bundle_key', 6),
       array('test_entity_bundle_key', 5),
-    ), t('Test TableSort by entity: bundle ASC in field storage.'), TRUE);
+    ), 'Test TableSort by entity: bundle ASC in field storage.', TRUE);
 
     $_GET['sort'] = 'desc';
     $_GET['order'] = 'Type';
@@ -1568,7 +1568,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 4),
-    ), t('Test TableSort by entity: bundle DESC in field storage.'), TRUE);
+    ), 'Test TableSort by entity: bundle DESC in field storage.', TRUE);
 
     $_GET['sort'] = 'asc';
     $_GET['order'] = 'Field';
@@ -1584,7 +1584,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 4),
       array('test_entity_bundle_key', 5),
       array('test_entity_bundle_key', 6),
-    ), t('Test TableSort by field ASC.'), TRUE);
+    ), 'Test TableSort by field ASC.', TRUE);
 
     $_GET['sort'] = 'desc';
     $_GET['order'] = 'Field';
@@ -1600,7 +1600,7 @@ class EntityFieldQueryTestCase extends DrupalWebTestCase {
       array('test_entity_bundle_key', 3),
       array('test_entity_bundle_key', 2),
       array('test_entity_bundle_key', 1),
-    ), t('Test TableSort by field DESC.'), TRUE);
+    ), 'Test TableSort by field DESC.', TRUE);
 
     unset($_GET['sort']);
     unset($_GET['order']);
diff --git a/modules/simpletest/tests/error.test b/modules/simpletest/tests/error.test
index 5b6b04b..f946e82 100644
--- a/modules/simpletest/tests/error.test
+++ b/modules/simpletest/tests/error.test
@@ -42,7 +42,7 @@ class DrupalErrorHandlerTestCase extends DrupalWebTestCase {
     // Set error reporting to collect notices.
     variable_set('error_level', ERROR_REPORTING_DISPLAY_ALL);
     $this->drupalGet('error-test/generate-warnings');
-    $this->assertResponse(200, t('Received expected HTTP status code.'));
+    $this->assertResponse(200, 'Received expected HTTP status code.');
     $this->assertErrorMessage($error_notice);
     $this->assertErrorMessage($error_warning);
     $this->assertErrorMessage($error_user_notice);
@@ -50,7 +50,7 @@ class DrupalErrorHandlerTestCase extends DrupalWebTestCase {
     // Set error reporting to not collect notices.
     variable_set('error_level', ERROR_REPORTING_DISPLAY_SOME);
     $this->drupalGet('error-test/generate-warnings');
-    $this->assertResponse(200, t('Received expected HTTP status code.'));
+    $this->assertResponse(200, 'Received expected HTTP status code.');
     $this->assertNoErrorMessage($error_notice);
     $this->assertErrorMessage($error_warning);
     $this->assertErrorMessage($error_user_notice);
@@ -58,7 +58,7 @@ class DrupalErrorHandlerTestCase extends DrupalWebTestCase {
     // Set error reporting to not show any errors.
     variable_set('error_level', ERROR_REPORTING_HIDE);
     $this->drupalGet('error-test/generate-warnings');
-    $this->assertResponse(200, t('Received expected HTTP status code.'));
+    $this->assertResponse(200, 'Received expected HTTP status code.');
     $this->assertNoErrorMessage($error_notice);
     $this->assertNoErrorMessage($error_warning);
     $this->assertNoErrorMessage($error_user_notice);
@@ -84,17 +84,17 @@ class DrupalErrorHandlerTestCase extends DrupalWebTestCase {
     );
 
     $this->drupalGet('error-test/trigger-exception');
-    $this->assertTrue(strpos($this->drupalGetHeader(':status'), '500 Service unavailable (with message)'), t('Received expected HTTP status line.'));
+    $this->assertTrue(strpos($this->drupalGetHeader(':status'), '500 Service unavailable (with message)'), 'Received expected HTTP status line.');
     $this->assertErrorMessage($error_exception);
 
     $this->drupalGet('error-test/trigger-pdo-exception');
-    $this->assertTrue(strpos($this->drupalGetHeader(':status'), '500 Service unavailable (with message)'), t('Received expected HTTP status line.'));
+    $this->assertTrue(strpos($this->drupalGetHeader(':status'), '500 Service unavailable (with message)'), 'Received expected HTTP status line.');
     // We cannot use assertErrorMessage() since the extact error reported
     // varies from database to database. Check that the SQL string is displayed.
-    $this->assertText($error_pdo_exception['%type'], t('Found %type in error page.', $error_pdo_exception));
-    $this->assertText($error_pdo_exception['!message'], t('Found !message in error page.', $error_pdo_exception));
-    $error_details = t('in %function (line ', $error_pdo_exception);
-    $this->assertRaw($error_details, t("Found '!message' in error page.", array('!message' => $error_details)));
+    $this->assertText($error_pdo_exception['%type'], format_string('Found %type in error page.', $error_pdo_exception));
+    $this->assertText($error_pdo_exception['!message'], format_string('Found !message in error page.', $error_pdo_exception));
+    $error_details = format_string('in %function (line ', $error_pdo_exception);
+    $this->assertRaw($error_details, format_string("Found '!message' in error page.", array('!message' => $error_details)));
   }
 
   /**
@@ -102,7 +102,7 @@ class DrupalErrorHandlerTestCase extends DrupalWebTestCase {
    */
   function assertErrorMessage(array $error) {
     $message = t('%type: !message in %function (line ', $error);
-    $this->assertRaw($message, t('Found error message: !message.', array('!message' => $message)));
+    $this->assertRaw($message, format_string('Found error message: !message.', array('!message' => $message)));
   }
 
   /**
@@ -110,7 +110,7 @@ class DrupalErrorHandlerTestCase extends DrupalWebTestCase {
    */
   function assertNoErrorMessage(array $error) {
     $message = t('%type: !message in %function (line ', $error);
-    $this->assertNoRaw($message, t('Did not find error message: !message.', array('!message' => $message)));
+    $this->assertNoRaw($message, format_string('Did not find error message: !message.', array('!message' => $message)));
   }
 }
 
diff --git a/modules/simpletest/tests/file.test b/modules/simpletest/tests/file.test
index 3df31ba..0f2cdb6 100644
--- a/modules/simpletest/tests/file.test
+++ b/modules/simpletest/tests/file.test
@@ -57,13 +57,13 @@ class FileTestCase extends DrupalWebTestCase {
    *   File object to compare.
    */
   function assertFileUnchanged($before, $after) {
-    $this->assertEqual($before->fid, $after->fid, t('File id is the same: %file1 == %file2.', array('%file1' => $before->fid, '%file2' => $after->fid)), 'File unchanged');
-    $this->assertEqual($before->uid, $after->uid, t('File owner is the same: %file1 == %file2.', array('%file1' => $before->uid, '%file2' => $after->uid)), 'File unchanged');
-    $this->assertEqual($before->filename, $after->filename, t('File name is the same: %file1 == %file2.', array('%file1' => $before->filename, '%file2' => $after->filename)), 'File unchanged');
-    $this->assertEqual($before->uri, $after->uri, t('File path is the same: %file1 == %file2.', array('%file1' => $before->uri, '%file2' => $after->uri)), 'File unchanged');
-    $this->assertEqual($before->filemime, $after->filemime, t('File MIME type is the same: %file1 == %file2.', array('%file1' => $before->filemime, '%file2' => $after->filemime)), 'File unchanged');
-    $this->assertEqual($before->filesize, $after->filesize, t('File size is the same: %file1 == %file2.', array('%file1' => $before->filesize, '%file2' => $after->filesize)), 'File unchanged');
-    $this->assertEqual($before->status, $after->status, t('File status is the same: %file1 == %file2.', array('%file1' => $before->status, '%file2' => $after->status)), 'File unchanged');
+    $this->assertEqual($before->fid, $after->fid, format_string('File id is the same: %file1 == %file2.', array('%file1' => $before->fid, '%file2' => $after->fid)), 'File unchanged');
+    $this->assertEqual($before->uid, $after->uid, format_string('File owner is the same: %file1 == %file2.', array('%file1' => $before->uid, '%file2' => $after->uid)), 'File unchanged');
+    $this->assertEqual($before->filename, $after->filename, format_string('File name is the same: %file1 == %file2.', array('%file1' => $before->filename, '%file2' => $after->filename)), 'File unchanged');
+    $this->assertEqual($before->uri, $after->uri, format_string('File path is the same: %file1 == %file2.', array('%file1' => $before->uri, '%file2' => $after->uri)), 'File unchanged');
+    $this->assertEqual($before->filemime, $after->filemime, format_string('File MIME type is the same: %file1 == %file2.', array('%file1' => $before->filemime, '%file2' => $after->filemime)), 'File unchanged');
+    $this->assertEqual($before->filesize, $after->filesize, format_string('File size is the same: %file1 == %file2.', array('%file1' => $before->filesize, '%file2' => $after->filesize)), 'File unchanged');
+    $this->assertEqual($before->status, $after->status, format_string('File status is the same: %file1 == %file2.', array('%file1' => $before->status, '%file2' => $after->status)), 'File unchanged');
   }
 
   /**
@@ -75,8 +75,8 @@ class FileTestCase extends DrupalWebTestCase {
    *   File object to compare.
    */
   function assertDifferentFile($file1, $file2) {
-    $this->assertNotEqual($file1->fid, $file2->fid, t('Files have different ids: %file1 != %file2.', array('%file1' => $file1->fid, '%file2' => $file2->fid)), 'Different file');
-    $this->assertNotEqual($file1->uri, $file2->uri, t('Files have different paths: %file1 != %file2.', array('%file1' => $file1->uri, '%file2' => $file2->uri)), 'Different file');
+    $this->assertNotEqual($file1->fid, $file2->fid, format_string('Files have different ids: %file1 != %file2.', array('%file1' => $file1->fid, '%file2' => $file2->fid)), 'Different file');
+    $this->assertNotEqual($file1->uri, $file2->uri, format_string('Files have different paths: %file1 != %file2.', array('%file1' => $file1->uri, '%file2' => $file2->uri)), 'Different file');
   }
 
   /**
@@ -88,8 +88,8 @@ class FileTestCase extends DrupalWebTestCase {
    *   File object to compare.
    */
   function assertSameFile($file1, $file2) {
-    $this->assertEqual($file1->fid, $file2->fid, t('Files have the same ids: %file1 == %file2.', array('%file1' => $file1->fid, '%file2-fid' => $file2->fid)), 'Same file');
-    $this->assertEqual($file1->uri, $file2->uri, t('Files have the same path: %file1 == %file2.', array('%file1' => $file1->uri, '%file2' => $file2->uri)), 'Same file');
+    $this->assertEqual($file1->fid, $file2->fid, format_string('Files have the same ids: %file1 == %file2.', array('%file1' => $file1->fid, '%file2-fid' => $file2->fid)), 'Same file');
+    $this->assertEqual($file1->uri, $file2->uri, format_string('Files have the same path: %file1 == %file2.', array('%file1' => $file1->uri, '%file2' => $file2->uri)), 'Same file');
   }
 
   /**
@@ -176,7 +176,7 @@ class FileTestCase extends DrupalWebTestCase {
     if (!isset($path)) {
       $path = file_default_scheme() . '://' . $this->randomName();
     }
-    $this->assertTrue(drupal_mkdir($path) && is_dir($path), t('Directory was created successfully.'));
+    $this->assertTrue(drupal_mkdir($path) && is_dir($path), 'Directory was created successfully.');
     return $path;
   }
 
@@ -212,7 +212,7 @@ class FileTestCase extends DrupalWebTestCase {
     }
 
     file_put_contents($filepath, $contents);
-    $this->assertTrue(is_file($filepath), t('The test file exists on the disk.'), 'Create test file');
+    $this->assertTrue(is_file($filepath), 'The test file exists on the disk.', 'Create test file');
 
     $file = new stdClass();
     $file->uri = $filepath;
@@ -224,7 +224,7 @@ class FileTestCase extends DrupalWebTestCase {
     $file->status = 0;
     // Write the record directly rather than calling file_save() so we don't
     // invoke the hooks.
-    $this->assertNotIdentical(drupal_write_record('file_managed', $file), FALSE, t('The file was added to the database.'), 'Create test file');
+    $this->assertNotIdentical(drupal_write_record('file_managed', $file), FALSE, 'The file was added to the database.', 'Create test file');
 
     return $file;
   }
@@ -257,19 +257,19 @@ class FileHookTestCase extends FileTestCase {
     // Determine if there were any expected that were not called.
     $uncalled = array_diff($expected, $actual);
     if (count($uncalled)) {
-      $this->assertTrue(FALSE, t('Expected hooks %expected to be called but %uncalled was not called.', array('%expected' => implode(', ', $expected), '%uncalled' => implode(', ', $uncalled))));
+      $this->assertTrue(FALSE, format_string('Expected hooks %expected to be called but %uncalled was not called.', array('%expected' => implode(', ', $expected), '%uncalled' => implode(', ', $uncalled))));
     }
     else {
-      $this->assertTrue(TRUE, t('All the expected hooks were called: %expected', array('%expected' => empty($expected) ? t('(none)') : implode(', ', $expected))));
+      $this->assertTrue(TRUE, format_string('All the expected hooks were called: %expected', array('%expected' => empty($expected) ? t('(none)') : implode(', ', $expected))));
     }
 
     // Determine if there were any unexpected calls.
     $unexpected = array_diff($actual, $expected);
     if (count($unexpected)) {
-      $this->assertTrue(FALSE, t('Unexpected hooks were called: %unexpected.', array('%unexpected' => empty($unexpected) ? t('(none)') : implode(', ', $unexpected))));
+      $this->assertTrue(FALSE, format_string('Unexpected hooks were called: %unexpected.', array('%unexpected' => empty($unexpected) ? t('(none)') : implode(', ', $unexpected))));
     }
     else {
-      $this->assertTrue(TRUE, t('No unexpected hooks were called.'));
+      $this->assertTrue(TRUE, 'No unexpected hooks were called.');
     }
   }
 
@@ -288,13 +288,13 @@ class FileHookTestCase extends FileTestCase {
 
     if (!isset($message)) {
       if ($actual_count == $expected_count) {
-        $message = t('hook_file_@name was called correctly.', array('@name' => $hook));
+        $message = format_string('hook_file_@name was called correctly.', array('@name' => $hook));
       }
       elseif ($expected_count == 0) {
         $message = format_plural($actual_count, 'hook_file_@name was not expected to be called but was actually called once.', 'hook_file_@name was not expected to be called but was actually called @count times.', array('@name' => $hook, '@count' => $actual_count));
       }
       else {
-        $message = t('hook_file_@name was expected to be called %expected times but was called %actual times.', array('@name' => $hook, '%expected' => $expected_count, '%actual' => $actual_count));
+        $message = format_string('hook_file_@name was expected to be called %expected times but was called %actual times.', array('@name' => $hook, '%expected' => $expected_count, '%actual' => $actual_count));
       }
     }
     $this->assertEqual($actual_count, $expected_count, $message);
@@ -388,24 +388,24 @@ class FileValidatorTest extends DrupalWebTestCase {
     $file = new stdClass();
     $file->filename = 'asdf.txt';
     $errors = file_validate_extensions($file, 'asdf txt pork');
-    $this->assertEqual(count($errors), 0, t('Valid extension accepted.'), 'File');
+    $this->assertEqual(count($errors), 0, 'Valid extension accepted.', 'File');
 
     $file->filename = 'asdf.txt';
     $errors = file_validate_extensions($file, 'exe png');
-    $this->assertEqual(count($errors), 1, t('Invalid extension blocked.'), 'File');
+    $this->assertEqual(count($errors), 1, 'Invalid extension blocked.', 'File');
   }
 
   /**
    *  This ensures a specific file is actually an image.
    */
   function testFileValidateIsImage() {
-    $this->assertTrue(file_exists($this->image->uri), t('The image being tested exists.'), 'File');
+    $this->assertTrue(file_exists($this->image->uri), 'The image being tested exists.', 'File');
     $errors = file_validate_is_image($this->image);
-    $this->assertEqual(count($errors), 0, t('No error reported for our image file.'), 'File');
+    $this->assertEqual(count($errors), 0, 'No error reported for our image file.', 'File');
 
-    $this->assertTrue(file_exists($this->non_image->uri), t('The non-image being tested exists.'), 'File');
+    $this->assertTrue(file_exists($this->non_image->uri), 'The non-image being tested exists.', 'File');
     $errors = file_validate_is_image($this->non_image);
-    $this->assertEqual(count($errors), 1, t('An error reported for our non-image file.'), 'File');
+    $this->assertEqual(count($errors), 1, 'An error reported for our non-image file.', 'File');
   }
 
   /**
@@ -415,19 +415,19 @@ class FileValidatorTest extends DrupalWebTestCase {
   function testFileValidateImageResolution() {
     // Non-images.
     $errors = file_validate_image_resolution($this->non_image);
-    $this->assertEqual(count($errors), 0, t("Shouldn't get any errors for a non-image file."), 'File');
+    $this->assertEqual(count($errors), 0, 'Should not get any errors for a non-image file.', 'File');
     $errors = file_validate_image_resolution($this->non_image, '50x50', '100x100');
-    $this->assertEqual(count($errors), 0, t("Don't check the resolution on non files."), 'File');
+    $this->assertEqual(count($errors), 0, 'Do not check the resolution on non files.', 'File');
 
     // Minimum size.
     $errors = file_validate_image_resolution($this->image);
-    $this->assertEqual(count($errors), 0, t('No errors for an image when there is no minimum or maximum resolution.'), 'File');
+    $this->assertEqual(count($errors), 0, 'No errors for an image when there is no minimum or maximum resolution.', 'File');
     $errors = file_validate_image_resolution($this->image, 0, '200x1');
-    $this->assertEqual(count($errors), 1, t("Got an error for an image that wasn't wide enough."), 'File');
+    $this->assertEqual(count($errors), 1, 'Got an error for an image that was not wide enough.', 'File');
     $errors = file_validate_image_resolution($this->image, 0, '1x200');
-    $this->assertEqual(count($errors), 1, t("Got an error for an image that wasn't tall enough."), 'File');
+    $this->assertEqual(count($errors), 1, 'Got an error for an image that was not tall enough.', 'File');
     $errors = file_validate_image_resolution($this->image, 0, '200x200');
-    $this->assertEqual(count($errors), 1, t('Small images report an error.'), 'File');
+    $this->assertEqual(count($errors), 1, 'Small images report an error.', 'File');
 
     // Maximum size.
     if (image_get_toolkit()) {
@@ -436,18 +436,18 @@ class FileValidatorTest extends DrupalWebTestCase {
       $this->image->uri = 'temporary://druplicon.png';
 
       $errors = file_validate_image_resolution($this->image, '10x5');
-      $this->assertEqual(count($errors), 0, t('No errors should be reported when an oversized image can be scaled down.'), 'File');
+      $this->assertEqual(count($errors), 0, 'No errors should be reported when an oversized image can be scaled down.', 'File');
 
       $info = image_get_info($this->image->uri);
-      $this->assertTrue($info['width'] <= 10, t('Image scaled to correct width.'), 'File');
-      $this->assertTrue($info['height'] <= 5, t('Image scaled to correct height.'), 'File');
+      $this->assertTrue($info['width'] <= 10, 'Image scaled to correct width.', 'File');
+      $this->assertTrue($info['height'] <= 5, 'Image scaled to correct height.', 'File');
 
       drupal_unlink('temporary://druplicon.png');
     }
     else {
       // TODO: should check that the error is returned if no toolkit is available.
       $errors = file_validate_image_resolution($this->image, '5x10');
-      $this->assertEqual(count($errors), 1, t("Oversize images that can't be scaled get an error."), 'File');
+      $this->assertEqual(count($errors), 1, 'Oversize images that cannot be scaled get an error.', 'File');
     }
   }
 
@@ -462,17 +462,17 @@ class FileValidatorTest extends DrupalWebTestCase {
     $file->filename = str_repeat('x', 240);
     $this->assertEqual(strlen($file->filename), 240);
     $errors = file_validate_name_length($file);
-    $this->assertEqual(count($errors), 0, t('No errors reported for 240 length filename.'), 'File');
+    $this->assertEqual(count($errors), 0, 'No errors reported for 240 length filename.', 'File');
 
     // Add a filename with a length too long and test it.
     $file->filename = str_repeat('x', 241);
     $errors = file_validate_name_length($file);
-    $this->assertEqual(count($errors), 1, t('An error reported for 241 length filename.'), 'File');
+    $this->assertEqual(count($errors), 1, 'An error reported for 241 length filename.', 'File');
 
     // Add a filename with an empty string and test it.
     $file->filename = '';
     $errors = file_validate_name_length($file);
-    $this->assertEqual(count($errors), 1, t('An error reported for 0 length filename.'), 'File');
+    $this->assertEqual(count($errors), 1, 'An error reported for 0 length filename.', 'File');
   }
 
 
@@ -490,7 +490,7 @@ class FileValidatorTest extends DrupalWebTestCase {
     $file = new stdClass();
     $file->filesize = 999999;
     $errors = file_validate_size($file, 1, 1);
-    $this->assertEqual(count($errors), 0, t('No size limits enforced on uid=1.'), 'File');
+    $this->assertEqual(count($errors), 0, 'No size limits enforced on uid=1.', 'File');
 
     // Run these tests as a regular user.
     $user = $this->drupalCreateUser();
@@ -499,13 +499,13 @@ class FileValidatorTest extends DrupalWebTestCase {
     $file = new stdClass();
     $file->filesize = 1000;
     $errors = file_validate_size($file, 0, 0);
-    $this->assertEqual(count($errors), 0, t('No limits means no errors.'), 'File');
+    $this->assertEqual(count($errors), 0, 'No limits means no errors.', 'File');
     $errors = file_validate_size($file, 1, 0);
-    $this->assertEqual(count($errors), 1, t('Error for the file being over the limit.'), 'File');
+    $this->assertEqual(count($errors), 1, 'Error for the file being over the limit.', 'File');
     $errors = file_validate_size($file, 0, 1);
-    $this->assertEqual(count($errors), 1, t('Error for the user being over their limit.'), 'File');
+    $this->assertEqual(count($errors), 1, 'Error for the user being over their limit.', 'File');
     $errors = file_validate_size($file, 1, 1);
-    $this->assertEqual(count($errors), 2, t('Errors for both the file and their limit.'), 'File');
+    $this->assertEqual(count($errors), 2, 'Errors for both the file and their limit.', 'File');
 
     $user = $original_user;
     drupal_save_session(TRUE);
@@ -534,15 +534,15 @@ class FileUnmanagedSaveDataTest extends FileTestCase {
 
     // No filename.
     $filepath = file_unmanaged_save_data($contents);
-    $this->assertTrue($filepath, t('Unnamed file saved correctly.'));
-    $this->assertEqual(file_uri_scheme($filepath), file_default_scheme(), t("File was placed in Drupal's files directory."));
-    $this->assertEqual($contents, file_get_contents($filepath), t('Contents of the file are correct.'));
+    $this->assertTrue($filepath, 'Unnamed file saved correctly.');
+    $this->assertEqual(file_uri_scheme($filepath), file_default_scheme(), "File was placed in Drupal's files directory.");
+    $this->assertEqual($contents, file_get_contents($filepath), 'Contents of the file are correct.');
 
     // Provide a filename.
     $filepath = file_unmanaged_save_data($contents, 'public://asdf.txt', FILE_EXISTS_REPLACE);
-    $this->assertTrue($filepath, t('Unnamed file saved correctly.'));
-    $this->assertEqual('asdf.txt', drupal_basename($filepath), t('File was named correctly.'));
-    $this->assertEqual($contents, file_get_contents($filepath), t('Contents of the file are correct.'));
+    $this->assertTrue($filepath, 'Unnamed file saved correctly.');
+    $this->assertEqual('asdf.txt', drupal_basename($filepath), 'File was named correctly.');
+    $this->assertEqual($contents, file_get_contents($filepath), 'Contents of the file are correct.');
     $this->assertFilePermissions($filepath, variable_get('file_chmod_file', 0664));
   }
 }
@@ -599,10 +599,10 @@ class FileSaveUploadTest extends FileHookTestCase {
     $this->image = current($image_files);
 
     list(, $this->image_extension) = explode('.', $this->image->filename);
-    $this->assertTrue(is_file($this->image->uri), t("The image file we're going to upload exists."));
+    $this->assertTrue(is_file($this->image->uri), "The image file we're going to upload exists.");
 
     $this->phpfile = current($this->drupalGetTestFiles('php'));
-    $this->assertTrue(is_file($this->phpfile->uri), t("The PHP file we're going to upload exists."));
+    $this->assertTrue(is_file($this->phpfile->uri), "The PHP file we're going to upload exists.");
 
     $this->maxFidBefore = db_query('SELECT MAX(fid) AS fid FROM {file_managed}')->fetchField();
 
@@ -612,8 +612,8 @@ class FileSaveUploadTest extends FileHookTestCase {
       'files[file_test_upload]' => drupal_realpath($this->image->uri),
     );
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called then clean out the hook
     // counters.
@@ -626,9 +626,9 @@ class FileSaveUploadTest extends FileHookTestCase {
    */
   function testNormal() {
     $max_fid_after = db_query('SELECT MAX(fid) AS fid FROM {file_managed}')->fetchField();
-    $this->assertTrue($max_fid_after > $this->maxFidBefore, t('A new file was created.'));
+    $this->assertTrue($max_fid_after > $this->maxFidBefore, 'A new file was created.');
     $file1 = file_load($max_fid_after);
-    $this->assertTrue($file1, t('Loaded the file.'));
+    $this->assertTrue($file1, 'Loaded the file.');
     // MIME type of the uploaded image may be either image/jpeg or image/png.
     $this->assertEqual(substr($file1->filemime, 0, 5), 'image', 'A MIME type was set.');
 
@@ -640,7 +640,7 @@ class FileSaveUploadTest extends FileHookTestCase {
     $image2 = current($this->drupalGetTestFiles('image'));
     $edit = array('files[file_test_upload]' => drupal_realpath($image2->uri));
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
     $this->assertRaw(t('You WIN!'));
     $max_fid_after = db_query('SELECT MAX(fid) AS fid FROM {file_managed}')->fetchField();
 
@@ -654,8 +654,8 @@ class FileSaveUploadTest extends FileHookTestCase {
 
     // Load both files using file_load_multiple().
     $files = file_load_multiple(array($file1->fid, $file2->fid));
-    $this->assertTrue(isset($files[$file1->fid]), t('File was loaded successfully'));
-    $this->assertTrue(isset($files[$file2->fid]), t('File was loaded successfully'));
+    $this->assertTrue(isset($files[$file1->fid]), 'File was loaded successfully');
+    $this->assertTrue(isset($files[$file2->fid]), 'File was loaded successfully');
 
     // Upload a third file to a subdirectory.
     $image3 = current($this->drupalGetTestFiles('image'));
@@ -666,12 +666,12 @@ class FileSaveUploadTest extends FileHookTestCase {
       'file_subdir' => $dir,
     );
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
     $this->assertRaw(t('You WIN!'));
     $this->assertTrue(is_file('temporary://' . $dir . '/' . trim(drupal_basename($image3_realpath))));
 
     // Check that file_load_multiple() with no arguments returns FALSE.
-    $this->assertFalse(file_load_multiple(), t('No files were loaded.'));
+    $this->assertFalse(file_load_multiple(), 'No files were loaded.');
   }
 
   /**
@@ -690,10 +690,10 @@ class FileSaveUploadTest extends FileHookTestCase {
     );
 
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
     $message = t('Only files with the following extensions are allowed:') . ' <em class="placeholder">' . $extensions . '</em>';
-    $this->assertRaw($message, t('Can\'t upload a disallowed extension'));
-    $this->assertRaw(t('Epic upload FAIL!'), t('Found the failure message.'));
+    $this->assertRaw($message, 'Cannot upload a disallowed extension');
+    $this->assertRaw(t('Epic upload FAIL!'), 'Found the failure message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate'));
@@ -710,9 +710,9 @@ class FileSaveUploadTest extends FileHookTestCase {
     );
 
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertNoRaw(t('Only files with the following extensions are allowed:'), t('Can upload an allowed extension.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertNoRaw(t('Only files with the following extensions are allowed:'), 'Can upload an allowed extension.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'load', 'update'));
@@ -727,9 +727,9 @@ class FileSaveUploadTest extends FileHookTestCase {
       'allow_all_extensions' => TRUE,
     );
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertNoRaw(t('Only files with the following extensions are allowed:'), t('Can upload any extension.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertNoRaw(t('Only files with the following extensions are allowed:'), 'Can upload any extension.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'load', 'update'));
@@ -749,11 +749,11 @@ class FileSaveUploadTest extends FileHookTestCase {
     );
 
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
     $message = t('For security reasons, your upload has been renamed to') . ' <em class="placeholder">' . $this->phpfile->filename . '.txt' . '</em>';
-    $this->assertRaw($message, t('Dangerous file was renamed.'));
-    $this->assertRaw(t('File MIME type is text/plain.'), t('Dangerous file\'s MIME type was changed.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertRaw($message, 'Dangerous file was renamed.');
+    $this->assertRaw(t('File MIME type is text/plain.'), "Dangerous file's MIME type was changed.");
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'insert'));
@@ -765,10 +765,10 @@ class FileSaveUploadTest extends FileHookTestCase {
     file_test_reset();
 
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertNoRaw(t('For security reasons, your upload has been renamed'), t('Found no security message.'));
-    $this->assertRaw(t('File name is !filename', array('!filename' => $this->phpfile->filename)), t('Dangerous file was not renamed when insecure uploads is TRUE.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertNoRaw(t('For security reasons, your upload has been renamed'), 'Found no security message.');
+    $this->assertRaw(t('File name is !filename', array('!filename' => $this->phpfile->filename)), 'Dangerous file was not renamed when insecure uploads is TRUE.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'insert'));
@@ -799,10 +799,10 @@ class FileSaveUploadTest extends FileHookTestCase {
     $munged_filename .= '_.' . $this->image_extension;
 
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertRaw(t('For security reasons, your upload has been renamed'), t('Found security message.'));
-    $this->assertRaw(t('File name is !filename', array('!filename' => $munged_filename)), t('File was successfully munged.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertRaw(t('For security reasons, your upload has been renamed'), 'Found security message.');
+    $this->assertRaw(t('File name is !filename', array('!filename' => $munged_filename)), 'File was successfully munged.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'insert'));
@@ -817,10 +817,10 @@ class FileSaveUploadTest extends FileHookTestCase {
     );
 
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertNoRaw(t('For security reasons, your upload has been renamed'), t('Found no security message.'));
-    $this->assertRaw(t('File name is !filename', array('!filename' => $this->image->filename)), t('File was not munged when allowing any extension.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertNoRaw(t('For security reasons, your upload has been renamed'), 'Found no security message.');
+    $this->assertRaw(t('File name is !filename', array('!filename' => $this->image->filename)), 'File was not munged when allowing any extension.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'insert'));
@@ -835,8 +835,8 @@ class FileSaveUploadTest extends FileHookTestCase {
       'files[file_test_upload]' => drupal_realpath($this->image->uri)
     );
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'insert'));
@@ -851,8 +851,8 @@ class FileSaveUploadTest extends FileHookTestCase {
       'files[file_test_upload]' => drupal_realpath($this->image->uri)
     );
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('validate', 'load', 'update'));
@@ -867,8 +867,8 @@ class FileSaveUploadTest extends FileHookTestCase {
       'files[file_test_upload]' => drupal_realpath($this->image->uri)
     );
     $this->drupalPost('file-test/upload', $edit, t('Submit'));
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertRaw(t('Epic upload FAIL!'), t('Found the failure message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertRaw(t('Epic upload FAIL!'), 'Found the failure message.');
 
     // Check that the no hooks were called while failing.
     $this->assertFileHooksCalled(array());
@@ -879,7 +879,7 @@ class FileSaveUploadTest extends FileHookTestCase {
    */
   function testNoUpload() {
     $this->drupalPost('file-test/upload', array(), t('Submit'));
-    $this->assertNoRaw(t('Epic upload FAIL!'), t('Failure message not found.'));
+    $this->assertNoRaw(t('Epic upload FAIL!'), 'Failure message not found.');
   }
 }
 
@@ -917,16 +917,16 @@ class FileDirectoryTest extends FileTestCase {
   function testFileCheckDirectoryHandling() {
     // A directory to operate on.
     $directory = file_default_scheme() . '://' . $this->randomName() . '/' . $this->randomName();
-    $this->assertFalse(is_dir($directory), t('Directory does not exist prior to testing.'));
+    $this->assertFalse(is_dir($directory), 'Directory does not exist prior to testing.');
 
     // Non-existent directory.
-    $this->assertFalse(file_prepare_directory($directory, 0), t('Error reported for non-existing directory.'), 'File');
+    $this->assertFalse(file_prepare_directory($directory, 0), 'Error reported for non-existing directory.', 'File');
 
     // Make a directory.
-    $this->assertTrue(file_prepare_directory($directory, FILE_CREATE_DIRECTORY), t('No error reported when creating a new directory.'), 'File');
+    $this->assertTrue(file_prepare_directory($directory, FILE_CREATE_DIRECTORY), 'No error reported when creating a new directory.', 'File');
 
     // Make sure directory actually exists.
-    $this->assertTrue(is_dir($directory), t('Directory actually exists.'), 'File');
+    $this->assertTrue(is_dir($directory), 'Directory actually exists.', 'File');
 
     if (substr(PHP_OS, 0, 3) != 'WIN') {
       // PHP on Windows doesn't support any kind of useful read-only mode for
@@ -936,10 +936,10 @@ class FileDirectoryTest extends FileTestCase {
 
       // Make directory read only.
       @drupal_chmod($directory, 0444);
-      $this->assertFalse(file_prepare_directory($directory, 0), t('Error reported for a non-writeable directory.'), 'File');
+      $this->assertFalse(file_prepare_directory($directory, 0), 'Error reported for a non-writeable directory.', 'File');
 
       // Test directory permission modification.
-      $this->assertTrue(file_prepare_directory($directory, FILE_MODIFY_PERMISSIONS), t('No error reported when making directory writeable.'), 'File');
+      $this->assertTrue(file_prepare_directory($directory, FILE_MODIFY_PERMISSIONS), 'No error reported when making directory writeable.', 'File');
     }
 
     // Test that the directory has the correct permissions.
@@ -947,12 +947,12 @@ class FileDirectoryTest extends FileTestCase {
 
     // Remove .htaccess file to then test that it gets re-created.
     @drupal_unlink(file_default_scheme() . '://.htaccess');
-    $this->assertFalse(is_file(file_default_scheme() . '://.htaccess'), t('Successfully removed the .htaccess file in the files directory.'), 'File');
+    $this->assertFalse(is_file(file_default_scheme() . '://.htaccess'), 'Successfully removed the .htaccess file in the files directory.', 'File');
     file_ensure_htaccess();
-    $this->assertTrue(is_file(file_default_scheme() . '://.htaccess'), t('Successfully re-created the .htaccess file in the files directory.'), 'File');
+    $this->assertTrue(is_file(file_default_scheme() . '://.htaccess'), 'Successfully re-created the .htaccess file in the files directory.', 'File');
     // Verify contents of .htaccess file.
     $file = file_get_contents(file_default_scheme() . '://.htaccess');
-    $this->assertEqual($file, "SetHandler Drupal_Security_Do_Not_Remove_See_SA_2006_006\nOptions None\nOptions +FollowSymLinks", t('The .htaccess file contains the proper content.'), 'File');
+    $this->assertEqual($file, "SetHandler Drupal_Security_Do_Not_Remove_See_SA_2006_006\nOptions None\nOptions +FollowSymLinks", 'The .htaccess file contains the proper content.', 'File');
   }
 
   /**
@@ -966,14 +966,14 @@ class FileDirectoryTest extends FileTestCase {
     $directory = 'misc';
     $original = $directory . '/' . $basename;
     $path = file_create_filename($basename, $directory);
-    $this->assertEqual($path, $original, t('New filepath %new equals %original.', array('%new' => $path, '%original' => $original)), 'File');
+    $this->assertEqual($path, $original, format_string('New filepath %new equals %original.', array('%new' => $path, '%original' => $original)), 'File');
 
     // Then we test against a file that already exists within that directory.
     $basename = 'druplicon.png';
     $original = $directory . '/' . $basename;
     $expected = $directory . '/druplicon_0.png';
     $path = file_create_filename($basename, $directory);
-    $this->assertEqual($path, $expected, t('Creating a new filepath from %original equals %new.', array('%new' => $path, '%original' => $original)), 'File');
+    $this->assertEqual($path, $expected, format_string('Creating a new filepath from %original equals %new.', array('%new' => $path, '%original' => $original)), 'File');
 
     // @TODO: Finally we copy a file into a directory several times, to ensure a properly iterating filename suffix.
   }
@@ -994,19 +994,19 @@ class FileDirectoryTest extends FileTestCase {
     // First test for non-existent file.
     $destination = 'misc/xyz.txt';
     $path = file_destination($destination, FILE_EXISTS_REPLACE);
-    $this->assertEqual($path, $destination, t('Non-existing filepath destination is correct with FILE_EXISTS_REPLACE.'), 'File');
+    $this->assertEqual($path, $destination, 'Non-existing filepath destination is correct with FILE_EXISTS_REPLACE.', 'File');
     $path = file_destination($destination, FILE_EXISTS_RENAME);
-    $this->assertEqual($path, $destination, t('Non-existing filepath destination is correct with FILE_EXISTS_RENAME.'), 'File');
+    $this->assertEqual($path, $destination, 'Non-existing filepath destination is correct with FILE_EXISTS_RENAME.', 'File');
     $path = file_destination($destination, FILE_EXISTS_ERROR);
-    $this->assertEqual($path, $destination, t('Non-existing filepath destination is correct with FILE_EXISTS_ERROR.'), 'File');
+    $this->assertEqual($path, $destination, 'Non-existing filepath destination is correct with FILE_EXISTS_ERROR.', 'File');
 
     $destination = 'misc/druplicon.png';
     $path = file_destination($destination, FILE_EXISTS_REPLACE);
-    $this->assertEqual($path, $destination, t('Existing filepath destination remains the same with FILE_EXISTS_REPLACE.'), 'File');
+    $this->assertEqual($path, $destination, 'Existing filepath destination remains the same with FILE_EXISTS_REPLACE.', 'File');
     $path = file_destination($destination, FILE_EXISTS_RENAME);
-    $this->assertNotEqual($path, $destination, t('A new filepath destination is created when filepath destination already exists with FILE_EXISTS_RENAME.'), 'File');
+    $this->assertNotEqual($path, $destination, 'A new filepath destination is created when filepath destination already exists with FILE_EXISTS_RENAME.', 'File');
     $path = file_destination($destination, FILE_EXISTS_ERROR);
-    $this->assertEqual($path, FALSE, t('An error is returned when filepath destination already exists with FILE_EXISTS_ERROR.'), 'File');
+    $this->assertEqual($path, FALSE, 'An error is returned when filepath destination already exists with FILE_EXISTS_ERROR.', 'File');
   }
 
   /**
@@ -1016,9 +1016,9 @@ class FileDirectoryTest extends FileTestCase {
     // Start with an empty variable to ensure we have a clean slate.
     variable_set('file_temporary_path', '');
     $tmp_directory = file_directory_temp();
-    $this->assertEqual(empty($tmp_directory), FALSE, t('file_directory_temp() returned a non-empty value.'));
+    $this->assertEqual(empty($tmp_directory), FALSE, 'file_directory_temp() returned a non-empty value.');
     $setting = variable_get('file_temporary_path', '');
-    $this->assertEqual($setting, $tmp_directory, t("The 'file_temporary_path' variable has the same value that file_directory_temp() returned."));
+    $this->assertEqual($setting, $tmp_directory, "The 'file_temporary_path' variable has the same value that file_directory_temp() returned.");
   }
 }
 
@@ -1063,21 +1063,21 @@ class FileScanDirectoryTest extends FileTestCase {
     // passed to the callback.
     $all_files = file_scan_directory($this->path, '/^javascript-/');
     ksort($all_files);
-    $this->assertEqual(2, count($all_files), t('Found two, expected javascript files.'));
+    $this->assertEqual(2, count($all_files), 'Found two, expected javascript files.');
 
     // Check the first file.
     $file = reset($all_files);
-    $this->assertEqual(key($all_files), $file->uri, t('Correct array key was used for the first returned file.'));
-    $this->assertEqual($file->uri, $this->path . '/javascript-1.txt', t('First file name was set correctly.'));
-    $this->assertEqual($file->filename, 'javascript-1.txt', t('First basename was set correctly'));
-    $this->assertEqual($file->name, 'javascript-1', t('First name was set correctly.'));
+    $this->assertEqual(key($all_files), $file->uri, 'Correct array key was used for the first returned file.');
+    $this->assertEqual($file->uri, $this->path . '/javascript-1.txt', 'First file name was set correctly.');
+    $this->assertEqual($file->filename, 'javascript-1.txt', 'First basename was set correctly');
+    $this->assertEqual($file->name, 'javascript-1', 'First name was set correctly.');
 
     // Check the second file.
     $file = next($all_files);
-    $this->assertEqual(key($all_files), $file->uri, t('Correct array key was used for the second returned file.'));
-    $this->assertEqual($file->uri, $this->path . '/javascript-2.script', t('Second file name was set correctly.'));
-    $this->assertEqual($file->filename, 'javascript-2.script', t('Second basename was set correctly'));
-    $this->assertEqual($file->name, 'javascript-2', t('Second name was set correctly.'));
+    $this->assertEqual(key($all_files), $file->uri, 'Correct array key was used for the second returned file.');
+    $this->assertEqual($file->uri, $this->path . '/javascript-2.script', 'Second file name was set correctly.');
+    $this->assertEqual($file->filename, 'javascript-2.script', 'Second basename was set correctly');
+    $this->assertEqual($file->name, 'javascript-2', 'Second name was set correctly.');
   }
 
   /**
@@ -1086,18 +1086,18 @@ class FileScanDirectoryTest extends FileTestCase {
   function testOptionCallback() {
     // When nothing is matched nothing should be passed to the callback.
     $all_files = file_scan_directory($this->path, '/^NONEXISTINGFILENAME/', array('callback' => 'file_test_file_scan_callback'));
-    $this->assertEqual(0, count($all_files), t('No files were found.'));
+    $this->assertEqual(0, count($all_files), 'No files were found.');
     $results = file_test_file_scan_callback();
     file_test_file_scan_callback_reset();
-    $this->assertEqual(0, count($results), t('No files were passed to the callback.'));
+    $this->assertEqual(0, count($results), 'No files were passed to the callback.');
 
     // Grab a listing of all the JavaSscript files and check that they're
     // passed to the callback.
     $all_files = file_scan_directory($this->path, '/^javascript-/', array('callback' => 'file_test_file_scan_callback'));
-    $this->assertEqual(2, count($all_files), t('Found two, expected javascript files.'));
+    $this->assertEqual(2, count($all_files), 'Found two, expected javascript files.');
     $results = file_test_file_scan_callback();
     file_test_file_scan_callback_reset();
-    $this->assertEqual(2, count($results), t('Files were passed to the callback.'));
+    $this->assertEqual(2, count($results), 'Files were passed to the callback.');
   }
 
   /**
@@ -1106,11 +1106,11 @@ class FileScanDirectoryTest extends FileTestCase {
   function testOptionNoMask() {
     // Grab a listing of all the JavaSscript files.
     $all_files = file_scan_directory($this->path, '/^javascript-/');
-    $this->assertEqual(2, count($all_files), t('Found two, expected javascript files.'));
+    $this->assertEqual(2, count($all_files), 'Found two, expected javascript files.');
 
     // Now use the nomast parameter to filter out the .script file.
     $filtered_files = file_scan_directory($this->path, '/^javascript-/', array('nomask' => '/.script$/'));
-    $this->assertEqual(1, count($filtered_files), t('Filtered correctly.'));
+    $this->assertEqual(1, count($filtered_files), 'Filtered correctly.');
   }
 
   /**
@@ -1121,25 +1121,25 @@ class FileScanDirectoryTest extends FileTestCase {
     $expected = array($this->path . '/javascript-1.txt', $this->path . '/javascript-2.script');
     $actual = array_keys(file_scan_directory($this->path, '/^javascript-/', array('key' => 'filepath')));
     sort($actual);
-    $this->assertEqual($expected, $actual, t('Returned the correct values for the filename key.'));
+    $this->assertEqual($expected, $actual, 'Returned the correct values for the filename key.');
 
     // "basename", for the basename of the file.
     $expected = array('javascript-1.txt', 'javascript-2.script');
     $actual = array_keys(file_scan_directory($this->path, '/^javascript-/', array('key' => 'filename')));
     sort($actual);
-    $this->assertEqual($expected, $actual, t('Returned the correct values for the basename key.'));
+    $this->assertEqual($expected, $actual, 'Returned the correct values for the basename key.');
 
     // "name" for the name of the file without an extension.
     $expected = array('javascript-1', 'javascript-2');
     $actual = array_keys(file_scan_directory($this->path, '/^javascript-/', array('key' => 'name')));
     sort($actual);
-    $this->assertEqual($expected, $actual, t('Returned the correct values for the name key.'));
+    $this->assertEqual($expected, $actual, 'Returned the correct values for the name key.');
 
     // Invalid option that should default back to "filename".
     $expected = array($this->path . '/javascript-1.txt', $this->path . '/javascript-2.script');
     $actual = array_keys(file_scan_directory($this->path, '/^javascript-/', array('key' => 'INVALID')));
     sort($actual);
-    $this->assertEqual($expected, $actual, t('An invalid key defaulted back to the default.'));
+    $this->assertEqual($expected, $actual, 'An invalid key defaulted back to the default.');
   }
 
   /**
@@ -1147,10 +1147,10 @@ class FileScanDirectoryTest extends FileTestCase {
    */
   function testOptionRecurse() {
     $files = file_scan_directory(drupal_get_path('module', 'simpletest'), '/^javascript-/', array('recurse' => FALSE));
-    $this->assertTrue(empty($files), t("Without recursion couldn't find javascript files."));
+    $this->assertTrue(empty($files), "Without recursion couldn't find javascript files.");
 
     $files = file_scan_directory(drupal_get_path('module', 'simpletest'), '/^javascript-/', array('recurse' => TRUE));
-    $this->assertEqual(2, count($files), t('With recursion we found the expected javascript files.'));
+    $this->assertEqual(2, count($files), 'With recursion we found the expected javascript files.');
   }
 
 
@@ -1160,10 +1160,10 @@ class FileScanDirectoryTest extends FileTestCase {
    */
   function testOptionMinDepth() {
     $files = file_scan_directory($this->path, '/^javascript-/', array('min_depth' => 0));
-    $this->assertEqual(2, count($files), t('No minimum-depth gets files in current directory.'));
+    $this->assertEqual(2, count($files), 'No minimum-depth gets files in current directory.');
 
     $files = file_scan_directory($this->path, '/^javascript-/', array('min_depth' => 1));
-    $this->assertTrue(empty($files), t("Minimum-depth of 1 successfully excludes files from current directory."));
+    $this->assertTrue(empty($files), "Minimum-depth of 1 successfully excludes files from current directory.");
   }
 }
 
@@ -1203,8 +1203,8 @@ class FileUnmanagedDeleteTest extends FileTestCase {
     $file = $this->createFile();
 
     // Delete a regular file
-    $this->assertTrue(file_unmanaged_delete($file->uri), t('Deleted worked.'));
-    $this->assertFalse(file_exists($file->uri), t('Test file has actually been deleted.'));
+    $this->assertTrue(file_unmanaged_delete($file->uri), 'Deleted worked.');
+    $this->assertFalse(file_exists($file->uri), 'Test file has actually been deleted.');
   }
 
   /**
@@ -1212,7 +1212,7 @@ class FileUnmanagedDeleteTest extends FileTestCase {
    */
   function testMissing() {
     // Try to delete a non-existing file
-    $this->assertTrue(file_unmanaged_delete(file_default_scheme() . '/' . $this->randomName()), t('Returns true when deleting a non-existent file.'));
+    $this->assertTrue(file_unmanaged_delete(file_default_scheme() . '/' . $this->randomName()), 'Returns true when deleting a non-existent file.');
   }
 
   /**
@@ -1223,8 +1223,8 @@ class FileUnmanagedDeleteTest extends FileTestCase {
     $directory = $this->createDirectory();
 
     // Try to delete a directory
-    $this->assertFalse(file_unmanaged_delete($directory), t('Could not delete the delete directory.'));
-    $this->assertTrue(file_exists($directory), t('Directory has not been deleted.'));
+    $this->assertFalse(file_unmanaged_delete($directory), 'Could not delete the delete directory.');
+    $this->assertTrue(file_exists($directory), 'Directory has not been deleted.');
   }
 }
 
@@ -1265,8 +1265,8 @@ class FileUnmanagedDeleteRecursiveTest extends FileTestCase {
     file_put_contents($filepath, '');
 
     // Delete the file.
-    $this->assertTrue(file_unmanaged_delete_recursive($filepath), t('Function reported success.'));
-    $this->assertFalse(file_exists($filepath), t('Test file has been deleted.'));
+    $this->assertTrue(file_unmanaged_delete_recursive($filepath), 'Function reported success.');
+    $this->assertFalse(file_exists($filepath), 'Test file has been deleted.');
   }
 
   /**
@@ -1277,8 +1277,8 @@ class FileUnmanagedDeleteRecursiveTest extends FileTestCase {
     $directory = $this->createDirectory();
 
     // Delete the directory.
-    $this->assertTrue(file_unmanaged_delete_recursive($directory), t('Function reported success.'));
-    $this->assertFalse(file_exists($directory), t('Directory has been deleted.'));
+    $this->assertTrue(file_unmanaged_delete_recursive($directory), 'Function reported success.');
+    $this->assertFalse(file_exists($directory), 'Directory has been deleted.');
   }
 
   /**
@@ -1293,10 +1293,10 @@ class FileUnmanagedDeleteRecursiveTest extends FileTestCase {
     file_put_contents($filepathB, '');
 
     // Delete the directory.
-    $this->assertTrue(file_unmanaged_delete_recursive($directory), t('Function reported success.'));
-    $this->assertFalse(file_exists($filepathA), t('Test file A has been deleted.'));
-    $this->assertFalse(file_exists($filepathB), t('Test file B has been deleted.'));
-    $this->assertFalse(file_exists($directory), t('Directory has been deleted.'));
+    $this->assertTrue(file_unmanaged_delete_recursive($directory), 'Function reported success.');
+    $this->assertFalse(file_exists($filepathA), 'Test file A has been deleted.');
+    $this->assertFalse(file_exists($filepathB), 'Test file B has been deleted.');
+    $this->assertFalse(file_exists($directory), 'Directory has been deleted.');
   }
 
   /**
@@ -1312,11 +1312,11 @@ class FileUnmanagedDeleteRecursiveTest extends FileTestCase {
     file_put_contents($filepathB, '');
 
     // Delete the directory.
-    $this->assertTrue(file_unmanaged_delete_recursive($directory), t('Function reported success.'));
-    $this->assertFalse(file_exists($filepathA), t('Test file A has been deleted.'));
-    $this->assertFalse(file_exists($filepathB), t('Test file B has been deleted.'));
-    $this->assertFalse(file_exists($subdirectory), t('Subdirectory has been deleted.'));
-    $this->assertFalse(file_exists($directory), t('Directory has been deleted.'));
+    $this->assertTrue(file_unmanaged_delete_recursive($directory), 'Function reported success.');
+    $this->assertFalse(file_exists($filepathA), 'Test file A has been deleted.');
+    $this->assertFalse(file_exists($filepathB), 'Test file B has been deleted.');
+    $this->assertFalse(file_exists($subdirectory), 'Subdirectory has been deleted.');
+    $this->assertFalse(file_exists($directory), 'Directory has been deleted.');
   }
 }
 
@@ -1358,21 +1358,21 @@ class FileUnmanagedMoveTest extends FileTestCase {
     // Moving to a new name.
     $desired_filepath = 'public://' . $this->randomName();
     $new_filepath = file_unmanaged_move($file->uri, $desired_filepath, FILE_EXISTS_ERROR);
-    $this->assertTrue($new_filepath, t('Move was successful.'));
-    $this->assertEqual($new_filepath, $desired_filepath, t('Returned expected filepath.'));
-    $this->assertTrue(file_exists($new_filepath), t('File exists at the new location.'));
-    $this->assertFalse(file_exists($file->uri), t('No file remains at the old location.'));
+    $this->assertTrue($new_filepath, 'Move was successful.');
+    $this->assertEqual($new_filepath, $desired_filepath, 'Returned expected filepath.');
+    $this->assertTrue(file_exists($new_filepath), 'File exists at the new location.');
+    $this->assertFalse(file_exists($file->uri), 'No file remains at the old location.');
     $this->assertFilePermissions($new_filepath, variable_get('file_chmod_file', 0664));
 
     // Moving with rename.
     $desired_filepath = 'public://' . $this->randomName();
-    $this->assertTrue(file_exists($new_filepath), t('File exists before moving.'));
-    $this->assertTrue(file_put_contents($desired_filepath, ' '), t('Created a file so a rename will have to happen.'));
+    $this->assertTrue(file_exists($new_filepath), 'File exists before moving.');
+    $this->assertTrue(file_put_contents($desired_filepath, ' '), 'Created a file so a rename will have to happen.');
     $newer_filepath = file_unmanaged_move($new_filepath, $desired_filepath, FILE_EXISTS_RENAME);
-    $this->assertTrue($newer_filepath, t('Move was successful.'));
-    $this->assertNotEqual($newer_filepath, $desired_filepath, t('Returned expected filepath.'));
-    $this->assertTrue(file_exists($newer_filepath), t('File exists at the new location.'));
-    $this->assertFalse(file_exists($new_filepath), t('No file remains at the old location.'));
+    $this->assertTrue($newer_filepath, 'Move was successful.');
+    $this->assertNotEqual($newer_filepath, $desired_filepath, 'Returned expected filepath.');
+    $this->assertTrue(file_exists($newer_filepath), 'File exists at the new location.');
+    $this->assertFalse(file_exists($new_filepath), 'No file remains at the old location.');
     $this->assertFilePermissions($newer_filepath, variable_get('file_chmod_file', 0664));
 
     // TODO: test moving to a directory (rather than full directory/file path)
@@ -1385,7 +1385,7 @@ class FileUnmanagedMoveTest extends FileTestCase {
   function testMissing() {
     // Move non-existent file.
     $new_filepath = file_unmanaged_move($this->randomName(), $this->randomName());
-    $this->assertFalse($new_filepath, t('Moving a missing file fails.'));
+    $this->assertFalse($new_filepath, 'Moving a missing file fails.');
   }
 
   /**
@@ -1397,14 +1397,14 @@ class FileUnmanagedMoveTest extends FileTestCase {
 
     // Move the file onto itself without renaming shouldn't make changes.
     $new_filepath = file_unmanaged_move($file->uri, $file->uri, FILE_EXISTS_REPLACE);
-    $this->assertFalse($new_filepath, t('Moving onto itself without renaming fails.'));
-    $this->assertTrue(file_exists($file->uri), t('File exists after moving onto itself.'));
+    $this->assertFalse($new_filepath, 'Moving onto itself without renaming fails.');
+    $this->assertTrue(file_exists($file->uri), 'File exists after moving onto itself.');
 
     // Move the file onto itself with renaming will result in a new filename.
     $new_filepath = file_unmanaged_move($file->uri, $file->uri, FILE_EXISTS_RENAME);
-    $this->assertTrue($new_filepath, t('Moving onto itself with renaming works.'));
-    $this->assertFalse(file_exists($file->uri), t('Original file has been removed.'));
-    $this->assertTrue(file_exists($new_filepath), t('File exists after moving onto itself.'));
+    $this->assertTrue($new_filepath, 'Moving onto itself with renaming works.');
+    $this->assertFalse(file_exists($file->uri), 'Original file has been removed.');
+    $this->assertTrue(file_exists($new_filepath), 'File exists after moving onto itself.');
   }
 }
 
@@ -1446,20 +1446,20 @@ class FileUnmanagedCopyTest extends FileTestCase {
     // Copying to a new name.
     $desired_filepath = 'public://' . $this->randomName();
     $new_filepath = file_unmanaged_copy($file->uri, $desired_filepath, FILE_EXISTS_ERROR);
-    $this->assertTrue($new_filepath, t('Copy was successful.'));
-    $this->assertEqual($new_filepath, $desired_filepath, t('Returned expected filepath.'));
-    $this->assertTrue(file_exists($file->uri), t('Original file remains.'));
-    $this->assertTrue(file_exists($new_filepath), t('New file exists.'));
+    $this->assertTrue($new_filepath, 'Copy was successful.');
+    $this->assertEqual($new_filepath, $desired_filepath, 'Returned expected filepath.');
+    $this->assertTrue(file_exists($file->uri), 'Original file remains.');
+    $this->assertTrue(file_exists($new_filepath), 'New file exists.');
     $this->assertFilePermissions($new_filepath, variable_get('file_chmod_file', 0664));
 
     // Copying with rename.
     $desired_filepath = 'public://' . $this->randomName();
-    $this->assertTrue(file_put_contents($desired_filepath, ' '), t('Created a file so a rename will have to happen.'));
+    $this->assertTrue(file_put_contents($desired_filepath, ' '), 'Created a file so a rename will have to happen.');
     $newer_filepath = file_unmanaged_copy($file->uri, $desired_filepath, FILE_EXISTS_RENAME);
-    $this->assertTrue($newer_filepath, t('Copy was successful.'));
-    $this->assertNotEqual($newer_filepath, $desired_filepath, t('Returned expected filepath.'));
-    $this->assertTrue(file_exists($file->uri), t('Original file remains.'));
-    $this->assertTrue(file_exists($newer_filepath), t('New file exists.'));
+    $this->assertTrue($newer_filepath, 'Copy was successful.');
+    $this->assertNotEqual($newer_filepath, $desired_filepath, 'Returned expected filepath.');
+    $this->assertTrue(file_exists($file->uri), 'Original file remains.');
+    $this->assertTrue(file_exists($newer_filepath), 'New file exists.');
     $this->assertFilePermissions($newer_filepath, variable_get('file_chmod_file', 0664));
 
     // TODO: test copying to a directory (rather than full directory/file path)
@@ -1472,9 +1472,9 @@ class FileUnmanagedCopyTest extends FileTestCase {
   function testNonExistent() {
     // Copy non-existent file
     $desired_filepath = $this->randomName();
-    $this->assertFalse(file_exists($desired_filepath), t("Randomly named file doesn't exists."));
+    $this->assertFalse(file_exists($desired_filepath), "Randomly named file doesn't exists.");
     $new_filepath = file_unmanaged_copy($desired_filepath, $this->randomName());
-    $this->assertFalse($new_filepath, t('Copying a missing file fails.'));
+    $this->assertFalse($new_filepath, 'Copying a missing file fails.');
   }
 
   /**
@@ -1486,28 +1486,28 @@ class FileUnmanagedCopyTest extends FileTestCase {
 
     // Copy the file onto itself with renaming works.
     $new_filepath = file_unmanaged_copy($file->uri, $file->uri, FILE_EXISTS_RENAME);
-    $this->assertTrue($new_filepath, t('Copying onto itself with renaming works.'));
-    $this->assertNotEqual($new_filepath, $file->uri, t('Copied file has a new name.'));
-    $this->assertTrue(file_exists($file->uri), t('Original file exists after copying onto itself.'));
-    $this->assertTrue(file_exists($new_filepath), t('Copied file exists after copying onto itself.'));
+    $this->assertTrue($new_filepath, 'Copying onto itself with renaming works.');
+    $this->assertNotEqual($new_filepath, $file->uri, 'Copied file has a new name.');
+    $this->assertTrue(file_exists($file->uri), 'Original file exists after copying onto itself.');
+    $this->assertTrue(file_exists($new_filepath), 'Copied file exists after copying onto itself.');
     $this->assertFilePermissions($new_filepath, variable_get('file_chmod_file', 0664));
 
     // Copy the file onto itself without renaming fails.
     $new_filepath = file_unmanaged_copy($file->uri, $file->uri, FILE_EXISTS_ERROR);
-    $this->assertFalse($new_filepath, t('Copying onto itself without renaming fails.'));
-    $this->assertTrue(file_exists($file->uri), t('File exists after copying onto itself.'));
+    $this->assertFalse($new_filepath, 'Copying onto itself without renaming fails.');
+    $this->assertTrue(file_exists($file->uri), 'File exists after copying onto itself.');
 
     // Copy the file into same directory without renaming fails.
     $new_filepath = file_unmanaged_copy($file->uri, drupal_dirname($file->uri), FILE_EXISTS_ERROR);
-    $this->assertFalse($new_filepath, t('Copying onto itself fails.'));
-    $this->assertTrue(file_exists($file->uri), t('File exists after copying onto itself.'));
+    $this->assertFalse($new_filepath, 'Copying onto itself fails.');
+    $this->assertTrue(file_exists($file->uri), 'File exists after copying onto itself.');
 
     // Copy the file into same directory with renaming works.
     $new_filepath = file_unmanaged_copy($file->uri, drupal_dirname($file->uri), FILE_EXISTS_RENAME);
-    $this->assertTrue($new_filepath, t('Copying into same directory works.'));
-    $this->assertNotEqual($new_filepath, $file->uri, t('Copied file has a new name.'));
-    $this->assertTrue(file_exists($file->uri), t('Original file exists after copying onto itself.'));
-    $this->assertTrue(file_exists($new_filepath), t('Copied file exists after copying onto itself.'));
+    $this->assertTrue($new_filepath, 'Copying into same directory works.');
+    $this->assertNotEqual($new_filepath, $file->uri, 'Copied file has a new name.');
+    $this->assertTrue(file_exists($file->uri), 'Original file exists after copying onto itself.');
+    $this->assertTrue(file_exists($new_filepath), 'Copied file exists after copying onto itself.');
     $this->assertFilePermissions($new_filepath, variable_get('file_chmod_file', 0664));
   }
 }
@@ -1547,11 +1547,11 @@ class FileDeleteTest extends FileHookTestCase {
     $file = $this->createFile();
 
     // Check that deletion removes the file and database record.
-    $this->assertTrue(is_file($file->uri), t('File exists.'));
-    $this->assertIdentical(file_delete($file), TRUE, t('Delete worked.'));
+    $this->assertTrue(is_file($file->uri), 'File exists.');
+    $this->assertIdentical(file_delete($file), TRUE, 'Delete worked.');
     $this->assertFileHooksCalled(array('delete'));
-    $this->assertFalse(file_exists($file->uri), t('Test file has actually been deleted.'));
-    $this->assertFalse(file_load($file->fid), t('File was removed from the database.'));
+    $this->assertFalse(file_exists($file->uri), 'Test file has actually been deleted.');
+    $this->assertFalse(file_load($file->fid), 'File was removed from the database.');
   }
 
   /**
@@ -1565,9 +1565,9 @@ class FileDeleteTest extends FileHookTestCase {
     file_usage_delete($file, 'testing', 'test', 1);
     file_delete($file);
     $usage = file_usage_list($file);
-    $this->assertEqual($usage['testing']['test'], array(1 => 1), t('Test file is still in use.'));
-    $this->assertTrue(file_exists($file->uri), t('File still exists on the disk.'));
-    $this->assertTrue(file_load($file->fid), t('File still exists in the database.'));
+    $this->assertEqual($usage['testing']['test'], array(1 => 1), 'Test file is still in use.');
+    $this->assertTrue(file_exists($file->uri), 'File still exists on the disk.');
+    $this->assertTrue(file_load($file->fid), 'File still exists in the database.');
 
     // Clear out the call to hook_file_load().
     file_test_reset();
@@ -1576,9 +1576,9 @@ class FileDeleteTest extends FileHookTestCase {
     file_delete($file);
     $usage = file_usage_list($file);
     $this->assertFileHooksCalled(array('delete'));
-    $this->assertTrue(empty($usage), t('File usage data was removed.'));
-    $this->assertFalse(file_exists($file->uri), t('File has been deleted after its last usage was removed.'));
-    $this->assertFalse(file_load($file->fid), t('File was removed from the database.'));
+    $this->assertTrue(empty($usage), 'File usage data was removed.');
+    $this->assertFalse(file_exists($file->uri), 'File has been deleted after its last usage was removed.');
+    $this->assertFalse(file_load($file->fid), 'File was removed from the database.');
   }
 }
 
@@ -1608,20 +1608,20 @@ class FileMoveTest extends FileHookTestCase {
     $result = file_move(clone $source, $desired_filepath, FILE_EXISTS_ERROR);
 
     // Check the return status and that the contents changed.
-    $this->assertTrue($result, t('File moved successfully.'));
+    $this->assertTrue($result, 'File moved successfully.');
     $this->assertFalse(file_exists($source->uri));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of file correctly written.'));
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of file correctly written.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('move', 'load', 'update'));
 
     // Make sure we got the same file back.
-    $this->assertEqual($source->fid, $result->fid, t("Source file id's' %fid is unchanged after move.", array('%fid' => $source->fid)));
+    $this->assertEqual($source->fid, $result->fid, format_string("Source file id's' %fid is unchanged after move.", array('%fid' => $source->fid)));
 
     // Reload the file from the database and check that the changes were
     // actually saved.
     $loaded_file = file_load($result->fid, TRUE);
-    $this->assertTrue($loaded_file, t('File can be loaded from the database.'));
+    $this->assertTrue($loaded_file, 'File can be loaded from the database.');
     $this->assertFileUnchanged($result, $loaded_file);
   }
 
@@ -1640,9 +1640,9 @@ class FileMoveTest extends FileHookTestCase {
     $result = file_move(clone $source, $target->uri, FILE_EXISTS_RENAME);
 
     // Check the return status and that the contents changed.
-    $this->assertTrue($result, t('File moved successfully.'));
+    $this->assertTrue($result, 'File moved successfully.');
     $this->assertFalse(file_exists($source->uri));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of file correctly written.'));
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of file correctly written.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('move', 'load', 'update'));
@@ -1656,8 +1656,8 @@ class FileMoveTest extends FileHookTestCase {
 
     // Compare the source and results.
     $loaded_source = file_load($source->fid, TRUE);
-    $this->assertEqual($loaded_source->fid, $result->fid, t("Returned file's id matches the source."));
-    $this->assertNotEqual($loaded_source->uri, $source->uri, t("Returned file path has changed from the original."));
+    $this->assertEqual($loaded_source->fid, $result->fid, "Returned file's id matches the source.");
+    $this->assertNotEqual($loaded_source->uri, $source->uri, 'Returned file path has changed from the original.');
   }
 
   /**
@@ -1675,9 +1675,9 @@ class FileMoveTest extends FileHookTestCase {
     $result = file_move(clone $source, $target->uri, FILE_EXISTS_REPLACE);
 
     // Look at the results.
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of file were overwritten.'));
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of file were overwritten.');
     $this->assertFalse(file_exists($source->uri));
-    $this->assertTrue($result, t('File moved successfully.'));
+    $this->assertTrue($result, 'File moved successfully.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('move', 'update', 'delete', 'load'));
@@ -1703,8 +1703,8 @@ class FileMoveTest extends FileHookTestCase {
     // Copy the file over itself. Clone the object so we don't have to worry
     // about the function changing our reference copy.
     $result = file_move(clone $source, $source->uri, FILE_EXISTS_REPLACE);
-    $this->assertFalse($result, t('File move failed.'));
-    $this->assertEqual($contents, file_get_contents($source->uri), t('Contents of file were not altered.'));
+    $this->assertFalse($result, 'File move failed.');
+    $this->assertEqual($contents, file_get_contents($source->uri), 'Contents of file were not altered.');
 
     // Check that no hooks were called while failing.
     $this->assertFileHooksCalled(array());
@@ -1729,9 +1729,9 @@ class FileMoveTest extends FileHookTestCase {
     $result = file_move(clone $source, $target->uri, FILE_EXISTS_ERROR);
 
     // Check the return status and that the contents did not change.
-    $this->assertFalse($result, t('File move failed.'));
+    $this->assertFalse($result, 'File move failed.');
     $this->assertTrue(file_exists($source->uri));
-    $this->assertEqual($contents, file_get_contents($target->uri), t('Contents of file were not altered.'));
+    $this->assertEqual($contents, file_get_contents($target->uri), 'Contents of file were not altered.');
 
     // Check that no hooks were called while failing.
     $this->assertFileHooksCalled(array());
@@ -1769,16 +1769,16 @@ class FileCopyTest extends FileHookTestCase {
     $result = file_copy(clone $source, $desired_uri, FILE_EXISTS_ERROR);
 
     // Check the return status and that the contents changed.
-    $this->assertTrue($result, t('File copied successfully.'));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of file were copied correctly.'));
+    $this->assertTrue($result, 'File copied successfully.');
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of file were copied correctly.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('copy', 'insert'));
 
     $this->assertDifferentFile($source, $result);
-    $this->assertEqual($result->uri, $desired_uri, t('The copied file object has the desired filepath.'));
-    $this->assertTrue(file_exists($source->uri), t('The original file still exists.'));
-    $this->assertTrue(file_exists($result->uri), t('The copied file exists.'));
+    $this->assertEqual($result->uri, $desired_uri, 'The copied file object has the desired filepath.');
+    $this->assertTrue(file_exists($source->uri), 'The original file still exists.');
+    $this->assertTrue(file_exists($result->uri), 'The copied file exists.');
 
     // Reload the file from the database and check that the changes were
     // actually saved.
@@ -1800,9 +1800,9 @@ class FileCopyTest extends FileHookTestCase {
     $result = file_copy(clone $source, $target->uri, FILE_EXISTS_RENAME);
 
     // Check the return status and that the contents changed.
-    $this->assertTrue($result, t('File copied successfully.'));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of file were copied correctly.'));
-    $this->assertNotEqual($result->uri, $source->uri, t('Returned file path has changed from the original.'));
+    $this->assertTrue($result, 'File copied successfully.');
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of file were copied correctly.');
+    $this->assertNotEqual($result->uri, $source->uri, 'Returned file path has changed from the original.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('copy', 'insert'));
@@ -1840,8 +1840,8 @@ class FileCopyTest extends FileHookTestCase {
     $result = file_copy(clone $source, $target->uri, FILE_EXISTS_REPLACE);
 
     // Check the return status and that the contents changed.
-    $this->assertTrue($result, t('File copied successfully.'));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of file were overwritten.'));
+    $this->assertTrue($result, 'File copied successfully.');
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of file were overwritten.');
     $this->assertDifferentFile($source, $result);
 
     // Check that the correct hooks were called.
@@ -1878,8 +1878,8 @@ class FileCopyTest extends FileHookTestCase {
     $result = file_copy(clone $source, $target->uri, FILE_EXISTS_ERROR);
 
     // Check the return status and that the contents were not changed.
-    $this->assertFalse($result, t('File copy failed.'));
-    $this->assertEqual($contents, file_get_contents($target->uri), t('Contents of file were not altered.'));
+    $this->assertFalse($result, 'File copy failed.');
+    $this->assertEqual($contents, file_get_contents($target->uri), 'Contents of file were not altered.');
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array());
@@ -1906,7 +1906,7 @@ class FileLoadTest extends FileHookTestCase {
    * Try to load a non-existent file by fid.
    */
   function testLoadMissingFid() {
-    $this->assertFalse(file_load(-1), t("Try to load an invalid fid fails."));
+    $this->assertFalse(file_load(-1), "Try to load an invalid fid fails.");
     $this->assertFileHooksCalled(array());
   }
 
@@ -1915,7 +1915,7 @@ class FileLoadTest extends FileHookTestCase {
    */
   function testLoadMissingFilepath() {
     $files = file_load_multiple(array(), array('uri' => 'foobar://misc/druplicon.png'));
-    $this->assertFalse(reset($files), t("Try to load a file that doesn't exist in the database fails."));
+    $this->assertFalse(reset($files), "Try to load a file that doesn't exist in the database fails.");
     $this->assertFileHooksCalled(array());
   }
 
@@ -1924,7 +1924,7 @@ class FileLoadTest extends FileHookTestCase {
    */
   function testLoadInvalidStatus() {
     $files = file_load_multiple(array(), array('status' => -99));
-    $this->assertFalse(reset($files), t("Trying to load a file with an invalid status fails."));
+    $this->assertFalse(reset($files), "Trying to load a file with an invalid status fails.");
     $this->assertFileHooksCalled(array());
   }
 
@@ -1937,13 +1937,13 @@ class FileLoadTest extends FileHookTestCase {
 
     $by_fid_file = file_load($file->fid);
     $this->assertFileHookCalled('load');
-    $this->assertTrue(is_object($by_fid_file), t('file_load() returned an object.'));
-    $this->assertEqual($by_fid_file->fid, $file->fid, t("Loading by fid got the same fid."), 'File');
-    $this->assertEqual($by_fid_file->uri, $file->uri, t("Loading by fid got the correct filepath."), 'File');
-    $this->assertEqual($by_fid_file->filename, $file->filename, t("Loading by fid got the correct filename."), 'File');
-    $this->assertEqual($by_fid_file->filemime, $file->filemime, t("Loading by fid got the correct MIME type."), 'File');
-    $this->assertEqual($by_fid_file->status, $file->status, t("Loading by fid got the correct status."), 'File');
-    $this->assertTrue($by_fid_file->file_test['loaded'], t('file_test_file_load() was able to modify the file during load.'));
+    $this->assertTrue(is_object($by_fid_file), 'file_load() returned an object.');
+    $this->assertEqual($by_fid_file->fid, $file->fid, 'Loading by fid got the same fid.', 'File');
+    $this->assertEqual($by_fid_file->uri, $file->uri, 'Loading by fid got the correct filepath.', 'File');
+    $this->assertEqual($by_fid_file->filename, $file->filename, 'Loading by fid got the correct filename.', 'File');
+    $this->assertEqual($by_fid_file->filemime, $file->filemime, 'Loading by fid got the correct MIME type.', 'File');
+    $this->assertEqual($by_fid_file->status, $file->status, 'Loading by fid got the correct status.', 'File');
+    $this->assertTrue($by_fid_file->file_test['loaded'], 'file_test_file_load() was able to modify the file during load.');
   }
 
   /**
@@ -1957,19 +1957,19 @@ class FileLoadTest extends FileHookTestCase {
     file_test_reset();
     $by_path_files = file_load_multiple(array(), array('uri' => $file->uri));
     $this->assertFileHookCalled('load');
-    $this->assertEqual(1, count($by_path_files), t('file_load_multiple() returned an array of the correct size.'));
+    $this->assertEqual(1, count($by_path_files), 'file_load_multiple() returned an array of the correct size.');
     $by_path_file = reset($by_path_files);
-    $this->assertTrue($by_path_file->file_test['loaded'], t('file_test_file_load() was able to modify the file during load.'));
-    $this->assertEqual($by_path_file->fid, $file->fid, t("Loading by filepath got the correct fid."), 'File');
+    $this->assertTrue($by_path_file->file_test['loaded'], 'file_test_file_load() was able to modify the file during load.');
+    $this->assertEqual($by_path_file->fid, $file->fid, 'Loading by filepath got the correct fid.', 'File');
 
     // Load by fid.
     file_test_reset();
     $by_fid_files = file_load_multiple(array($file->fid), array());
     $this->assertFileHookCalled('load');
-    $this->assertEqual(1, count($by_fid_files), t('file_load_multiple() returned an array of the correct size.'));
+    $this->assertEqual(1, count($by_fid_files), 'file_load_multiple() returned an array of the correct size.');
     $by_fid_file = reset($by_fid_files);
-    $this->assertTrue($by_fid_file->file_test['loaded'], t('file_test_file_load() was able to modify the file during load.'));
-    $this->assertEqual($by_fid_file->uri, $file->uri, t("Loading by fid got the correct filepath."), 'File');
+    $this->assertTrue($by_fid_file->file_test['loaded'], 'file_test_file_load() was able to modify the file during load.');
+    $this->assertEqual($by_fid_file->uri, $file->uri, 'Loading by fid got the correct filepath.', 'File');
   }
 }
 
@@ -2004,13 +2004,13 @@ class FileSaveTest extends FileHookTestCase {
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('insert'));
 
-    $this->assertNotNull($saved_file, t("Saving the file should give us back a file object."), 'File');
-    $this->assertTrue($saved_file->fid > 0, t("A new file ID is set when saving a new file to the database."), 'File');
+    $this->assertNotNull($saved_file, 'Saving the file should give us back a file object.', 'File');
+    $this->assertTrue($saved_file->fid > 0, 'A new file ID is set when saving a new file to the database.', 'File');
     $loaded_file = db_query('SELECT * FROM {file_managed} f WHERE f.fid = :fid', array(':fid' => $saved_file->fid))->fetch(PDO::FETCH_OBJ);
-    $this->assertNotNull($loaded_file, t("Record exists in the database."));
-    $this->assertEqual($loaded_file->status, $file->status, t("Status was saved correctly."));
-    $this->assertEqual($saved_file->filesize, filesize($file->uri), t("File size was set correctly."), 'File');
-    $this->assertTrue($saved_file->timestamp > 1, t("File size was set correctly."), 'File');
+    $this->assertNotNull($loaded_file, 'Record exists in the database.');
+    $this->assertEqual($loaded_file->status, $file->status, 'Status was saved correctly.');
+    $this->assertEqual($saved_file->filesize, filesize($file->uri), 'File size was set correctly.', 'File');
+    $this->assertTrue($saved_file->timestamp > 1, 'File size was set correctly.', 'File');
 
 
     // Resave the file, updating the existing record.
@@ -2021,11 +2021,11 @@ class FileSaveTest extends FileHookTestCase {
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('load', 'update'));
 
-    $this->assertEqual($resaved_file->fid, $saved_file->fid, t("The file ID of an existing file is not changed when updating the database."), 'File');
-    $this->assertTrue($resaved_file->timestamp >= $saved_file->timestamp, t("Timestamp didn't go backwards."), 'File');
+    $this->assertEqual($resaved_file->fid, $saved_file->fid, 'The file ID of an existing file is not changed when updating the database.', 'File');
+    $this->assertTrue($resaved_file->timestamp >= $saved_file->timestamp, "Timestamp didn't go backwards.", 'File');
     $loaded_file = db_query('SELECT * FROM {file_managed} f WHERE f.fid = :fid', array(':fid' => $saved_file->fid))->fetch(PDO::FETCH_OBJ);
-    $this->assertNotNull($loaded_file, t("Record still exists in the database."), 'File');
-    $this->assertEqual($loaded_file->status, $saved_file->status, t("Status was saved correctly."));
+    $this->assertNotNull($loaded_file, 'Record still exists in the database.', 'File');
+    $this->assertEqual($loaded_file->status, $saved_file->status, 'Status was saved correctly.');
 
     // Try to insert a second file with the same name apart from case insensitivity
     // to ensure the 'uri' index allows for filenames with different cases.
@@ -2080,11 +2080,11 @@ class FileUsageTest extends FileTestCase {
 
     $usage = file_usage_list($file);
 
-    $this->assertEqual(count($usage['testing']), 2, t('Returned the correct number of items.'));
-    $this->assertTrue(isset($usage['testing']['foo'][1]), t('Returned the correct id.'));
-    $this->assertTrue(isset($usage['testing']['bar'][2]), t('Returned the correct id.'));
-    $this->assertEqual($usage['testing']['foo'][1], 1, t('Returned the correct count.'));
-    $this->assertEqual($usage['testing']['bar'][2], 2, t('Returned the correct count.'));
+    $this->assertEqual(count($usage['testing']), 2, 'Returned the correct number of items.');
+    $this->assertTrue(isset($usage['testing']['foo'][1]), 'Returned the correct id.');
+    $this->assertTrue(isset($usage['testing']['bar'][2]), 'Returned the correct id.');
+    $this->assertEqual($usage['testing']['foo'][1], 1, 'Returned the correct count.');
+    $this->assertEqual($usage['testing']['bar'][2], 2, 'Returned the correct count.');
   }
 
   /**
@@ -2103,13 +2103,13 @@ class FileUsageTest extends FileTestCase {
       ->condition('f.fid', $file->fid)
       ->execute()
       ->fetchAllAssoc('id');
-    $this->assertEqual(count($usage), 2, t('Created two records'));
-    $this->assertEqual($usage[1]->module, 'testing', t('Correct module'));
-    $this->assertEqual($usage[2]->module, 'testing', t('Correct module'));
-    $this->assertEqual($usage[1]->type, 'foo', t('Correct type'));
-    $this->assertEqual($usage[2]->type, 'bar', t('Correct type'));
-    $this->assertEqual($usage[1]->count, 1, t('Correct count'));
-    $this->assertEqual($usage[2]->count, 2, t('Correct count'));
+    $this->assertEqual(count($usage), 2, 'Created two records');
+    $this->assertEqual($usage[1]->module, 'testing', 'Correct module');
+    $this->assertEqual($usage[2]->module, 'testing', 'Correct module');
+    $this->assertEqual($usage[1]->type, 'foo', 'Correct type');
+    $this->assertEqual($usage[2]->type, 'bar', 'Correct type');
+    $this->assertEqual($usage[1]->count, 1, 'Correct count');
+    $this->assertEqual($usage[2]->count, 2, 'Correct count');
   }
 
   /**
@@ -2134,7 +2134,7 @@ class FileUsageTest extends FileTestCase {
       ->condition('f.fid', $file->fid)
       ->execute()
       ->fetchField();
-    $this->assertEqual(2, $count, t('The count was decremented correctly.'));
+    $this->assertEqual(2, $count, 'The count was decremented correctly.');
 
     // Multiple decrement and removal.
     file_usage_delete($file, 'testing', 'bar', 2, 2);
@@ -2143,7 +2143,7 @@ class FileUsageTest extends FileTestCase {
       ->condition('f.fid', $file->fid)
       ->execute()
       ->fetchField();
-    $this->assertIdentical(FALSE, $count, t('The count was removed entirely when empty.'));
+    $this->assertIdentical(FALSE, $count, 'The count was removed entirely when empty.');
 
     // Non-existent decrement.
     file_usage_delete($file, 'testing', 'bar', 2);
@@ -2152,7 +2152,7 @@ class FileUsageTest extends FileTestCase {
       ->condition('f.fid', $file->fid)
       ->execute()
       ->fetchField();
-    $this->assertIdentical(FALSE, $count, t('Decrementing non-exist record complete.'));
+    $this->assertIdentical(FALSE, $count, 'Decrementing non-exist record complete.');
   }
 }
 
@@ -2175,7 +2175,7 @@ class FileValidateTest extends FileHookTestCase {
     $file = $this->createFile();
 
     // Empty validators.
-    $this->assertEqual(file_validate($file, array()), array(), t('Validating an empty array works successfully.'));
+    $this->assertEqual(file_validate($file, array()), array(), 'Validating an empty array works successfully.');
     $this->assertFileHooksCalled(array('validate'));
 
     // Use the file_test.module's test validator to ensure that passing tests
@@ -2183,14 +2183,14 @@ class FileValidateTest extends FileHookTestCase {
     file_test_reset();
     file_test_set_return('validate', array());
     $passing = array('file_test_validator' => array(array()));
-    $this->assertEqual(file_validate($file, $passing), array(), t('Validating passes.'));
+    $this->assertEqual(file_validate($file, $passing), array(), 'Validating passes.');
     $this->assertFileHooksCalled(array('validate'));
 
     // Now test for failures in validators passed in and by hook_validate.
     file_test_reset();
     file_test_set_return('validate', array('Epic fail'));
     $failing = array('file_test_validator' => array(array('Failed', 'Badly')));
-    $this->assertEqual(file_validate($file, $failing), array('Failed', 'Badly', 'Epic fail'), t('Validating returns errors.'));
+    $this->assertEqual(file_validate($file, $failing), array('Failed', 'Badly', 'Epic fail'), 'Validating returns errors.');
     $this->assertFileHooksCalled(array('validate'));
   }
 }
@@ -2214,13 +2214,13 @@ class FileSaveDataTest extends FileHookTestCase {
     $contents = $this->randomName(8);
 
     $result = file_save_data($contents);
-    $this->assertTrue($result, t('Unnamed file saved correctly.'));
+    $this->assertTrue($result, 'Unnamed file saved correctly.');
 
-    $this->assertEqual(file_default_scheme(), file_uri_scheme($result->uri), t("File was placed in Drupal's files directory."));
-    $this->assertEqual($result->filename, drupal_basename($result->uri), t("Filename was set to the file's basename."));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of the file are correct.'));
-    $this->assertEqual($result->filemime, 'application/octet-stream', t('A MIME type was set.'));
-    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, t("The file's status was set to permanent."));
+    $this->assertEqual(file_default_scheme(), file_uri_scheme($result->uri), "File was placed in Drupal's files directory.");
+    $this->assertEqual($result->filename, drupal_basename($result->uri), "Filename was set to the file's basename.");
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of the file are correct.');
+    $this->assertEqual($result->filemime, 'application/octet-stream', 'A MIME type was set.');
+    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, "The file's status was set to permanent.");
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('insert'));
@@ -2239,13 +2239,13 @@ class FileSaveDataTest extends FileHookTestCase {
     $filename = 'Текстовый файл.txt';
 
     $result = file_save_data($contents, 'public://' . $filename);
-    $this->assertTrue($result, t('Unnamed file saved correctly.'));
+    $this->assertTrue($result, 'Unnamed file saved correctly.');
 
-    $this->assertEqual('public', file_uri_scheme($result->uri), t("File was placed in Drupal's files directory."));
-    $this->assertEqual($filename, drupal_basename($result->uri), t('File was named correctly.'));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of the file are correct.'));
-    $this->assertEqual($result->filemime, 'text/plain', t('A MIME type was set.'));
-    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, t("The file's status was set to permanent."));
+    $this->assertEqual('public', file_uri_scheme($result->uri), "File was placed in Drupal's files directory.");
+    $this->assertEqual($filename, drupal_basename($result->uri), 'File was named correctly.');
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of the file are correct.');
+    $this->assertEqual($result->filemime, 'text/plain', 'A MIME type was set.');
+    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, "The file's status was set to permanent.");
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('insert'));
@@ -2263,13 +2263,13 @@ class FileSaveDataTest extends FileHookTestCase {
     $contents = $this->randomName(8);
 
     $result = file_save_data($contents, $existing->uri, FILE_EXISTS_RENAME);
-    $this->assertTrue($result, t("File saved successfully."));
+    $this->assertTrue($result, 'File saved successfully.');
 
-    $this->assertEqual('public', file_uri_scheme($result->uri), t("File was placed in Drupal's files directory."));
-    $this->assertEqual($result->filename, $existing->filename, t("Filename was set to the basename of the source, rather than that of the renamed file."));
-    $this->assertEqual($contents, file_get_contents($result->uri), t("Contents of the file are correct."));
-    $this->assertEqual($result->filemime, 'application/octet-stream', t("A MIME type was set."));
-    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, t("The file's status was set to permanent."));
+    $this->assertEqual('public', file_uri_scheme($result->uri), "File was placed in Drupal's files directory.");
+    $this->assertEqual($result->filename, $existing->filename, 'Filename was set to the basename of the source, rather than that of the renamed file.');
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of the file are correct.');
+    $this->assertEqual($result->filemime, 'application/octet-stream', 'A MIME type was set.');
+    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, "The file's status was set to permanent.");
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('insert'));
@@ -2291,13 +2291,13 @@ class FileSaveDataTest extends FileHookTestCase {
     $contents = $this->randomName(8);
 
     $result = file_save_data($contents, $existing->uri, FILE_EXISTS_REPLACE);
-    $this->assertTrue($result, t('File saved successfully.'));
+    $this->assertTrue($result, 'File saved successfully.');
 
-    $this->assertEqual('public', file_uri_scheme($result->uri), t("File was placed in Drupal's files directory."));
-    $this->assertEqual($result->filename, $existing->filename, t('Filename was set to the basename of the existing file, rather than preserving the original name.'));
-    $this->assertEqual($contents, file_get_contents($result->uri), t('Contents of the file are correct.'));
-    $this->assertEqual($result->filemime, 'application/octet-stream', t('A MIME type was set.'));
-    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, t("The file's status was set to permanent."));
+    $this->assertEqual('public', file_uri_scheme($result->uri), "File was placed in Drupal's files directory.");
+    $this->assertEqual($result->filename, $existing->filename, 'Filename was set to the basename of the existing file, rather than preserving the original name.');
+    $this->assertEqual($contents, file_get_contents($result->uri), 'Contents of the file are correct.');
+    $this->assertEqual($result->filemime, 'application/octet-stream', 'A MIME type was set.');
+    $this->assertEqual($result->status, FILE_STATUS_PERMANENT, "The file's status was set to permanent.");
 
     // Check that the correct hooks were called.
     $this->assertFileHooksCalled(array('load', 'update'));
@@ -2318,8 +2318,8 @@ class FileSaveDataTest extends FileHookTestCase {
 
     // Check the overwrite error.
     $result = file_save_data('asdf', $existing->uri, FILE_EXISTS_ERROR);
-    $this->assertFalse($result, t('Overwriting a file fails when FILE_EXISTS_ERROR is specified.'));
-    $this->assertEqual($contents, file_get_contents($existing->uri), t('Contents of existing file were unchanged.'));
+    $this->assertFalse($result, 'Overwriting a file fails when FILE_EXISTS_ERROR is specified.');
+    $this->assertEqual($contents, file_get_contents($existing->uri), 'Contents of existing file were unchanged.');
 
     // Check that no hooks were called while failing.
     $this->assertFileHooksCalled(array());
@@ -2357,17 +2357,17 @@ class FileDownloadTest extends FileTestCase {
     // URLs can't contain characters outside the ASCII set so $filename has to be
     // encoded.
     $filename = $GLOBALS['base_url'] . '/' . file_stream_wrapper_get_instance_by_scheme('public')->getDirectoryPath() . '/' . rawurlencode($file->filename);
-    $this->assertEqual($filename, $url, t('Correctly generated a URL for a created file.'));
+    $this->assertEqual($filename, $url, 'Correctly generated a URL for a created file.');
     $this->drupalHead($url);
-    $this->assertResponse(200, t('Confirmed that the generated URL is correct by downloading the created file.'));
+    $this->assertResponse(200, 'Confirmed that the generated URL is correct by downloading the created file.');
 
     // Test generating an URL to a shipped file (i.e. a file that is part of
     // Drupal core, a module or a theme, for example a JavaScript file).
     $filepath = 'misc/jquery.js';
     $url = file_create_url($filepath);
-    $this->assertEqual($GLOBALS['base_url'] . '/' . $filepath, $url, t('Correctly generated a URL for a shipped file.'));
+    $this->assertEqual($GLOBALS['base_url'] . '/' . $filepath, $url, 'Correctly generated a URL for a shipped file.');
     $this->drupalHead($url);
-    $this->assertResponse(200, t('Confirmed that the generated URL is correct by downloading the shipped file.'));
+    $this->assertResponse(200, 'Confirmed that the generated URL is correct by downloading the shipped file.');
   }
 
   /**
@@ -2385,21 +2385,21 @@ class FileDownloadTest extends FileTestCase {
     file_test_set_return('download', array('x-foo' => 'Bar'));
     $this->drupalGet($url);
     $headers = $this->drupalGetHeaders();
-    $this->assertEqual($headers['x-foo'], 'Bar', t('Found header set by file_test module on private download.'));
-    $this->assertResponse(200, t('Correctly allowed access to a file when file_test provides headers.'));
+    $this->assertEqual($headers['x-foo'], 'Bar', 'Found header set by file_test module on private download.');
+    $this->assertResponse(200, 'Correctly allowed access to a file when file_test provides headers.');
 
     // Test that the file transfered correctly.
-    $this->assertEqual($contents, $this->content, t('Contents of the file are correct.'));
+    $this->assertEqual($contents, $this->content, 'Contents of the file are correct.');
 
     // Deny access to all downloads via a -1 header.
     file_test_set_return('download', -1);
     $this->drupalHead($url);
-    $this->assertResponse(403, t('Correctly denied access to a file when file_test sets the header to -1.'));
+    $this->assertResponse(403, 'Correctly denied access to a file when file_test sets the header to -1.');
 
     // Try non-existent file.
     $url = file_create_url('private://' . $this->randomName());
     $this->drupalHead($url);
-    $this->assertResponse(404, t('Correctly returned 404 response for a non-existent file.'));
+    $this->assertResponse(404, 'Correctly returned 404 response for a non-existent file.');
   }
 
   /**
@@ -2453,7 +2453,7 @@ class FileDownloadTest extends FileTestCase {
     $file = $this->createFile($filepath, NULL, $scheme);
 
     $url = file_create_url($file->uri);
-    $this->assertEqual($url, $expected_url, t('Generated URL matches expected URL.'));
+    $this->assertEqual($url, $expected_url, 'Generated URL matches expected URL.');
 
     if ($scheme == 'private') {
       // Tell the implementation of hook_file_download() in file_test.module
@@ -2463,7 +2463,7 @@ class FileDownloadTest extends FileTestCase {
 
     $this->drupalGet($url);
     if ($this->assertResponse(200) == 'pass') {
-      $this->assertRaw(file_get_contents($file->uri), t('Contents of the file are correct.'));
+      $this->assertRaw(file_get_contents($file->uri), 'Contents of the file are correct.');
     }
 
     file_delete($file);
@@ -2497,28 +2497,28 @@ class FileURLRewritingTest extends FileTestCase {
     variable_set('file_test_hook_file_url_alter', 'cdn');
     $filepath = 'misc/jquery.js';
     $url = file_create_url($filepath);
-    $this->assertEqual(FILE_URL_TEST_CDN_1 . '/' . $filepath, $url, t('Correctly generated a CDN URL for a shipped file.'));
+    $this->assertEqual(FILE_URL_TEST_CDN_1 . '/' . $filepath, $url, 'Correctly generated a CDN URL for a shipped file.');
     $filepath = 'misc/favicon.ico';
     $url = file_create_url($filepath);
-    $this->assertEqual(FILE_URL_TEST_CDN_2 . '/' . $filepath, $url, t('Correctly generated a CDN URL for a shipped file.'));
+    $this->assertEqual(FILE_URL_TEST_CDN_2 . '/' . $filepath, $url, 'Correctly generated a CDN URL for a shipped file.');
 
     // Test alteration of file URLs to use root-relative URLs.
     variable_set('file_test_hook_file_url_alter', 'root-relative');
     $filepath = 'misc/jquery.js';
     $url = file_create_url($filepath);
-    $this->assertEqual(base_path() . '/' . $filepath, $url, t('Correctly generated a root-relative URL for a shipped file.'));
+    $this->assertEqual(base_path() . '/' . $filepath, $url, 'Correctly generated a root-relative URL for a shipped file.');
     $filepath = 'misc/favicon.ico';
     $url = file_create_url($filepath);
-    $this->assertEqual(base_path() . '/' . $filepath, $url, t('Correctly generated a root-relative URL for a shipped file.'));
+    $this->assertEqual(base_path() . '/' . $filepath, $url, 'Correctly generated a root-relative URL for a shipped file.');
 
     // Test alteration of file URLs to use protocol-relative URLs.
     variable_set('file_test_hook_file_url_alter', 'protocol-relative');
     $filepath = 'misc/jquery.js';
     $url = file_create_url($filepath);
-    $this->assertEqual('/' . base_path() . '/' . $filepath, $url, t('Correctly generated a protocol-relative URL for a shipped file.'));
+    $this->assertEqual('/' . base_path() . '/' . $filepath, $url, 'Correctly generated a protocol-relative URL for a shipped file.');
     $filepath = 'misc/favicon.ico';
     $url = file_create_url($filepath);
-    $this->assertEqual('/' . base_path() . '/' . $filepath, $url, t('Correctly generated a protocol-relative URL for a shipped file.'));
+    $this->assertEqual('/' . base_path() . '/' . $filepath, $url, 'Correctly generated a protocol-relative URL for a shipped file.');
   }
 
   /**
@@ -2532,19 +2532,19 @@ class FileURLRewritingTest extends FileTestCase {
     $file = $this->createFile();
     $url = file_create_url($file->uri);
     $public_directory_path = file_stream_wrapper_get_instance_by_scheme('public')->getDirectoryPath();
-    $this->assertEqual(FILE_URL_TEST_CDN_2 . '/' . $public_directory_path . '/' . $file->filename, $url, t('Correctly generated a CDN URL for a created file.'));
+    $this->assertEqual(FILE_URL_TEST_CDN_2 . '/' . $public_directory_path . '/' . $file->filename, $url, 'Correctly generated a CDN URL for a created file.');
 
     // Test alteration of file URLs to use root-relative URLs.
     variable_set('file_test_hook_file_url_alter', 'root-relative');
     $file = $this->createFile();
     $url = file_create_url($file->uri);
-    $this->assertEqual(base_path() . '/' . $public_directory_path . '/' . $file->filename, $url, t('Correctly generated a root-relative URL for a created file.'));
+    $this->assertEqual(base_path() . '/' . $public_directory_path . '/' . $file->filename, $url, 'Correctly generated a root-relative URL for a created file.');
 
     // Test alteration of file URLs to use a protocol-relative URLs.
     variable_set('file_test_hook_file_url_alter', 'protocol-relative');
     $file = $this->createFile();
     $url = file_create_url($file->uri);
-    $this->assertEqual('/' . base_path() . '/' . $public_directory_path . '/' . $file->filename, $url, t('Correctly generated a protocol-relative URL for a created file.'));
+    $this->assertEqual('/' . base_path() . '/' . $public_directory_path . '/' . $file->filename, $url, 'Correctly generated a protocol-relative URL for a created file.');
   }
 }
 
@@ -2574,8 +2574,17 @@ class FileNameMungingTest extends FileTestCase {
     variable_set('allow_insecure_uploads', 0);
     $munged_name = file_munge_filename($this->name, '', TRUE);
     $messages = drupal_get_messages();
-    $this->assertTrue(in_array(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $munged_name)), $messages['status']), t('Alert properly set when a file is renamed.'));
-    $this->assertNotEqual($munged_name, $this->name, t('The new filename (%munged) has been modified from the original (%original)', array('%munged' => $munged_name, '%original' => $this->name)));
+    $this->assertTrue(in_array(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $munged_name)), $messages['status']), 'Alert properly set when a file is renamed.');
+    $this->assertNotEqual($munged_name, $this->name, format_string('The new filename (%munged) has been modified from the original (%original)', array('%munged' => $munged_name, '%original' => $this->name)));
+  }
+
+  /**
+   * Tests munging with a null byte in the filename.
+   */
+  function testMungeNullByte() {
+    $prefix = $this->randomName();
+    $filename = $prefix . '.' . $this->bad_extension . "\0.txt";
+    $this->assertEqual(file_munge_filename($filename, ''), $prefix . '.' . $this->bad_extension . '_.txt', 'A filename with a null byte is correctly munged to remove the null byte.');
   }
 
   /**
@@ -2585,7 +2594,7 @@ class FileNameMungingTest extends FileTestCase {
   function testMungeIgnoreInsecure() {
     variable_set('allow_insecure_uploads', 1);
     $munged_name = file_munge_filename($this->name, '');
-    $this->assertIdentical($munged_name, $this->name, t('The original filename (%original) matches the munged filename (%munged) when insecure uploads are enabled.', array('%munged' => $munged_name, '%original' => $this->name)));
+    $this->assertIdentical($munged_name, $this->name, format_string('The original filename (%original) matches the munged filename (%munged) when insecure uploads are enabled.', array('%munged' => $munged_name, '%original' => $this->name)));
   }
 
   /**
@@ -2594,7 +2603,7 @@ class FileNameMungingTest extends FileTestCase {
   function testMungeIgnoreWhitelisted() {
     // Declare our extension as whitelisted.
     $munged_name = file_munge_filename($this->name, $this->bad_extension);
-    $this->assertIdentical($munged_name, $this->name, t('The new filename (%munged) matches the original (%original) once the extension has been whitelisted.', array('%munged' => $munged_name, '%original' => $this->name)));
+    $this->assertIdentical($munged_name, $this->name, format_string('The new filename (%munged) matches the original (%original) once the extension has been whitelisted.', array('%munged' => $munged_name, '%original' => $this->name)));
   }
 
   /**
@@ -2603,7 +2612,7 @@ class FileNameMungingTest extends FileTestCase {
   function testUnMunge() {
     $munged_name = file_munge_filename($this->name, '', FALSE);
     $unmunged_name = file_unmunge_filename($munged_name);
-    $this->assertIdentical($unmunged_name, $this->name, t('The unmunged (%unmunged) filename matches the original (%original)', array('%unmunged' => $unmunged_name, '%original' => $this->name)));
+    $this->assertIdentical($unmunged_name, $this->name, format_string('The unmunged (%unmunged) filename matches the original (%original)', array('%unmunged' => $unmunged_name, '%original' => $this->name)));
   }
 }
 
@@ -2650,11 +2659,11 @@ class FileMimeTypeTest extends DrupalWebTestCase {
     foreach ($test_case as $input => $expected) {
       // Test stream [URI].
       $output = file_get_mimetype($prefix . $input);
-      $this->assertIdentical($output, $expected, t('Mimetype for %input is %output (expected: %expected).', array('%input' => $input, '%output' => $output, '%expected' => $expected)));
+      $this->assertIdentical($output, $expected, format_string('Mimetype for %input is %output (expected: %expected).', array('%input' => $input, '%output' => $output, '%expected' => $expected)));
 
       // Test normal path equivalent
       $output = file_get_mimetype($input);
-      $this->assertIdentical($output, $expected, t('Mimetype (using default mappings) for %input is %output (expected: %expected).', array('%input' => $input, '%output' => $output, '%expected' => $expected)));
+      $this->assertIdentical($output, $expected, format_string('Mimetype (using default mappings) for %input is %output (expected: %expected).', array('%input' => $input, '%output' => $output, '%expected' => $expected)));
     }
 
     // Now test passing in the map.
@@ -2687,7 +2696,7 @@ class FileMimeTypeTest extends DrupalWebTestCase {
 
     foreach ($test_case as $input => $expected) {
       $output = file_get_mimetype($input, $mapping);
-      $this->assertIdentical($output, $expected, t('Mimetype (using passed-in mappings) for %input is %output (expected: %expected).', array('%input' => $input, '%output' => $output, '%expected' => $expected)));
+      $this->assertIdentical($output, $expected, format_string('Mimetype (using passed-in mappings) for %input is %output (expected: %expected).', array('%input' => $input, '%output' => $output, '%expected' => $expected)));
     }
   }
 }
@@ -2723,9 +2732,9 @@ class StreamWrapperTest extends DrupalWebTestCase {
    */
   function testGetClassName() {
     // Check the dummy scheme.
-    $this->assertEqual($this->classname, file_stream_wrapper_get_class($this->scheme), t('Got correct class name for dummy scheme.'));
+    $this->assertEqual($this->classname, file_stream_wrapper_get_class($this->scheme), 'Got correct class name for dummy scheme.');
     // Check core's scheme.
-    $this->assertEqual('DrupalPublicStreamWrapper', file_stream_wrapper_get_class('public'), t('Got correct class name for public scheme.'));
+    $this->assertEqual('DrupalPublicStreamWrapper', file_stream_wrapper_get_class('public'), 'Got correct class name for public scheme.');
   }
 
   /**
@@ -2733,10 +2742,10 @@ class StreamWrapperTest extends DrupalWebTestCase {
    */
   function testGetInstanceByScheme() {
     $instance = file_stream_wrapper_get_instance_by_scheme($this->scheme);
-    $this->assertEqual($this->classname, get_class($instance), t('Got correct class type for dummy scheme.'));
+    $this->assertEqual($this->classname, get_class($instance), 'Got correct class type for dummy scheme.');
 
     $instance = file_stream_wrapper_get_instance_by_scheme('public');
-    $this->assertEqual('DrupalPublicStreamWrapper', get_class($instance), t('Got correct class type for public scheme.'));
+    $this->assertEqual('DrupalPublicStreamWrapper', get_class($instance), 'Got correct class type for public scheme.');
   }
 
   /**
@@ -2744,30 +2753,30 @@ class StreamWrapperTest extends DrupalWebTestCase {
    */
   function testUriFunctions() {
     $instance = file_stream_wrapper_get_instance_by_uri($this->scheme . '://foo');
-    $this->assertEqual($this->classname, get_class($instance), t('Got correct class type for dummy URI.'));
+    $this->assertEqual($this->classname, get_class($instance), 'Got correct class type for dummy URI.');
 
     $instance = file_stream_wrapper_get_instance_by_uri('public://foo');
-    $this->assertEqual('DrupalPublicStreamWrapper', get_class($instance), t('Got correct class type for public URI.'));
+    $this->assertEqual('DrupalPublicStreamWrapper', get_class($instance), 'Got correct class type for public URI.');
 
     // Test file_uri_target().
-    $this->assertEqual(file_uri_target('public://foo/bar.txt'), 'foo/bar.txt', t('Got a valid stream target from public://foo/bar.txt.'));
-    $this->assertFalse(file_uri_target('foo/bar.txt'), t('foo/bar.txt is not a valid stream.'));
+    $this->assertEqual(file_uri_target('public://foo/bar.txt'), 'foo/bar.txt', 'Got a valid stream target from public://foo/bar.txt.');
+    $this->assertFalse(file_uri_target('foo/bar.txt'), 'foo/bar.txt is not a valid stream.');
 
     // Test file_build_uri() and DrupalLocalStreamWrapper::getDirectoryPath().
-    $this->assertEqual(file_build_uri('foo/bar.txt'), 'public://foo/bar.txt', t('Expected scheme was added.'));
-    $this->assertEqual(file_stream_wrapper_get_instance_by_scheme('public')->getDirectoryPath(), variable_get('file_public_path'), t('Expected default directory path was returned.'));
-    $this->assertEqual(file_stream_wrapper_get_instance_by_scheme('temporary')->getDirectoryPath(), variable_get('file_temporary_path'), t('Expected temporary directory path was returned.'));
+    $this->assertEqual(file_build_uri('foo/bar.txt'), 'public://foo/bar.txt', 'Expected scheme was added.');
+    $this->assertEqual(file_stream_wrapper_get_instance_by_scheme('public')->getDirectoryPath(), variable_get('file_public_path'), 'Expected default directory path was returned.');
+    $this->assertEqual(file_stream_wrapper_get_instance_by_scheme('temporary')->getDirectoryPath(), variable_get('file_temporary_path'), 'Expected temporary directory path was returned.');
 
     variable_set('file_default_scheme', 'private');
-    $this->assertEqual(file_build_uri('foo/bar.txt'), 'private://foo/bar.txt', t('Got a valid URI from foo/bar.txt.'));
+    $this->assertEqual(file_build_uri('foo/bar.txt'), 'private://foo/bar.txt', 'Got a valid URI from foo/bar.txt.');
   }
 
   /**
    * Test the scheme functions.
    */
   function testGetValidStreamScheme() {
-    $this->assertEqual('foo', file_uri_scheme('foo://pork//chops'), t('Got the correct scheme from foo://asdf'));
-    $this->assertTrue(file_stream_wrapper_valid_scheme(file_uri_scheme('public://asdf')), t('Got a valid stream scheme from public://asdf'));
-    $this->assertFalse(file_stream_wrapper_valid_scheme(file_uri_scheme('foo://asdf')), t('Did not get a valid stream scheme from foo://asdf'));
+    $this->assertEqual('foo', file_uri_scheme('foo://pork//chops'), 'Got the correct scheme from foo://asdf');
+    $this->assertTrue(file_stream_wrapper_valid_scheme(file_uri_scheme('public://asdf')), 'Got a valid stream scheme from public://asdf');
+    $this->assertFalse(file_stream_wrapper_valid_scheme(file_uri_scheme('foo://asdf')), 'Did not get a valid stream scheme from foo://asdf');
   }
 }
diff --git a/modules/simpletest/tests/filter_test.module b/modules/simpletest/tests/filter_test.module
index 2cebc70..63b7f66 100644
--- a/modules/simpletest/tests/filter_test.module
+++ b/modules/simpletest/tests/filter_test.module
@@ -44,6 +44,8 @@ function filter_test_filter_info() {
 }
 
 /**
+ * Implements callback_filter_process().
+ *
  * Process handler for filter_test_replace filter.
  *
  * Replaces all text with filter and text format information.
diff --git a/modules/simpletest/tests/form.test b/modules/simpletest/tests/form.test
index 7eac198..a1506cc 100644
--- a/modules/simpletest/tests/form.test
+++ b/modules/simpletest/tests/form.test
@@ -230,7 +230,7 @@ class FormsTestCase extends DrupalWebTestCase {
     // First, try to submit without the required checkbox.
     $edit = array();
     $this->drupalPost('form-test/checkbox', $edit, t('Submit'));
-    $this->assertRaw(t('!name field is required.', array('!name' => 'required_checkbox')), t('A required checkbox is actually mandatory'));
+    $this->assertRaw(t('!name field is required.', array('!name' => 'required_checkbox')), 'A required checkbox is actually mandatory');
 
     // Now try to submit the form correctly.
     $values = drupal_json_decode($this->drupalPost(NULL, array('required_checkbox' => 1), t('Submit')));
@@ -243,7 +243,7 @@ class FormsTestCase extends DrupalWebTestCase {
       'zero_checkbox_off' => '',
     );
     foreach ($expected_values as $widget => $expected_value) {
-      $this->assertEqual($values[$widget], $expected_value, t('Checkbox %widget returns expected value (expected: %expected, got: %value)', array(
+      $this->assertEqual($values[$widget], $expected_value, format_string('Checkbox %widget returns expected value (expected: %expected, got: %value)', array(
         '%widget' => var_export($widget, TRUE),
         '%expected' => var_export($expected_value, TRUE),
         '%value' => var_export($values[$widget], TRUE),
@@ -307,7 +307,7 @@ class FormsTestCase extends DrupalWebTestCase {
       'multiple_no_default_required' => array('three' => 'three'),
     );
     foreach ($expected as $key => $value) {
-      $this->assertIdentical($values[$key], $value, t('@name: @actual is equal to @expected.', array(
+      $this->assertIdentical($values[$key], $value, format_string('@name: @actual is equal to @expected.', array(
         '@name' => $key,
         '@actual' => var_export($values[$key], TRUE),
         '@expected' => var_export($value, TRUE),
@@ -358,7 +358,7 @@ class FormsTestCase extends DrupalWebTestCase {
 
     // All the elements should be marked as disabled, including the ones below
     // the disabled container.
-    $this->assertEqual(count($disabled_elements), 32, t('The correct elements have the disabled property in the HTML code.'));
+    $this->assertEqual(count($disabled_elements), 32, 'The correct elements have the disabled property in the HTML code.');
 
     $this->drupalPost(NULL, $edit, t('Submit'));
     $returned_values['hijacked'] = drupal_json_decode($this->content);
@@ -387,7 +387,7 @@ class FormsTestCase extends DrupalWebTestCase {
           // Checkboxes values are not filtered out.
           $values[$key] = array_filter($values[$key]);
         }
-        $this->assertIdentical($expected_value, $values[$key], t('Default value for %type: expected %expected, returned %returned.', array('%type' => $key, '%expected' => var_export($expected_value, TRUE), '%returned' => var_export($values[$key], TRUE))));
+        $this->assertIdentical($expected_value, $values[$key], format_string('Default value for %type: expected %expected, returned %returned.', array('%type' => $key, '%expected' => var_export($expected_value, TRUE), '%returned' => var_export($values[$key], TRUE))));
       }
 
       // Recurse children.
@@ -438,7 +438,7 @@ class FormsTestCase extends DrupalWebTestCase {
         ':div-class' => $class,
         ':value' => isset($item['#value']) ? $item['#value'] : '',
       ));
-      $this->assertTrue(isset($element[0]), t('Disabled form element class found for #type %type.', array('%type' => $item['#type'])));
+      $this->assertTrue(isset($element[0]), format_string('Disabled form element class found for #type %type.', array('%type' => $item['#type'])));
     }
 
     // Verify special element #type text-format.
@@ -446,12 +446,12 @@ class FormsTestCase extends DrupalWebTestCase {
       ':name' => 'text_format[value]',
       ':div-class' => 'form-disabled',
     ));
-    $this->assertTrue(isset($element[0]), t('Disabled form element class found for #type %type.', array('%type' => 'text_format[value]')));
+    $this->assertTrue(isset($element[0]), format_string('Disabled form element class found for #type %type.', array('%type' => 'text_format[value]')));
     $element = $this->xpath('//div[contains(@class, :div-class)]/descendant::select[@name=:name]', array(
       ':name' => 'text_format[format]',
       ':div-class' => 'form-disabled',
     ));
-    $this->assertTrue(isset($element[0]), t('Disabled form element class found for #type %type.', array('%type' => 'text_format[format]')));
+    $this->assertTrue(isset($element[0]), format_string('Disabled form element class found for #type %type.', array('%type' => 'text_format[format]')));
   }
 
   /**
@@ -464,7 +464,7 @@ class FormsTestCase extends DrupalWebTestCase {
     $checkbox = $this->xpath('//input[@name="checkboxes[two]"]');
     $checkbox[0]['value'] = 'FORGERY';
     $this->drupalPost(NULL, array('checkboxes[one]' => TRUE, 'checkboxes[two]' => TRUE), t('Submit'));
-    $this->assertText('An illegal choice has been detected.', t('Input forgery was detected.'));
+    $this->assertText('An illegal choice has been detected.', 'Input forgery was detected.');
   }
 }
 
@@ -521,7 +521,7 @@ class FormElementTestCase extends DrupalWebTestCase {
         ':id' => 'edit-' . $type . '-foo',
         ':class' => 'description',
       ));
-      $this->assertTrue(count($elements), t('Custom %type option description found.', array(
+      $this->assertTrue(count($elements), format_string('Custom %type option description found.', array(
         '%type' => $type,
       )));
     }
@@ -558,7 +558,7 @@ class FormAlterTestCase extends DrupalWebTestCase {
       'system_form_form_test_alter_form_alter() executed.',
     );
     $content = preg_replace('/\s+/', ' ', filter_xss($this->content, array()));
-    $this->assert(strpos($content, implode(' ', $expected)) !== FALSE, t('Form alter hooks executed in the expected order.'));
+    $this->assert(strpos($content, implode(' ', $expected)) !== FALSE, 'Form alter hooks executed in the expected order.');
   }
 }
 
@@ -589,8 +589,8 @@ class FormValidationTestCase extends DrupalWebTestCase {
       'name' => 'element_validate',
     );
     $this->drupalPost(NULL, $edit, 'Save');
-    $this->assertFieldByName('name', '#value changed by #element_validate', t('Form element #value was altered.'));
-    $this->assertText('Name value: value changed by form_set_value() in #element_validate', t('Form element value in $form_state was altered.'));
+    $this->assertFieldByName('name', '#value changed by #element_validate', 'Form element #value was altered.');
+    $this->assertText('Name value: value changed by form_set_value() in #element_validate', 'Form element value in $form_state was altered.');
 
     // Verify that #validate handlers can alter the form and submitted
     // form values.
@@ -598,8 +598,8 @@ class FormValidationTestCase extends DrupalWebTestCase {
       'name' => 'validate',
     );
     $this->drupalPost(NULL, $edit, 'Save');
-    $this->assertFieldByName('name', '#value changed by #validate', t('Form element #value was altered.'));
-    $this->assertText('Name value: value changed by form_set_value() in #validate', t('Form element value in $form_state was altered.'));
+    $this->assertFieldByName('name', '#value changed by #validate', 'Form element #value was altered.');
+    $this->assertText('Name value: value changed by form_set_value() in #validate', 'Form element value in $form_state was altered.');
 
     // Verify that #element_validate handlers can make form elements
     // inaccessible, but values persist.
@@ -607,13 +607,13 @@ class FormValidationTestCase extends DrupalWebTestCase {
       'name' => 'element_validate_access',
     );
     $this->drupalPost(NULL, $edit, 'Save');
-    $this->assertNoFieldByName('name', t('Form element was hidden.'));
-    $this->assertText('Name value: element_validate_access', t('Value for inaccessible form element exists.'));
+    $this->assertNoFieldByName('name', 'Form element was hidden.');
+    $this->assertText('Name value: element_validate_access', 'Value for inaccessible form element exists.');
 
     // Verify that value for inaccessible form element persists.
     $this->drupalPost(NULL, array(), 'Save');
-    $this->assertNoFieldByName('name', t('Form element was hidden.'));
-    $this->assertText('Name value: element_validate_access', t('Value for inaccessible form element exists.'));
+    $this->assertNoFieldByName('name', 'Form element was hidden.');
+    $this->assertText('Name value: element_validate_access', 'Value for inaccessible form element exists.');
   }
 
   /**
@@ -657,6 +657,17 @@ class FormValidationTestCase extends DrupalWebTestCase {
     $this->assertText(t('!name field is required.', array('!name' => 'Title')));
     $this->assertText('Test element is invalid');
   }
+
+  /**
+   *  Tests error border of multiple fields with same name in a page.
+   */
+  function testMultiFormSameNameErrorClass() {
+    $this->drupalGet('form-test/double-form');
+    $edit = array();
+    $this->drupalPost(NULL, $edit, t('Save'));
+    $this->assertFieldByXpath('//input[@id="edit-name" and contains(@class, "error")]', NULL, 'Error input form element class found for first element.');
+    $this->assertNoFieldByXpath('//input[@id="edit-name--2" and contains(@class, "error")]', NULL, 'No error input form element class found for second element.');
+  }
 }
 
 /**
@@ -686,57 +697,57 @@ class FormsElementsLabelsTestCase extends DrupalWebTestCase {
     // Check that the checkbox/radio processing is not interfering with
     // basic placement.
     $elements = $this->xpath('//input[@id="edit-form-checkboxes-test-third-checkbox"]/following-sibling::label[@for="edit-form-checkboxes-test-third-checkbox" and @class="option"]');
-    $this->assertTrue(isset($elements[0]), t("Label follows field and label option class correct for regular checkboxes."));
+    $this->assertTrue(isset($elements[0]), "Label follows field and label option class correct for regular checkboxes.");
 
     // Make sure the label is rendered for checkboxes.
     $elements = $this->xpath('//input[@id="edit-form-checkboxes-test-0"]/following-sibling::label[@for="edit-form-checkboxes-test-0" and @class="option"]');
-    $this->assertTrue(isset($elements[0]), t("Label 0 found checkbox."));
+    $this->assertTrue(isset($elements[0]), "Label 0 found checkbox.");
 
     $elements = $this->xpath('//input[@id="edit-form-radios-test-second-radio"]/following-sibling::label[@for="edit-form-radios-test-second-radio" and @class="option"]');
-    $this->assertTrue(isset($elements[0]), t("Label follows field and label option class correct for regular radios."));
+    $this->assertTrue(isset($elements[0]), "Label follows field and label option class correct for regular radios.");
 
     // Make sure the label is rendered for radios.
     $elements = $this->xpath('//input[@id="edit-form-radios-test-0"]/following-sibling::label[@for="edit-form-radios-test-0" and @class="option"]');
-    $this->assertTrue(isset($elements[0]), t("Label 0 found radios."));
+    $this->assertTrue(isset($elements[0]), "Label 0 found radios.");
 
     // Exercise various defaults for checkboxes and modifications to ensure
     // appropriate override and correct behavior.
     $elements = $this->xpath('//input[@id="edit-form-checkbox-test"]/following-sibling::label[@for="edit-form-checkbox-test" and @class="option"]');
-    $this->assertTrue(isset($elements[0]), t("Label follows field and label option class correct for a checkbox by default."));
+    $this->assertTrue(isset($elements[0]), "Label follows field and label option class correct for a checkbox by default.");
 
     // Exercise various defaults for textboxes and modifications to ensure
     // appropriate override and correct behavior.
     $elements = $this->xpath('//label[@for="edit-form-textfield-test-title-and-required"]/child::span[@class="form-required"]/parent::*/following-sibling::input[@id="edit-form-textfield-test-title-and-required"]');
-    $this->assertTrue(isset($elements[0]), t("Label precedes textfield, with required marker inside label."));
+    $this->assertTrue(isset($elements[0]), "Label precedes textfield, with required marker inside label.");
 
     $elements = $this->xpath('//input[@id="edit-form-textfield-test-no-title-required"]/preceding-sibling::label[@for="edit-form-textfield-test-no-title-required"]/span[@class="form-required"]');
-    $this->assertTrue(isset($elements[0]), t("Label tag with required marker precedes required textfield with no title."));
+    $this->assertTrue(isset($elements[0]), "Label tag with required marker precedes required textfield with no title.");
 
     $elements = $this->xpath('//input[@id="edit-form-textfield-test-title-invisible"]/preceding-sibling::label[@for="edit-form-textfield-test-title-invisible" and @class="element-invisible"]');
-    $this->assertTrue(isset($elements[0]), t("Label preceding field and label class is element-invisible."));
+    $this->assertTrue(isset($elements[0]), "Label preceding field and label class is element-invisible.");
 
     $elements = $this->xpath('//input[@id="edit-form-textfield-test-title"]/preceding-sibling::span[@class="form-required"]');
-    $this->assertFalse(isset($elements[0]), t("No required marker on non-required field."));
+    $this->assertFalse(isset($elements[0]), "No required marker on non-required field.");
 
     $elements = $this->xpath('//input[@id="edit-form-textfield-test-title-after"]/following-sibling::label[@for="edit-form-textfield-test-title-after" and @class="option"]');
-    $this->assertTrue(isset($elements[0]), t("Label after field and label option class correct for text field."));
+    $this->assertTrue(isset($elements[0]), "Label after field and label option class correct for text field.");
 
     $elements = $this->xpath('//label[@for="edit-form-textfield-test-title-no-show"]');
-    $this->assertFalse(isset($elements[0]), t("No label tag when title set not to display."));
+    $this->assertFalse(isset($elements[0]), "No label tag when title set not to display.");
 
     // Check #field_prefix and #field_suffix placement.
     $elements = $this->xpath('//span[@class="field-prefix"]/following-sibling::div[@id="edit-form-radios-test"]');
-    $this->assertTrue(isset($elements[0]), t("Properly placed the #field_prefix element after the label and before the field."));
+    $this->assertTrue(isset($elements[0]), "Properly placed the #field_prefix element after the label and before the field.");
 
     $elements = $this->xpath('//span[@class="field-suffix"]/preceding-sibling::div[@id="edit-form-radios-test"]');
-    $this->assertTrue(isset($elements[0]), t("Properly places the #field_suffix element immediately after the form field."));
+    $this->assertTrue(isset($elements[0]), "Properly places the #field_suffix element immediately after the form field.");
 
     // Check #prefix and #suffix placement.
     $elements = $this->xpath('//div[@id="form-test-textfield-title-prefix"]/following-sibling::div[contains(@class, \'form-item-form-textfield-test-title\')]');
-    $this->assertTrue(isset($elements[0]), t("Properly places the #prefix element before the form item."));
+    $this->assertTrue(isset($elements[0]), "Properly places the #prefix element before the form item.");
 
     $elements = $this->xpath('//div[@id="form-test-textfield-title-suffix"]/preceding-sibling::div[contains(@class, \'form-item-form-textfield-test-title\')]');
-    $this->assertTrue(isset($elements[0]), t("Properly places the #suffix element before the form item."));
+    $this->assertTrue(isset($elements[0]), "Properly places the #suffix element before the form item.");
 
     // Check title attribute for radios and checkboxes.
     $elements = $this->xpath('//div[@id="edit-form-checkboxes-title-attribute"]');
@@ -771,14 +782,14 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
 
     $this->drupalGet('form_test/tableselect/multiple-true');
 
-    $this->assertNoText(t('Empty text.'), t('Empty text should not be displayed.'));
+    $this->assertNoText(t('Empty text.'), 'Empty text should not be displayed.');
 
     // Test for the presence of the Select all rows tableheader.
-    $this->assertFieldByXPath('//th[@class="select-all"]', NULL, t('Presence of the "Select all" checkbox.'));
+    $this->assertFieldByXPath('//th[@class="select-all"]', NULL, 'Presence of the "Select all" checkbox.');
 
     $rows = array('row1', 'row2', 'row3');
     foreach ($rows as $row) {
-      $this->assertFieldByXPath('//input[@type="checkbox"]', $row, t('Checkbox for value @row.', array('@row' => $row)));
+      $this->assertFieldByXPath('//input[@type="checkbox"]', $row, format_string('Checkbox for value @row.', array('@row' => $row)));
     }
   }
 
@@ -788,14 +799,14 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
   function testMultipleFalse() {
     $this->drupalGet('form_test/tableselect/multiple-false');
 
-    $this->assertNoText(t('Empty text.'), t('Empty text should not be displayed.'));
+    $this->assertNoText(t('Empty text.'), 'Empty text should not be displayed.');
 
     // Test for the absence of the Select all rows tableheader.
-    $this->assertNoFieldByXPath('//th[@class="select-all"]', '', t('Absence of the "Select all" checkbox.'));
+    $this->assertNoFieldByXPath('//th[@class="select-all"]', '', 'Absence of the "Select all" checkbox.');
 
     $rows = array('row1', 'row2', 'row3');
     foreach ($rows as $row) {
-      $this->assertFieldByXPath('//input[@type="radio"]', $row, t('Radio button for value @row.', array('@row' => $row)));
+      $this->assertFieldByXPath('//input[@type="radio"]', $row, format_string('Radio button for value @row.', array('@row' => $row)));
     }
   }
 
@@ -804,7 +815,7 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
    */
   function testEmptyText() {
     $this->drupalGet('form_test/tableselect/empty-text');
-    $this->assertText(t('Empty text.'), t('Empty text should be displayed.'));
+    $this->assertText(t('Empty text.'), 'Empty text should be displayed.');
   }
 
   /**
@@ -817,18 +828,18 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
     $edit['tableselect[row1]'] = TRUE;
     $this->drupalPost('form_test/tableselect/multiple-true', $edit, 'Submit');
 
-    $this->assertText(t('Submitted: row1 = row1'), t('Checked checkbox row1'));
-    $this->assertText(t('Submitted: row2 = 0'), t('Unchecked checkbox row2.'));
-    $this->assertText(t('Submitted: row3 = 0'), t('Unchecked checkbox row3.'));
+    $this->assertText(t('Submitted: row1 = row1'), 'Checked checkbox row1');
+    $this->assertText(t('Submitted: row2 = 0'), 'Unchecked checkbox row2.');
+    $this->assertText(t('Submitted: row3 = 0'), 'Unchecked checkbox row3.');
 
     // Test a submission with multiple checkboxes checked.
     $edit['tableselect[row1]'] = TRUE;
     $edit['tableselect[row3]'] = TRUE;
     $this->drupalPost('form_test/tableselect/multiple-true', $edit, 'Submit');
 
-    $this->assertText(t('Submitted: row1 = row1'), t('Checked checkbox row1.'));
-    $this->assertText(t('Submitted: row2 = 0'), t('Unchecked checkbox row2.'));
-    $this->assertText(t('Submitted: row3 = row3'), t('Checked checkbox row3.'));
+    $this->assertText(t('Submitted: row1 = row1'), 'Checked checkbox row1.');
+    $this->assertText(t('Submitted: row2 = 0'), 'Unchecked checkbox row2.');
+    $this->assertText(t('Submitted: row3 = row3'), 'Checked checkbox row3.');
 
   }
 
@@ -838,7 +849,7 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
   function testMultipleFalseSubmit() {
     $edit['tableselect'] = 'row1';
     $this->drupalPost('form_test/tableselect/multiple-false', $edit, 'Submit');
-    $this->assertText(t('Submitted: row1'), t('Selected radio button'));
+    $this->assertText(t('Submitted: row1'), 'Selected radio button');
   }
 
   /**
@@ -847,18 +858,18 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
   function testAdvancedSelect() {
     // When #multiple = TRUE a Select all checkbox should be displayed by default.
     $this->drupalGet('form_test/tableselect/advanced-select/multiple-true-default');
-    $this->assertFieldByXPath('//th[@class="select-all"]', NULL, t('Display a "Select all" checkbox by default when #multiple is TRUE.'));
+    $this->assertFieldByXPath('//th[@class="select-all"]', NULL, 'Display a "Select all" checkbox by default when #multiple is TRUE.');
 
     // When #js_select is set to FALSE, a "Select all" checkbox should not be displayed.
     $this->drupalGet('form_test/tableselect/advanced-select/multiple-true-no-advanced-select');
-    $this->assertNoFieldByXPath('//th[@class="select-all"]', NULL, t('Do not display a "Select all" checkbox when #js_select is FALSE.'));
+    $this->assertNoFieldByXPath('//th[@class="select-all"]', NULL, 'Do not display a "Select all" checkbox when #js_select is FALSE.');
 
     // A "Select all" checkbox never makes sense when #multiple = FALSE, regardless of the value of #js_select.
     $this->drupalGet('form_test/tableselect/advanced-select/multiple-false-default');
-    $this->assertNoFieldByXPath('//th[@class="select-all"]', NULL, t('Do not display a "Select all" checkbox when #multiple is FALSE.'));
+    $this->assertNoFieldByXPath('//th[@class="select-all"]', NULL, 'Do not display a "Select all" checkbox when #multiple is FALSE.');
 
     $this->drupalGet('form_test/tableselect/advanced-select/multiple-false-advanced-select');
-    $this->assertNoFieldByXPath('//th[@class="select-all"]', NULL, t('Do not display a "Select all" checkbox when #multiple is FALSE, even when #js_select is TRUE.'));
+    $this->assertNoFieldByXPath('//th[@class="select-all"]', NULL, 'Do not display a "Select all" checkbox when #multiple is FALSE, even when #js_select is TRUE.');
   }
 
 
@@ -877,11 +888,11 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
 
     // Test with a valid value.
     list($processed_form, $form_state, $errors) = $this->formSubmitHelper($form, array('tableselect' => array('row1' => 'row1')));
-    $this->assertFalse(isset($errors['tableselect']), t('Option checker allows valid values for checkboxes.'));
+    $this->assertFalse(isset($errors['tableselect']), 'Option checker allows valid values for checkboxes.');
 
     // Test with an invalid value.
     list($processed_form, $form_state, $errors) = $this->formSubmitHelper($form, array('tableselect' => array('non_existing_value' => 'non_existing_value')));
-    $this->assertTrue(isset($errors['tableselect']), t('Option checker disallows invalid values for checkboxes.'));
+    $this->assertTrue(isset($errors['tableselect']), 'Option checker disallows invalid values for checkboxes.');
 
   }
 
@@ -902,11 +913,11 @@ class FormsElementsTableSelectFunctionalTest extends DrupalWebTestCase {
 
     // Test with a valid value.
     list($processed_form, $form_state, $errors) = $this->formSubmitHelper($form, array('tableselect' => 'row1'));
-    $this->assertFalse(isset($errors['tableselect']), t('Option checker allows valid values for radio buttons.'));
+    $this->assertFalse(isset($errors['tableselect']), 'Option checker allows valid values for radio buttons.');
 
     // Test with an invalid value.
     list($processed_form, $form_state, $errors) = $this->formSubmitHelper($form, array('tableselect' => 'non_existing_value'));
-    $this->assertTrue(isset($errors['tableselect']), t('Option checker disallows invalid values for radio buttons.'));
+    $this->assertTrue(isset($errors['tableselect']), 'Option checker disallows invalid values for radio buttons.');
   }
 
 
@@ -973,7 +984,7 @@ class FormsElementsVerticalTabsFunctionalTest extends DrupalWebTestCase {
     $this->drupalGet('form_test/vertical-tabs');
     $position1 = strpos($this->content, 'misc/vertical-tabs.js');
     $position2 = strpos($this->content, 'misc/collapse.js');
-    $this->assertTrue($position1 !== FALSE && $position2 !== FALSE && $position1 < $position2, t('vertical-tabs.js is included before collapse.js'));
+    $this->assertTrue($position1 !== FALSE && $position2 !== FALSE && $position1 < $position2, 'vertical-tabs.js is included before collapse.js');
   }
 }
 
@@ -1026,7 +1037,7 @@ class FormsFormStorageTestCase extends DrupalWebTestCase {
 
     $this->drupalPost(NULL, $edit, 'Save');
     $this->assertText('Form constructions: 4');
-    $this->assertText('Title: new', t('The form storage has stored the values.'));
+    $this->assertText('Title: new', 'The form storage has stored the values.');
   }
 
   /**
@@ -1050,7 +1061,7 @@ class FormsFormStorageTestCase extends DrupalWebTestCase {
 
     $this->drupalPost(NULL, $edit, 'Save');
     $this->assertText('Form constructions: 3');
-    $this->assertText('Title: new', t('The form storage has stored the values.'));
+    $this->assertText('Title: new', 'The form storage has stored the values.');
   }
 
   /**
@@ -1058,7 +1069,7 @@ class FormsFormStorageTestCase extends DrupalWebTestCase {
    */
   function testValidation() {
     $this->drupalPost('form_test/form-storage', array('title' => '', 'value' => 'value_is_set'), 'Continue submit');
-    $this->assertPattern('/value_is_set/', t('The input values have been kept.'));
+    $this->assertPattern('/value_is_set/', 'The input values have been kept.');
   }
 
   /**
@@ -1148,8 +1159,8 @@ class FormsFormWrapperTestCase extends DrupalWebTestCase {
    */
   function testWrapperCallback() {
     $this->drupalGet('form_test/wrapper-callback');
-    $this->assertText('Form wrapper callback element output.', t('The form contains form wrapper elements.'));
-    $this->assertText('Form builder element output.', t('The form contains form builder elements.'));
+    $this->assertText('Form wrapper callback element output.', 'The form contains form wrapper elements.');
+    $this->assertText('Form builder element output.', 'The form contains form builder elements.');
   }
 }
 
@@ -1182,22 +1193,22 @@ class FormStateValuesCleanTestCase extends DrupalWebTestCase {
     );
 
     // Verify that all internal Form API elements were removed.
-    $this->assertFalse(isset($values['form_id']), t('%element was removed.', array('%element' => 'form_id')));
-    $this->assertFalse(isset($values['form_token']), t('%element was removed.', array('%element' => 'form_token')));
-    $this->assertFalse(isset($values['form_build_id']), t('%element was removed.', array('%element' => 'form_build_id')));
-    $this->assertFalse(isset($values['op']), t('%element was removed.', array('%element' => 'op')));
+    $this->assertFalse(isset($values['form_id']), format_string('%element was removed.', array('%element' => 'form_id')));
+    $this->assertFalse(isset($values['form_token']), format_string('%element was removed.', array('%element' => 'form_token')));
+    $this->assertFalse(isset($values['form_build_id']), format_string('%element was removed.', array('%element' => 'form_build_id')));
+    $this->assertFalse(isset($values['op']), format_string('%element was removed.', array('%element' => 'op')));
 
     // Verify that all buttons were removed.
-    $this->assertFalse(isset($values['foo']), t('%element was removed.', array('%element' => 'foo')));
-    $this->assertFalse(isset($values['bar']), t('%element was removed.', array('%element' => 'bar')));
-    $this->assertFalse(isset($values['baz']['foo']), t('%element was removed.', array('%element' => 'foo')));
-    $this->assertFalse(isset($values['baz']['baz']), t('%element was removed.', array('%element' => 'baz')));
+    $this->assertFalse(isset($values['foo']), format_string('%element was removed.', array('%element' => 'foo')));
+    $this->assertFalse(isset($values['bar']), format_string('%element was removed.', array('%element' => 'bar')));
+    $this->assertFalse(isset($values['baz']['foo']), format_string('%element was removed.', array('%element' => 'foo')));
+    $this->assertFalse(isset($values['baz']['baz']), format_string('%element was removed.', array('%element' => 'baz')));
 
     // Verify that nested form value still exists.
-    $this->assertTrue(isset($values['baz']['beer']), t('Nested form value still exists.'));
+    $this->assertTrue(isset($values['baz']['beer']), 'Nested form value still exists.');
 
     // Verify that actual form values equal resulting form values.
-    $this->assertEqual($values, $result, t('Expected form values equal actual form values.'));
+    $this->assertEqual($values, $result, 'Expected form values equal actual form values.');
   }
 }
 
@@ -1232,7 +1243,7 @@ class FormStateValuesCleanAdvancedTestCase extends DrupalWebTestCase {
     $this->image = current($image_files);
 
     // Check if the physical file is there.
-    $this->assertTrue(is_file($this->image->uri), t("The image file we're going to upload exists."));
+    $this->assertTrue(is_file($this->image->uri), "The image file we're going to upload exists.");
 
     // "Browse" for the desired file.
     $edit = array('files[image]' => drupal_realpath($this->image->uri));
@@ -1241,8 +1252,8 @@ class FormStateValuesCleanAdvancedTestCase extends DrupalWebTestCase {
     $this->drupalPost('form_test/form-state-values-clean-advanced', $edit, t('Submit'));
 
     // Expecting a 200 HTTP code.
-    $this->assertResponse(200, t('Received a 200 response for posted test file.'));
-    $this->assertRaw(t('You WIN!'), t('Found the success message.'));
+    $this->assertResponse(200, 'Received a 200 response for posted test file.');
+    $this->assertRaw(t('You WIN!'), 'Found the success message.');
   }
 }
 
@@ -1279,14 +1290,14 @@ class FormsRebuildTestCase extends DrupalWebTestCase {
     $this->drupalPost('form-test/form-rebuild-preserve-values', $edit, 'Add more');
 
     // Verify that initial elements retained their submitted values.
-    $this->assertFieldChecked('edit-checkbox-1-default-off', t('A submitted checked checkbox retained its checked state during a rebuild.'));
-    $this->assertNoFieldChecked('edit-checkbox-1-default-on', t('A submitted unchecked checkbox retained its unchecked state during a rebuild.'));
-    $this->assertFieldById('edit-text-1', 'foo', t('A textfield retained its submitted value during a rebuild.'));
+    $this->assertFieldChecked('edit-checkbox-1-default-off', 'A submitted checked checkbox retained its checked state during a rebuild.');
+    $this->assertNoFieldChecked('edit-checkbox-1-default-on', 'A submitted unchecked checkbox retained its unchecked state during a rebuild.');
+    $this->assertFieldById('edit-text-1', 'foo', 'A textfield retained its submitted value during a rebuild.');
 
     // Verify that newly added elements were initialized with their default values.
-    $this->assertFieldChecked('edit-checkbox-2-default-on', t('A newly added checkbox was initialized with a default checked state.'));
-    $this->assertNoFieldChecked('edit-checkbox-2-default-off', t('A newly added checkbox was initialized with a default unchecked state.'));
-    $this->assertFieldById('edit-text-2', 'DEFAULT 2', t('A newly added textfield was initialized with its default value.'));
+    $this->assertFieldChecked('edit-checkbox-2-default-on', 'A newly added checkbox was initialized with a default checked state.');
+    $this->assertNoFieldChecked('edit-checkbox-2-default-off', 'A newly added checkbox was initialized with a default unchecked state.');
+    $this->assertFieldById('edit-text-2', 'DEFAULT 2', 'A newly added textfield was initialized with its default value.');
   }
 
   /**
@@ -1320,7 +1331,7 @@ class FormsRebuildTestCase extends DrupalWebTestCase {
     // field items in the field for which we just added an item.
     $this->drupalGet('node/add/page');
     $this->drupalPostAJAX(NULL, array(), array('field_ajax_test_add_more' => t('Add another item')), 'system/ajax', array(), array(), 'page-node-form');
-    $this->assert(count($this->xpath('//div[contains(@class, "field-name-field-ajax-test")]//input[@type="text"]')) == 2, t('AJAX submission succeeded.'));
+    $this->assert(count($this->xpath('//div[contains(@class, "field-name-field-ajax-test")]//input[@type="text"]')) == 2, 'AJAX submission succeeded.');
 
     // Submit the form with the non-Ajax "Save" button, leaving the title field
     // blank to trigger a validation error, and ensure that a validation error
@@ -1328,15 +1339,15 @@ class FormsRebuildTestCase extends DrupalWebTestCase {
     // re-rendered without being re-built, which is what happens when there's
     // a validation error.
     $this->drupalPost(NULL, array(), t('Save'));
-    $this->assertText('Title field is required.', t('Non-AJAX submission correctly triggered a validation error.'));
+    $this->assertText('Title field is required.', 'Non-AJAX submission correctly triggered a validation error.');
 
     // Ensure that the form contains two items in the multi-valued field, so we
     // know we're testing a form that was correctly retrieved from cache.
-    $this->assert(count($this->xpath('//form[contains(@id, "page-node-form")]//div[contains(@class, "form-item-field-ajax-test")]//input[@type="text"]')) == 2, t('Form retained its state from cache.'));
+    $this->assert(count($this->xpath('//form[contains(@id, "page-node-form")]//div[contains(@class, "form-item-field-ajax-test")]//input[@type="text"]')) == 2, 'Form retained its state from cache.');
 
     // Ensure that the form's action is correct.
     $forms = $this->xpath('//form[contains(@class, "node-page-form")]');
-    $this->assert(count($forms) == 1 && $forms[0]['action'] == url('node/add/page'), t('Re-rendered form contains the correct action value.'));
+    $this->assert(count($forms) == 1 && $forms[0]['action'] == url('node/add/page'), 'Re-rendered form contains the correct action value.');
   }
 }
 
@@ -1490,7 +1501,7 @@ class FormsProgrammaticTestCase extends DrupalWebTestCase {
       '%values' => print_r($values, TRUE),
       '%errors' => $valid_form ? t('None') : implode(' ', $errors),
     );
-    $this->assertTrue($valid_input == $valid_form, t('Input values: %values<br/>Validation handler errors: %errors', $args));
+    $this->assertTrue($valid_input == $valid_form, format_string('Input values: %values<br/>Validation handler errors: %errors', $args));
 
     // We check submitted values only if we have a valid input.
     if ($valid_input) {
@@ -1498,7 +1509,7 @@ class FormsProgrammaticTestCase extends DrupalWebTestCase {
       // submission handler was properly executed.
       $stored_values = $form_state['storage']['programmatic_form_submit'];
       foreach ($values as $key => $value) {
-        $this->assertTrue(isset($stored_values[$key]) && $stored_values[$key] == $value, t('Submission handler correctly executed: %stored_key is %stored_value', array('%stored_key' => $key, '%stored_value' => print_r($value, TRUE))));
+        $this->assertTrue(isset($stored_values[$key]) && $stored_values[$key] == $value, format_string('Submission handler correctly executed: %stored_key is %stored_value', array('%stored_key' => $key, '%stored_value' => print_r($value, TRUE))));
       }
     }
   }
@@ -1535,24 +1546,24 @@ class FormsTriggeringElementTestCase extends DrupalWebTestCase {
     // $form_state['triggering_element'] and the form submit handler not
     // running.
     $this->drupalPost($path, $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('There is no clicked button.', t('$form_state[\'triggering_element\'] set to NULL.'));
-    $this->assertNoText('Submit handler for form_test_clicked_button executed.', t('Form submit handler did not execute.'));
+    $this->assertText('There is no clicked button.', '$form_state[\'triggering_element\'] set to NULL.');
+    $this->assertNoText('Submit handler for form_test_clicked_button executed.', 'Form submit handler did not execute.');
 
     // Ensure submitting a form with one or more submit buttons results in
     // $form_state['triggering_element'] being set to the first one the user has
     // access to. An argument with 'r' in it indicates a restricted
     // (#access=FALSE) button.
     $this->drupalPost($path . '/s', $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('The clicked button is button1.', t('$form_state[\'triggering_element\'] set to only button.'));
-    $this->assertText('Submit handler for form_test_clicked_button executed.', t('Form submit handler executed.'));
+    $this->assertText('The clicked button is button1.', '$form_state[\'triggering_element\'] set to only button.');
+    $this->assertText('Submit handler for form_test_clicked_button executed.', 'Form submit handler executed.');
 
     $this->drupalPost($path . '/s/s', $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('The clicked button is button1.', t('$form_state[\'triggering_element\'] set to first button.'));
-    $this->assertText('Submit handler for form_test_clicked_button executed.', t('Form submit handler executed.'));
+    $this->assertText('The clicked button is button1.', '$form_state[\'triggering_element\'] set to first button.');
+    $this->assertText('Submit handler for form_test_clicked_button executed.', 'Form submit handler executed.');
 
     $this->drupalPost($path . '/rs/s', $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('The clicked button is button2.', t('$form_state[\'triggering_element\'] set to first available button.'));
-    $this->assertText('Submit handler for form_test_clicked_button executed.', t('Form submit handler executed.'));
+    $this->assertText('The clicked button is button2.', '$form_state[\'triggering_element\'] set to first available button.');
+    $this->assertText('Submit handler for form_test_clicked_button executed.', 'Form submit handler executed.');
 
     // Ensure submitting a form with buttons of different types results in
     // $form_state['triggering_element'] being set to the first button,
@@ -1560,16 +1571,16 @@ class FormsTriggeringElementTestCase extends DrupalWebTestCase {
     // submit handler not executing. The types are 's'(ubmit), 'b'(utton), and
     // 'i'(mage_button).
     $this->drupalPost($path . '/s/b/i', $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('The clicked button is button1.', t('$form_state[\'triggering_element\'] set to first button.'));
-    $this->assertText('Submit handler for form_test_clicked_button executed.', t('Form submit handler executed.'));
+    $this->assertText('The clicked button is button1.', '$form_state[\'triggering_element\'] set to first button.');
+    $this->assertText('Submit handler for form_test_clicked_button executed.', 'Form submit handler executed.');
 
     $this->drupalPost($path . '/b/s/i', $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('The clicked button is button1.', t('$form_state[\'triggering_element\'] set to first button.'));
-    $this->assertNoText('Submit handler for form_test_clicked_button executed.', t('Form submit handler did not execute.'));
+    $this->assertText('The clicked button is button1.', '$form_state[\'triggering_element\'] set to first button.');
+    $this->assertNoText('Submit handler for form_test_clicked_button executed.', 'Form submit handler did not execute.');
 
     $this->drupalPost($path . '/i/s/b', $edit, NULL, array(), array(), $form_html_id);
-    $this->assertText('The clicked button is button1.', t('$form_state[\'triggering_element\'] set to first button.'));
-    $this->assertText('Submit handler for form_test_clicked_button executed.', t('Form submit handler executed.'));
+    $this->assertText('The clicked button is button1.', '$form_state[\'triggering_element\'] set to first button.');
+    $this->assertText('Submit handler for form_test_clicked_button executed.', 'Form submit handler executed.');
   }
 
   /**
@@ -1597,8 +1608,8 @@ class FormsTriggeringElementTestCase extends DrupalWebTestCase {
     // because negative assertions alone can be brittle. See
     // testNoButtonInfoInPost() for why the triggering element gets set to
     // 'button2'.
-    $this->assertNoText('The clicked button is button1.', t('$form_state[\'triggering_element\'] not set to a restricted button.'));
-    $this->assertText('The clicked button is button2.', t('$form_state[\'triggering_element\'] not set to a restricted button.'));
+    $this->assertNoText('The clicked button is button1.', '$form_state[\'triggering_element\'] not set to a restricted button.');
+    $this->assertText('The clicked button is button2.', '$form_state[\'triggering_element\'] not set to a restricted button.');
   }
 }
 
@@ -1748,7 +1759,7 @@ class FormCheckboxTestCase extends DrupalWebTestCase {
           $checked = ($default_value === '1foobar');
         }
         $checked_in_html = strpos($form, 'checked') !== FALSE;
-        $message = t('#default_value is %default_value #return_value is %return_value.', array('%default_value' => var_export($default_value, TRUE), '%return_value' => var_export($return_value, TRUE)));
+        $message = format_string('#default_value is %default_value #return_value is %return_value.', array('%default_value' => var_export($default_value, TRUE), '%return_value' => var_export($return_value, TRUE)));
         $this->assertIdentical($checked, $checked_in_html, $message);
       }
     }
@@ -1756,12 +1767,12 @@ class FormCheckboxTestCase extends DrupalWebTestCase {
     // Ensure that $form_state['values'] is populated correctly for a checkboxes
     // group that includes a 0-indexed array of options.
     $results = json_decode($this->drupalPost('form-test/checkboxes-zero', array(), 'Save'));
-    $this->assertIdentical($results->checkbox_off, array(0, 0, 0), t('All three in checkbox_off are zeroes: off.'));
-    $this->assertIdentical($results->checkbox_zero_default, array('0', 0, 0), t('The first choice is on in checkbox_zero_default'));
-    $this->assertIdentical($results->checkbox_string_zero_default, array('0', 0, 0), t('The first choice is on in checkbox_string_zero_default'));
+    $this->assertIdentical($results->checkbox_off, array(0, 0, 0), 'All three in checkbox_off are zeroes: off.');
+    $this->assertIdentical($results->checkbox_zero_default, array('0', 0, 0), 'The first choice is on in checkbox_zero_default');
+    $this->assertIdentical($results->checkbox_string_zero_default, array('0', 0, 0), 'The first choice is on in checkbox_string_zero_default');
     $edit = array('checkbox_off[0]' => '0');
     $results = json_decode($this->drupalPost('form-test/checkboxes-zero', $edit, 'Save'));
-    $this->assertIdentical($results->checkbox_off, array('0', 0, 0), t('The first choice is on in checkbox_off but the rest is not'));
+    $this->assertIdentical($results->checkbox_off, array('0', 0, 0), 'The first choice is on in checkbox_off but the rest is not');
 
     // Ensure that each checkbox is rendered correctly for a checkboxes group
     // that includes a 0-indexed array of options.
@@ -1770,7 +1781,7 @@ class FormCheckboxTestCase extends DrupalWebTestCase {
     foreach ($checkboxes as $checkbox) {
       $checked = isset($checkbox['checked']);
       $name = (string) $checkbox['name'];
-      $this->assertIdentical($checked, $name == 'checkbox_zero_default[0]' || $name == 'checkbox_string_zero_default[0]', t('Checkbox %name correctly checked', array('%name' => $name)));
+      $this->assertIdentical($checked, $name == 'checkbox_zero_default[0]' || $name == 'checkbox_string_zero_default[0]', format_string('Checkbox %name correctly checked', array('%name' => $name)));
     }
     $edit = array('checkbox_off[0]' => '0');
     $this->drupalPost('form-test/checkboxes-zero/0', $edit, 'Save');
@@ -1778,7 +1789,7 @@ class FormCheckboxTestCase extends DrupalWebTestCase {
     foreach ($checkboxes as $checkbox) {
       $checked = isset($checkbox['checked']);
       $name = (string) $checkbox['name'];
-      $this->assertIdentical($checked, $name == 'checkbox_off[0]' || $name == 'checkbox_zero_default[0]' || $name == 'checkbox_string_zero_default[0]', t('Checkbox %name correctly checked', array('%name' => $name)));
+      $this->assertIdentical($checked, $name == 'checkbox_off[0]' || $name == 'checkbox_zero_default[0]' || $name == 'checkbox_string_zero_default[0]', format_string('Checkbox %name correctly checked', array('%name' => $name)));
     }
   }
 }
diff --git a/modules/simpletest/tests/graph.test b/modules/simpletest/tests/graph.test
index c190161..691744e 100644
--- a/modules/simpletest/tests/graph.test
+++ b/modules/simpletest/tests/graph.test
@@ -69,7 +69,7 @@ class GraphUnitTest extends DrupalUnitTestCase {
     $this->assertReversePaths($graph, $expected_reverse_paths);
 
     // Assert that DFS didn't created "missing" vertexes automatically.
-    $this->assertFALSE(isset($graph[6]), t('Vertex 6 has not been created'));
+    $this->assertFALSE(isset($graph[6]), 'Vertex 6 has not been created');
 
     $expected_components = array(
       array(1, 2, 3, 4, 5, 7),
@@ -115,7 +115,7 @@ class GraphUnitTest extends DrupalUnitTestCase {
       // Build an array with keys = $paths and values = TRUE.
       $expected = array_fill_keys($paths, TRUE);
       $result = isset($graph[$vertex]['paths']) ? $graph[$vertex]['paths'] : array();
-      $this->assertEqual($expected, $result, t('Expected paths for vertex @vertex: @expected-paths, got @paths', array('@vertex' => $vertex, '@expected-paths' => $this->displayArray($expected, TRUE), '@paths' => $this->displayArray($result, TRUE))));
+      $this->assertEqual($expected, $result, format_string('Expected paths for vertex @vertex: @expected-paths, got @paths', array('@vertex' => $vertex, '@expected-paths' => $this->displayArray($expected, TRUE), '@paths' => $this->displayArray($result, TRUE))));
     }
   }
 
@@ -133,7 +133,7 @@ class GraphUnitTest extends DrupalUnitTestCase {
       // Build an array with keys = $paths and values = TRUE.
       $expected = array_fill_keys($paths, TRUE);
       $result = isset($graph[$vertex]['reverse_paths']) ? $graph[$vertex]['reverse_paths'] : array();
-      $this->assertEqual($expected, $result, t('Expected reverse paths for vertex @vertex: @expected-paths, got @paths', array('@vertex' => $vertex, '@expected-paths' => $this->displayArray($expected, TRUE), '@paths' => $this->displayArray($result, TRUE))));
+      $this->assertEqual($expected, $result, format_string('Expected reverse paths for vertex @vertex: @expected-paths, got @paths', array('@vertex' => $vertex, '@expected-paths' => $this->displayArray($expected, TRUE), '@paths' => $this->displayArray($result, TRUE))));
     }
   }
 
@@ -153,9 +153,9 @@ class GraphUnitTest extends DrupalUnitTestCase {
         $result_components[] = $graph[$vertex]['component'];
         unset($unassigned_vertices[$vertex]);
       }
-      $this->assertEqual(1, count(array_unique($result_components)), t('Expected one unique component for vertices @vertices, got @components', array('@vertices' => $this->displayArray($component), '@components' => $this->displayArray($result_components))));
+      $this->assertEqual(1, count(array_unique($result_components)), format_string('Expected one unique component for vertices @vertices, got @components', array('@vertices' => $this->displayArray($component), '@components' => $this->displayArray($result_components))));
     }
-    $this->assertEqual(array(), $unassigned_vertices, t('Vertices not assigned to a component: @vertices', array('@vertices' => $this->displayArray($unassigned_vertices, TRUE))));
+    $this->assertEqual(array(), $unassigned_vertices, format_string('Vertices not assigned to a component: @vertices', array('@vertices' => $this->displayArray($unassigned_vertices, TRUE))));
   }
 
   /**
@@ -170,7 +170,7 @@ class GraphUnitTest extends DrupalUnitTestCase {
     foreach ($expected_orders as $order) {
       $previous_vertex = array_shift($order);
       foreach ($order as $vertex) {
-        $this->assertTrue($graph[$previous_vertex]['weight'] < $graph[$vertex]['weight'], t('Weights of @previous-vertex and @vertex are correct relative to each other', array('@previous-vertex' => $previous_vertex, '@vertex' => $vertex)));
+        $this->assertTrue($graph[$previous_vertex]['weight'] < $graph[$vertex]['weight'], format_string('Weights of @previous-vertex and @vertex are correct relative to each other', array('@previous-vertex' => $previous_vertex, '@vertex' => $vertex)));
       }
     }
   }
diff --git a/modules/simpletest/tests/image.test b/modules/simpletest/tests/image.test
index 403c9d7..dc95a6e 100644
--- a/modules/simpletest/tests/image.test
+++ b/modules/simpletest/tests/image.test
@@ -55,19 +55,19 @@ class ImageToolkitTestCase extends DrupalWebTestCase {
     // Determine if there were any expected that were not called.
     $uncalled = array_diff($expected, $actual);
     if (count($uncalled)) {
-      $this->assertTrue(FALSE, t('Expected operations %expected to be called but %uncalled was not called.', array('%expected' => implode(', ', $expected), '%uncalled' => implode(', ', $uncalled))));
+      $this->assertTrue(FALSE, format_string('Expected operations %expected to be called but %uncalled was not called.', array('%expected' => implode(', ', $expected), '%uncalled' => implode(', ', $uncalled))));
     }
     else {
-      $this->assertTrue(TRUE, t('All the expected operations were called: %expected', array('%expected' => implode(', ', $expected))));
+      $this->assertTrue(TRUE, format_string('All the expected operations were called: %expected', array('%expected' => implode(', ', $expected))));
     }
 
     // Determine if there were any unexpected calls.
     $unexpected = array_diff($actual, $expected);
     if (count($unexpected)) {
-      $this->assertTrue(FALSE, t('Unexpected operations were called: %unexpected.', array('%unexpected' => implode(', ', $unexpected))));
+      $this->assertTrue(FALSE, format_string('Unexpected operations were called: %unexpected.', array('%unexpected' => implode(', ', $unexpected))));
     }
     else {
-      $this->assertTrue(TRUE, t('No unexpected operations were called.'));
+      $this->assertTrue(TRUE, 'No unexpected operations were called.');
     }
   }
 }
@@ -90,8 +90,8 @@ class ImageToolkitUnitTest extends ImageToolkitTestCase {
    */
   function testGetAvailableToolkits() {
     $toolkits = image_get_available_toolkits();
-    $this->assertTrue(isset($toolkits['test']), t('The working toolkit was returned.'));
-    $this->assertFalse(isset($toolkits['broken']), t('The toolkit marked unavailable was not returned'));
+    $this->assertTrue(isset($toolkits['test']), 'The working toolkit was returned.');
+    $this->assertFalse(isset($toolkits['broken']), 'The toolkit marked unavailable was not returned');
     $this->assertToolkitOperationsCalled(array());
   }
 
@@ -100,8 +100,8 @@ class ImageToolkitUnitTest extends ImageToolkitTestCase {
    */
   function testLoad() {
     $image = image_load($this->file, $this->toolkit);
-    $this->assertTrue(is_object($image), t('Returned an object.'));
-    $this->assertEqual($this->toolkit, $image->toolkit, t('Image had toolkit set.'));
+    $this->assertTrue(is_object($image), 'Returned an object.');
+    $this->assertEqual($this->toolkit, $image->toolkit, 'Image had toolkit set.');
     $this->assertToolkitOperationsCalled(array('load', 'get_info'));
   }
 
@@ -109,7 +109,7 @@ class ImageToolkitUnitTest extends ImageToolkitTestCase {
    * Test the image_save() function.
    */
   function testSave() {
-    $this->assertFalse(image_save($this->image), t('Function returned the expected value.'));
+    $this->assertFalse(image_save($this->image), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('save'));
   }
 
@@ -117,13 +117,13 @@ class ImageToolkitUnitTest extends ImageToolkitTestCase {
    * Test the image_resize() function.
    */
   function testResize() {
-    $this->assertTrue(image_resize($this->image, 1, 2), t('Function returned the expected value.'));
+    $this->assertTrue(image_resize($this->image, 1, 2), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('resize'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['resize'][0][1], 1, t('Width was passed correctly'));
-    $this->assertEqual($calls['resize'][0][2], 2, t('Height was passed correctly'));
+    $this->assertEqual($calls['resize'][0][1], 1, 'Width was passed correctly');
+    $this->assertEqual($calls['resize'][0][2], 2, 'Height was passed correctly');
   }
 
   /**
@@ -131,69 +131,69 @@ class ImageToolkitUnitTest extends ImageToolkitTestCase {
    */
   function testScale() {
 // TODO: need to test upscaling
-    $this->assertTrue(image_scale($this->image, 10, 10), t('Function returned the expected value.'));
+    $this->assertTrue(image_scale($this->image, 10, 10), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('resize'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['resize'][0][1], 10, t('Width was passed correctly'));
-    $this->assertEqual($calls['resize'][0][2], 5, t('Height was based off aspect ratio and passed correctly'));
+    $this->assertEqual($calls['resize'][0][1], 10, 'Width was passed correctly');
+    $this->assertEqual($calls['resize'][0][2], 5, 'Height was based off aspect ratio and passed correctly');
   }
 
   /**
    * Test the image_scale_and_crop() function.
    */
   function testScaleAndCrop() {
-    $this->assertTrue(image_scale_and_crop($this->image, 5, 10), t('Function returned the expected value.'));
+    $this->assertTrue(image_scale_and_crop($this->image, 5, 10), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('resize', 'crop'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
 
-    $this->assertEqual($calls['crop'][0][1], 7.5, t('X was computed and passed correctly'));
-    $this->assertEqual($calls['crop'][0][2], 0, t('Y was computed and passed correctly'));
-    $this->assertEqual($calls['crop'][0][3], 5, t('Width was computed and passed correctly'));
-    $this->assertEqual($calls['crop'][0][4], 10, t('Height was computed and passed correctly'));
+    $this->assertEqual($calls['crop'][0][1], 7.5, 'X was computed and passed correctly');
+    $this->assertEqual($calls['crop'][0][2], 0, 'Y was computed and passed correctly');
+    $this->assertEqual($calls['crop'][0][3], 5, 'Width was computed and passed correctly');
+    $this->assertEqual($calls['crop'][0][4], 10, 'Height was computed and passed correctly');
   }
 
   /**
    * Test the image_rotate() function.
    */
   function testRotate() {
-    $this->assertTrue(image_rotate($this->image, 90, 1), t('Function returned the expected value.'));
+    $this->assertTrue(image_rotate($this->image, 90, 1), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('rotate'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['rotate'][0][1], 90, t('Degrees were passed correctly'));
-    $this->assertEqual($calls['rotate'][0][2], 1, t('Background color was passed correctly'));
+    $this->assertEqual($calls['rotate'][0][1], 90, 'Degrees were passed correctly');
+    $this->assertEqual($calls['rotate'][0][2], 1, 'Background color was passed correctly');
   }
 
   /**
    * Test the image_crop() function.
    */
   function testCrop() {
-    $this->assertTrue(image_crop($this->image, 1, 2, 3, 4), t('Function returned the expected value.'));
+    $this->assertTrue(image_crop($this->image, 1, 2, 3, 4), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('crop'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual($calls['crop'][0][1], 1, t('X was passed correctly'));
-    $this->assertEqual($calls['crop'][0][2], 2, t('Y was passed correctly'));
-    $this->assertEqual($calls['crop'][0][3], 3, t('Width was passed correctly'));
-    $this->assertEqual($calls['crop'][0][4], 4, t('Height was passed correctly'));
+    $this->assertEqual($calls['crop'][0][1], 1, 'X was passed correctly');
+    $this->assertEqual($calls['crop'][0][2], 2, 'Y was passed correctly');
+    $this->assertEqual($calls['crop'][0][3], 3, 'Width was passed correctly');
+    $this->assertEqual($calls['crop'][0][4], 4, 'Height was passed correctly');
   }
 
   /**
    * Test the image_desaturate() function.
    */
   function testDesaturate() {
-    $this->assertTrue(image_desaturate($this->image), t('Function returned the expected value.'));
+    $this->assertTrue(image_desaturate($this->image), 'Function returned the expected value.');
     $this->assertToolkitOperationsCalled(array('desaturate'));
 
     // Check the parameters.
     $calls = image_test_get_all_calls();
-    $this->assertEqual(count($calls['desaturate'][0]), 1, t('Only the image was passed.'));
+    $this->assertEqual(count($calls['desaturate'][0]), 1, 'Only the image was passed.');
   }
 }
 
@@ -453,11 +453,11 @@ class ImageToolkitGdTestCase extends DrupalWebTestCase {
         file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
         image_save($image, $directory . '/' . $op . '.' . $image->info['extension']);
 
-        $this->assertTrue($correct_dimensions_real, t('Image %file after %action action has proper dimensions.', array('%file' => $file, '%action' => $op)));
-        $this->assertTrue($correct_dimensions_object, t('Image %file object after %action action is reporting the proper height and width values.', array('%file' => $file, '%action' => $op)));
+        $this->assertTrue($correct_dimensions_real, format_string('Image %file after %action action has proper dimensions.', array('%file' => $file, '%action' => $op)));
+        $this->assertTrue($correct_dimensions_object, format_string('Image %file object after %action action is reporting the proper height and width values.', array('%file' => $file, '%action' => $op)));
         // JPEG colors will always be messed up due to compression.
         if ($image->info['extension'] != 'jpg') {
-          $this->assertTrue($correct_colors, t('Image %file object after %action action has the correct color placement.', array('%file' => $file, '%action' => $op)));
+          $this->assertTrue($correct_colors, format_string('Image %file object after %action action has the correct color placement.', array('%file' => $file, '%action' => $op)));
         }
       }
     }
diff --git a/modules/simpletest/tests/lock.test b/modules/simpletest/tests/lock.test
index 0b423ff..797befc 100644
--- a/modules/simpletest/tests/lock.test
+++ b/modules/simpletest/tests/lock.test
@@ -23,35 +23,35 @@ class LockFunctionalTest extends DrupalWebTestCase {
   function testLockAcquire() {
     $lock_acquired = 'TRUE: Lock successfully acquired in system_test_lock_acquire()';
     $lock_not_acquired = 'FALSE: Lock not acquired in system_test_lock_acquire()';
-    $this->assertTrue(lock_acquire('system_test_lock_acquire'), t('Lock acquired by this request.'), t('Lock'));
-    $this->assertTrue(lock_acquire('system_test_lock_acquire'), t('Lock extended by this request.'), t('Lock'));
+    $this->assertTrue(lock_acquire('system_test_lock_acquire'), 'Lock acquired by this request.', 'Lock');
+    $this->assertTrue(lock_acquire('system_test_lock_acquire'), 'Lock extended by this request.', 'Lock');
     lock_release('system_test_lock_acquire');
 
     // Cause another request to acquire the lock.
     $this->drupalGet('system-test/lock-acquire');
-    $this->assertText($lock_acquired, t('Lock acquired by the other request.'), t('Lock'));
+    $this->assertText($lock_acquired, 'Lock acquired by the other request.', 'Lock');
     // The other request has finished, thus it should have released its lock.
-    $this->assertTrue(lock_acquire('system_test_lock_acquire'), t('Lock acquired by this request.'), t('Lock'));
+    $this->assertTrue(lock_acquire('system_test_lock_acquire'), 'Lock acquired by this request.', 'Lock');
     // This request holds the lock, so the other request cannot acquire it.
     $this->drupalGet('system-test/lock-acquire');
-    $this->assertText($lock_not_acquired, t('Lock not acquired by the other request.'), t('Lock'));
+    $this->assertText($lock_not_acquired, 'Lock not acquired by the other request.', 'Lock');
     lock_release('system_test_lock_acquire');
 
     // Try a very short timeout and lock breaking.
-    $this->assertTrue(lock_acquire('system_test_lock_acquire', 0.5), t('Lock acquired by this request.'), t('Lock'));
+    $this->assertTrue(lock_acquire('system_test_lock_acquire', 0.5), 'Lock acquired by this request.', 'Lock');
     sleep(1);
     // The other request should break our lock.
     $this->drupalGet('system-test/lock-acquire');
-    $this->assertText($lock_acquired, t('Lock acquired by the other request, breaking our lock.'), t('Lock'));
+    $this->assertText($lock_acquired, 'Lock acquired by the other request, breaking our lock.', 'Lock');
     // We cannot renew it, since the other thread took it.
-    $this->assertFalse(lock_acquire('system_test_lock_acquire'), t('Lock cannot be extended by this request.'), t('Lock'));
+    $this->assertFalse(lock_acquire('system_test_lock_acquire'), 'Lock cannot be extended by this request.', 'Lock');
 
     // Check the shut-down function.
     $lock_acquired_exit = 'TRUE: Lock successfully acquired in system_test_lock_exit()';
     $lock_not_acquired_exit = 'FALSE: Lock not acquired in system_test_lock_exit()';
     $this->drupalGet('system-test/lock-exit');
-    $this->assertText($lock_acquired_exit, t('Lock acquired by the other request before exit.'), t('Lock'));
-    $this->assertTrue(lock_acquire('system_test_lock_exit'), t('Lock acquired by this request after the other request exits.'), t('Lock'));
+    $this->assertText($lock_acquired_exit, 'Lock acquired by the other request before exit.', 'Lock');
+    $this->assertTrue(lock_acquire('system_test_lock_exit'), 'Lock acquired by this request after the other request exits.', 'Lock');
   }
 }
 
diff --git a/modules/simpletest/tests/mail.test b/modules/simpletest/tests/mail.test
index b7ce685..8024010 100644
--- a/modules/simpletest/tests/mail.test
+++ b/modules/simpletest/tests/mail.test
@@ -38,7 +38,7 @@ class MailTestCase extends DrupalWebTestCase implements MailSystemInterface {
     $message = drupal_mail('simpletest', 'mail_test', 'testing@example.com', $language);
 
     // Assert whether the message was sent through the send function.
-    $this->assertEqual(self::$sent_message['to'], 'testing@example.com', t('Pluggable mail system is extendable.'));
+    $this->assertEqual(self::$sent_message['to'], 'testing@example.com', 'Pluggable mail system is extendable.');
   }
 
   /**
diff --git a/modules/simpletest/tests/menu.test b/modules/simpletest/tests/menu.test
index 1ecc1b1..52672c5 100644
--- a/modules/simpletest/tests/menu.test
+++ b/modules/simpletest/tests/menu.test
@@ -48,7 +48,7 @@ class MenuWebTestCase extends DrupalWebTestCase {
     // No parts must be left, or an expected "Home" will always pass.
     $pass = ($pass && empty($parts));
 
-    $this->assertTrue($pass, t('Breadcrumb %parts found on @path.', array(
+    $this->assertTrue($pass, format_string('Breadcrumb %parts found on @path.', array(
       '%parts' => implode(' » ', $trail),
       '@path' => $this->getUrl(),
     )));
@@ -78,7 +78,7 @@ class MenuWebTestCase extends DrupalWebTestCase {
           $i++;
         }
         $elements = $this->xpath($xpath);
-        $this->assertTrue(!empty($elements), t('Active trail to current page was found in menu tree.'));
+        $this->assertTrue(!empty($elements), 'Active trail to current page was found in menu tree.');
 
         // Append prefix for active link asserted below.
         $xpath .= '/following-sibling::ul/descendant::';
@@ -95,7 +95,7 @@ class MenuWebTestCase extends DrupalWebTestCase {
         ':title' => $active_link_title,
       );
       $elements = $this->xpath($xpath, $args);
-      $this->assertTrue(!empty($elements), t('Active link %title was found in menu tree, including active trail links %tree.', array(
+      $this->assertTrue(!empty($elements), format_string('Active link %title was found in menu tree, including active trail links %tree.', array(
         '%title' => $active_link_title,
         '%tree' => implode(' » ', $tree),
       )));
@@ -145,8 +145,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
    */
   function testTitleCallbackFalse() {
     $this->drupalGet('node');
-    $this->assertText('A title with @placeholder', t('Raw text found on the page'));
-    $this->assertNoText(t('A title with @placeholder', array('@placeholder' => 'some other text')), t('Text with placeholder substitutions not found.'));
+    $this->assertText('A title with @placeholder', 'Raw text found on the page');
+    $this->assertNoText(t('A title with @placeholder', array('@placeholder' => 'some other text')), 'Text with placeholder substitutions not found.');
   }
 
   /**
@@ -166,8 +166,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
    */
   function testThemeCallbackAdministrative() {
     $this->drupalGet('menu-test/theme-callback/use-admin-theme');
-    $this->assertText('Custom theme: seven. Actual theme: seven.', t('The administrative theme can be correctly set in a theme callback.'));
-    $this->assertRaw('seven/style.css', t("The administrative theme's CSS appears on the page."));
+    $this->assertText('Custom theme: seven. Actual theme: seven.', 'The administrative theme can be correctly set in a theme callback.');
+    $this->assertRaw('seven/style.css', "The administrative theme's CSS appears on the page.");
   }
 
   /**
@@ -175,8 +175,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
    */
   function testThemeCallbackInheritance() {
     $this->drupalGet('menu-test/theme-callback/use-admin-theme/inheritance');
-    $this->assertText('Custom theme: seven. Actual theme: seven. Theme callback inheritance is being tested.', t('Theme callback inheritance correctly uses the administrative theme.'));
-    $this->assertRaw('seven/style.css', t("The administrative theme's CSS appears on the page."));
+    $this->assertText('Custom theme: seven. Actual theme: seven. Theme callback inheritance is being tested.', 'Theme callback inheritance correctly uses the administrative theme.');
+    $this->assertRaw('seven/style.css', "The administrative theme's CSS appears on the page.");
   }
 
   /**
@@ -185,7 +185,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
    */
   function testFileInheritance() {
     $this->drupalGet('admin/config/development/file-inheritance');
-    $this->assertText('File inheritance test description', t('File inheritance works.'));
+    $this->assertText('File inheritance test description', 'File inheritance works.');
   }
 
   /**
@@ -208,14 +208,14 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     // For a regular user, the fact that the site is in maintenance mode means
     // we expect the theme callback system to be bypassed entirely.
     $this->drupalGet('menu-test/theme-callback/use-admin-theme');
-    $this->assertRaw('bartik/css/style.css', t("The maintenance theme's CSS appears on the page."));
+    $this->assertRaw('bartik/css/style.css', "The maintenance theme's CSS appears on the page.");
 
     // An administrator, however, should continue to see the requested theme.
     $admin_user = $this->drupalCreateUser(array('access site in maintenance mode'));
     $this->drupalLogin($admin_user);
     $this->drupalGet('menu-test/theme-callback/use-admin-theme');
-    $this->assertText('Custom theme: seven. Actual theme: seven.', t('The theme callback system is correctly triggered for an administrator when the site is in maintenance mode.'));
-    $this->assertRaw('seven/style.css', t("The administrative theme's CSS appears on the page."));
+    $this->assertText('Custom theme: seven. Actual theme: seven.', 'The theme callback system is correctly triggered for an administrator when the site is in maintenance mode.');
+    $this->assertRaw('seven/style.css', "The administrative theme's CSS appears on the page.");
   }
 
   /**
@@ -244,11 +244,11 @@ class MenuRouterTestCase extends DrupalWebTestCase {
 
     $this->drupalGet('user/login');
     // Check that we got to 'user'.
-    $this->assertTrue($this->url == url('user', array('absolute' => TRUE)), t("Logged-in user redirected to q=user on accessing q=user/login"));
+    $this->assertTrue($this->url == url('user', array('absolute' => TRUE)), "Logged-in user redirected to q=user on accessing q=user/login");
 
     // user/register should redirect to user/UID/edit.
     $this->drupalGet('user/register');
-    $this->assertTrue($this->url == url('user/' . $this->loggedInUser->uid . '/edit', array('absolute' => TRUE)), t("Logged-in user redirected to q=user/UID/edit on accessing q=user/register"));
+    $this->assertTrue($this->url == url('user/' . $this->loggedInUser->uid . '/edit', array('absolute' => TRUE)), "Logged-in user redirected to q=user/UID/edit on accessing q=user/register");
   }
 
   /**
@@ -257,14 +257,14 @@ class MenuRouterTestCase extends DrupalWebTestCase {
   function testThemeCallbackOptionalTheme() {
     // Request a theme that is not enabled.
     $this->drupalGet('menu-test/theme-callback/use-stark-theme');
-    $this->assertText('Custom theme: NONE. Actual theme: bartik.', t('The theme callback system falls back on the default theme when a theme that is not enabled is requested.'));
-    $this->assertRaw('bartik/css/style.css', t("The default theme's CSS appears on the page."));
+    $this->assertText('Custom theme: NONE. Actual theme: bartik.', 'The theme callback system falls back on the default theme when a theme that is not enabled is requested.');
+    $this->assertRaw('bartik/css/style.css', "The default theme's CSS appears on the page.");
 
     // Now enable the theme and request it again.
     theme_enable(array('stark'));
     $this->drupalGet('menu-test/theme-callback/use-stark-theme');
-    $this->assertText('Custom theme: stark. Actual theme: stark.', t('The theme callback system uses an optional theme once it has been enabled.'));
-    $this->assertRaw('stark/layout.css', t("The optional theme's CSS appears on the page."));
+    $this->assertText('Custom theme: stark. Actual theme: stark.', 'The theme callback system uses an optional theme once it has been enabled.');
+    $this->assertRaw('stark/layout.css', "The optional theme's CSS appears on the page.");
   }
 
   /**
@@ -272,8 +272,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
    */
   function testThemeCallbackFakeTheme() {
     $this->drupalGet('menu-test/theme-callback/use-fake-theme');
-    $this->assertText('Custom theme: NONE. Actual theme: bartik.', t('The theme callback system falls back on the default theme when a theme that does not exist is requested.'));
-    $this->assertRaw('bartik/css/style.css', t("The default theme's CSS appears on the page."));
+    $this->assertText('Custom theme: NONE. Actual theme: bartik.', 'The theme callback system falls back on the default theme when a theme that does not exist is requested.');
+    $this->assertRaw('bartik/css/style.css', "The default theme's CSS appears on the page.");
   }
 
   /**
@@ -281,8 +281,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
    */
   function testThemeCallbackNoThemeRequested() {
     $this->drupalGet('menu-test/theme-callback/no-theme-requested');
-    $this->assertText('Custom theme: NONE. Actual theme: bartik.', t('The theme callback system falls back on the default theme when no theme is requested.'));
-    $this->assertRaw('bartik/css/style.css', t("The default theme's CSS appears on the page."));
+    $this->assertText('Custom theme: NONE. Actual theme: bartik.', 'The theme callback system falls back on the default theme when no theme is requested.');
+    $this->assertRaw('bartik/css/style.css', "The default theme's CSS appears on the page.");
   }
 
   /**
@@ -297,8 +297,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     // Visit a page that does not implement a theme callback. The above request
     // should be honored.
     $this->drupalGet('menu-test/no-theme-callback');
-    $this->assertText('Custom theme: stark. Actual theme: stark.', t('The result of hook_custom_theme() is used as the theme for the current page.'));
-    $this->assertRaw('stark/layout.css', t("The Stark theme's CSS appears on the page."));
+    $this->assertText('Custom theme: stark. Actual theme: stark.', 'The result of hook_custom_theme() is used as the theme for the current page.');
+    $this->assertRaw('stark/layout.css', "The Stark theme's CSS appears on the page.");
   }
 
   /**
@@ -313,8 +313,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     // The menu "theme callback" should take precedence over a value set in
     // hook_custom_theme().
     $this->drupalGet('menu-test/theme-callback/use-admin-theme');
-    $this->assertText('Custom theme: seven. Actual theme: seven.', t('The result of hook_custom_theme() does not override what was set in a theme callback.'));
-    $this->assertRaw('seven/style.css', t("The Seven theme's CSS appears on the page."));
+    $this->assertText('Custom theme: seven. Actual theme: seven.', 'The result of hook_custom_theme() does not override what was set in a theme callback.');
+    $this->assertRaw('seven/style.css', "The Seven theme's CSS appears on the page.");
   }
 
   /**
@@ -348,19 +348,19 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     menu_link_maintain('menu_test', 'update', 'menu_test_maintain/1', 'Menu link updated');
     // Load a different page to be sure that we have up to date information.
     $this->drupalGet('menu_test_maintain/1');
-    $this->assertLink(t('Menu link updated'), 0, t('Found updated menu link'));
-    $this->assertNoLink(t('Menu link #1'), 0, t('Not found menu link #1'));
-    $this->assertNoLink(t('Menu link #1'), 0, t('Not found menu link #1-1'));
-    $this->assertLink(t('Menu link #2'), 0, t('Found menu link #2'));
+    $this->assertLink(t('Menu link updated'), 0, 'Found updated menu link');
+    $this->assertNoLink(t('Menu link #1'), 0, 'Not found menu link #1');
+    $this->assertNoLink(t('Menu link #1'), 0, 'Not found menu link #1-1');
+    $this->assertLink(t('Menu link #2'), 0, 'Found menu link #2');
 
     // Delete all links for the given path.
     menu_link_maintain('menu_test', 'delete', 'menu_test_maintain/1', '');
     // Load a different page to be sure that we have up to date information.
     $this->drupalGet('menu_test_maintain/2');
-    $this->assertNoLink(t('Menu link updated'), 0, t('Not found deleted menu link'));
-    $this->assertNoLink(t('Menu link #1'), 0, t('Not found menu link #1'));
-    $this->assertNoLink(t('Menu link #1'), 0, t('Not found menu link #1-1'));
-    $this->assertLink(t('Menu link #2'), 0, t('Found menu link #2'));
+    $this->assertNoLink(t('Menu link updated'), 0, 'Not found deleted menu link');
+    $this->assertNoLink(t('Menu link #1'), 0, 'Not found menu link #1');
+    $this->assertNoLink(t('Menu link #1'), 0, 'Not found menu link #1-1');
+    $this->assertLink(t('Menu link #2'), 0, 'Found menu link #2');
   }
 
   /**
@@ -397,7 +397,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
 
     $sql = "SELECT menu_name FROM {menu_links} WHERE router_path = 'menu_name_test'";
     $name = db_query($sql)->fetchField();
-    $this->assertEqual($name, 'original', t('Menu name is "original".'));
+    $this->assertEqual($name, 'original', 'Menu name is "original".');
 
     // Change the menu_name parameter in menu_test.module, then force a menu
     // rebuild.
@@ -406,7 +406,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
 
     $sql = "SELECT menu_name FROM {menu_links} WHERE router_path = 'menu_name_test'";
     $name = db_query($sql)->fetchField();
-    $this->assertEqual($name, 'changed', t('Menu name was successfully changed after rebuild.'));
+    $this->assertEqual($name, 'changed', 'Menu name was successfully changed after rebuild.');
   }
 
   /**
@@ -417,8 +417,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     $child_link = db_query('SELECT * FROM {menu_links} WHERE link_path = :link_path', array(':link_path' => 'menu-test/hierarchy/parent/child'))->fetchAssoc();
     $unattached_child_link = db_query('SELECT * FROM {menu_links} WHERE link_path = :link_path', array(':link_path' => 'menu-test/hierarchy/parent/child2/child'))->fetchAssoc();
 
-    $this->assertEqual($child_link['plid'], $parent_link['mlid'], t('The parent of a directly attached child is correct.'));
-    $this->assertEqual($unattached_child_link['plid'], $parent_link['mlid'], t('The parent of a non-directly attached child is correct.'));
+    $this->assertEqual($child_link['plid'], $parent_link['mlid'], 'The parent of a directly attached child is correct.');
+    $this->assertEqual($unattached_child_link['plid'], $parent_link['mlid'], 'The parent of a non-directly attached child is correct.');
   }
 
   /**
@@ -438,40 +438,40 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     $plid = $parent['mlid'];
 
     $link = $links['menu-test/hidden/menu/list'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/menu/add'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/menu/settings'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/menu/manage/%'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $parent = $links['menu-test/hidden/menu/manage/%'];
     $depth = $parent['depth'] + 1;
     $plid = $parent['mlid'];
 
     $link = $links['menu-test/hidden/menu/manage/%/list'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/menu/manage/%/add'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/menu/manage/%/edit'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/menu/manage/%/delete'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     // Verify links for two dynamic arguments.
     $links = db_select('menu_links', 'ml')
@@ -486,28 +486,28 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     $plid = $parent['mlid'];
 
     $link = $links['menu-test/hidden/block/list'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/block/add'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/block/manage/%/%'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $parent = $links['menu-test/hidden/block/manage/%/%'];
     $depth = $parent['depth'] + 1;
     $plid = $parent['mlid'];
 
     $link = $links['menu-test/hidden/block/manage/%/%/configure'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
 
     $link = $links['menu-test/hidden/block/manage/%/%/delete'];
-    $this->assertEqual($link['depth'], $depth, t('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
-    $this->assertEqual($link['plid'], $plid, t('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
+    $this->assertEqual($link['depth'], $depth, format_string('%path depth @link_depth is equal to @depth.', array('%path' => $link['router_path'], '@link_depth' => $link['depth'], '@depth' => $depth)));
+    $this->assertEqual($link['plid'], $plid, format_string('%path plid @link_plid is equal to @plid.', array('%path' => $link['router_path'], '@link_plid' => $link['plid'], '@plid' => $plid)));
   }
 
   /**
@@ -524,7 +524,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
   function testMenuSetItem() {
     $item = menu_get_item('node');
 
-    $this->assertEqual($item['path'], 'node', t("Path from menu_get_item('node') is equal to 'node'"), 'menu');
+    $this->assertEqual($item['path'], 'node', "Path from menu_get_item('node') is equal to 'node'", 'menu');
 
     // Modify the path for the item then save it.
     $item['path'] = 'node_test';
@@ -532,7 +532,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
 
     menu_set_item('node', $item);
     $compare_item = menu_get_item('node');
-    $this->assertEqual($compare_item, $item, t('Modified menu item is equal to newly retrieved menu item.'), 'menu');
+    $this->assertEqual($compare_item, $item, 'Modified menu item is equal to newly retrieved menu item.', 'menu');
   }
 
   /**
@@ -541,13 +541,13 @@ class MenuRouterTestCase extends DrupalWebTestCase {
   function testMenuItemHooks() {
     // Create an item.
     menu_link_maintain('menu_test', 'insert', 'menu_test_maintain/4', 'Menu link #4');
-    $this->assertEqual(menu_test_static_variable(), 'insert', t('hook_menu_link_insert() fired correctly'));
+    $this->assertEqual(menu_test_static_variable(), 'insert', 'hook_menu_link_insert() fired correctly');
     // Update the item.
     menu_link_maintain('menu_test', 'update', 'menu_test_maintain/4', 'Menu link updated');
-    $this->assertEqual(menu_test_static_variable(), 'update', t('hook_menu_link_update() fired correctly'));
+    $this->assertEqual(menu_test_static_variable(), 'update', 'hook_menu_link_update() fired correctly');
     // Delete the item.
     menu_link_maintain('menu_test', 'delete', 'menu_test_maintain/4', '');
-    $this->assertEqual(menu_test_static_variable(), 'delete', t('hook_menu_link_delete() fired correctly'));
+    $this->assertEqual(menu_test_static_variable(), 'delete', 'hook_menu_link_delete() fired correctly');
   }
 
   /**
@@ -572,8 +572,8 @@ class MenuRouterTestCase extends DrupalWebTestCase {
 
     // Load front page.
     $this->drupalGet('node');
-    $this->assertRaw('title="Test title attribute"', t('Title attribute of a menu link renders.'));
-    $this->assertRaw('testparam=testvalue', t('Query parameter added to menu link.'));
+    $this->assertRaw('title="Test title attribute"', 'Title attribute of a menu link renders.');
+    $this->assertRaw('testparam=testvalue', 'Query parameter added to menu link.');
   }
 
   /**
@@ -606,7 +606,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
     $this->drupalGet('menu-title-test/case' . $case_no);
     $this->assertResponse(200);
     $asserted_title = $override ? 'Alternative example title - Case ' . $case_no : 'Example title - Case ' . $case_no;
-    $this->assertTitle($asserted_title . ' | Drupal', t('Menu title is') . ': ' . $asserted_title, 'Menu');
+    $this->assertTitle($asserted_title . ' | Drupal', format_string('Menu title is: %title.', array('%title' => $asserted_title)), 'Menu');
   }
 
   /**
@@ -663,7 +663,7 @@ class MenuRouterTestCase extends DrupalWebTestCase {
 
     foreach ($expected as $router_path => $load_functions) {
       $router_item = $this->menuLoadRouter($router_path);
-      $this->assertIdentical(unserialize($router_item['load_functions']), $load_functions, t('Expected load functions for router %router_path' , array('%router_path' => $router_path)));
+      $this->assertIdentical(unserialize($router_item['load_functions']), $load_functions, format_string('Expected load functions for router %router_path' , array('%router_path' => $router_path)));
     }
   }
 }
@@ -744,7 +744,7 @@ class MenuLinksUnitTestCase extends DrupalWebTestCase {
 
       $menu_link = menu_link_load($mlid);
       menu_link_save($menu_link);
-      $this->assertEqual($menu_link['plid'], $plid, t('Menu link %mlid has parent of %plid, expected %expected_plid.', array('%mlid' => $mlid, '%plid' => $menu_link['plid'], '%expected_plid' => $plid)));
+      $this->assertEqual($menu_link['plid'], $plid, format_string('Menu link %mlid has parent of %plid, expected %expected_plid.', array('%mlid' => $mlid, '%plid' => $menu_link['plid'], '%expected_plid' => $plid)));
     }
   }
 
@@ -905,14 +905,14 @@ class MenuRebuildTestCase extends DrupalWebTestCase {
   function testMenuRebuildByVariable() {
     // Check if 'admin' path exists.
     $admin_exists = db_query('SELECT path from {menu_router} WHERE path = :path', array(':path' => 'admin'))->fetchField();
-    $this->assertEqual($admin_exists, 'admin', t("The path 'admin/' exists prior to deleting."));
+    $this->assertEqual($admin_exists, 'admin', "The path 'admin/' exists prior to deleting.");
 
     // Delete the path item 'admin', and test that the path doesn't exist in the database.
     $delete = db_delete('menu_router')
       ->condition('path', 'admin')
       ->execute();
     $admin_exists = db_query('SELECT path from {menu_router} WHERE path = :path', array(':path' => 'admin'))->fetchField();
-    $this->assertFalse($admin_exists, t("The path 'admin/' has been deleted and doesn't exist in the database."));
+    $this->assertFalse($admin_exists, "The path 'admin/' has been deleted and doesn't exist in the database.");
 
     // Now we enable the rebuild variable and trigger menu_execute_active_handler()
     // to rebuild the menu item. Now 'admin' should exist.
@@ -920,7 +920,7 @@ class MenuRebuildTestCase extends DrupalWebTestCase {
     // menu_execute_active_handler() should trigger the rebuild.
     $this->drupalGet('<front>');
     $admin_exists = db_query('SELECT path from {menu_router} WHERE path = :path', array(':path' => 'admin'))->fetchField();
-    $this->assertEqual($admin_exists, 'admin', t("The menu has been rebuilt, the path 'admin' now exists again."));
+    $this->assertEqual($admin_exists, 'admin', "The menu has been rebuilt, the path 'admin' now exists again.");
   }
 
 }
@@ -955,12 +955,12 @@ class MenuTreeDataTestCase extends DrupalUnitTestCase {
     $tree = menu_tree_data($this->links);
 
     // Validate that parent items #1, #2, and #5 exist on the root level.
-    $this->assertSameLink($this->links[1], $tree[1]['link'], t('Parent item #1 exists.'));
-    $this->assertSameLink($this->links[2], $tree[2]['link'], t('Parent item #2 exists.'));
-    $this->assertSameLink($this->links[5], $tree[5]['link'], t('Parent item #5 exists.'));
+    $this->assertSameLink($this->links[1], $tree[1]['link'], 'Parent item #1 exists.');
+    $this->assertSameLink($this->links[2], $tree[2]['link'], 'Parent item #2 exists.');
+    $this->assertSameLink($this->links[5], $tree[5]['link'], 'Parent item #5 exists.');
 
     // Validate that child item #4 exists at the correct location in the hierarchy.
-    $this->assertSameLink($this->links[4], $tree[2]['below'][3]['below'][4]['link'], t('Child item #4 exists in the hierarchy.'));
+    $this->assertSameLink($this->links[4], $tree[2]['below'][3]['below'][4]['link'], 'Child item #4 exists in the hierarchy.');
   }
 
   /**
@@ -976,7 +976,7 @@ class MenuTreeDataTestCase extends DrupalUnitTestCase {
    *   TRUE if the assertion succeeded, FALSE otherwise.
    */
   protected function assertSameLink($link1, $link2, $message = '') {
-    return $this->assert($link1['mlid'] == $link2['mlid'], $message ? $message : t('First link is identical to second link'));
+    return $this->assert($link1['mlid'] == $link2['mlid'], $message ? $message : 'First link is identical to second link');
   }
 }
 
@@ -1025,16 +1025,16 @@ class MenuTreeOutputTestCase extends DrupalWebTestCase {
     $output = menu_tree_output($this->tree_data);
 
     // Validate that the - in main-menu is changed into an underscore
-    $this->assertEqual( $output['1']['#theme'], 'menu_link__main_menu', t('Hyphen is changed to a dash on menu_link'));
-    $this->assertEqual( $output['#theme_wrappers'][0], 'menu_tree__main_menu', t('Hyphen is changed to a dash on menu_tree wrapper'));
+    $this->assertEqual( $output['1']['#theme'], 'menu_link__main_menu', 'Hyphen is changed to a dash on menu_link');
+    $this->assertEqual( $output['#theme_wrappers'][0], 'menu_tree__main_menu', 'Hyphen is changed to a dash on menu_tree wrapper');
     // Looking for child items in the data
-    $this->assertEqual( $output['1']['#below']['2']['#href'], 'a/b', t('Checking the href on a child item'));
-    $this->assertTrue( in_array('active-trail',$output['1']['#below']['2']['#attributes']['class']) , t('Checking the active trail class'));
+    $this->assertEqual( $output['1']['#below']['2']['#href'], 'a/b', 'Checking the href on a child item');
+    $this->assertTrue( in_array('active-trail',$output['1']['#below']['2']['#attributes']['class']) , 'Checking the active trail class');
     // Validate that the hidden and no access items are missing
-    $this->assertFalse( isset($output['5']), t('Hidden item should be missing'));
-    $this->assertFalse( isset($output['6']), t('False access should be missing'));
+    $this->assertFalse( isset($output['5']), 'Hidden item should be missing');
+    $this->assertFalse( isset($output['6']), 'False access should be missing');
     // Item 7 is after a couple hidden items. Just to make sure that 5 and 6 are skipped and 7 still included
-    $this->assertTrue( isset($output['7']), t('Item after hidden items is present'));
+    $this->assertTrue( isset($output['7']), 'Item after hidden items is present');
   }
 }
 
@@ -1698,13 +1698,13 @@ class MenuTrailTestCase extends MenuWebTestCase {
       // Check that the initial trail (during the Drupal bootstrap) matches
       // what we expect.
       $initial_trail = variable_get('menu_test_active_trail_initial', array());
-      $this->assertEqual(count($initial_trail), count($expected_trail[$status_code]['initial']), t('The initial active trail for a @status_code page contains the expected number of items (expected: @expected, found: @found).', array(
+      $this->assertEqual(count($initial_trail), count($expected_trail[$status_code]['initial']), format_string('The initial active trail for a @status_code page contains the expected number of items (expected: @expected, found: @found).', array(
         '@status_code' => $status_code,
         '@expected' => count($expected_trail[$status_code]['initial']),
         '@found' => count($initial_trail),
       )));
       foreach (array_keys($expected_trail[$status_code]['initial']) as $index => $path) {
-        $this->assertEqual($initial_trail[$index]['href'], $path, t('Element number @number of the initial active trail for a @status_code page contains the correct path (expected: @expected, found: @found)', array(
+        $this->assertEqual($initial_trail[$index]['href'], $path, format_string('Element number @number of the initial active trail for a @status_code page contains the correct path (expected: @expected, found: @found)', array(
           '@number' => $index + 1,
           '@status_code' => $status_code,
           '@expected' => $path,
@@ -1715,13 +1715,13 @@ class MenuTrailTestCase extends MenuWebTestCase {
       // Check that the final trail (after the user has been redirected to the
       // custom 403/404 page) matches what we expect.
       $final_trail = variable_get('menu_test_active_trail_final', array());
-      $this->assertEqual(count($final_trail), count($expected_trail[$status_code]['final']), t('The final active trail for a @status_code page contains the expected number of items (expected: @expected, found: @found).', array(
+      $this->assertEqual(count($final_trail), count($expected_trail[$status_code]['final']), format_string('The final active trail for a @status_code page contains the expected number of items (expected: @expected, found: @found).', array(
         '@status_code' => $status_code,
         '@expected' => count($expected_trail[$status_code]['final']),
         '@found' => count($final_trail),
       )));
       foreach (array_keys($expected_trail[$status_code]['final']) as $index => $path) {
-        $this->assertEqual($final_trail[$index]['href'], $path, t('Element number @number of the final active trail for a @status_code page contains the correct path (expected: @expected, found: @found)', array(
+        $this->assertEqual($final_trail[$index]['href'], $path, format_string('Element number @number of the final active trail for a @status_code page contains the correct path (expected: @expected, found: @found)', array(
           '@number' => $index + 1,
           '@status_code' => $status_code,
           '@expected' => $path,
diff --git a/modules/simpletest/tests/module.test b/modules/simpletest/tests/module.test
index 769c4cf..371339f 100644
--- a/modules/simpletest/tests/module.test
+++ b/modules/simpletest/tests/module.test
@@ -76,9 +76,9 @@ class ModuleUnitTest extends DrupalWebTestCase {
    */
   protected function assertModuleList(Array $expected_values, $condition) {
     $expected_values = array_combine($expected_values, $expected_values);
-    $this->assertEqual($expected_values, module_list(), t('@condition: module_list() returns correct results', array('@condition' => $condition)));
+    $this->assertEqual($expected_values, module_list(), format_string('@condition: module_list() returns correct results', array('@condition' => $condition)));
     ksort($expected_values);
-    $this->assertIdentical($expected_values, module_list(FALSE, FALSE, TRUE), t('@condition: module_list() returns correctly sorted results', array('@condition' => $condition)));
+    $this->assertIdentical($expected_values, module_list(FALSE, FALSE, TRUE), format_string('@condition: module_list() returns correctly sorted results', array('@condition' => $condition)));
   }
 
   /**
@@ -87,16 +87,16 @@ class ModuleUnitTest extends DrupalWebTestCase {
   function testModuleImplements() {
     // Clear the cache.
     cache_clear_all('module_implements', 'cache_bootstrap');
-    $this->assertFalse(cache_get('module_implements', 'cache_bootstrap'), t('The module implements cache is empty.'));
+    $this->assertFalse(cache_get('module_implements', 'cache_bootstrap'), 'The module implements cache is empty.');
     $this->drupalGet('');
-    $this->assertTrue(cache_get('module_implements', 'cache_bootstrap'), t('The module implements cache is populated after requesting a page.'));
+    $this->assertTrue(cache_get('module_implements', 'cache_bootstrap'), 'The module implements cache is populated after requesting a page.');
 
     // Test again with an authenticated user.
     $this->user = $this->drupalCreateUser();
     $this->drupalLogin($this->user);
     cache_clear_all('module_implements', 'cache_bootstrap');
     $this->drupalGet('');
-    $this->assertTrue(cache_get('module_implements', 'cache_bootstrap'), t('The module implements cache is populated after requesting a page.'));
+    $this->assertTrue(cache_get('module_implements', 'cache_bootstrap'), 'The module implements cache is populated after requesting a page.');
 
     // Make sure group include files are detected properly even when the file is
     // already loaded when the cache is rebuilt.
@@ -117,7 +117,7 @@ class ModuleUnitTest extends DrupalWebTestCase {
     module_enable(array('module_test'), FALSE);
     $this->resetAll();
     $this->drupalGet('module-test/hook-dynamic-loading-invoke');
-    $this->assertText('success!', t('module_invoke() dynamically loads a hook defined in hook_hook_info().'));
+    $this->assertText('success!', 'module_invoke() dynamically loads a hook defined in hook_hook_info().');
   }
 
   /**
@@ -127,7 +127,7 @@ class ModuleUnitTest extends DrupalWebTestCase {
     module_enable(array('module_test'), FALSE);
     $this->resetAll();
     $this->drupalGet('module-test/hook-dynamic-loading-invoke-all');
-    $this->assertText('success!', t('module_invoke_all() dynamically loads a hook defined in hook_hook_info().'));
+    $this->assertText('success!', 'module_invoke_all() dynamically loads a hook defined in hook_hook_info().');
   }
 
   /**
@@ -138,79 +138,79 @@ class ModuleUnitTest extends DrupalWebTestCase {
     // are not already enabled. (If they were, the tests below would not work
     // correctly.)
     module_enable(array('module_test'), FALSE);
-    $this->assertTrue(module_exists('module_test'), t('Test module is enabled.'));
-    $this->assertFalse(module_exists('forum'), t('Forum module is disabled.'));
-    $this->assertFalse(module_exists('poll'), t('Poll module is disabled.'));
-    $this->assertFalse(module_exists('php'), t('PHP module is disabled.'));
+    $this->assertTrue(module_exists('module_test'), 'Test module is enabled.');
+    $this->assertFalse(module_exists('forum'), 'Forum module is disabled.');
+    $this->assertFalse(module_exists('poll'), 'Poll module is disabled.');
+    $this->assertFalse(module_exists('php'), 'PHP module is disabled.');
 
     // First, create a fake missing dependency. Forum depends on poll, which
     // depends on a made-up module, foo. Nothing should be installed.
     variable_set('dependency_test', 'missing dependency');
     drupal_static_reset('system_rebuild_module_data');
     $result = module_enable(array('forum'));
-    $this->assertFalse($result, t('module_enable() returns FALSE if dependencies are missing.'));
-    $this->assertFalse(module_exists('forum'), t('module_enable() aborts if dependencies are missing.'));
+    $this->assertFalse($result, 'module_enable() returns FALSE if dependencies are missing.');
+    $this->assertFalse(module_exists('forum'), 'module_enable() aborts if dependencies are missing.');
 
     // Now, fix the missing dependency. Forum module depends on poll, but poll
     // depends on the PHP module. module_enable() should work.
     variable_set('dependency_test', 'dependency');
     drupal_static_reset('system_rebuild_module_data');
     $result = module_enable(array('forum'));
-    $this->assertTrue($result, t('module_enable() returns the correct value.'));
+    $this->assertTrue($result, 'module_enable() returns the correct value.');
     // Verify that the fake dependency chain was installed.
-    $this->assertTrue(module_exists('poll') && module_exists('php'), t('Dependency chain was installed by module_enable().'));
+    $this->assertTrue(module_exists('poll') && module_exists('php'), 'Dependency chain was installed by module_enable().');
     // Verify that the original module was installed.
-    $this->assertTrue(module_exists('forum'), t('Module installation with unlisted dependencies succeeded.'));
+    $this->assertTrue(module_exists('forum'), 'Module installation with unlisted dependencies succeeded.');
     // Finally, verify that the modules were enabled in the correct order.
-    $this->assertEqual(variable_get('test_module_enable_order', array()), array('php', 'poll', 'forum'), t('Modules were enabled in the correct order by module_enable().'));
+    $this->assertEqual(variable_get('test_module_enable_order', array()), array('php', 'poll', 'forum'), 'Modules were enabled in the correct order by module_enable().');
 
     // Now, disable the PHP module. Both forum and poll should be disabled as
     // well, in the correct order.
     module_disable(array('php'));
-    $this->assertTrue(!module_exists('forum') && !module_exists('poll'), t('Depedency chain was disabled by module_disable().'));
-    $this->assertFalse(module_exists('php'), t('Disabling a module with unlisted dependents succeeded.'));
-    $this->assertEqual(variable_get('test_module_disable_order', array()), array('forum', 'poll', 'php'), t('Modules were disabled in the correct order by module_disable().'));
+    $this->assertTrue(!module_exists('forum') && !module_exists('poll'), 'Depedency chain was disabled by module_disable().');
+    $this->assertFalse(module_exists('php'), 'Disabling a module with unlisted dependents succeeded.');
+    $this->assertEqual(variable_get('test_module_disable_order', array()), array('forum', 'poll', 'php'), 'Modules were disabled in the correct order by module_disable().');
 
     // Disable a module that is listed as a dependency by the installation
     // profile. Make sure that the profile itself is not on the list of
     // dependent modules to be disabled.
     $profile = drupal_get_profile();
     $info = install_profile_info($profile);
-    $this->assertTrue(in_array('comment', $info['dependencies']), t('Comment module is listed as a dependency of the installation profile.'));
-    $this->assertTrue(module_exists('comment'), t('Comment module is enabled.'));
+    $this->assertTrue(in_array('comment', $info['dependencies']), 'Comment module is listed as a dependency of the installation profile.');
+    $this->assertTrue(module_exists('comment'), 'Comment module is enabled.');
     module_disable(array('comment'));
-    $this->assertFalse(module_exists('comment'), t('Comment module was disabled.'));
+    $this->assertFalse(module_exists('comment'), 'Comment module was disabled.');
     $disabled_modules = variable_get('test_module_disable_order', array());
-    $this->assertTrue(in_array('comment', $disabled_modules), t('Comment module is in the list of disabled modules.'));
-    $this->assertFalse(in_array($profile, $disabled_modules), t('The installation profile is not in the list of disabled modules.'));
+    $this->assertTrue(in_array('comment', $disabled_modules), 'Comment module is in the list of disabled modules.');
+    $this->assertFalse(in_array($profile, $disabled_modules), 'The installation profile is not in the list of disabled modules.');
 
     // Try to uninstall the PHP module by itself. This should be rejected,
     // since the modules which it depends on need to be uninstalled first, and
     // that is too destructive to perform automatically.
     $result = drupal_uninstall_modules(array('php'));
-    $this->assertFalse($result, t('Calling drupal_uninstall_modules() on a module whose dependents are not uninstalled fails.'));
+    $this->assertFalse($result, 'Calling drupal_uninstall_modules() on a module whose dependents are not uninstalled fails.');
     foreach (array('forum', 'poll', 'php') as $module) {
-      $this->assertNotEqual(drupal_get_installed_schema_version($module), SCHEMA_UNINSTALLED, t('The @module module was not uninstalled.', array('@module' => $module)));
+      $this->assertNotEqual(drupal_get_installed_schema_version($module), SCHEMA_UNINSTALLED, format_string('The @module module was not uninstalled.', array('@module' => $module)));
     }
 
     // Now uninstall all three modules explicitly, but in the incorrect order,
     // and make sure that drupal_uninstal_modules() uninstalled them in the
     // correct sequence.
     $result = drupal_uninstall_modules(array('poll', 'php', 'forum'));
-    $this->assertTrue($result, t('drupal_uninstall_modules() returns the correct value.'));
+    $this->assertTrue($result, 'drupal_uninstall_modules() returns the correct value.');
     foreach (array('forum', 'poll', 'php') as $module) {
-      $this->assertEqual(drupal_get_installed_schema_version($module), SCHEMA_UNINSTALLED, t('The @module module was uninstalled.', array('@module' => $module)));
+      $this->assertEqual(drupal_get_installed_schema_version($module), SCHEMA_UNINSTALLED, format_string('The @module module was uninstalled.', array('@module' => $module)));
     }
-    $this->assertEqual(variable_get('test_module_uninstall_order', array()), array('forum', 'poll', 'php'), t('Modules were uninstalled in the correct order by drupal_uninstall_modules().'));
+    $this->assertEqual(variable_get('test_module_uninstall_order', array()), array('forum', 'poll', 'php'), 'Modules were uninstalled in the correct order by drupal_uninstall_modules().');
 
     // Uninstall the profile module from above, and make sure that the profile
     // itself is not on the list of dependent modules to be uninstalled.
     $result = drupal_uninstall_modules(array('comment'));
-    $this->assertTrue($result, t('drupal_uninstall_modules() returns the correct value.'));
-    $this->assertEqual(drupal_get_installed_schema_version('comment'), SCHEMA_UNINSTALLED, t('Comment module was uninstalled.'));
+    $this->assertTrue($result, 'drupal_uninstall_modules() returns the correct value.');
+    $this->assertEqual(drupal_get_installed_schema_version('comment'), SCHEMA_UNINSTALLED, 'Comment module was uninstalled.');
     $uninstalled_modules = variable_get('test_module_uninstall_order', array());
-    $this->assertTrue(in_array('comment', $uninstalled_modules), t('Comment module is in the list of uninstalled modules.'));
-    $this->assertFalse(in_array($profile, $uninstalled_modules), t('The installation profile is not in the list of uninstalled modules.'));
+    $this->assertTrue(in_array('comment', $uninstalled_modules), 'Comment module is in the list of uninstalled modules.');
+    $this->assertFalse(in_array($profile, $uninstalled_modules), 'The installation profile is not in the list of uninstalled modules.');
 
     // Enable forum module again, which should enable both the poll module and
     // php module. But, this time do it with poll module declaring a dependency
@@ -219,11 +219,11 @@ class ModuleUnitTest extends DrupalWebTestCase {
     variable_set('dependency_test', 'version dependency');
     drupal_static_reset('system_rebuild_module_data');
     $result = module_enable(array('forum'));
-    $this->assertTrue($result, t('module_enable() returns the correct value.'));
+    $this->assertTrue($result, 'module_enable() returns the correct value.');
     // Verify that the fake dependency chain was installed.
-    $this->assertTrue(module_exists('poll') && module_exists('php'), t('Dependency chain was installed by module_enable().'));
+    $this->assertTrue(module_exists('poll') && module_exists('php'), 'Dependency chain was installed by module_enable().');
     // Verify that the original module was installed.
-    $this->assertTrue(module_exists('forum'), t('Module installation with version dependencies succeeded.'));
+    $this->assertTrue(module_exists('forum'), 'Module installation with version dependencies succeeded.');
     // Finally, verify that the modules were enabled in the correct order.
     $enable_order = variable_get('test_module_enable_order', array());
     $php_position = array_search('php', $enable_order);
@@ -231,7 +231,7 @@ class ModuleUnitTest extends DrupalWebTestCase {
     $forum_position = array_search('forum', $enable_order);
     $php_before_poll = $php_position !== FALSE && $poll_position !== FALSE && $php_position < $poll_position;
     $poll_before_forum = $poll_position !== FALSE && $forum_position !== FALSE && $poll_position < $forum_position;
-    $this->assertTrue($php_before_poll && $poll_before_forum, t('Modules were enabled in the correct order by module_enable().'));
+    $this->assertTrue($php_before_poll && $poll_before_forum, 'Modules were enabled in the correct order by module_enable().');
   }
 }
 
@@ -267,8 +267,8 @@ class ModuleInstallTestCase extends DrupalWebTestCase {
     // Check for data that was inserted using drupal_write_record() while the
     // 'module_test' module was being installed and enabled.
     $data = db_query("SELECT data FROM {module_test}")->fetchCol();
-    $this->assertTrue(in_array('Data inserted in hook_install()', $data), t('Data inserted using drupal_write_record() in hook_install() is correctly saved.'));
-    $this->assertTrue(in_array('Data inserted in hook_enable()', $data), t('Data inserted using drupal_write_record() in hook_enable() is correctly saved.'));
+    $this->assertTrue(in_array('Data inserted in hook_install()', $data), 'Data inserted using drupal_write_record() in hook_install() is correctly saved.');
+    $this->assertTrue(in_array('Data inserted in hook_enable()', $data), 'Data inserted using drupal_write_record() in hook_enable() is correctly saved.');
   }
 }
 
@@ -299,6 +299,6 @@ class ModuleUninstallTestCase extends DrupalWebTestCase {
 
     // Are the perms defined by module_test removed from {role_permission}.
     $count = db_query("SELECT COUNT(rid) FROM {role_permission} WHERE permission = :perm", array(':perm' => 'module_test perm'))->fetchField();
-    $this->assertEqual(0, $count, t('Permissions were all removed.'));
+    $this->assertEqual(0, $count, 'Permissions were all removed.');
   }
 }
diff --git a/modules/simpletest/tests/pager.test b/modules/simpletest/tests/pager.test
index 6fdeec5..6e8ce8e 100644
--- a/modules/simpletest/tests/pager.test
+++ b/modules/simpletest/tests/pager.test
@@ -101,24 +101,24 @@ class PagerFunctionalWebTestCase extends DrupalWebTestCase {
 
     // Verify first/previous and next/last items and links.
     if (isset($first)) {
-      $this->assertClass($first, 'pager-first', "Item for first page has .pager-first class.");
-      $this->assertTrue($first->a, "Link to first page found.");
-      $this->assertNoClass($first->a, 'active', "Link to first page is not active.");
+      $this->assertClass($first, 'pager-first', 'Item for first page has .pager-first class.');
+      $this->assertTrue($first->a, 'Link to first page found.');
+      $this->assertNoClass($first->a, 'active', 'Link to first page is not active.');
     }
     if (isset($previous)) {
-      $this->assertClass($previous, 'pager-previous', "Item for first page has .pager-previous class.");
-      $this->assertTrue($previous->a, "Link to previous page found.");
-      $this->assertNoClass($previous->a, 'active', "Link to previous page is not active.");
+      $this->assertClass($previous, 'pager-previous', 'Item for first page has .pager-previous class.');
+      $this->assertTrue($previous->a, 'Link to previous page found.');
+      $this->assertNoClass($previous->a, 'active', 'Link to previous page is not active.');
     }
     if (isset($next)) {
-      $this->assertClass($next, 'pager-next', "Item for next page has .pager-next class.");
-      $this->assertTrue($next->a, "Link to next page found.");
-      $this->assertNoClass($next->a, 'active', "Link to next page is not active.");
+      $this->assertClass($next, 'pager-next', 'Item for next page has .pager-next class.');
+      $this->assertTrue($next->a, 'Link to next page found.');
+      $this->assertNoClass($next->a, 'active', 'Link to next page is not active.');
     }
     if (isset($last)) {
-      $this->assertClass($last, 'pager-last', "Item for last page has .pager-last class.");
-      $this->assertTrue($last->a, "Link to last page found.");
-      $this->assertNoClass($last->a, 'active', "Link to last page is not active.");
+      $this->assertClass($last, 'pager-last', 'Item for last page has .pager-last class.');
+      $this->assertTrue($last->a, 'Link to last page found.');
+      $this->assertNoClass($last->a, 'active', 'Link to last page is not active.');
     }
   }
 
diff --git a/modules/simpletest/tests/password.test b/modules/simpletest/tests/password.test
index e100c2e..5259d19 100644
--- a/modules/simpletest/tests/password.test
+++ b/modules/simpletest/tests/password.test
@@ -35,26 +35,26 @@ class PasswordHashingTest extends DrupalWebTestCase {
     $password = 'baz';
     $account = (object) array('name' => 'foo', 'pass' => md5($password));
     // The md5 password should be flagged as needing an update.
-    $this->assertTrue(user_needs_new_hash($account), t('User with md5 password needs a new hash.'));
+    $this->assertTrue(user_needs_new_hash($account), 'User with md5 password needs a new hash.');
     // Re-hash the password.
     $old_hash = $account->pass;
     $account->pass = user_hash_password($password);
-    $this->assertIdentical(_password_get_count_log2($account->pass), DRUPAL_MIN_HASH_COUNT, t('Re-hashed password has the minimum number of log2 iterations.'));
-    $this->assertTrue($account->pass != $old_hash, t('Password hash changed.'));
-    $this->assertTrue(user_check_password($password, $account), t('Password check succeeds.'));
+    $this->assertIdentical(_password_get_count_log2($account->pass), DRUPAL_MIN_HASH_COUNT, 'Re-hashed password has the minimum number of log2 iterations.');
+    $this->assertTrue($account->pass != $old_hash, 'Password hash changed.');
+    $this->assertTrue(user_check_password($password, $account), 'Password check succeeds.');
     // Since the log2 setting hasn't changed and the user has a valid password,
     // user_needs_new_hash() should return FALSE.
-    $this->assertFalse(user_needs_new_hash($account), t('User does not need a new hash.'));
+    $this->assertFalse(user_needs_new_hash($account), 'User does not need a new hash.');
     // Increment the log2 iteration to MIN + 1.
     variable_set('password_count_log2', DRUPAL_MIN_HASH_COUNT + 1);
-    $this->assertTrue(user_needs_new_hash($account), t('User needs a new hash after incrementing the log2 count.'));
+    $this->assertTrue(user_needs_new_hash($account), 'User needs a new hash after incrementing the log2 count.');
     // Re-hash the password.
     $old_hash = $account->pass;
     $account->pass = user_hash_password($password);
-    $this->assertIdentical(_password_get_count_log2($account->pass), DRUPAL_MIN_HASH_COUNT + 1, t('Re-hashed password has the correct number of log2 iterations.'));
-    $this->assertTrue($account->pass != $old_hash, t('Password hash changed again.'));
+    $this->assertIdentical(_password_get_count_log2($account->pass), DRUPAL_MIN_HASH_COUNT + 1, 'Re-hashed password has the correct number of log2 iterations.');
+    $this->assertTrue($account->pass != $old_hash, 'Password hash changed again.');
     // Now the hash should be OK.
-    $this->assertFalse(user_needs_new_hash($account), t('Re-hashed password does not need a new hash.'));
-    $this->assertTrue(user_check_password($password, $account), t('Password check succeeds with re-hashed password.'));
+    $this->assertFalse(user_needs_new_hash($account), 'Re-hashed password does not need a new hash.');
+    $this->assertTrue(user_check_password($password, $account), 'Password check succeeds with re-hashed password.');
   }
 }
diff --git a/modules/simpletest/tests/path.test b/modules/simpletest/tests/path.test
index a506349..b8b3c93 100644
--- a/modules/simpletest/tests/path.test
+++ b/modules/simpletest/tests/path.test
@@ -41,7 +41,7 @@ class DrupalMatchPathTestCase extends DrupalWebTestCase {
     foreach ($tests as $patterns => $cases) {
       foreach ($cases as $path => $expected_result) {
         $actual_result = drupal_match_path($path, $patterns);
-        $this->assertIdentical($actual_result, $expected_result, t('Tried matching the path <code>@path</code> to the pattern <pre>@patterns</pre> - expected @expected, got @actual.', array('@path' => $path, '@patterns' => $patterns, '@expected' => var_export($expected_result, TRUE), '@actual' => var_export($actual_result, TRUE))));
+        $this->assertIdentical($actual_result, $expected_result, format_string('Tried matching the path <code>@path</code> to the pattern <pre>@patterns</pre> - expected @expected, got @actual.', array('@path' => $path, '@patterns' => $patterns, '@expected' => var_export($expected_result, TRUE), '@actual' => var_export($actual_result, TRUE))));
       }
     }
   }
@@ -196,8 +196,8 @@ class UrlAlterFunctionalTest extends DrupalWebTestCase {
    */
   function testCurrentUrlRequestedPath() {
     $this->drupalGet('url-alter-test/bar');
-    $this->assertRaw('request_path=url-alter-test/bar', t('request_path() returns the requested path.'));
-    $this->assertRaw('current_path=url-alter-test/foo', t('current_path() returns the internal path.'));
+    $this->assertRaw('request_path=url-alter-test/bar', 'request_path() returns the requested path.');
+    $this->assertRaw('current_path=url-alter-test/foo', 'current_path() returns the internal path.');
   }
 
   /**
@@ -223,7 +223,7 @@ class UrlAlterFunctionalTest extends DrupalWebTestCase {
     $result = url($original);
     $base_path = base_path() . (variable_get('clean_url', '0') ? '' : '?q=');
     $result = substr($result, strlen($base_path));
-    $this->assertIdentical($result, $final, t('Altered outbound URL %original, expected %final, and got %result.', array('%original' => $original, '%final' => $final, '%result' => $result)));
+    $this->assertIdentical($result, $final, format_string('Altered outbound URL %original, expected %final, and got %result.', array('%original' => $original, '%final' => $final, '%result' => $result)));
   }
 
   /**
@@ -240,7 +240,7 @@ class UrlAlterFunctionalTest extends DrupalWebTestCase {
   protected function assertUrlInboundAlter($original, $final) {
     // Test inbound altering.
     $result = drupal_get_normal_path($original);
-    $this->assertIdentical($result, $final, t('Altered inbound URL %original, expected %final, and got %result.', array('%original' => $original, '%final' => $final, '%result' => $result)));
+    $this->assertIdentical($result, $final, format_string('Altered inbound URL %original, expected %final, and got %result.', array('%original' => $original, '%final' => $final, '%result' => $result)));
   }
 }
 
@@ -271,8 +271,8 @@ class PathLookupTest extends DrupalWebTestCase {
       'alias' => 'foo',
     );
     path_save($path);
-    $this->assertEqual(drupal_lookup_path('alias', $path['source']), $path['alias'], t('Basic alias lookup works.'));
-    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], t('Basic source lookup works.'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source']), $path['alias'], 'Basic alias lookup works.');
+    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], 'Basic source lookup works.');
 
     // Create a language specific alias for the default language (English).
     $path = array(
@@ -281,8 +281,8 @@ class PathLookupTest extends DrupalWebTestCase {
       'language' => 'en',
     );
     path_save($path);
-    $this->assertEqual(drupal_lookup_path('alias', $path['source']), $path['alias'], t('English alias overrides language-neutral alias.'));
-    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], t('English source overrides language-neutral source.'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source']), $path['alias'], 'English alias overrides language-neutral alias.');
+    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], 'English source overrides language-neutral source.');
 
     // Create a language-neutral alias for the same path, again.
     $path = array(
@@ -290,7 +290,7 @@ class PathLookupTest extends DrupalWebTestCase {
       'alias' => 'bar',
     );
     path_save($path);
-    $this->assertEqual(drupal_lookup_path('alias', $path['source']), "users/$name", t('English alias still returned after entering a language-neutral alias.'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source']), "users/$name", 'English alias still returned after entering a language-neutral alias.');
 
     // Create a language-specific (xx-lolspeak) alias for the same path.
     $path = array(
@@ -299,9 +299,9 @@ class PathLookupTest extends DrupalWebTestCase {
       'language' => 'xx-lolspeak',
     );
     path_save($path);
-    $this->assertEqual(drupal_lookup_path('alias', $path['source']), "users/$name", t('English alias still returned after entering a LOLspeak alias.'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source']), "users/$name", 'English alias still returned after entering a LOLspeak alias.');
     // The LOLspeak alias should be returned if we really want LOLspeak.
-    $this->assertEqual(drupal_lookup_path('alias', $path['source'], 'xx-lolspeak'), 'LOL', t('LOLspeak alias returned if we specify xx-lolspeak to drupal_lookup_path().'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source'], 'xx-lolspeak'), 'LOL', 'LOLspeak alias returned if we specify xx-lolspeak to drupal_lookup_path().');
 
     // Create a new alias for this path in English, which should override the
     // previous alias for "user/$uid".
@@ -311,8 +311,8 @@ class PathLookupTest extends DrupalWebTestCase {
       'language' => 'en',
     );
     path_save($path);
-    $this->assertEqual(drupal_lookup_path('alias', $path['source']), $path['alias'], t('Recently created English alias returned.'));
-    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], t('Recently created English source returned.'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source']), $path['alias'], 'Recently created English alias returned.');
+    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], 'Recently created English source returned.');
 
     // Remove the English aliases, which should cause a fallback to the most
     // recently created language-neutral alias, 'bar'.
@@ -320,7 +320,7 @@ class PathLookupTest extends DrupalWebTestCase {
       ->condition('language', 'en')
       ->execute();
     drupal_clear_path_cache();
-    $this->assertEqual(drupal_lookup_path('alias', $path['source']), 'bar', t('Path lookup falls back to recently created language-neutral alias.'));
+    $this->assertEqual(drupal_lookup_path('alias', $path['source']), 'bar', 'Path lookup falls back to recently created language-neutral alias.');
 
     // Test the situation where the alias and language are the same, but
     // the source differs. The newer alias record should be returned.
@@ -330,7 +330,7 @@ class PathLookupTest extends DrupalWebTestCase {
       'alias' => 'bar',
     );
     path_save($path);
-    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], t('Newer alias record is returned when comparing two LANGUAGE_NONE paths with the same alias.'));
+    $this->assertEqual(drupal_lookup_path('source', $path['alias']), $path['source'], 'Newer alias record is returned when comparing two LANGUAGE_NONE paths with the same alias.');
   }
 }
 
@@ -375,7 +375,7 @@ class PathSaveTest extends DrupalWebTestCase {
     // Test to see if the original alias is available to modules during
     // hook_path_update().
     $results = variable_get('path_test_results', array());
-    $this->assertIdentical($results['hook_path_update']['original']['alias'], $path_original['alias'], t('Old path alias available to modules during hook_path_update.'));
-    $this->assertIdentical($results['hook_path_update']['original']['source'], $path_original['source'], t('Old path alias available to modules during hook_path_update.'));
+    $this->assertIdentical($results['hook_path_update']['original']['alias'], $path_original['alias'], 'Old path alias available to modules during hook_path_update.');
+    $this->assertIdentical($results['hook_path_update']['original']['source'], $path_original['source'], 'Old path alias available to modules during hook_path_update.');
   }
 }
diff --git a/modules/simpletest/tests/psr_0_test/lib/Drupal/psr_0_test/Tests/ExampleTest.php b/modules/simpletest/tests/psr_0_test/lib/Drupal/psr_0_test/Tests/ExampleTest.php
new file mode 100644
index 0000000..3098c92
--- /dev/null
+++ b/modules/simpletest/tests/psr_0_test/lib/Drupal/psr_0_test/Tests/ExampleTest.php
@@ -0,0 +1,18 @@
+<?php
+
+namespace Drupal\psr_0_test\Tests;
+
+class ExampleTest extends \DrupalWebTestCase {
+
+  public static function getInfo() {
+    return array(
+      'name' => 'PSR0 example test: PSR-0 in disabled modules.',
+      'description' => 'We want to assert that this test case is being discovered.',
+      'group' => 'SimpleTest',
+    );
+  }
+
+  function testArithmetics() {
+    $this->assert(1 + 1 == 2, '1 + 1 == 2');
+  }
+}
diff --git a/modules/simpletest/tests/psr_0_test/lib/Drupal/psr_0_test/Tests/Nested/NestedExampleTest.php b/modules/simpletest/tests/psr_0_test/lib/Drupal/psr_0_test/Tests/Nested/NestedExampleTest.php
new file mode 100644
index 0000000..324ed43
--- /dev/null
+++ b/modules/simpletest/tests/psr_0_test/lib/Drupal/psr_0_test/Tests/Nested/NestedExampleTest.php
@@ -0,0 +1,18 @@
+<?php
+
+namespace Drupal\psr_0_test\Tests\Nested;
+
+class NestedExampleTest extends \DrupalWebTestCase {
+
+  public static function getInfo() {
+    return array(
+      'name' => 'PSR0 example test: PSR-0 in nested subfolders.',
+      'description' => 'We want to assert that this PSR-0 test case is being discovered.',
+      'group' => 'SimpleTest',
+    );
+  }
+
+  function testArithmetics() {
+    $this->assert(1 + 1 == 2, '1 + 1 == 2');
+  }
+}
diff --git a/modules/simpletest/tests/psr_0_test/psr_0_test.info b/modules/simpletest/tests/psr_0_test/psr_0_test.info
new file mode 100644
index 0000000..48ca8d8
--- /dev/null
+++ b/modules/simpletest/tests/psr_0_test/psr_0_test.info
@@ -0,0 +1,6 @@
+name = PSR-0 Test cases
+description = Test classes to be discovered by simpletest.
+core = 7.x
+
+hidden = TRUE
+package = Testing
diff --git a/modules/simpletest/tests/psr_0_test/psr_0_test.module b/modules/simpletest/tests/psr_0_test/psr_0_test.module
new file mode 100644
index 0000000..b3d9bbc
--- /dev/null
+++ b/modules/simpletest/tests/psr_0_test/psr_0_test.module
@@ -0,0 +1 @@
+<?php
diff --git a/modules/simpletest/tests/schema.test b/modules/simpletest/tests/schema.test
index 8945117..4199428 100644
--- a/modules/simpletest/tests/schema.test
+++ b/modules/simpletest/tests/schema.test
@@ -44,7 +44,7 @@ class SchemaTestCase extends DrupalWebTestCase {
     db_create_table('test_table', $table_specification);
 
     // Assert that the table exists.
-    $this->assertTrue(db_table_exists('test_table'), t('The table exists.'));
+    $this->assertTrue(db_table_exists('test_table'), 'The table exists.');
 
     // Assert that the table comment has been set.
     $this->checkSchemaComment($table_specification['description'], 'test_table');
@@ -53,46 +53,46 @@ class SchemaTestCase extends DrupalWebTestCase {
     $this->checkSchemaComment($table_specification['fields']['test_field']['description'], 'test_table', 'test_field');
 
     // An insert without a value for the column 'test_table' should fail.
-    $this->assertFalse($this->tryInsert(), t('Insert without a default failed.'));
+    $this->assertFalse($this->tryInsert(), 'Insert without a default failed.');
 
     // Add a default value to the column.
     db_field_set_default('test_table', 'test_field', 0);
     // The insert should now succeed.
-    $this->assertTrue($this->tryInsert(), t('Insert with a default succeeded.'));
+    $this->assertTrue($this->tryInsert(), 'Insert with a default succeeded.');
 
     // Remove the default.
     db_field_set_no_default('test_table', 'test_field');
     // The insert should fail again.
-    $this->assertFalse($this->tryInsert(), t('Insert without a default failed.'));
+    $this->assertFalse($this->tryInsert(), 'Insert without a default failed.');
 
     // Test for fake index and test for the boolean result of indexExists().
     $index_exists = Database::getConnection()->schema()->indexExists('test_table', 'test_field');
-    $this->assertIdentical($index_exists, FALSE, t('Fake index does not exists'));
+    $this->assertIdentical($index_exists, FALSE, 'Fake index does not exists');
     // Add index.
     db_add_index('test_table', 'test_field', array('test_field'));
     // Test for created index and test for the boolean result of indexExists().
     $index_exists = Database::getConnection()->schema()->indexExists('test_table', 'test_field');
-    $this->assertIdentical($index_exists, TRUE, t('Index created.'));
+    $this->assertIdentical($index_exists, TRUE, 'Index created.');
 
     // Rename the table.
     db_rename_table('test_table', 'test_table2');
 
     // Index should be renamed.
     $index_exists = Database::getConnection()->schema()->indexExists('test_table2', 'test_field');
-    $this->assertTrue($index_exists, t('Index was renamed.'));
+    $this->assertTrue($index_exists, 'Index was renamed.');
 
     // We need the default so that we can insert after the rename.
     db_field_set_default('test_table2', 'test_field', 0);
-    $this->assertFalse($this->tryInsert(), t('Insert into the old table failed.'));
-    $this->assertTrue($this->tryInsert('test_table2'), t('Insert into the new table succeeded.'));
+    $this->assertFalse($this->tryInsert(), 'Insert into the old table failed.');
+    $this->assertTrue($this->tryInsert('test_table2'), 'Insert into the new table succeeded.');
 
     // We should have successfully inserted exactly two rows.
     $count = db_query('SELECT COUNT(*) FROM {test_table2}')->fetchField();
-    $this->assertEqual($count, 2, t('Two fields were successfully inserted.'));
+    $this->assertEqual($count, 2, 'Two fields were successfully inserted.');
 
     // Try to drop the table.
     db_drop_table('test_table2');
-    $this->assertFalse(db_table_exists('test_table2'), t('The dropped table does not exist.'));
+    $this->assertFalse(db_table_exists('test_table2'), 'The dropped table does not exist.');
 
     // Recreate the table.
     db_create_table('test_table', $table_specification);
@@ -108,14 +108,14 @@ class SchemaTestCase extends DrupalWebTestCase {
     // Assert that the column comment has been set.
     $this->checkSchemaComment('Changed column description.', 'test_table', 'test_serial');
 
-    $this->assertTrue($this->tryInsert(), t('Insert with a serial succeeded.'));
+    $this->assertTrue($this->tryInsert(), 'Insert with a serial succeeded.');
     $max1 = db_query('SELECT MAX(test_serial) FROM {test_table}')->fetchField();
-    $this->assertTrue($this->tryInsert(), t('Insert with a serial succeeded.'));
+    $this->assertTrue($this->tryInsert(), 'Insert with a serial succeeded.');
     $max2 = db_query('SELECT MAX(test_serial) FROM {test_table}')->fetchField();
-    $this->assertTrue($max2 > $max1, t('The serial is monotone.'));
+    $this->assertTrue($max2 > $max1, 'The serial is monotone.');
 
     $count = db_query('SELECT COUNT(*) FROM {test_table}')->fetchField();
-    $this->assertEqual($count, 2, t('There were two rows.'));
+    $this->assertEqual($count, 2, 'There were two rows.');
 
     // Use database specific data type and ensure that table is created.
     $table_specification = array(
@@ -134,7 +134,7 @@ class SchemaTestCase extends DrupalWebTestCase {
       db_create_table('test_timestamp', $table_specification);
     }
     catch (Exception $e) {}
-    $this->assertTrue(db_table_exists('test_timestamp'), t('Table with database specific datatype was created.'));
+    $this->assertTrue(db_table_exists('test_timestamp'), 'Table with database specific datatype was created.');
   }
 
   function tryInsert($table = 'test_table') {
@@ -162,7 +162,7 @@ class SchemaTestCase extends DrupalWebTestCase {
   function checkSchemaComment($description, $table, $column = NULL) {
     if (method_exists(Database::getConnection()->schema(), 'getComment')) {
       $comment = Database::getConnection()->schema()->getComment($table, $column);
-      $this->assertEqual($comment, $description, t('The comment matches the schema description.'));
+      $this->assertEqual($comment, $description, 'The comment matches the schema description.');
     }
   }
 
@@ -193,8 +193,8 @@ class SchemaTestCase extends DrupalWebTestCase {
 
     // Finally, check each column and try to insert invalid values into them.
     foreach ($table_spec['fields'] as $column_name => $column_spec) {
-      $this->assertTrue(db_field_exists($table_name, $column_name), t('Unsigned @type column was created.', array('@type' => $column_spec['type'])));
-      $this->assertFalse($this->tryUnsignedInsert($table_name, $column_name), t('Unsigned @type column rejected a negative value.', array('@type' => $column_spec['type'])));
+      $this->assertTrue(db_field_exists($table_name, $column_name), format_string('Unsigned @type column was created.', array('@type' => $column_spec['type'])));
+      $this->assertFalse($this->tryUnsignedInsert($table_name, $column_name), format_string('Unsigned @type column rejected a negative value.', array('@type' => $column_spec['type'])));
     }
   }
 
@@ -312,7 +312,7 @@ class SchemaTestCase extends DrupalWebTestCase {
       'primary key' => array('serial_column'),
     );
     db_create_table($table_name, $table_spec);
-    $this->pass(t('Table %table created.', array('%table' => $table_name)));
+    $this->pass(format_string('Table %table created.', array('%table' => $table_name)));
 
     // Check the characteristics of the field.
     $this->assertFieldCharacteristics($table_name, 'test_field', $field_spec);
@@ -329,7 +329,7 @@ class SchemaTestCase extends DrupalWebTestCase {
       'primary key' => array('serial_column'),
     );
     db_create_table($table_name, $table_spec);
-    $this->pass(t('Table %table created.', array('%table' => $table_name)));
+    $this->pass(format_string('Table %table created.', array('%table' => $table_name)));
 
     // Insert some rows to the table to test the handling of initial values.
     for ($i = 0; $i < 3; $i++) {
@@ -339,7 +339,7 @@ class SchemaTestCase extends DrupalWebTestCase {
     }
 
     db_add_field($table_name, 'test_field', $field_spec);
-    $this->pass(t('Column %column created.', array('%column' => 'test_field')));
+    $this->pass(format_string('Column %column created.', array('%column' => 'test_field')));
 
     // Check the characteristics of the field.
     $this->assertFieldCharacteristics($table_name, 'test_field', $field_spec);
@@ -362,7 +362,7 @@ class SchemaTestCase extends DrupalWebTestCase {
         ->countQuery()
         ->execute()
         ->fetchField();
-      $this->assertEqual($count, 0, t('Initial values filled out.'));
+      $this->assertEqual($count, 0, 'Initial values filled out.');
     }
 
     // Check that the default value has been registered.
@@ -376,7 +376,7 @@ class SchemaTestCase extends DrupalWebTestCase {
         ->condition('serial_column', $id)
         ->execute()
         ->fetchField();
-      $this->assertEqual($field_value, $field_spec['default'], t('Default value registered.'));
+      $this->assertEqual($field_value, $field_spec['default'], 'Default value registered.');
     }
 
     db_drop_field($table_name, $field_name);
diff --git a/modules/simpletest/tests/session.test b/modules/simpletest/tests/session.test
index a0feffb..0d9b6bd 100644
--- a/modules/simpletest/tests/session.test
+++ b/modules/simpletest/tests/session.test
@@ -22,11 +22,11 @@ class SessionTestCase extends DrupalWebTestCase {
    * Tests for drupal_save_session() and drupal_session_regenerate().
    */
   function testSessionSaveRegenerate() {
-    $this->assertFalse(drupal_save_session(), t('drupal_save_session() correctly returns FALSE (inside of testing framework) when initially called with no arguments.'), t('Session'));
-    $this->assertFalse(drupal_save_session(FALSE), t('drupal_save_session() correctly returns FALSE when called with FALSE.'), t('Session'));
-    $this->assertFalse(drupal_save_session(), t('drupal_save_session() correctly returns FALSE when saving has been disabled.'), t('Session'));
-    $this->assertTrue(drupal_save_session(TRUE), t('drupal_save_session() correctly returns TRUE when called with TRUE.'), t('Session'));
-    $this->assertTrue(drupal_save_session(), t('drupal_save_session() correctly returns TRUE when saving has been enabled.'), t('Session'));
+    $this->assertFalse(drupal_save_session(), 'drupal_save_session() correctly returns FALSE (inside of testing framework) when initially called with no arguments.', 'Session');
+    $this->assertFalse(drupal_save_session(FALSE), 'drupal_save_session() correctly returns FALSE when called with FALSE.', 'Session');
+    $this->assertFalse(drupal_save_session(), 'drupal_save_session() correctly returns FALSE when saving has been disabled.', 'Session');
+    $this->assertTrue(drupal_save_session(TRUE), 'drupal_save_session() correctly returns TRUE when called with TRUE.', 'Session');
+    $this->assertTrue(drupal_save_session(), 'drupal_save_session() correctly returns TRUE when saving has been enabled.', 'Session');
 
     // Test session hardening code from SA-2008-044.
     $user = $this->drupalCreateUser(array('access content'));
@@ -36,7 +36,7 @@ class SessionTestCase extends DrupalWebTestCase {
 
     // Make sure the session cookie is set as HttpOnly.
     $this->drupalLogin($user);
-    $this->assertTrue(preg_match('/HttpOnly/i', $this->drupalGetHeader('Set-Cookie', TRUE)), t('Session cookie is set as HttpOnly.'));
+    $this->assertTrue(preg_match('/HttpOnly/i', $this->drupalGetHeader('Set-Cookie', TRUE)), 'Session cookie is set as HttpOnly.');
     $this->drupalLogout();
 
     // Verify that the session is regenerated if a module calls exit
@@ -46,7 +46,7 @@ class SessionTestCase extends DrupalWebTestCase {
     $this->drupalGet('session-test/id');
     $matches = array();
     preg_match('/\s*session_id:(.*)\n/', $this->drupalGetContent(), $matches);
-    $this->assertTrue(!empty($matches[1]) , t('Found session ID before logging in.'));
+    $this->assertTrue(!empty($matches[1]) , 'Found session ID before logging in.');
     $original_session = $matches[1];
 
     // We cannot use $this->drupalLogin($user); because we exit in
@@ -57,14 +57,14 @@ class SessionTestCase extends DrupalWebTestCase {
     );
     $this->drupalPost('user', $edit, t('Log in'));
     $this->drupalGet('user');
-    $pass = $this->assertText($user->name, t('Found name: %name', array('%name' => $user->name)), t('User login'));
+    $pass = $this->assertText($user->name, format_string('Found name: %name', array('%name' => $user->name)), 'User login');
     $this->_logged_in = $pass;
 
     $this->drupalGet('session-test/id');
     $matches = array();
     preg_match('/\s*session_id:(.*)\n/', $this->drupalGetContent(), $matches);
-    $this->assertTrue(!empty($matches[1]) , t('Found session ID after logging in.'));
-    $this->assertTrue($matches[1] != $original_session, t('Session ID changed after login.'));
+    $this->assertTrue(!empty($matches[1]) , 'Found session ID after logging in.');
+    $this->assertTrue($matches[1] != $original_session, 'Session ID changed after login.');
   }
 
   /**
@@ -80,48 +80,48 @@ class SessionTestCase extends DrupalWebTestCase {
 
     $value_1 = $this->randomName();
     $this->drupalGet('session-test/set/' . $value_1);
-    $this->assertText($value_1, t('The session value was stored.'), t('Session'));
+    $this->assertText($value_1, 'The session value was stored.', 'Session');
     $this->drupalGet('session-test/get');
-    $this->assertText($value_1, t('Session correctly returned the stored data for an authenticated user.'), t('Session'));
+    $this->assertText($value_1, 'Session correctly returned the stored data for an authenticated user.', 'Session');
 
     // Attempt to write over val_1. If drupal_save_session(FALSE) is working.
     // properly, val_1 will still be set.
     $value_2 = $this->randomName();
     $this->drupalGet('session-test/no-set/' . $value_2);
-    $this->assertText($value_2, t('The session value was correctly passed to session-test/no-set.'), t('Session'));
+    $this->assertText($value_2, 'The session value was correctly passed to session-test/no-set.', 'Session');
     $this->drupalGet('session-test/get');
-    $this->assertText($value_1, t('Session data is not saved for drupal_save_session(FALSE).'), t('Session'));
+    $this->assertText($value_1, 'Session data is not saved for drupal_save_session(FALSE).', 'Session');
 
     // Switch browser cookie to anonymous user, then back to user 1.
     $this->sessionReset();
     $this->sessionReset($user->uid);
-    $this->assertText($value_1, t('Session data persists through browser close.'), t('Session'));
+    $this->assertText($value_1, 'Session data persists through browser close.', 'Session');
 
     // Logout the user and make sure the stored value no longer persists.
     $this->drupalLogout();
     $this->sessionReset();
     $this->drupalGet('session-test/get');
-    $this->assertNoText($value_1, t("After logout, previous user's session data is not available."), t('Session'));
+    $this->assertNoText($value_1, "After logout, previous user's session data is not available.", 'Session');
 
     // Now try to store some data as an anonymous user.
     $value_3 = $this->randomName();
     $this->drupalGet('session-test/set/' . $value_3);
-    $this->assertText($value_3, t('Session data stored for anonymous user.'), t('Session'));
+    $this->assertText($value_3, 'Session data stored for anonymous user.', 'Session');
     $this->drupalGet('session-test/get');
-    $this->assertText($value_3, t('Session correctly returned the stored data for an anonymous user.'), t('Session'));
+    $this->assertText($value_3, 'Session correctly returned the stored data for an anonymous user.', 'Session');
 
     // Try to store data when drupal_save_session(FALSE).
     $value_4 = $this->randomName();
     $this->drupalGet('session-test/no-set/' . $value_4);
-    $this->assertText($value_4, t('The session value was correctly passed to session-test/no-set.'), t('Session'));
+    $this->assertText($value_4, 'The session value was correctly passed to session-test/no-set.', 'Session');
     $this->drupalGet('session-test/get');
-    $this->assertText($value_3, t('Session data is not saved for drupal_save_session(FALSE).'), t('Session'));
+    $this->assertText($value_3, 'Session data is not saved for drupal_save_session(FALSE).', 'Session');
 
     // Login, the data should persist.
     $this->drupalLogin($user);
     $this->sessionReset($user->uid);
     $this->drupalGet('session-test/get');
-    $this->assertNoText($value_1, t('Session has persisted for an authenticated user after logging out and then back in.'), t('Session'));
+    $this->assertNoText($value_1, 'Session has persisted for an authenticated user after logging out and then back in.', 'Session');
 
     // Change session and create another user.
     $user2 = $this->drupalCreateUser(array('access content'));
@@ -143,29 +143,29 @@ class SessionTestCase extends DrupalWebTestCase {
     $this->drupalGet('');
     $this->assertSessionCookie(FALSE);
     $this->assertSessionEmpty(TRUE);
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'MISS', t('Page was not cached.'));
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'MISS', 'Page was not cached.');
 
     // Start a new session by setting a message.
     $this->drupalGet('session-test/set-message');
     $this->assertSessionCookie(TRUE);
-    $this->assertTrue($this->drupalGetHeader('Set-Cookie'), t('New session was started.'));
+    $this->assertTrue($this->drupalGetHeader('Set-Cookie'), 'New session was started.');
 
     // Display the message, during the same request the session is destroyed
     // and the session cookie is unset.
     $this->drupalGet('');
     $this->assertSessionCookie(FALSE);
     $this->assertSessionEmpty(FALSE);
-    $this->assertFalse($this->drupalGetHeader('X-Drupal-Cache'), t('Caching was bypassed.'));
-    $this->assertText(t('This is a dummy message.'), t('Message was displayed.'));
-    $this->assertTrue(preg_match('/SESS\w+=deleted/', $this->drupalGetHeader('Set-Cookie')), t('Session cookie was deleted.'));
+    $this->assertFalse($this->drupalGetHeader('X-Drupal-Cache'), 'Caching was bypassed.');
+    $this->assertText(t('This is a dummy message.'), 'Message was displayed.');
+    $this->assertTrue(preg_match('/SESS\w+=deleted/', $this->drupalGetHeader('Set-Cookie')), 'Session cookie was deleted.');
 
     // Verify that session was destroyed.
     $this->drupalGet('');
     $this->assertSessionCookie(FALSE);
     $this->assertSessionEmpty(TRUE);
-    $this->assertNoText(t('This is a dummy message.'), t('Message was not cached.'));
-    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', t('Page was cached.'));
-    $this->assertFalse($this->drupalGetHeader('Set-Cookie'), t('New session was not started.'));
+    $this->assertNoText(t('This is a dummy message.'), 'Message was not cached.');
+    $this->assertEqual($this->drupalGetHeader('X-Drupal-Cache'), 'HIT', 'Page was cached.');
+    $this->assertFalse($this->drupalGetHeader('Set-Cookie'), 'New session was not started.');
 
     // Verify that no session is created if drupal_save_session(FALSE) is called.
     $this->drupalGet('session-test/set-message-but-dont-save');
@@ -176,7 +176,7 @@ class SessionTestCase extends DrupalWebTestCase {
     $this->drupalGet('');
     $this->assertSessionCookie(FALSE);
     $this->assertSessionEmpty(TRUE);
-    $this->assertNoText(t('This is a dummy message.'), t('The message was not saved.'));
+    $this->assertNoText(t('This is a dummy message.'), 'The message was not saved.');
   }
 
   /**
@@ -196,29 +196,29 @@ class SessionTestCase extends DrupalWebTestCase {
     sleep(1);
     $this->drupalGet('session-test/set/foo');
     $times2 = db_query($sql, array(':uid' => $user->uid))->fetchObject();
-    $this->assertEqual($times2->access, $times1->access, t('Users table was not updated.'));
-    $this->assertNotEqual($times2->timestamp, $times1->timestamp, t('Sessions table was updated.'));
+    $this->assertEqual($times2->access, $times1->access, 'Users table was not updated.');
+    $this->assertNotEqual($times2->timestamp, $times1->timestamp, 'Sessions table was updated.');
 
     // Write the same value again, i.e. do not modify the session.
     sleep(1);
     $this->drupalGet('session-test/set/foo');
     $times3 = db_query($sql, array(':uid' => $user->uid))->fetchObject();
-    $this->assertEqual($times3->access, $times1->access, t('Users table was not updated.'));
-    $this->assertEqual($times3->timestamp, $times2->timestamp, t('Sessions table was not updated.'));
+    $this->assertEqual($times3->access, $times1->access, 'Users table was not updated.');
+    $this->assertEqual($times3->timestamp, $times2->timestamp, 'Sessions table was not updated.');
 
     // Do not change the session.
     sleep(1);
     $this->drupalGet('');
     $times4 = db_query($sql, array(':uid' => $user->uid))->fetchObject();
-    $this->assertEqual($times4->access, $times3->access, t('Users table was not updated.'));
-    $this->assertEqual($times4->timestamp, $times3->timestamp, t('Sessions table was not updated.'));
+    $this->assertEqual($times4->access, $times3->access, 'Users table was not updated.');
+    $this->assertEqual($times4->timestamp, $times3->timestamp, 'Sessions table was not updated.');
 
     // Force updating of users and sessions table once per second.
     variable_set('session_write_interval', 0);
     $this->drupalGet('');
     $times5 = db_query($sql, array(':uid' => $user->uid))->fetchObject();
-    $this->assertNotEqual($times5->access, $times4->access, t('Users table was updated.'));
-    $this->assertNotEqual($times5->timestamp, $times4->timestamp, t('Sessions table was updated.'));
+    $this->assertNotEqual($times5->access, $times4->access, 'Users table was updated.');
+    $this->assertNotEqual($times5->timestamp, $times4->timestamp, 'Sessions table was updated.');
   }
 
   /**
@@ -228,7 +228,7 @@ class SessionTestCase extends DrupalWebTestCase {
     $user = $this->drupalCreateUser(array('access content'));
     $this->drupalLogin($user);
     $this->drupalGet('session-test/is-logged-in');
-    $this->assertResponse(200, t('User is logged in.'));
+    $this->assertResponse(200, 'User is logged in.');
 
     // Reset the sid in {sessions} to a blank string. This may exist in the
     // wild in some cases, although we normally prevent it from happening.
@@ -239,10 +239,10 @@ class SessionTestCase extends DrupalWebTestCase {
     $this->curlClose();
     $this->additionalCurlOptions[CURLOPT_COOKIE] = rawurlencode($this->session_name) . '=;';
     $this->drupalGet('session-test/id-from-cookie');
-    $this->assertRaw("session_id:\n", t('Session ID is blank as sent from cookie header.'));
+    $this->assertRaw("session_id:\n", 'Session ID is blank as sent from cookie header.');
     // Assert that we have an anonymous session now.
     $this->drupalGet('session-test/is-logged-in');
-    $this->assertResponse(403, t('An empty session ID is not allowed.'));
+    $this->assertResponse(403, 'An empty session ID is not allowed.');
   }
 
   /**
@@ -260,7 +260,7 @@ class SessionTestCase extends DrupalWebTestCase {
     $this->additionalCurlOptions[CURLOPT_COOKIEFILE] = $this->cookieFile;
     $this->additionalCurlOptions[CURLOPT_COOKIESESSION] = TRUE;
     $this->drupalGet('session-test/get');
-    $this->assertResponse(200, t('Session test module is correctly enabled.'), t('Session'));
+    $this->assertResponse(200, 'Session test module is correctly enabled.', 'Session');
   }
 
   /**
@@ -268,10 +268,10 @@ class SessionTestCase extends DrupalWebTestCase {
    */
   function assertSessionCookie($sent) {
     if ($sent) {
-      $this->assertNotNull($this->session_id, t('Session cookie was sent.'));
+      $this->assertNotNull($this->session_id, 'Session cookie was sent.');
     }
     else {
-      $this->assertNull($this->session_id, t('Session cookie was not sent.'));
+      $this->assertNull($this->session_id, 'Session cookie was not sent.');
     }
   }
 
@@ -280,10 +280,10 @@ class SessionTestCase extends DrupalWebTestCase {
    */
   function assertSessionEmpty($empty) {
     if ($empty) {
-      $this->assertIdentical($this->drupalGetHeader('X-Session-Empty'), '1', t('Session was empty.'));
+      $this->assertIdentical($this->drupalGetHeader('X-Session-Empty'), '1', 'Session was empty.');
     }
     else {
-      $this->assertIdentical($this->drupalGetHeader('X-Session-Empty'), '0', t('Session was not empty.'));
+      $this->assertIdentical($this->drupalGetHeader('X-Session-Empty'), '0', 'Session was not empty.');
     }
   }
 }
diff --git a/modules/simpletest/tests/tablesort.test b/modules/simpletest/tests/tablesort.test
index 9c068f8..ffc9535 100644
--- a/modules/simpletest/tests/tablesort.test
+++ b/modules/simpletest/tests/tablesort.test
@@ -58,7 +58,7 @@ class TableSortTest extends DrupalUnitTestCase {
     );
     $ts = tablesort_init($headers);
     $this->verbose(strtr('$ts: <pre>!ts</pre>', array('!ts' => check_plain(var_export($ts, TRUE)))));
-    $this->assertEqual($ts, $expected_ts, t('Simple table headers sorted correctly.'));
+    $this->assertEqual($ts, $expected_ts, 'Simple table headers sorted correctly.');
 
     // Test with simple table headers plus $_GET parameters that should _not_
     // override the default.
@@ -71,7 +71,7 @@ class TableSortTest extends DrupalUnitTestCase {
     );
     $ts = tablesort_init($headers);
     $this->verbose(strtr('$ts: <pre>!ts</pre>', array('!ts' => check_plain(var_export($ts, TRUE)))));
-    $this->assertEqual($ts, $expected_ts, t('Simple table headers plus non-overriding $_GET parameters sorted correctly.'));
+    $this->assertEqual($ts, $expected_ts, 'Simple table headers plus non-overriding $_GET parameters sorted correctly.');
 
     // Test with simple table headers plus $_GET parameters that _should_
     // override the default.
@@ -87,7 +87,7 @@ class TableSortTest extends DrupalUnitTestCase {
     $expected_ts['query'] = array('alpha' => 'beta');
     $ts = tablesort_init($headers);
     $this->verbose(strtr('$ts: <pre>!ts</pre>', array('!ts' => check_plain(var_export($ts, TRUE)))));
-    $this->assertEqual($ts, $expected_ts, t('Simple table headers plus $_GET parameters sorted correctly.'));
+    $this->assertEqual($ts, $expected_ts, 'Simple table headers plus $_GET parameters sorted correctly.');
 
     // Test complex table headers.
 
@@ -118,7 +118,7 @@ class TableSortTest extends DrupalUnitTestCase {
       'query' => array(),
     );
     $this->verbose(strtr('$ts: <pre>!ts</pre>', array('!ts' => check_plain(var_export($ts, TRUE)))));
-    $this->assertEqual($ts, $expected_ts, t('Complex table headers sorted correctly.'));
+    $this->assertEqual($ts, $expected_ts, 'Complex table headers sorted correctly.');
 
     // Test complex table headers plus $_GET parameters that should _not_
     // override the default.
@@ -137,7 +137,7 @@ class TableSortTest extends DrupalUnitTestCase {
       'query' => array(),
     );
     $this->verbose(strtr('$ts: <pre>!ts</pre>', array('!ts' => check_plain(var_export($ts, TRUE)))));
-    $this->assertEqual($ts, $expected_ts, t('Complex table headers plus non-overriding $_GET parameters sorted correctly.'));
+    $this->assertEqual($ts, $expected_ts, 'Complex table headers plus non-overriding $_GET parameters sorted correctly.');
     unset($_GET['sort'], $_GET['order'], $_GET['alpha']);
 
     // Test complex table headers plus $_GET parameters that _should_
@@ -159,7 +159,7 @@ class TableSortTest extends DrupalUnitTestCase {
     );
     $ts = tablesort_init($headers);
     $this->verbose(strtr('$ts: <pre>!ts</pre>', array('!ts' => check_plain(var_export($ts, TRUE)))));
-    $this->assertEqual($ts, $expected_ts, t('Complex table headers plus $_GET parameters sorted correctly.'));
+    $this->assertEqual($ts, $expected_ts, 'Complex table headers plus $_GET parameters sorted correctly.');
     unset($_GET['sort'], $_GET['order'], $_GET['alpha']);
 
   }
diff --git a/modules/simpletest/tests/theme.test b/modules/simpletest/tests/theme.test
index 0ee473e..519a7a9 100644
--- a/modules/simpletest/tests/theme.test
+++ b/modules/simpletest/tests/theme.test
@@ -33,22 +33,22 @@ class ThemeTestCase extends DrupalWebTestCase {
     variable_set('site_frontpage', 'nobody-home');
     $args = array('node', '1', 'edit');
     $suggestions = theme_get_suggestions($args, 'page');
-    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1', 'page__node__edit'), t('Found expected node edit page suggestions'));
+    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1', 'page__node__edit'), 'Found expected node edit page suggestions');
     // Check attack vectors.
     $args = array('node', '\\1');
     $suggestions = theme_get_suggestions($args, 'page');
-    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1'), t('Removed invalid \\ from suggestions'));
+    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1'), 'Removed invalid \\ from suggestions');
     $args = array('node', '1/');
     $suggestions = theme_get_suggestions($args, 'page');
-    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1'), t('Removed invalid / from suggestions'));
+    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1'), 'Removed invalid / from suggestions');
     $args = array('node', "1\0");
     $suggestions = theme_get_suggestions($args, 'page');
-    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1'), t('Removed invalid \\0 from suggestions'));
+    $this->assertEqual($suggestions, array('page__node', 'page__node__%', 'page__node__1'), 'Removed invalid \\0 from suggestions');
     // Define path with hyphens to be used to generate suggestions.
     $args = array('node', '1', 'hyphen-path');
     $result = array('page__node', 'page__node__%', 'page__node__1', 'page__node__hyphen_path');
     $suggestions = theme_get_suggestions($args, 'page');
-    $this->assertEqual($suggestions, $result, t('Found expected page suggestions for paths containing hyphens.'));
+    $this->assertEqual($suggestions, $result, 'Found expected page suggestions for paths containing hyphens.');
   }
 
   /**
@@ -78,7 +78,7 @@ class ThemeTestCase extends DrupalWebTestCase {
     $suggestions = theme_get_suggestions(explode('/', $_GET['q']), 'page');
     // Set it back to not annoy the batch runner.
     $_GET['q'] = $q;
-    $this->assertTrue(in_array('page__front', $suggestions), t('Front page template was suggested.'));
+    $this->assertTrue(in_array('page__front', $suggestions), 'Front page template was suggested.');
   }
 
   /**
@@ -86,7 +86,7 @@ class ThemeTestCase extends DrupalWebTestCase {
    */
   function testAlter() {
     $this->drupalGet('theme-test/alter');
-    $this->assertText('The altered data is test_theme_theme_test_alter_alter was invoked.', t('The theme was able to implement an alter hook during page building before anything was rendered.'));
+    $this->assertText('The altered data is test_theme_theme_test_alter_alter was invoked.', 'The theme was able to implement an alter hook during page building before anything was rendered.');
   }
 
   /**
@@ -101,7 +101,7 @@ class ThemeTestCase extends DrupalWebTestCase {
     // test theme. First we test with CSS aggregation disabled.
     variable_set('preprocess_css', 0);
     $this->drupalGet('theme-test/suggestion');
-    $this->assertNoText('system.base.css', t('The theme\'s .info file is able to override a module CSS file from being added to the page.'));
+    $this->assertNoText('system.base.css', 'The theme\'s .info file is able to override a module CSS file from being added to the page.');
 
     // Also test with aggregation enabled, simply ensuring no PHP errors are
     // triggered during drupal_build_css_cache() when a source file doesn't
@@ -131,19 +131,19 @@ class ThemeTestCase extends DrupalWebTestCase {
   function testListThemes() {
     $themes = list_themes();
     // Check if drupal_theme_access() retrieves enabled themes properly from list_themes().
-    $this->assertTrue(drupal_theme_access('test_theme'), t('Enabled theme detected'));
+    $this->assertTrue(drupal_theme_access('test_theme'), 'Enabled theme detected');
     // Check if list_themes() returns disabled themes.
-    $this->assertTrue(array_key_exists('test_basetheme', $themes), t('Disabled theme detected'));
+    $this->assertTrue(array_key_exists('test_basetheme', $themes), 'Disabled theme detected');
     // Check for base theme and subtheme lists.
     $base_theme_list = array('test_basetheme' => 'Theme test base theme');
     $sub_theme_list = array('test_subtheme' => 'Theme test subtheme');
-    $this->assertIdentical($themes['test_basetheme']->sub_themes, $sub_theme_list, t('Base theme\'s object includes list of subthemes.'));
-    $this->assertIdentical($themes['test_subtheme']->base_themes, $base_theme_list, t('Subtheme\'s object includes list of base themes.'));
+    $this->assertIdentical($themes['test_basetheme']->sub_themes, $sub_theme_list, 'Base theme\'s object includes list of subthemes.');
+    $this->assertIdentical($themes['test_subtheme']->base_themes, $base_theme_list, 'Subtheme\'s object includes list of base themes.');
     // Check for theme engine in subtheme.
-    $this->assertIdentical($themes['test_subtheme']->engine, 'phptemplate', t('Subtheme\'s object includes the theme engine.'));
+    $this->assertIdentical($themes['test_subtheme']->engine, 'phptemplate', 'Subtheme\'s object includes the theme engine.');
     // Check for theme engine prefix.
-    $this->assertIdentical($themes['test_basetheme']->prefix, 'phptemplate', t('Base theme\'s object includes the theme engine prefix.'));
-    $this->assertIdentical($themes['test_subtheme']->prefix, 'phptemplate', t('Subtheme\'s object includes the theme engine prefix.'));
+    $this->assertIdentical($themes['test_basetheme']->prefix, 'phptemplate', 'Base theme\'s object includes the theme engine prefix.');
+    $this->assertIdentical($themes['test_subtheme']->prefix, 'phptemplate', 'Subtheme\'s object includes the theme engine prefix.');
   }
 
   /**
@@ -151,9 +151,9 @@ class ThemeTestCase extends DrupalWebTestCase {
    */
   function testThemeGetSetting() {
     $GLOBALS['theme_key'] = 'test_theme';
-    $this->assertIdentical(theme_get_setting('theme_test_setting'), 'default value', t('theme_get_setting() uses the default theme automatically.'));
-    $this->assertNotEqual(theme_get_setting('subtheme_override', 'test_basetheme'), theme_get_setting('subtheme_override', 'test_subtheme'), t('Base theme\'s default settings values can be overridden by subtheme.'));
-    $this->assertIdentical(theme_get_setting('basetheme_only', 'test_subtheme'), 'base theme value', t('Base theme\'s default settings values are inherited by subtheme.'));
+    $this->assertIdentical(theme_get_setting('theme_test_setting'), 'default value', 'theme_get_setting() uses the default theme automatically.');
+    $this->assertNotEqual(theme_get_setting('subtheme_override', 'test_basetheme'), theme_get_setting('subtheme_override', 'test_subtheme'), 'Base theme\'s default settings values can be overridden by subtheme.');
+    $this->assertIdentical(theme_get_setting('basetheme_only', 'test_subtheme'), 'base theme value', 'Base theme\'s default settings values are inherited by subtheme.');
   }
 }
 
@@ -177,8 +177,8 @@ class ThemeTableTestCase extends DrupalWebTestCase {
     $rows = array(array(1,2,3), array(4,5,6), array(7,8,9));
     $this->content = theme('table', array('header' => $header, 'rows' => $rows));
     $js = drupal_add_js();
-    $this->assertTrue(isset($js['misc/tableheader.js']), t('tableheader.js was included when $sticky = TRUE.'));
-    $this->assertRaw('sticky-enabled',  t('Table has a class of sticky-enabled when $sticky = TRUE.'));
+    $this->assertTrue(isset($js['misc/tableheader.js']), 'tableheader.js was included when $sticky = TRUE.');
+    $this->assertRaw('sticky-enabled', 'Table has a class of sticky-enabled when $sticky = TRUE.');
     drupal_static_reset('drupal_add_js');
   }
 
@@ -193,8 +193,8 @@ class ThemeTableTestCase extends DrupalWebTestCase {
     $colgroups = array();
     $this->content = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => $attributes, 'caption' => $caption, 'colgroups' => $colgroups, 'sticky' => FALSE));
     $js = drupal_add_js();
-    $this->assertFalse(isset($js['misc/tableheader.js']), t('tableheader.js was not included because $sticky = FALSE.'));
-    $this->assertNoRaw('sticky-enabled',  t('Table does not have a class of sticky-enabled because $sticky = FALSE.'));
+    $this->assertFalse(isset($js['misc/tableheader.js']), 'tableheader.js was not included because $sticky = FALSE.');
+    $this->assertNoRaw('sticky-enabled', 'Table does not have a class of sticky-enabled because $sticky = FALSE.');
     drupal_static_reset('drupal_add_js');
   }
 
@@ -211,10 +211,24 @@ class ThemeTableTestCase extends DrupalWebTestCase {
       ),
     );
     $this->content = theme('table', array('header' => $header, 'rows' => array(), 'empty' => t('No strings available.')));
-    $this->assertRaw('<tr class="odd"><td colspan="3" class="empty message">No strings available.</td>', t('Correct colspan was set on empty message.'));
-    $this->assertRaw('<thead><tr><th>Header 1</th>', t('Table header was printed.'));
+    $this->assertRaw('<tr class="odd"><td colspan="3" class="empty message">No strings available.</td>', 'Correct colspan was set on empty message.');
+    $this->assertRaw('<thead><tr><th>Header 1</th>', 'Table header was printed.');
   }
 
+  /**
+   * Tests that the 'no_striping' option works correctly.
+   */
+  function testThemeTableWithNoStriping() {
+    $rows = array(
+      array(
+        'data' => array(1),
+        'no_striping' => TRUE,
+      ),
+    );
+    $this->content = theme('table', array('rows' => $rows));
+    $this->assertNoRaw('class="odd"', 'Odd/even classes were not added because $no_striping = TRUE.');
+    $this->assertNoRaw('no_striping', 'No invalid no_striping HTML attribute was printed.');
+  }
 }
 
 /**
@@ -321,14 +335,14 @@ class ThemeLinksTest extends DrupalWebTestCase {
     $html = drupal_render($render_array);
     $dom = new DOMDocument();
     $dom->loadHTML($html);
-    $this->assertEqual($dom->getElementsByTagName('ul')->length, 1, t('One "ul" tag found in the rendered HTML.'));
+    $this->assertEqual($dom->getElementsByTagName('ul')->length, 1, 'One "ul" tag found in the rendered HTML.');
     $list_elements = $dom->getElementsByTagName('li');
-    $this->assertEqual($list_elements->length, 3, t('Three "li" tags found in the rendered HTML.'));
-    $this->assertEqual($list_elements->item(0)->nodeValue, 'Parent link original', t('First expected link found.'));
-    $this->assertEqual($list_elements->item(1)->nodeValue, 'First child link', t('Second expected link found.'));
-    $this->assertEqual($list_elements->item(2)->nodeValue, 'Second child link', t('Third expected link found.'));
-    $this->assertIdentical(strpos($html, 'Parent link copy'), FALSE, t('"Parent link copy" link not found.'));
-    $this->assertIdentical(strpos($html, 'Third child link'), FALSE, t('"Third child link" link not found.'));
+    $this->assertEqual($list_elements->length, 3, 'Three "li" tags found in the rendered HTML.');
+    $this->assertEqual($list_elements->item(0)->nodeValue, 'Parent link original', 'First expected link found.');
+    $this->assertEqual($list_elements->item(1)->nodeValue, 'First child link', 'Second expected link found.');
+    $this->assertEqual($list_elements->item(2)->nodeValue, 'Second child link', 'Third expected link found.');
+    $this->assertIdentical(strpos($html, 'Parent link copy'), FALSE, '"Parent link copy" link not found.');
+    $this->assertIdentical(strpos($html, 'Third child link'), FALSE, '"Third child link" link not found.');
 
     // Now render 'first_child', followed by the rest of the links, and make
     // sure we get two separate <ul>'s with the appropriate links contained
@@ -339,21 +353,21 @@ class ThemeLinksTest extends DrupalWebTestCase {
     // First check the child HTML.
     $dom = new DOMDocument();
     $dom->loadHTML($child_html);
-    $this->assertEqual($dom->getElementsByTagName('ul')->length, 1, t('One "ul" tag found in the rendered child HTML.'));
+    $this->assertEqual($dom->getElementsByTagName('ul')->length, 1, 'One "ul" tag found in the rendered child HTML.');
     $list_elements = $dom->getElementsByTagName('li');
-    $this->assertEqual($list_elements->length, 2, t('Two "li" tags found in the rendered child HTML.'));
-    $this->assertEqual($list_elements->item(0)->nodeValue, 'Parent link copy', t('First expected link found.'));
-    $this->assertEqual($list_elements->item(1)->nodeValue, 'First child link', t('Second expected link found.'));
+    $this->assertEqual($list_elements->length, 2, 'Two "li" tags found in the rendered child HTML.');
+    $this->assertEqual($list_elements->item(0)->nodeValue, 'Parent link copy', 'First expected link found.');
+    $this->assertEqual($list_elements->item(1)->nodeValue, 'First child link', 'Second expected link found.');
     // Then check the parent HTML.
     $dom = new DOMDocument();
     $dom->loadHTML($parent_html);
-    $this->assertEqual($dom->getElementsByTagName('ul')->length, 1, t('One "ul" tag found in the rendered parent HTML.'));
+    $this->assertEqual($dom->getElementsByTagName('ul')->length, 1, 'One "ul" tag found in the rendered parent HTML.');
     $list_elements = $dom->getElementsByTagName('li');
-    $this->assertEqual($list_elements->length, 2, t('Two "li" tags found in the rendered parent HTML.'));
-    $this->assertEqual($list_elements->item(0)->nodeValue, 'Parent link original', t('First expected link found.'));
-    $this->assertEqual($list_elements->item(1)->nodeValue, 'Second child link', t('Second expected link found.'));
-    $this->assertIdentical(strpos($parent_html, 'First child link'), FALSE, t('"First child link" link not found.'));
-    $this->assertIdentical(strpos($parent_html, 'Third child link'), FALSE, t('"Third child link" link not found.'));
+    $this->assertEqual($list_elements->length, 2, 'Two "li" tags found in the rendered parent HTML.');
+    $this->assertEqual($list_elements->item(0)->nodeValue, 'Parent link original', 'First expected link found.');
+    $this->assertEqual($list_elements->item(1)->nodeValue, 'Second child link', 'Second expected link found.');
+    $this->assertIdentical(strpos($parent_html, 'First child link'), FALSE, '"First child link" link not found.');
+    $this->assertIdentical(strpos($parent_html, 'Third child link'), FALSE, '"Third child link" link not found.');
   }
 }
 
@@ -378,8 +392,8 @@ class ThemeHookInitTestCase extends DrupalWebTestCase {
    */
   function testThemeInitializationHookInit() {
     $this->drupalGet('theme-test/hook-init');
-    $this->assertRaw('Themed output generated in hook_init()', t('Themed output generated in hook_init() correctly appears on the page.'));
-    $this->assertRaw('bartik/css/style.css', t("The default theme's CSS appears on the page when the theme system is initialized in hook_init()."));
+    $this->assertRaw('Themed output generated in hook_init()', 'Themed output generated in hook_init() correctly appears on the page.');
+    $this->assertRaw('bartik/css/style.css', "The default theme's CSS appears on the page when the theme system is initialized in hook_init().");
   }
 }
 
@@ -406,7 +420,7 @@ class ThemeFastTestCase extends DrupalWebTestCase {
   function testUserAutocomplete() {
     $this->drupalLogin($this->account);
     $this->drupalGet('user/autocomplete/' . $this->account->name);
-    $this->assertText('registry not initialized', t('The registry was not initialized'));
+    $this->assertText('registry not initialized', 'The registry was not initialized');
   }
 }
 
@@ -428,11 +442,11 @@ class ThemeHtmlTag extends DrupalUnitTestCase {
   function testThemeHtmlTag() {
     // Test auto-closure meta tag generation
     $tag['element'] = array('#tag' => 'meta', '#attributes' => array('name' => 'description', 'content' => 'Drupal test'));
-    $this->assertEqual('<meta name="description" content="Drupal test" />'."\n", theme_html_tag($tag), t('Test auto-closure meta tag generation.'));
+    $this->assertEqual('<meta name="description" content="Drupal test" />'."\n", theme_html_tag($tag), 'Test auto-closure meta tag generation.');
 
     // Test title tag generation
     $tag['element'] = array('#tag' => 'title', '#value' => 'title test');
-    $this->assertEqual('<title>title test</title>'."\n", theme_html_tag($tag), t('Test title tag generation.'));
+    $this->assertEqual('<title>title test</title>'."\n", theme_html_tag($tag), 'Test title tag generation.');
   }
 }
 
diff --git a/modules/simpletest/tests/unicode.test b/modules/simpletest/tests/unicode.test
index cf7991b..4aaf26d 100644
--- a/modules/simpletest/tests/unicode.test
+++ b/modules/simpletest/tests/unicode.test
@@ -80,7 +80,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
     }
 
     foreach ($testcase as $input => $output) {
-      $this->assertEqual(drupal_strtolower($input), $output, t('%input is lowercased as %output', array('%input' => $input, '%output' => $output)));
+      $this->assertEqual(drupal_strtolower($input), $output, format_string('%input is lowercased as %output', array('%input' => $input, '%output' => $output)));
     }
   }
 
@@ -94,7 +94,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
     }
 
     foreach ($testcase as $input => $output) {
-      $this->assertEqual(drupal_strtoupper($input), $output, t('%input is uppercased as %output', array('%input' => $input, '%output' => $output)));
+      $this->assertEqual(drupal_strtoupper($input), $output, format_string('%input is uppercased as %output', array('%input' => $input, '%output' => $output)));
     }
   }
 
@@ -110,7 +110,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
     }
 
     foreach ($testcase as $input => $output) {
-      $this->assertEqual(drupal_ucfirst($input), $output, t('%input is ucfirst-ed as %output', array('%input' => $input, '%output' => $output)));
+      $this->assertEqual(drupal_ucfirst($input), $output, format_string('%input is ucfirst-ed as %output', array('%input' => $input, '%output' => $output)));
     }
   }
 
@@ -121,7 +121,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
     );
 
     foreach ($testcase as $input => $output) {
-      $this->assertEqual(drupal_strlen($input), $output, t('%input length is %output', array('%input' => $input, '%output' => $output)));
+      $this->assertEqual(drupal_strlen($input), $output, format_string('%input length is %output', array('%input' => $input, '%output' => $output)));
     }
   }
 
@@ -181,7 +181,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
     foreach ($testcase as $test) {
       list($input, $start, $length, $output) = $test;
       $result = drupal_substr($input, $start, $length);
-      $this->assertEqual($result, $output, t('%input substring at offset %offset for %length characters is %output (got %result)', array('%input' => $input, '%offset' => $start, '%length' => $length, '%output' => $output, '%result' => $result)));
+      $this->assertEqual($result, $output, format_string('%input substring at offset %offset for %length characters is %output (got %result)', array('%input' => $input, '%offset' => $start, '%length' => $length, '%output' => $output, '%result' => $result)));
     }
   }
 
@@ -213,7 +213,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
       '&euro;' => '€',
     );
     foreach ($testcase as $input => $output) {
-      $this->assertEqual(decode_entities($input), $output, t('Make sure the decoded entity of @input is @output', array('@input' => $input, '@output' => $output)));
+      $this->assertEqual(decode_entities($input), $output, format_string('Make sure the decoded entity of @input is @output', array('@input' => $input, '@output' => $output)));
     }
   }
 
@@ -299,7 +299,7 @@ class UnicodeUnitTest extends DrupalUnitTestCase {
     foreach ($cases as $case) {
       list($input, $max_length, $expected) = $case;
       $output = truncate_utf8($input, $max_length, $wordsafe, $ellipsis);
-      $this->assertEqual($output, $expected, t('%input truncate to %length characters with %wordsafe, %ellipsis is %expected (got %output)', array('%input' => $input, '%length' => $max_length, '%output' => $output, '%expected' => $expected, '%wordsafe' => ($wordsafe ? 'word-safe' : 'not word-safe'), '%ellipsis' => ($ellipsis ? 'ellipsis' : 'not ellipsis'))));
+      $this->assertEqual($output, $expected, format_string('%input truncate to %length characters with %wordsafe, %ellipsis is %expected (got %output)', array('%input' => $input, '%length' => $max_length, '%output' => $output, '%expected' => $expected, '%wordsafe' => ($wordsafe ? 'word-safe' : 'not word-safe'), '%ellipsis' => ($ellipsis ? 'ellipsis' : 'not ellipsis'))));
     }
   }
 }
diff --git a/modules/simpletest/tests/update.test b/modules/simpletest/tests/update.test
index 966efff..1606085 100644
--- a/modules/simpletest/tests/update.test
+++ b/modules/simpletest/tests/update.test
@@ -35,7 +35,7 @@ class UpdateDependencyOrderingTestCase extends DrupalWebTestCase {
       'update_test_1_update_7002',
     );
     $actual_updates = array_keys(update_resolve_dependencies($starting_updates));
-    $this->assertEqual($expected_updates, $actual_updates, t('Updates within a single module run in the correct order.'));
+    $this->assertEqual($expected_updates, $actual_updates, 'Updates within a single module run in the correct order.');
   }
 
   /**
@@ -49,9 +49,9 @@ class UpdateDependencyOrderingTestCase extends DrupalWebTestCase {
     $update_order = array_keys(update_resolve_dependencies($starting_updates));
     // Make sure that each dependency is satisfied.
     $first_dependency_satisfied = array_search('update_test_2_update_7000', $update_order) < array_search('update_test_3_update_7000', $update_order);
-    $this->assertTrue($first_dependency_satisfied, t('The dependency of the second module on the first module is respected by the update function order.'));
+    $this->assertTrue($first_dependency_satisfied, 'The dependency of the second module on the first module is respected by the update function order.');
     $second_dependency_satisfied = array_search('update_test_3_update_7000', $update_order) < array_search('update_test_2_update_7001', $update_order);
-    $this->assertTrue($second_dependency_satisfied, t('The dependency of the first module on the second module is respected by the update function order.'));
+    $this->assertTrue($second_dependency_satisfied, 'The dependency of the first module on the second module is respected by the update function order.');
   }
 }
 
@@ -79,9 +79,9 @@ class UpdateDependencyMissingTestCase extends DrupalWebTestCase {
       'update_test_2' => 7000,
     );
     $update_graph = update_resolve_dependencies($starting_updates);
-    $this->assertTrue($update_graph['update_test_2_update_7000']['allowed'], t("The module's first update function is allowed to run, since it does not have any missing dependencies."));
-    $this->assertFalse($update_graph['update_test_2_update_7001']['allowed'], t("The module's second update function is not allowed to run, since it has a direct dependency on a missing update."));
-    $this->assertFalse($update_graph['update_test_2_update_7002']['allowed'], t("The module's third update function is not allowed to run, since it has an indirect dependency on a missing update."));
+    $this->assertTrue($update_graph['update_test_2_update_7000']['allowed'], "The module's first update function is allowed to run, since it does not have any missing dependencies.");
+    $this->assertFalse($update_graph['update_test_2_update_7001']['allowed'], "The module's second update function is not allowed to run, since it has a direct dependency on a missing update.");
+    $this->assertFalse($update_graph['update_test_2_update_7002']['allowed'], "The module's third update function is not allowed to run, since it has an indirect dependency on a missing update.");
   }
 }
 
@@ -107,9 +107,9 @@ class UpdateDependencyHookInvocationTestCase extends DrupalWebTestCase {
    */
   function testHookUpdateDependencies() {
     $update_dependencies = update_retrieve_dependencies();
-    $this->assertTrue($update_dependencies['system'][7000]['update_test_1'] == 7000, t('An update function that has a dependency on two separate modules has the first dependency recorded correctly.'));
-    $this->assertTrue($update_dependencies['system'][7000]['update_test_2'] == 7001, t('An update function that has a dependency on two separate modules has the second dependency recorded correctly.'));
-    $this->assertTrue($update_dependencies['system'][7001]['update_test_1'] == 7002, t('An update function that depends on more than one update from the same module only has the dependency on the higher-numbered update function recorded.'));
+    $this->assertTrue($update_dependencies['system'][7000]['update_test_1'] == 7000, 'An update function that has a dependency on two separate modules has the first dependency recorded correctly.');
+    $this->assertTrue($update_dependencies['system'][7000]['update_test_2'] == 7001, 'An update function that has a dependency on two separate modules has the second dependency recorded correctly.');
+    $this->assertTrue($update_dependencies['system'][7001]['update_test_1'] == 7002, 'An update function that depends on more than one update from the same module only has the dependency on the higher-numbered update function recorded.');
   }
 }
 
diff --git a/modules/simpletest/tests/upgrade/drupal-6.duplicate-permission.database.php b/modules/simpletest/tests/upgrade/drupal-6.duplicate-permission.database.php
new file mode 100644
index 0000000..5da5e84
--- /dev/null
+++ b/modules/simpletest/tests/upgrade/drupal-6.duplicate-permission.database.php
@@ -0,0 +1,8 @@
+<?php
+
+// Simulate duplicated permission condition.
+db_update('permission')->fields(array(
+  'perm' => 'access content, access content',
+))
+->condition('pid', 1)
+->execute();
diff --git a/modules/simpletest/tests/upgrade/update.field.test b/modules/simpletest/tests/upgrade/update.field.test
index 60d6ae8..a4b11c3 100644
--- a/modules/simpletest/tests/upgrade/update.field.test
+++ b/modules/simpletest/tests/upgrade/update.field.test
@@ -34,7 +34,7 @@ class FieldUpdatePathTestCase extends UpdatePathTestCase {
    * Tests that the update is successful.
    */
   public function testFilledUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The update was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The update was completed successfully.');
     $expected_settings = array(
       'extra_fields' => array(
         'display' => array(
diff --git a/modules/simpletest/tests/upgrade/update.trigger.test b/modules/simpletest/tests/upgrade/update.trigger.test
index a91f7b9..24ac87c 100644
--- a/modules/simpletest/tests/upgrade/update.trigger.test
+++ b/modules/simpletest/tests/upgrade/update.trigger.test
@@ -32,6 +32,6 @@ class TriggerUpdatePathTestCase extends UpdatePathTestCase {
    * Tests that the upgrade is successful.
    */
   public function testFilledUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
   }
 }
diff --git a/modules/simpletest/tests/upgrade/update.user.test b/modules/simpletest/tests/upgrade/update.user.test
index 4993139..dd0fc1b 100644
--- a/modules/simpletest/tests/upgrade/update.user.test
+++ b/modules/simpletest/tests/upgrade/update.user.test
@@ -29,7 +29,7 @@ class UserUpdatePathTestCase extends UpdatePathTestCase {
    * Tests that the update is successful.
    */
   public function testFilledUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The update was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The update was completed successfully.');
     $this->assertTrue(db_index_exists('users', 'picture'), 'The {users}.picture column has an index.');
   }
 }
diff --git a/modules/simpletest/tests/upgrade/upgrade.comment.test b/modules/simpletest/tests/upgrade/upgrade.comment.test
index 5fcf0b4..40d893a 100644
--- a/modules/simpletest/tests/upgrade/upgrade.comment.test
+++ b/modules/simpletest/tests/upgrade/upgrade.comment.test
@@ -27,6 +27,6 @@ class CommentUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   public function testCommentUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
   }
 }
diff --git a/modules/simpletest/tests/upgrade/upgrade.filter.test b/modules/simpletest/tests/upgrade/upgrade.filter.test
index 86248b7..584f4d9 100644
--- a/modules/simpletest/tests/upgrade/upgrade.filter.test
+++ b/modules/simpletest/tests/upgrade/upgrade.filter.test
@@ -28,20 +28,20 @@ class FilterFormatUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   function testFilterFormatUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     $format = filter_format_load('1');
-    $this->assertTrue($format->format == '1', t('Filter format found.'));
+    $this->assertTrue($format->format == '1', 'Filter format found.');
     $format->format = 'test_filter';
     $format->name = 'Test filter';
     filter_format_save($format);
     $format = filter_format_load('test_filter');
-    $this->assertTrue($format->format == 'test_filter', t('Saved a filter format with machine name.'));
+    $this->assertTrue($format->format == 'test_filter', 'Saved a filter format with machine name.');
 
     $account = user_load(4);
     user_save($account, array('signature_format' => 'test_filter'));
     $account = user_load(4);
-    $this->assertTrue($account->signature_format == 'test_filter', t('Signature format changed successfully to a filter format with machine name.'));
+    $this->assertTrue($account->signature_format == 'test_filter', 'Signature format changed successfully to a filter format with machine name.');
 
     $delta = db_insert('block_custom')
       ->fields(array(
@@ -50,6 +50,6 @@ class FilterFormatUpgradePathTestCase extends UpgradePathTestCase {
         'format' => 'test_filter',
       ))
       ->execute();
-    $this->assertTrue($delta > 0, t('Created a custom block using a filter format with machine name.'));
+    $this->assertTrue($delta > 0, 'Created a custom block using a filter format with machine name.');
   }
 }
diff --git a/modules/simpletest/tests/upgrade/upgrade.forum.test b/modules/simpletest/tests/upgrade/upgrade.forum.test
index ebac854..b0bbd4e 100644
--- a/modules/simpletest/tests/upgrade/upgrade.forum.test
+++ b/modules/simpletest/tests/upgrade/upgrade.forum.test
@@ -27,7 +27,7 @@ class ForumUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade (no negotiation).
    */
   public function testForumUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Work around http://drupal.org/node/931512
     $this->drupalPost('admin/structure/types/manage/forum/fields', array(), t('Save'));
@@ -47,11 +47,11 @@ class ForumUpgradePathTestCase extends UpgradePathTestCase {
     );
     $this->drupalPost("node/add/forum/$tid", $edit, t('Save'));
     $type = t('Forum topic');
-    $this->assertRaw(t('@type %title has been created.', array('@type' => $type, '%title' => $title)), t('Forum topic was created'));
+    $this->assertRaw(t('@type %title has been created.', array('@type' => $type, '%title' => $title)), 'Forum topic was created');
 
     // Retrieve node object, ensure that the topic was created and in the proper forum.
     $node = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($node != NULL, t('Node @title was loaded', array('@title' => $title)));
+    $this->assertTrue($node != NULL, format_string('Node @title was loaded', array('@title' => $title)));
     $this->assertEqual($node->taxonomy_forums[LANGUAGE_NONE][0]['tid'], $tid, 'Saved forum topic was in the expected forum');
 
     $this->drupalGet("forum/$tid");
@@ -59,6 +59,6 @@ class ForumUpgradePathTestCase extends UpgradePathTestCase {
     $this->drupalLogout();
 
     $this->drupalGet("node/add/forum/$tid");
-    $this->assertResponse(200, t('User can access forum creation page.'));
+    $this->assertResponse(200, 'User can access forum creation page.');
   }
 }
diff --git a/modules/simpletest/tests/upgrade/upgrade.locale.test b/modules/simpletest/tests/upgrade/upgrade.locale.test
index aec559d..2a3056b 100644
--- a/modules/simpletest/tests/upgrade/upgrade.locale.test
+++ b/modules/simpletest/tests/upgrade/upgrade.locale.test
@@ -27,7 +27,7 @@ class LocaleUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade (no negotiation).
    */
   public function testLocaleUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // The home page should be in French.
     $this->assertPageInLanguage('', 'fr');
@@ -46,13 +46,13 @@ class LocaleUpgradePathTestCase extends UpgradePathTestCase {
     // LANGUAGE_NEGOTIATION_PATH_DEFAULT.
     $this->variable_set('language_negotiation', 1);
 
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // The home page should be in French.
     $this->assertPageInLanguage('', 'fr');
 
     // The language switcher block should be displayed.
-    $this->assertRaw('block-locale-language', t('The language switcher block is displayed.'));
+    $this->assertRaw('block-locale-language', 'The language switcher block is displayed.');
 
     // The French prefix should not be active because French is the default language.
     $this->drupalGet('fr');
@@ -75,7 +75,7 @@ class LocaleUpgradePathTestCase extends UpgradePathTestCase {
       ->condition('uid', 1)
       ->execute();
 
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Both prefixes should be active.
     $this->assertPageInLanguage('fr', 'fr');
@@ -85,7 +85,7 @@ class LocaleUpgradePathTestCase extends UpgradePathTestCase {
     $this->assertPageInLanguage('', 'en');
 
     // The language switcher block should be displayed.
-    $this->assertRaw('block-locale-language', t('The language switcher block is displayed.'));
+    $this->assertRaw('block-locale-language', 'The language switcher block is displayed.');
   }
 
   /**
@@ -95,13 +95,13 @@ class LocaleUpgradePathTestCase extends UpgradePathTestCase {
     // LANGUAGE_NEGOTIATION_DOMAIN.
     $this->variable_set('language_negotiation', 3);
 
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // The home page should be in French.
     $this->assertPageInLanguage('', 'fr');
 
     // The language switcher block should be displayed.
-    $this->assertRaw('block-locale-language', t('The language switcher block is displayed.'));
+    $this->assertRaw('block-locale-language', 'The language switcher block is displayed.');
 
     // The language switcher block should point to http://en.example.com.
     $language_links = $this->xpath('//ul[contains(@class, :class)]/li/a', array(':class' => 'language-switcher-locale-url'));
@@ -111,7 +111,7 @@ class LocaleUpgradePathTestCase extends UpgradePathTestCase {
         $found_english_link = TRUE;
       }
     }
-    $this->assertTrue($found_english_link, t('The English link points to the correct domain.'));
+    $this->assertTrue($found_english_link, 'The English link points to the correct domain.');
 
     // Both prefixes should be inactive.
     $this->drupalGet('en');
diff --git a/modules/simpletest/tests/upgrade/upgrade.menu.test b/modules/simpletest/tests/upgrade/upgrade.menu.test
index bf28a5f..d9ae6c1 100644
--- a/modules/simpletest/tests/upgrade/upgrade.menu.test
+++ b/modules/simpletest/tests/upgrade/upgrade.menu.test
@@ -27,7 +27,7 @@ class MenuUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   public function testMenuUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Test the migration of "Default menu for content" setting to individual
     // node types.
diff --git a/modules/simpletest/tests/upgrade/upgrade.node.test b/modules/simpletest/tests/upgrade/upgrade.node.test
index b49a40b..4ac14c5 100644
--- a/modules/simpletest/tests/upgrade/upgrade.node.test
+++ b/modules/simpletest/tests/upgrade/upgrade.node.test
@@ -26,7 +26,7 @@ class NodeBodyUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   public function testNodeBodyUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     $instance = field_info_instance('node', 'body', 'story');
     $this->assertIdentical($instance['required'], 0, 'The required setting was preserved during the upgrade path.');
@@ -77,7 +77,7 @@ class DisabledNodeTypeTestCase extends UpgradePathTestCase {
    * Tests a successful upgrade.
    */
   public function testDisabledNodeTypeUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
     $this->assertTrue(field_info_instance('comment', 'comment_body', 'comment_node_broken'), 'Comment body field instance was created for comments attached to the disabled broken node type');
   }
 }
@@ -114,7 +114,7 @@ class PollUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   public function testPollUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Check modules page for poll
     $this->drupalGet('admin/modules');
@@ -126,14 +126,14 @@ class PollUpgradePathTestCase extends UpgradePathTestCase {
       $nbchoices = ($i % 4) + 2;
 
       for ($c = 0; $c < $nbchoices; $c++) {
-        $this->assertText("Choice $c for poll $i", t('Choice text is displayed correctly on poll view'));
+        $this->assertText("Choice $c for poll $i", 'Choice text is displayed correctly on poll view');
       }
 
       // Now check that the votes are correct
       $this->clickLink(t('Results'));
 
       for ($c = 0; $c < $nbchoices; $c++) {
-        $this->assertText("Choice $c for poll $i", t('Choice text is displayed correctly on result view'));
+        $this->assertText("Choice $c for poll $i", 'Choice text is displayed correctly on result view');
       }
 
       $nbvotes = floor (($i % 4) + 5);
@@ -141,7 +141,7 @@ class PollUpgradePathTestCase extends UpgradePathTestCase {
       for ($c = 0; $c < $nbchoices; $c++) {
         $votes = floor($nbvotes / $nbchoices);
         if (($nbvotes % $nbchoices) > $c) $votes++;
-        $this->assertTrue(preg_match("/$votes vote/", $elements[$c]), t('The number of votes is displayed correctly: expected ' . $votes . ', got ' . $elements[$c]));
+        $this->assertTrue(preg_match("/$votes vote/", $elements[$c]), 'The number of votes is displayed correctly: expected ' . $votes . ', got ' . $elements[$c]);
       }
     }
   }
diff --git a/modules/simpletest/tests/upgrade/upgrade.poll.test b/modules/simpletest/tests/upgrade/upgrade.poll.test
index 9bbbf90..ac4ea43 100644
--- a/modules/simpletest/tests/upgrade/upgrade.poll.test
+++ b/modules/simpletest/tests/upgrade/upgrade.poll.test
@@ -32,7 +32,7 @@ class PollUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   public function testPollUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Check modules page for poll
     $this->drupalGet('admin/modules');
@@ -44,14 +44,14 @@ class PollUpgradePathTestCase extends UpgradePathTestCase {
       $nbchoices = ($i % 4) + 2;
 
       for ($c = 0; $c < $nbchoices; $c++) {
-        $this->assertText("Choice $c for poll $i", t('Choice text is displayed correctly on poll view'));
+        $this->assertText("Choice $c for poll $i", 'Choice text is displayed correctly on poll view');
       }
 
       // Now check that the votes are correct
       $this->clickLink(t('Results'));
 
       for ($c = 0; $c < $nbchoices; $c++) {
-        $this->assertText("Choice $c for poll $i", t('Choice text is displayed correctly on result view'));
+        $this->assertText("Choice $c for poll $i", 'Choice text is displayed correctly on result view');
       }
 
       $nbvotes = floor (($i % 4) + 5);
@@ -59,7 +59,7 @@ class PollUpgradePathTestCase extends UpgradePathTestCase {
       for ($c = 0; $c < $nbchoices; $c++) {
         $votes = floor($nbvotes / $nbchoices);
         if (($nbvotes % $nbchoices) > $c) $votes++;
-        $this->assertTrue(preg_match("/$votes vote/", $elements[$c]), t('The number of votes is displayed correctly: expected ' . $votes . ', got ' . $elements[$c]));
+        $this->assertTrue(preg_match("/$votes vote/", $elements[$c]), 'The number of votes is displayed correctly: expected ' . $votes . ', got ' . $elements[$c]);
       }
     }
   }
diff --git a/modules/simpletest/tests/upgrade/upgrade.taxonomy.test b/modules/simpletest/tests/upgrade/upgrade.taxonomy.test
index 37de087..e0142f4 100644
--- a/modules/simpletest/tests/upgrade/upgrade.taxonomy.test
+++ b/modules/simpletest/tests/upgrade/upgrade.taxonomy.test
@@ -46,15 +46,15 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
    * Basic tests for the taxonomy upgrade.
    */
   public function testTaxonomyUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Visit the front page to assert for PHP warning and errors.
     $this->drupalGet('');
 
     // Check that taxonomy_vocabulary_node_type and taxonomy_term_node have been
     // removed.
-    $this->assertFalse(db_table_exists('taxonomy_vocabulary_node_type'), t('taxonomy_vocabulary_node_type has been removed.'));
-    $this->assertFalse(db_table_exists('taxonomy_term_node'), t('taxonomy_term_node has been removed.'));
+    $this->assertFalse(db_table_exists('taxonomy_vocabulary_node_type'), 'taxonomy_vocabulary_node_type has been removed.');
+    $this->assertFalse(db_table_exists('taxonomy_term_node'), 'taxonomy_term_node has been removed.');
 
     // Check that the node type 'page' has been associated to a taxonomy
     // reference field for each vocabulary.
@@ -66,7 +66,7 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
     $inst_keys = array_keys($instances);
     sort($voc_keys);
     sort($inst_keys);
-    $this->assertEqual($voc_keys, $inst_keys, t('Node type page has instances for every vocabulary.'));
+    $this->assertEqual($voc_keys, $inst_keys, 'Node type page has instances for every vocabulary.');
 
     // Ensure instance variables are getting through.
     foreach ($instances as $instance) {
@@ -80,13 +80,13 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
     // the taxonomyextra field.
     $instances = $this->instanceVocabularies('node', 'story');
     $field_names = array_flip($instances);
-    $this->assertEqual(count($field_names), 1, t('Only one taxonomy term field instance exists for story nodes'));
-    $this->assertEqual(key($field_names), 'taxonomyextra', t('Only the excess taxonomy term field is used on story nodes'));
+    $this->assertEqual(count($field_names), 1, 'Only one taxonomy term field instance exists for story nodes');
+    $this->assertEqual(key($field_names), 'taxonomyextra', 'Only the excess taxonomy term field is used on story nodes');
 
     // Check that the node type 'poll' has been associated to no taxonomy
     // reference field.
     $instances = $this->instanceVocabularies('node', 'poll');
-    $this->assertTrue(empty($instances), t('Node type poll has no taxonomy term reference field instances.'));
+    $this->assertTrue(empty($instances), 'Node type poll has no taxonomy term reference field instances.');
 
     // Check that each node of type 'page' and 'story' is associated to all the
     // terms except terms whose ID is equal to the node ID or is equal to the
@@ -147,14 +147,14 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
         if (!$should_be_displayed) {
           // Look for any link with the term path.
           $links = $this->xpath('//a[@href=:term_path]', array(':term_path' => $term_path));
-          $this->assertFalse($links, t('Term %name (@field) is not displayed on node %nid', $args));
+          $this->assertFalse($links, format_string('Term %name (@field) is not displayed on node %nid', $args));
         }
         else {
           // Look for a link with the term path inside the correct field.
           // We search for "SPACE + class + SPACE" to avoid matching a substring
           // of the class.
           $links = $this->xpath('//div[contains(concat(" ", normalize-space(@class), " "), :field_class)]//a[@href=:term_path]', array(':field_class' => ' ' . $field_class . ' ', ':term_path' => $term_path));
-          $this->assertTrue($links, t('Term %name (@field) is displayed on node %nid', $args));
+          $this->assertTrue($links, format_string('Term %name (@field) is displayed on node %nid', $args));
         }
       }
 
@@ -162,7 +162,7 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
       // ID 0. Make sure we ignored this instead of generating a bogus term.
       if ($node->nid == 1) {
         $link = l($term->name, 'taxonomy/term/0');
-        $this->assertNoRaw($link, t('Bogus term (tid 0) is not displayed on node 1 vid %old_vid.', $args));
+        $this->assertNoRaw($link, format_string('Bogus term (tid 0) is not displayed on node 1 vid %old_vid.', $args));
       }
 
       // The first 12 nodes have two revisions. For nodes with
@@ -170,7 +170,7 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
       // to terms whose ID is equal to the node ID or 49 less the node ID.
       $revisions = node_revision_list($node);
       if ($node->nid < 13) {
-        $this->assertEqual(count($revisions), 2, t('Node %nid has two revisions.', $args));
+        $this->assertEqual(count($revisions), 2, format_string('Node %nid has two revisions.', $args));
         $last_rev = end($revisions);
         $args['%old_vid'] = $last_rev->vid;
 
@@ -183,13 +183,13 @@ class UpgradePathTaxonomyTestCase extends UpgradePathTestCase {
 
         $term = $terms[$node->nid];
         $link = l($term->name, 'taxonomy/term/' . $term->tid);
-        $this->assertRaw($link, t('Term %name (@field) is displayed on node %nid vid %old_vid.', $args));
+        $this->assertRaw($link, format_string('Term %name (@field) is displayed on node %nid vid %old_vid.', $args));
         $term = $terms[49-$node->nid];
         $link = l($term->name, 'taxonomy/term/' . $term->tid);
-        $this->assertRaw($link, t('Term %name (@field) is displayed on node %nid %old_vid.', $args));
+        $this->assertRaw($link, format_string('Term %name (@field) is displayed on node %nid %old_vid.', $args));
       }
       else {
-        $this->assertEqual(count($revisions), 1, t('Node %nid has one revision.', $args));
+        $this->assertEqual(count($revisions), 1, format_string('Node %nid has one revision.', $args));
       }
     }
   }
diff --git a/modules/simpletest/tests/upgrade/upgrade.test b/modules/simpletest/tests/upgrade/upgrade.test
index 9df8ec7..784a091 100644
--- a/modules/simpletest/tests/upgrade/upgrade.test
+++ b/modules/simpletest/tests/upgrade/upgrade.test
@@ -256,7 +256,7 @@ abstract class UpgradePathTestCase extends DrupalWebTestCase {
     // Check if there still are pending updates.
     $this->drupalGet($update_url, array('external' => TRUE));
     $this->drupalPost(NULL, array(), t('Continue'));
-    if (!$this->assertText(t('No pending updates.'), t('No pending updates at the end of the update process.'))) {
+    if (!$this->assertText(t('No pending updates.'), 'No pending updates at the end of the update process.')) {
       return FALSE;
     }
 
@@ -358,14 +358,14 @@ class BasicUpgradePath extends UpgradePathTestCase {
     // Destroy a table that the upgrade process needs.
     db_drop_table('access');
     // Assert that the upgrade fails.
-    $this->assertFalse($this->performUpgrade(FALSE) && $this->pendingUpdates, t('A failed upgrade should return messages.'));
+    $this->assertFalse($this->performUpgrade(FALSE) && $this->pendingUpdates, 'A failed upgrade should return messages.');
   }
 
   /**
    * Test a successful upgrade.
    */
   public function testBasicUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Hit the frontpage.
     $this->drupalGet('');
@@ -374,7 +374,7 @@ class BasicUpgradePath extends UpgradePathTestCase {
     // Verify that we are still logged in.
     $this->drupalGet('user');
     $this->clickLink(t('Edit'));
-    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), t('We are still logged in as admin at the end of the upgrade.'));
+    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), 'We are still logged in as admin at the end of the upgrade.');
 
     // Logout and verify that we can login back in with our initial password.
     $this->drupalLogout();
@@ -394,7 +394,7 @@ class BasicUpgradePath extends UpgradePathTestCase {
     ));
 
     // Test that the site name is correctly displayed.
-    $this->assertText('Drupal 6', t('The site name is correctly displayed.'));
+    $this->assertText('Drupal 6', 'The site name is correctly displayed.');
 
     // Verify that the main admin sections are available.
     $this->drupalGet('admin');
@@ -408,11 +408,11 @@ class BasicUpgradePath extends UpgradePathTestCase {
 
     // Confirm that no {menu_links} entry exists for user/autocomplete.
     $result = db_query('SELECT COUNT(*) FROM {menu_links} WHERE link_path = :user_autocomplete', array(':user_autocomplete' => 'user/autocomplete'))->fetchField();
-    $this->assertFalse($result, t('No {menu_links} entry exists for user/autocomplete'));
+    $this->assertFalse($result, 'No {menu_links} entry exists for user/autocomplete');
 
     // Test that the environment after the upgrade is in a consistent status.
     $update_d6 = variable_get('update_d6', FALSE);
-    $this->assertFalse($update_d6, t('The D6 upgrade flag variable has been correctly disabled.'));
+    $this->assertFalse($update_d6, 'The D6 upgrade flag variable has been correctly disabled.');
   }
 }
 
@@ -446,7 +446,7 @@ class BasicStandardUpdatePath extends UpdatePathTestCase {
    * Tests a successful point release update.
    */
   public function testBasicStandardUpdate() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Hit the frontpage.
     $this->drupalGet('');
@@ -455,7 +455,7 @@ class BasicStandardUpdatePath extends UpdatePathTestCase {
     // Verify that we are still logged in.
     $this->drupalGet('user');
     $this->clickLink(t('Edit'));
-    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), t('We are still logged in as admin at the end of the upgrade.'));
+    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), 'We are still logged in as admin at the end of the upgrade.');
 
     // Logout and verify that we can login back in with our initial password.
     $this->drupalLogout();
@@ -475,7 +475,7 @@ class BasicStandardUpdatePath extends UpdatePathTestCase {
     ));
 
     // Test that the site name is correctly displayed.
-    $this->assertText('Drupal', t('The site name is correctly displayed.'));
+    $this->assertText('Drupal', 'The site name is correctly displayed.');
 
     // Verify that the main admin sections are available.
     $this->drupalGet('admin');
@@ -489,7 +489,7 @@ class BasicStandardUpdatePath extends UpdatePathTestCase {
 
     // Confirm that no {menu_links} entry exists for user/autocomplete.
     $result = db_query('SELECT COUNT(*) FROM {menu_links} WHERE link_path = :user_autocomplete', array(':user_autocomplete' => 'user/autocomplete'))->fetchField();
-    $this->assertFalse($result, t('No {menu_links} entry exists for user/autocomplete'));
+    $this->assertFalse($result, 'No {menu_links} entry exists for user/autocomplete');
   }
 }
 
@@ -522,7 +522,7 @@ class BasicMinimalUpdatePath extends UpdatePathTestCase {
    * Tests a successful point release update.
    */
   public function testBasicMinimalUpdate() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Hit the frontpage.
     $this->drupalGet('');
@@ -531,7 +531,7 @@ class BasicMinimalUpdatePath extends UpdatePathTestCase {
     // Verify that we are still logged in.
     $this->drupalGet('user');
     $this->clickLink(t('Edit'));
-    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), t('We are still logged in as admin at the end of the upgrade.'));
+    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), 'We are still logged in as admin at the end of the upgrade.');
 
     // Logout and verify that we can login back in with our initial password.
     $this->drupalLogout();
@@ -551,7 +551,7 @@ class BasicMinimalUpdatePath extends UpdatePathTestCase {
     ));
 
     // Test that the site name is correctly displayed.
-    $this->assertText('Drupal', t('The site name is correctly displayed.'));
+    $this->assertText('Drupal', 'The site name is correctly displayed.');
 
     // Verify that the main admin sections are available.
     $this->drupalGet('admin');
@@ -565,7 +565,21 @@ class BasicMinimalUpdatePath extends UpdatePathTestCase {
 
     // Confirm that no {menu_links} entry exists for user/autocomplete.
     $result = db_query('SELECT COUNT(*) FROM {menu_links} WHERE link_path = :user_autocomplete', array(':user_autocomplete' => 'user/autocomplete'))->fetchField();
-    $this->assertFalse($result, t('No {menu_links} entry exists for user/autocomplete'));
+    $this->assertFalse($result, 'No {menu_links} entry exists for user/autocomplete');
+
+    // Confirm that a date format that just differs in the case can be added.
+    $admin_date_format = 'j M y';
+    $edit = array('date_format' => $admin_date_format);
+    $this->drupalPost('admin/config/regional/date-time/formats/add', $edit, t('Add format'));
+
+    // Add a new date format which just differs in the case.
+    $admin_date_format_uppercase = 'j M Y';
+    $edit = array('date_format' => $admin_date_format_uppercase);
+    $this->drupalPost('admin/config/regional/date-time/formats/add', $edit, t('Add format'));
+    $this->assertText(t('Custom date format added.'));
+
+    // Verify that the unique key on {date_formats}.format still exists.
+    $this->assertTrue(db_index_exists('date_formats', 'formats'), 'Unique key on {date_formats} exists');
   }
 }
 
@@ -599,7 +613,7 @@ class FilledStandardUpdatePath extends UpdatePathTestCase {
    * Tests a successful point release update.
    */
   public function testFilledStandardUpdate() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Hit the frontpage.
     $this->drupalGet('');
@@ -608,7 +622,7 @@ class FilledStandardUpdatePath extends UpdatePathTestCase {
     // Verify that we are still logged in.
     $this->drupalGet('user');
     $this->clickLink(t('Edit'));
-    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), t('We are still logged in as admin at the end of the upgrade.'));
+    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), 'We are still logged in as admin at the end of the upgrade.');
 
     // Logout and verify that we can login back in with our initial password.
     $this->drupalLogout();
@@ -628,7 +642,7 @@ class FilledStandardUpdatePath extends UpdatePathTestCase {
     ));
 
     // Test that the site name is correctly displayed.
-    $this->assertText('Drupal', t('The site name is correctly displayed.'));
+    $this->assertText('Drupal', 'The site name is correctly displayed.');
 
     // Verify that the main admin sections are available.
     $this->drupalGet('admin');
@@ -642,7 +656,7 @@ class FilledStandardUpdatePath extends UpdatePathTestCase {
 
     // Confirm that no {menu_links} entry exists for user/autocomplete.
     $result = db_query('SELECT COUNT(*) FROM {menu_links} WHERE link_path = :user_autocomplete', array(':user_autocomplete' => 'user/autocomplete'))->fetchField();
-    $this->assertFalse($result, t('No {menu_links} entry exists for user/autocomplete'));
+    $this->assertFalse($result, 'No {menu_links} entry exists for user/autocomplete');
   }
 }
 
@@ -675,7 +689,7 @@ class FilledMinimalUpdatePath extends UpdatePathTestCase {
    * Tests a successful point release update.
    */
   public function testFilledStandardUpdate() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // Hit the frontpage.
     $this->drupalGet('');
@@ -684,7 +698,7 @@ class FilledMinimalUpdatePath extends UpdatePathTestCase {
     // Verify that we are still logged in.
     $this->drupalGet('user');
     $this->clickLink(t('Edit'));
-    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), t('We are still logged in as admin at the end of the upgrade.'));
+    $this->assertEqual($this->getUrl(), url('user/1/edit', array('absolute' => TRUE)), 'We are still logged in as admin at the end of the upgrade.');
 
     // Logout and verify that we can login back in with our initial password.
     $this->drupalLogout();
@@ -704,7 +718,7 @@ class FilledMinimalUpdatePath extends UpdatePathTestCase {
     ));
 
     // Test that the site name is correctly displayed.
-    $this->assertText('Drupal', t('The site name is correctly displayed.'));
+    $this->assertText('Drupal', 'The site name is correctly displayed.');
 
     // Verify that the main admin sections are available.
     $this->drupalGet('admin');
@@ -718,6 +732,6 @@ class FilledMinimalUpdatePath extends UpdatePathTestCase {
 
     // Confirm that no {menu_links} entry exists for user/autocomplete.
     $result = db_query('SELECT COUNT(*) FROM {menu_links} WHERE link_path = :user_autocomplete', array(':user_autocomplete' => 'user/autocomplete'))->fetchField();
-    $this->assertFalse($result, t('No {menu_links} entry exists for user/autocomplete'));
+    $this->assertFalse($result, 'No {menu_links} entry exists for user/autocomplete');
   }
 }
diff --git a/modules/simpletest/tests/upgrade/upgrade.translatable.test b/modules/simpletest/tests/upgrade/upgrade.translatable.test
index c9360f3..6fefb0f 100644
--- a/modules/simpletest/tests/upgrade/upgrade.translatable.test
+++ b/modules/simpletest/tests/upgrade/upgrade.translatable.test
@@ -28,7 +28,7 @@ class TranslatableUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade (no negotiation).
    */
   public function testTranslatableUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
 
     // The D6 database contains the english node "First translatable page" with
     // nid 53.
@@ -39,12 +39,12 @@ class TranslatableUpgradePathTestCase extends UpgradePathTestCase {
 
     // Check whether the node displays properly.
     $this->drupalGet("node/$nid");
-    $this->assertText($body, t('Translatable node body displays properly'));
+    $this->assertText($body, 'Translatable node body displays properly');
 
     // Retrieve node object, ensure that both the body and the teaser has
     // survived upgrade properly.
     $node = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($node != NULL, t('Node @title was loaded', array('@title' => $title)));
+    $this->assertTrue($node != NULL, format_string('Node @title was loaded', array('@title' => $title)));
     $this->assertEqual($node->body[LANGUAGE_NONE][0]['value'], $body, 'Body of the node survived upgrade properly');
     $this->assertEqual($node->body[LANGUAGE_NONE][0]['summary'], $teaser, 'Teaser of the node survived upgrade properly');
   }
diff --git a/modules/simpletest/tests/upgrade/upgrade.trigger.test b/modules/simpletest/tests/upgrade/upgrade.trigger.test
index 7413bed..ef23941 100644
--- a/modules/simpletest/tests/upgrade/upgrade.trigger.test
+++ b/modules/simpletest/tests/upgrade/upgrade.trigger.test
@@ -29,7 +29,7 @@ class UpgradePathTriggerTestCase extends UpgradePathTestCase {
    * Basic tests for the trigger upgrade.
    */
   public function testTaxonomyUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
     $this->drupalGet('admin/structure/trigger/node');
     $this->assertRaw('<td>'. t('Make post sticky') .'</td>');
     $this->assertRaw('<td>'. t('Publish post') .'</td>');
diff --git a/modules/simpletest/tests/upgrade/upgrade.upload.test b/modules/simpletest/tests/upgrade/upgrade.upload.test
index 276fae4..be352bd 100644
--- a/modules/simpletest/tests/upgrade/upgrade.upload.test
+++ b/modules/simpletest/tests/upgrade/upgrade.upload.test
@@ -29,7 +29,7 @@ class UploadUpgradePathTestCase extends UpgradePathTestCase {
    * Test a successful upgrade.
    */
   public function testUploadUpgrade() {
-    $this->assertTrue($this->performUpgrade(), t('The upgrade was completed successfully.'));
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
     $query = new EntityFieldQuery();
     $query->entityCondition('entity_type', 'node');
     $query->entityCondition('bundle', 'page');
diff --git a/modules/simpletest/tests/upgrade/upgrade.user.test b/modules/simpletest/tests/upgrade/upgrade.user.test
index c33ba11..d33234e 100644
--- a/modules/simpletest/tests/upgrade/upgrade.user.test
+++ b/modules/simpletest/tests/upgrade/upgrade.user.test
@@ -61,3 +61,32 @@ class UserUpgradePathNoPasswordTokenTestCase extends UpgradePathTestCase {
     $this->assertEqual(variable_get('user_mail_register_no_approval_required_body'), '[user:name], [site:name], [site:url], [site:url-brief], [user:mail], [date:medium], [site:login-url], [user:edit-url], [user:one-time-login-url].', 'Existing email templates have been modified (password token not involved).');
   }
 }
+
+/**
+ * Upgrade test for user.module (duplicated permission).
+ */
+class UserUpgradePathDuplicatedPermissionTestCase extends UpgradePathTestCase {
+  public static function getInfo() {
+    return array(
+      'name'  => 'User upgrade path (duplicated permission)',
+      'description'  => 'User upgrade path tests (duplicated permission).',
+      'group' => 'Upgrade path',
+    );
+  }
+
+  public function setUp() {
+    // Path to the database dump files.
+    $this->databaseDumpFiles = array(
+      drupal_get_path('module', 'simpletest') . '/tests/upgrade/drupal-6.bare.database.php',
+      drupal_get_path('module', 'simpletest') . '/tests/upgrade/drupal-6.duplicate-permission.database.php',
+    );
+    parent::setUp();
+  }
+
+  /**
+   * Test a successful upgrade.
+   */
+  public function testUserUpgrade() {
+    $this->assertTrue($this->performUpgrade(), 'The upgrade was completed successfully.');
+  }
+}
diff --git a/modules/simpletest/tests/xmlrpc.test b/modules/simpletest/tests/xmlrpc.test
index 1b5bff3..1a0fd86 100644
--- a/modules/simpletest/tests/xmlrpc.test
+++ b/modules/simpletest/tests/xmlrpc.test
@@ -48,7 +48,7 @@ class XMLRPCBasicTestCase extends DrupalWebTestCase {
     $url = url(NULL, array('absolute' => TRUE)) . 'xmlrpc.php';
     $signature = xmlrpc($url, array('system.methodSignature' => array('system.listMethods')));
     $this->assert(is_array($signature) && !empty($signature) && is_array($signature[0]),
-      t('system.methodSignature returns an array of signature arrays.'));
+      'system.methodSignature returns an array of signature arrays.');
   }
 
   /**
@@ -58,19 +58,19 @@ class XMLRPCBasicTestCase extends DrupalWebTestCase {
     $invalid_messages = array(
       array(
         'message' => xmlrpc_message(''),
-        'assertion' => t('Empty message correctly rejected during parsing.'),
+        'assertion' => 'Empty message correctly rejected during parsing.',
       ),
       array(
         'message' => xmlrpc_message('<?xml version="1.0" encoding="ISO-8859-1"?>'),
-        'assertion' => t('Empty message with XML declaration correctly rejected during parsing.'),
+        'assertion' => 'Empty message with XML declaration correctly rejected during parsing.',
       ),
       array(
         'message' => xmlrpc_message('<?xml version="1.0"?><params><param><value><string>value</string></value></param></params>'),
-        'assertion' => t('Non-empty message without a valid message type is rejected during parsing.'),
+        'assertion' => 'Non-empty message without a valid message type is rejected during parsing.',
       ),
       array(
         'message' => xmlrpc_message('<methodResponse><params><param><value><string>value</string></value></param></methodResponse>'),
-        'assertion' => t('Non-empty malformed message is rejected during parsing.'),
+        'assertion' => 'Non-empty malformed message is rejected during parsing.',
       ),
     );
 
@@ -217,7 +217,7 @@ class XMLRPCMessagesTestCase extends DrupalWebTestCase {
       $xml_message_l = xmlrpc_test_message_sized_in_kb($size);
       $xml_message_r = xmlrpc($xml_url, array('messages.messageSizedInKB' => array($size)));
 
-      $this->assertEqual($xml_message_l, $xml_message_r, t('XML-RPC messages.messageSizedInKB of %s Kb size received', array('%s' => $size)));
+      $this->assertEqual($xml_message_l, $xml_message_r, format_string('XML-RPC messages.messageSizedInKB of %s Kb size received', array('%s' => $size)));
     }
   }
 
@@ -236,9 +236,9 @@ class XMLRPCMessagesTestCase extends DrupalWebTestCase {
     $methods2 = xmlrpc($url, array('system.listMethods' => array()));
 
     $diff = array_diff($methods1, $methods2);
-    $this->assertTrue(is_array($diff) && !empty($diff), t('Method list is altered by hook_xmlrpc_alter'));
+    $this->assertTrue(is_array($diff) && !empty($diff), 'Method list is altered by hook_xmlrpc_alter');
     $removed = reset($diff);
-    $this->assertEqual($removed, 'system.methodSignature', t('Hiding builting system.methodSignature with hook_xmlrpc_alter works'));
+    $this->assertEqual($removed, 'system.methodSignature', 'Hiding builting system.methodSignature with hook_xmlrpc_alter works');
   }
 
 }
diff --git a/modules/syslog/syslog.info b/modules/syslog/syslog.info
index e0ef55c..6c821dc 100644
--- a/modules/syslog/syslog.info
+++ b/modules/syslog/syslog.info
@@ -4,3 +4,4 @@ package = Core
 version = VERSION
 core = 7.x
 files[] = syslog.test
+configure = admin/config/development/logging
diff --git a/modules/system/language.api.php b/modules/system/language.api.php
index 6714793..d868b6f 100644
--- a/modules/system/language.api.php
+++ b/modules/system/language.api.php
@@ -62,16 +62,22 @@ function hook_language_switch_links_alter(array &$links, $type, $path) {
 }
 
 /**
- * Allow modules to define their own language types.
+ * Define language types.
  *
  * @return
- *   An array of language type definitions. Each language type has an identifier
- *   key. The language type definition is an associative array that may contain
- *   the following key-value pairs:
- *   - "name": The human-readable language type identifier.
- *   - "description": A description of the language type.
- *   - "fixed": An array of language provider identifiers. Defining this key
- *     makes the language type non-configurable.
+ *   An associative array of language type definitions. The keys are the
+ *   identifiers, which are also used as names for global variables representing
+ *   the types in the bootstrap phase. The values are associative arrays that
+ *   may contain the following elements:
+ *   - name: The human-readable language type identifier.
+ *   - description: A description of the language type.
+ *   - fixed: A fixed array of language negotiation provider identifiers to use
+ *     to initialize this language. Defining this key makes the language type
+ *     non-configurable, so it will always use the specified providers in the
+ *     given priority order. Omit to make the language type configurable.
+ *
+ * @see hook_language_types_info_alter()
+ * @ingroup language_negotiation
  */
 function hook_language_types_info() {
   return array(
@@ -90,6 +96,9 @@ function hook_language_types_info() {
  *
  * @param $language_types
  *   Array of language type definitions.
+ *
+ * @see hook_language_types_info()
+ * @ingroup language_negotiation
  */
 function hook_language_types_info_alter(array &$language_types) {
   if (isset($language_types['custom_language_type'])) {
@@ -98,31 +107,35 @@ function hook_language_types_info_alter(array &$language_types) {
 }
 
 /**
- * Allow modules to define their own language providers.
+ * Define language negotiation providers.
  *
  * @return
- *   An array of language provider definitions. Each language provider has an
- *   identifier key. The language provider definition is an associative array
- *   that may contain the following key-value pairs:
- *   - "types": An array of allowed language types. If a language provider does
- *     not specify which language types it should be used with, it will be
- *     available for all the configurable language types.
- *   - "callbacks": An array of functions that will be called to perform various
- *     tasks. Possible key-value pairs are:
- *     - "language": Required. The callback that will determine the language
- *       value.
- *     - "switcher": The callback that will determine the language switch links
- *       associated to the current language provider.
- *     - "url_rewrite": The callback that will provide URL rewriting.
- *   - "file": A file that will be included before the callback is invoked; this
- *     allows callback functions to be in separate files.
- *   - "weight": The default weight the language provider has.
- *   - "name": A human-readable identifier.
- *   - "description": A description of the language provider.
- *   - "config": An internal path pointing to the language provider
- *     configuration page.
- *   - "cache": The value Drupal's page cache should be set to for the current
- *     language provider to be invoked.
+ *   An associative array of language negotiation provider definitions. The keys
+ *   are provider identifiers, and the values are associative arrays definining
+ *   each provider, with the following elements:
+ *   - types: An array of allowed language types. If a language negotiation
+ *     provider does not specify which language types it should be used with, it
+ *     will be available for all the configurable language types.
+ *   - callbacks: An associative array of functions that will be called to
+ *     perform various tasks. Possible elements are:
+ *     - negotiation: (required) Name of the callback function that determines
+ *       the language value.
+ *     - language_switch: (optional) Name of the callback function that
+ *       determines links for a language switcher block associated with this
+ *       provider. See language_switcher_url() for an example.
+ *     - url_rewrite: (optional) Name of the callback function that provides URL
+ *       rewriting, if needed by this provider.
+ *   - file: The file where callback functions are defined (this file will be
+ *     included before the callbacks are invoked).
+ *   - weight: The default weight of the provider.
+ *   - name: The translated human-readable name for the provider.
+ *   - description: A translated longer description of the provider.
+ *   - config: An internal path pointing to the provider's configuration page.
+ *   - cache: The value Drupal's page cache should be set to for the current
+ *     provider to be invoked.
+ *
+ * @see hook_language_negotiation_info_alter()
+ * @ingroup language_negotiation
  */
 function hook_language_negotiation_info() {
   return array(
@@ -135,18 +148,21 @@ function hook_language_negotiation_info() {
       'file' => drupal_get_path('module', 'custom') . '/custom.module',
       'weight' => -4,
       'types' => array('custom_language_type'),
-      'name' => t('Custom language provider'),
-      'description' => t('This is a custom language provider.'),
+      'name' => t('Custom language negotiation provider'),
+      'description' => t('This is a custom language negotiation provider.'),
       'cache' => 0,
     ),
   );
 }
 
 /**
- * Perform alterations on language providers.
+ * Perform alterations on language negoiation providers.
  *
  * @param $language_providers
- *   Array of language provider definitions.
+ *   Array of language negotiation provider definitions.
+ *
+ * @see hook_language_negotiation_info()
+ * @ingroup language_negotiation
  */
 function hook_language_negotiation_info_alter(array &$language_providers) {
   if (isset($language_providers['custom_language_provider'])) {
diff --git a/modules/system/system.admin.inc b/modules/system/system.admin.inc
index 061898c..05543be 100644
--- a/modules/system/system.admin.inc
+++ b/modules/system/system.admin.inc
@@ -1594,6 +1594,7 @@ function system_site_information_settings_validate($form, &$form_state) {
  * @ingroup forms
  */
 function system_cron_settings() {
+  global $base_url;
   $form['description'] = array(
     '#markup' => '<p>' . t('Cron takes care of running periodic tasks like checking for updates and indexing content for search.') . '</p>',
   );
@@ -1606,6 +1607,11 @@ function system_cron_settings() {
   $form['status'] = array(
     '#markup' => $status,
   );
+
+  $form['cron_url'] = array(
+    '#markup' => '<p>' . t('To run cron from outside the site, go to <a href="!cron">!cron</a>', array('!cron' => url($base_url . '/cron.php', array('external' => TRUE, 'query' => array('cron_key' => variable_get('cron_key', 'drupal')))))) . '</p>',
+  );
+
   $form['cron'] = array(
     '#type' => 'fieldset',
   );
diff --git a/modules/system/system.api.php b/modules/system/system.api.php
index adef261..2c529d4 100644
--- a/modules/system/system.api.php
+++ b/modules/system/system.api.php
@@ -84,25 +84,23 @@ function hook_hook_info_alter(&$hooks) {
  *     Defaults to TRUE.
  *   - load hook: The name of the hook which should be invoked by
  *     DrupalDefaultEntityController:attachLoad(), for example 'node_load'.
- *   - uri callback: A function taking an entity as argument and returning the
- *     URI elements of the entity, e.g. 'path' and 'options'. The actual entity
- *     URI can be constructed by passing these elements to url().
- *   - label callback: (optional) A function taking an entity and an entity type
- *     as arguments and returning the label of the entity. The entity label is
- *     the main string associated with an entity; for example, the title of a
- *     node or the subject of a comment. If there is an entity object property
- *     that defines the label, use the 'label' element of the 'entity keys'
- *     return value component to provide this information (see below). If more
- *     complex logic is needed to determine the label of an entity, you can
- *     instead specify a callback function here, which will be called to
- *     determine the entity label. See also the entity_label() function, which
- *     implements this logic.
- *   - language callback: (optional) A function taking an entity and an entity
- *     type as arguments and returning a language code. In most situations, when
- *     needing to determine this value, inspecting a property named after the
- *     'language' element of the 'entity keys' should be enough. The language
- *     callback is meant to be used primarily for temporary alterations of the
- *     property value: entity-defining modules are encouraged to always define a
+ *   - uri callback: The name of an implementation of
+ *     callback_entity_info_uri().
+ *   - label callback: (optional) The name of an implementation of
+ *     callback_entity_info_label(), which returns the label of the entity. The
+ *     entity label is the main string associated with an entity; for example,
+ *     the title of a node or the subject of a comment. If there is an entity
+ *     object property that defines the label, then using the 'label' element of
+ *     the 'entity keys' return value component suffices to provide this
+ *     information (see below). Alternatively, specifying this callback allows
+ *     more complex logic to determine the label of an entity. See also the
+ *     entity_label() function, which implements this logic.
+ *   - language callback: (optional) The name of an implementation of
+ *     callback_entity_info_language(). In most situations, when needing to
+ *     determine this value, inspecting a property named after the 'language'
+ *     element of the 'entity keys' should be enough. The language callback is
+ *     meant to be used primarily for temporary alterations of the property
+ *     value: entity-defining modules are encouraged to always define a
  *     language property, instead of using the callback as main entity language
  *     source. In fact not having a language property defined is likely to
  *     prevent an entity from being queried by language. Moreover, given that
@@ -154,7 +152,10 @@ function hook_hook_info_alter(&$hooks) {
  *       the name of the bundle object.
  *   - bundles: An array describing all bundles for this object type. Keys are
  *     bundles machine names, as found in the objects' 'bundle' property
- *     (defined in the 'entity keys' entry above). Elements:
+ *     (defined in the 'entity keys' entry above). This entry can be omitted if
+ *     this entity type exposes a single bundle (all entities have the same
+ *     collection of fields). The name of this single bundle will be the same as
+ *     the entity type. Elements:
  *     - label: The human-readable name of the bundle.
  *     - uri callback: Same as the 'uri callback' key documented above for the
  *       entity type, but for the bundle only. When determining the URI of an
@@ -706,9 +707,10 @@ function hook_element_info_alter(&$type) {
 /**
  * Perform cleanup tasks.
  *
- * This hook is run at the end of each page request. It is often used for
- * page logging and specialized cleanup. This hook MUST NOT print anything
- * because by the time it runs the response is already sent to the browser.
+ * This hook is run at the end of most regular page requests. It is often
+ * used for page logging and specialized cleanup. This hook MUST NOT print
+ * anything because by the time it runs the response is already sent to
+ * the browser.
  *
  * Only use this hook if your code must run even for cached page views.
  * If you have code which must run once on all non-cached pages, use
@@ -955,6 +957,7 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  * paths and whose values are an associative array of properties for each
  * path. (The complete list of properties is in the return value section below.)
  *
+ * @section sec_callback_funcs Callback Functions
  * The definition for each path may include a page callback function, which is
  * invoked when the registered path is requested. If there is no other
  * registered path that fits the requested path better, any further path
@@ -979,6 +982,7 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  * $jkl will be 'foo'. Note that this automatic passing of optional path
  * arguments applies only to page and theme callback functions.
  *
+ * @subsection sub_callback_arguments Callback Arguments
  * In addition to optional path arguments, the page callback and other callback
  * functions may specify argument lists as arrays. These argument lists may
  * contain both fixed/hard-coded argument values and integers that correspond
@@ -1021,6 +1025,8 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  * @endcode
  * See @link form_api Form API documentation @endlink for details.
  *
+ * @section sec_path_wildcards Wildcards in Paths
+ * @subsection sub_simple_wildcards Simple Wildcards
  * Wildcards within paths also work with integer substitution. For example,
  * your module could register path 'my-module/%/edit':
  * @code
@@ -1033,6 +1039,7 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  * with 'foo' and passed to the callback function. Note that wildcards may not
  * be used as the first component.
  *
+ * @subsection sub_autoload_wildcards Auto-Loader Wildcards
  * Registered paths may also contain special "auto-loader" wildcard components
  * in the form of '%mymodule_abc', where the '%' part means that this path
  * component is a wildcard, and the 'mymodule_abc' part defines the prefix for a
@@ -1064,6 +1071,7 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  * return FALSE for the path 'node/999/edit' if a node with a node ID of 999
  * does not exist. The menu routing system will return a 404 error in this case.
  *
+ * @subsection sub_argument_wildcards Argument Wildcards
  * You can also define a %wildcard_to_arg() function (for the example menu
  * entry above this would be 'mymodule_abc_to_arg()'). The _to_arg() function
  * is invoked to retrieve a value that is used in the path in place of the
@@ -1088,6 +1096,7 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  * are called when the menu system is generating links to related paths, such
  * as the tabs for a set of MENU_LOCAL_TASK items.
  *
+ * @section sec_render_tabs Rendering Menu Items As Tabs
  * You can also make groups of menu items to be rendered (by default) as tabs
  * on a page. To do that, first create one menu item of type MENU_NORMAL_ITEM,
  * with your chosen path, such as 'foo'. Then duplicate that menu item, using a
@@ -1201,6 +1210,10 @@ function hook_menu_get_item_alter(&$router_item, $path, $original_map) {
  *     same weight are ordered alphabetically.
  *   - "menu_name": Optional. Set this to a custom menu if you don't want your
  *     item to be placed in Navigation.
+ *   - "expanded": Optional. If set to TRUE, and if a menu link is provided for
+ *     this menu item (as a result of other properties), then the menu link is
+ *     always expanded, equivalent to its 'always expanded' checkbox being set
+ *     in the UI.
  *   - "context": (optional) Defines the context a tab may appear in. By
  *     default, all tabs are only displayed as local tasks when being rendered
  *     in a page context. All tabs that should be accessible as contextual links
@@ -1412,7 +1425,7 @@ function hook_menu_link_delete($link) {
  * - #link: An associative array containing:
  *   - title: The localized title of the link.
  *   - href: The system path to link to.
- *   - localized_options: An array of options to pass to url().
+ *   - localized_options: An array of options to pass to l().
  * - #active: Whether the link should be marked as 'active'.
  *
  * @param $data
@@ -1929,8 +1942,9 @@ function hook_image_toolkits() {
  *     The drupal_mail() id of the message. Look at module source code or
  *     drupal_mail() for possible id values.
  *  - 'to':
- *     The address or addresses the message will be sent to. The
- *     formatting of this string must comply with RFC 2822.
+ *     The address or addresses the message will be sent to. The formatting of
+ *     this string will be validated with the
+ *     @link http://php.net/manual/filter.filters.validate.php PHP e-mail validation filter. @endlink
  *  - 'from':
  *     The address the message will be marked as being from, which is
  *     either a custom address or the site-wide default email address.
@@ -2100,7 +2114,9 @@ function hook_permission() {
  * specify how a particular render array is to be rendered as HTML (this is
  * usually the case if the theme function is assigned to the render array's
  * #theme property), or they return the HTML that should be returned by an
- * invocation of theme().
+ * invocation of theme(). See
+ * @link http://drupal.org/node/933976 Using the theme layer Drupal 7.x @endlink
+ * for more information on how to implement theme hooks.
  *
  * The following parameters are all optional.
  *
@@ -2196,6 +2212,8 @@ function hook_permission() {
  *     'module', 'theme_engine', or 'theme'.
  *   - theme path: (automatically derived) The directory path of the theme or
  *     module, so that it doesn't need to be looked up.
+ *
+ * @see hook_theme_registry_alter()
  */
 function hook_theme($existing, $type, $theme, $path) {
   return array(
@@ -2290,7 +2308,8 @@ function hook_theme_registry_alter(&$theme_registry) {
  * @return
  *   The machine-readable name of the theme that should be used for the current
  *   page request. The value returned from this function will only have an
- *   effect if it corresponds to a currently-active theme on the site.
+ *   effect if it corresponds to a currently-active theme on the site. Do not
+ *   return a value if you do not wish to set a custom theme.
  */
 function hook_custom_theme() {
   // Allow the user to request a particular theme via a query parameter.
@@ -2476,8 +2495,9 @@ function hook_watchdog(array $log_entry) {
  *   An array to be filled in. Elements in this array include:
  *   - id: An ID to identify the mail sent. Look at module source code
  *     or drupal_mail() for possible id values.
- *   - to: The address or addresses the message will be sent to. The
- *     formatting of this string must comply with RFC 2822.
+ *   - to: The address or addresses the message will be sent to. The formatting
+ *     of this string will be validated with the
+ *     @link http://php.net/manual/filter.filters.validate.php PHP e-mail validation filter. @endlink
  *   - subject: Subject of the e-mail to be sent. This must not contain any
  *     newline characters, or the mail may not be sent properly. drupal_mail()
  *     sets this to an empty string when the hook is invoked.
@@ -2812,7 +2832,15 @@ function hook_file_insert($file) {
  * @see file_save()
  */
 function hook_file_update($file) {
-
+  $file_user = user_load($file->uid);
+  // Make sure that the file name starts with the owner's user name.
+  if (strpos($file->filename, $file_user->name) !== 0) {
+    $old_filename = $file->filename;
+    $file->filename = $file_user->name . '_' . $file->filename;
+    $file->save();
+
+    watchdog('file', t('%source has been renamed to %destination', array('%source' => $old_filename, '%destination' => $file->filename)));
+  }
 }
 
 /**
@@ -2826,7 +2854,14 @@ function hook_file_update($file) {
  * @see file_copy()
  */
 function hook_file_copy($file, $source) {
+  $file_user = user_load($file->uid);
+  // Make sure that the file name starts with the owner's user name.
+  if (strpos($file->filename, $file_user->name) !== 0) {
+    $file->filename = $file_user->name . '_' . $file->filename;
+    $file->save();
 
+    watchdog('file', t('Copied file %source has been renamed to %destination', array('%source' => $source->filename, '%destination' => $file->filename)));
+  }
 }
 
 /**
@@ -2840,7 +2875,14 @@ function hook_file_copy($file, $source) {
  * @see file_move()
  */
 function hook_file_move($file, $source) {
+  $file_user = user_load($file->uid);
+  // Make sure that the file name starts with the owner's user name.
+  if (strpos($file->filename, $file_user->name) !== 0) {
+    $file->filename = $file_user->name . '_' . $file->filename;
+    $file->save();
 
+    watchdog('file', t('Moved file %source has been renamed to %destination', array('%source' => $source->filename, '%destination' => $file->filename)));
+  }
 }
 
 /**
@@ -2992,8 +3034,9 @@ function hook_file_url_alter(&$uri) {
  *     status report page.
  *
  * @return
- *   A keyed array of requirements. Each requirement is itself an array with
- *   the following items:
+ *   An associative array where the keys are arbitrary but must be unique (it
+ *   is suggested to use the module short name as a prefix) and the values are
+ *   themselves associative arrays with the following elements:
  *   - title: The name of the requirement.
  *   - value: The current value (e.g., version, time, level, etc). During
  *     install phase, this should only be used for version numbers, do not set
@@ -3092,44 +3135,48 @@ function hook_schema() {
         'description' => 'The primary identifier for a node.',
         'type' => 'serial',
         'unsigned' => TRUE,
-        'not null' => TRUE),
+        'not null' => TRUE,
+      ),
       'vid' => array(
         'description' => 'The current {node_revision}.vid version identifier.',
         'type' => 'int',
         'unsigned' => TRUE,
         'not null' => TRUE,
-        'default' => 0),
+        'default' => 0,
+      ),
       'type' => array(
         'description' => 'The {node_type} of this node.',
         'type' => 'varchar',
         'length' => 32,
         'not null' => TRUE,
-        'default' => ''),
+        'default' => '',
+      ),
       'title' => array(
         'description' => 'The title of this node, always treated as non-markup plain text.',
         'type' => 'varchar',
         'length' => 255,
         'not null' => TRUE,
-        'default' => ''),
+        'default' => '',
       ),
+    ),
     'indexes' => array(
       'node_changed'        => array('changed'),
       'node_created'        => array('created'),
-      ),
+    ),
     'unique keys' => array(
       'nid_vid' => array('nid', 'vid'),
-      'vid'     => array('vid')
-      ),
+      'vid'     => array('vid'),
+    ),
     'foreign keys' => array(
       'node_revision' => array(
         'table' => 'node_revision',
         'columns' => array('vid' => 'vid'),
-        ),
+      ),
       'node_author' => array(
         'table' => 'users',
-        'columns' => array('uid' => 'uid')
-        ),
-       ),
+        'columns' => array('uid' => 'uid'),
+      ),
+    ),
     'primary key' => array('nid'),
   );
   return $schema;
@@ -3147,6 +3194,8 @@ function hook_schema() {
  *
  * @param $schema
  *   Nested array describing the schemas for all modules.
+ *
+ * @ingroup schemaapi
  */
 function hook_schema_alter(&$schema) {
   // Add field to existing schema.
@@ -3236,8 +3285,7 @@ function hook_query_TAG_alter(QueryAlterableInterface $query) {
  * a hook_update_N() is added to the module, this function needs to be updated
  * to reflect the current version of the database schema.
  *
- * See the Schema API documentation at
- * @link http://drupal.org/node/146843 http://drupal.org/node/146843 @endlink
+ * See the @link http://drupal.org/node/146843 Schema API documentation @endlink
  * for details on hook_schema and how database tables are defined.
  *
  * Note that since this function is called from a full bootstrap, all functions
@@ -3622,64 +3670,60 @@ function hook_registry_files_alter(&$files, $modules) {
  * variable_del() before your last task has completed and control is handed
  * back to the installer.
  *
- * @return
+ * @param array $install_state
+ *   An array of information about the current installation state.
+ *
+ * @return array
  *   A keyed array of tasks the profile will perform during the final stage of
  *   the installation. Each key represents the name of a function (usually a
  *   function defined by this profile, although that is not strictly required)
  *   that is called when that task is run. The values are associative arrays
  *   containing the following key-value pairs (all of which are optional):
- *     - 'display_name'
- *       The human-readable name of the task. This will be displayed to the
- *       user while the installer is running, along with a list of other tasks
- *       that are being run. Leave this unset to prevent the task from
- *       appearing in the list.
- *     - 'display'
- *       This is a boolean which can be used to provide finer-grained control
- *       over whether or not the task will display. This is mostly useful for
- *       tasks that are intended to display only under certain conditions; for
- *       these tasks, you can set 'display_name' to the name that you want to
- *       display, but then use this boolean to hide the task only when certain
- *       conditions apply.
- *     - 'type'
- *       A string representing the type of task. This parameter has three
- *       possible values:
- *       - 'normal': This indicates that the task will be treated as a regular
- *       callback function, which does its processing and optionally returns
- *       HTML output. This is the default behavior which is used when 'type' is
- *       not set.
- *       - 'batch': This indicates that the task function will return a batch
- *       API definition suitable for batch_set(). The installer will then take
- *       care of automatically running the task via batch processing.
- *       - 'form': This indicates that the task function will return a standard
+ *   - display_name: The human-readable name of the task. This will be
+ *     displayed to the user while the installer is running, along with a list
+ *     of other tasks that are being run. Leave this unset to prevent the task
+ *     from appearing in the list.
+ *   - display: This is a boolean which can be used to provide finer-grained
+ *     control over whether or not the task will display. This is mostly useful
+ *     for tasks that are intended to display only under certain conditions;
+ *     for these tasks, you can set 'display_name' to the name that you want to
+ *     display, but then use this boolean to hide the task only when certain
+ *     conditions apply.
+ *   - type: A string representing the type of task. This parameter has three
+ *     possible values:
+ *     - normal: (default) This indicates that the task will be treated as a
+ *       regular callback function, which does its processing and optionally
+ *       returns HTML output.
+ *     - batch: This indicates that the task function will return a batch API
+ *       definition suitable for batch_set(). The installer will then take care
+ *       of automatically running the task via batch processing.
+ *     - form: This indicates that the task function will return a standard
  *       form API definition (and separately define validation and submit
  *       handlers, as appropriate). The installer will then take care of
  *       automatically directing the user through the form submission process.
- *     - 'run'
- *       A constant representing the manner in which the task will be run. This
- *       parameter has three possible values:
- *       - INSTALL_TASK_RUN_IF_NOT_COMPLETED: This indicates that the task will
- *       run once during the installation of the profile. This is the default
- *       behavior which is used when 'run' is not set.
- *       - INSTALL_TASK_SKIP: This indicates that the task will not run during
+ *   - run: A constant representing the manner in which the task will be run.
+ *     This parameter has three possible values:
+ *     - INSTALL_TASK_RUN_IF_NOT_COMPLETED: (default) This indicates that the
+ *       task will run once during the installation of the profile.
+ *     - INSTALL_TASK_SKIP: This indicates that the task will not run during
  *       the current installation page request. It can be used to skip running
  *       an installation task when certain conditions are met, even though the
  *       task may still show on the list of installation tasks presented to the
  *       user.
- *       - INSTALL_TASK_RUN_IF_REACHED: This indicates that the task will run
- *       on each installation page request that reaches it. This is rarely
+ *     - INSTALL_TASK_RUN_IF_REACHED: This indicates that the task will run on
+ *       each installation page request that reaches it. This is rarely
  *       necessary for an installation profile to use; it is primarily used by
  *       the Drupal installer for bootstrap-related tasks.
- *     - 'function'
- *       Normally this does not need to be set, but it can be used to force the
- *       installer to call a different function when the task is run (rather
- *       than the function whose name is given by the array key). This could be
- *       used, for example, to allow the same function to be called by two
- *       different tasks.
+ *   - function: Normally this does not need to be set, but it can be used to
+ *     force the installer to call a different function when the task is run
+ *     (rather than the function whose name is given by the array key). This
+ *     could be used, for example, to allow the same function to be called by
+ *     two different tasks.
  *
  * @see install_state_defaults()
  * @see batch_set()
  */
-function hook_install_tasks() {
+function hook_install_tasks(&$install_state) {
   // Here, we define a variable to allow tasks to indicate that a particular,
   // processor-intensive batch process needs to be triggered later on in the
   // installation.
@@ -4669,6 +4713,77 @@ function hook_filetransfer_info_alter(&$filetransfer_info) {
  */
 
 /**
+ * @addtogroup callbacks
+ * @{
+ */
+
+/**
+ * Return the URI for an entity.
+ *
+ * Callback for hook_entity_info().
+ *
+ * @param $entity
+ *   The entity to return the URI for.
+ *
+ * @return
+ *   An associative array with the following elements:
+ *   - 'path': The URL path for the entity.
+ *   - 'options': (optional) An array of options for the url() function.
+ *   The actual entity URI can be constructed by passing these elements to
+ *   url().
+ */
+function callback_entity_info_uri($entity) {
+  return array(
+    'path' => 'node/' . $entity->nid,
+  );
+}
+
+/**
+ * Return the label of an entity.
+ *
+ * Callback for hook_entity_info().
+ *
+ * @param $entity
+ *   The entity for which to generate the label.
+ * @param $entity_type
+ *   The entity type; e.g., 'node' or 'user'.
+ *
+ * @return
+ *   An unsanitized string with the label of the entity.
+ *
+ * @see entity_label()
+ */
+function callback_entity_info_label($entity, $entity_type) {
+  return empty($entity->title) ? 'Untitled entity' : $entity->title;
+}
+
+/**
+ * Return the language code of the entity.
+ *
+ * Callback for hook_entity_info().
+ *
+ * The language callback is meant to be used primarily for temporary alterations
+ * of the property value.
+ *
+ * @param $entity
+ *   The entity for which to return the language.
+ * @param $entity_type
+ *   The entity type; e.g., 'node' or 'user'.
+ *
+ * @return
+ *   The language code for the language of the entity.
+ *
+ * @see entity_language()
+ */
+function callback_entity_info_language($entity, $entity_type) {
+  return $entity->language;
+}
+
+/**
+ * @} End of "addtogroup callbacks".
+ */
+
+/**
  * @defgroup update_api Update versions of API functions
  * @{
  * Functions that are similar to normal API functions, but do not invoke hooks.
diff --git a/modules/system/system.install b/modules/system/system.install
index 7b66767..a58e855 100644
--- a/modules/system/system.install
+++ b/modules/system/system.install
@@ -208,7 +208,7 @@ function system_requirements($phase) {
     'value' => $memory_limit == -1 ? t('-1 (Unlimited)') : $memory_limit,
   );
 
-  if ($memory_limit && $memory_limit != -1 && parse_size($memory_limit) < parse_size(DRUPAL_MINIMUM_PHP_MEMORY_LIMIT)) {
+  if (!drupal_check_memory_limit(DRUPAL_MINIMUM_PHP_MEMORY_LIMIT, $memory_limit)) {
     $description = '';
     if ($phase == 'install') {
       $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the installation process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
@@ -744,6 +744,7 @@ function system_schema() {
         'type' => 'varchar',
         'length' => 100,
         'not null' => TRUE,
+        'binary' => TRUE,
       ),
       'type' => array(
         'description' => 'The date format type, e.g. medium.',
@@ -1889,7 +1890,7 @@ function system_update_7007() {
   $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid ASC");
   $query = db_insert('role_permission')->fields(array('rid', 'permission'));
   foreach ($result as $role) {
-    foreach (explode(', ', $role->perm) as $perm) {
+    foreach (array_unique(explode(', ', $role->perm)) as $perm) {
       $query->values(array(
         'rid' => $role->rid,
         'permission' => $perm,
@@ -1982,7 +1983,7 @@ function system_update_7013() {
     $timezone = 'UTC';
   }
   variable_set('date_default_timezone', $timezone);
-  drupal_set_message('The default time zone has been set to <em>' . check_plain($timezone) . '</em>. Check the ' . l('date and time configuration page', 'admin/config/regional/settings') . ' to configure it correctly.', 'warning');
+  drupal_set_message(format_string('The default time zone has been set to %timezone. Check the <a href="@config-url">date and time configuration page</a> to configure it correctly.', array('%timezone' => $timezone, '@config-url' => url('admin/config/regional/settings'))), 'warning');
   // Remove temporary override.
   variable_del('date_temporary_timezone');
 }
@@ -2758,12 +2759,14 @@ function system_update_7061(&$sandbox) {
     // Retrieve a list of node revisions that have uploaded files attached.
     // DISTINCT queries are expensive, especially when paged, so we store the
     // data in its own table for the duration of the update.
-    $table = array(
-      'description' => t('Stores temporary data for system_update_7061.'),
-      'fields' => array('vid' => array('type' => 'int')),
-      'primary key' => array('vid'),
-    );
-    db_create_table('system_update_7061', $table);
+    if (!db_table_exists('system_update_7061')) {
+      $table = array(
+        'description' => t('Stores temporary data for system_update_7061.'),
+        'fields' => array('vid' => array('type' => 'int')),
+        'primary key' => array('vid'),
+      );
+      db_create_table('system_update_7061', $table);
+    }
     $query = db_select('upload', 'u');
     $query->distinct();
     $query->addField('u','vid');
@@ -3032,6 +3035,7 @@ function system_update_7073() {
     'default' => '',
     'binary' => TRUE,
   ));
+  db_drop_unique_key('file_managed', 'uri');
   db_change_field('file_managed', 'uri', 'uri', array(
     'description' => 'The URI to access the file (either local or remote).',
     'type' => 'varchar',
@@ -3040,6 +3044,7 @@ function system_update_7073() {
     'default' => '',
     'binary' => TRUE,
   ));
+  db_add_unique_key('file_managed', 'uri', array('uri'));
 }
 
 /**
@@ -3086,6 +3091,21 @@ function system_update_7077() {
   ));
 }
 
+
+/**
+ * Add binary to {date_formats}.format.
+ */
+function system_update_7078() {
+  db_drop_unique_key('date_formats', 'formats');
+  db_change_field('date_formats', 'format', 'format', array(
+    'description' => 'The date format string.',
+    'type' => 'varchar',
+    'length' => 100,
+    'not null' => TRUE,
+    'binary' => TRUE,
+  ), array('unique keys' => array('formats' => array('format', 'type'))));
+}
+
 /**
  * @} End of "defgroup updates-7.x-extra".
  * The next series of updates should start at 8000.
diff --git a/modules/system/system.module b/modules/system/system.module
index d47ab8a..2bbcd7f 100644
--- a/modules/system/system.module
+++ b/modules/system/system.module
@@ -1907,17 +1907,18 @@ function system_init() {
 
   // Ignore slave database servers for this request.
   //
-  // In Drupal's distributed database structure, new data is written to the master
-  // and then propagated to the slave servers.  This means there is a lag
-  // between when data is written to the master and when it is available on the slave.
-  // At these times, we will want to avoid using a slave server temporarily.
-  // For example, if a user posts a new node then we want to disable the slave
-  // server for that user temporarily to allow the slave server to catch up.
-  // That way, that user will see their changes immediately while for other
-  // users we still get the benefits of having a slave server, just with slightly
-  // stale data.  Code that wants to disable the slave server should use the
-  // db_set_ignore_slave() function to set $_SESSION['ignore_slave_server'] to
-  // the timestamp after which the slave can be re-enabled.
+  // In Drupal's distributed database structure, new data is written to the
+  // master and then propagated to the slave servers.  This means there is a
+  // lag between when data is written to the master and when it is available on
+  // the slave. At these times, we will want to avoid using a slave server
+  // temporarily. For example, if a user posts a new node then we want to
+  // disable the slave server for that user temporarily to allow the slave
+  // server to catch up. That way, that user will see their changes immediately
+  // while for other users we still get the benefits of having a slave server,
+  // just with slightly stale data.  Code that wants to disable the slave
+  // server should use the db_ignore_slave() function to set
+  // $_SESSION['ignore_slave_server'] to the timestamp after which the slave
+  // can be re-enabled.
   if (isset($_SESSION['ignore_slave_server'])) {
     if ($_SESSION['ignore_slave_server'] >= REQUEST_TIME) {
       Database::ignoreTarget('default', 'slave');
diff --git a/modules/system/system.queue.inc b/modules/system/system.queue.inc
index 47d8e7c..901c4d6 100644
--- a/modules/system/system.queue.inc
+++ b/modules/system/system.queue.inc
@@ -97,13 +97,6 @@ class DrupalQueue {
 }
 
 interface DrupalQueueInterface {
-  /**
-   * Start working with a queue.
-   *
-   * @param $name
-   *   Arbitrary string. The name of the queue to work with.
-   */
-  public function __construct($name);
 
   /**
    * Add a queue item and store it directly to the queue.
@@ -315,6 +308,12 @@ class MemoryQueue implements DrupalQueueInterface {
    */
   protected $id_sequence;
 
+  /**
+   * Start working with a queue.
+   *
+   * @param $name
+   *   Arbitrary string. The name of the queue to work with.
+   */
   public function __construct($name) {
     $this->queue = array();
     $this->id_sequence = 0;
diff --git a/modules/system/system.test b/modules/system/system.test
index abd21aa..99e0cbe 100644
--- a/modules/system/system.test
+++ b/modules/system/system.test
@@ -31,9 +31,9 @@ class ModuleTestCase extends DrupalWebTestCase {
     $tables = db_find_tables(Database::getConnection()->prefixTables('{' . $base_table . '}') . '%');
 
     if ($count) {
-      return $this->assertTrue($tables, t('Tables matching "@base_table" found.', array('@base_table' => $base_table)));
+      return $this->assertTrue($tables, format_string('Tables matching "@base_table" found.', array('@base_table' => $base_table)));
     }
-    return $this->assertFalse($tables, t('Tables matching "@base_table" not found.', array('@base_table' => $base_table)));
+    return $this->assertFalse($tables, format_string('Tables matching "@base_table" not found.', array('@base_table' => $base_table)));
   }
 
   /**
@@ -50,7 +50,7 @@ class ModuleTestCase extends DrupalWebTestCase {
         $tables_exist = FALSE;
       }
     }
-    return $this->assertTrue($tables_exist, t('All database tables defined by the @module module exist.', array('@module' => $module)));
+    return $this->assertTrue($tables_exist, format_string('All database tables defined by the @module module exist.', array('@module' => $module)));
   }
 
   /**
@@ -67,7 +67,7 @@ class ModuleTestCase extends DrupalWebTestCase {
         $tables_exist = TRUE;
       }
     }
-    return $this->assertFalse($tables_exist, t('None of the database tables defined by the @module module exist.', array('@module' => $module)));
+    return $this->assertFalse($tables_exist, format_string('None of the database tables defined by the @module module exist.', array('@module' => $module)));
   }
 
   /**
@@ -87,7 +87,7 @@ class ModuleTestCase extends DrupalWebTestCase {
       else {
         $message = 'Module "@module" is not enabled.';
       }
-      $this->assertEqual(module_exists($module), $enabled, t($message, array('@module' => $module)));
+      $this->assertEqual(module_exists($module), $enabled, format_string($message, array('@module' => $module)));
     }
   }
 
@@ -122,7 +122,7 @@ class ModuleTestCase extends DrupalWebTestCase {
       ->countQuery()
       ->execute()
       ->fetchField();
-    $this->assertTrue($count > 0, t('watchdog table contains @count rows for @message', array('@count' => $count, '@message' => $message)));
+    $this->assertTrue($count > 0, format_string('watchdog table contains @count rows for @message', array('@count' => $count, '@message' => $message)));
   }
 }
 
@@ -152,7 +152,7 @@ class EnableDisableTestCase extends ModuleTestCase {
         unset($modules[$name]);
       }
     }
-    $this->assertTrue(count($modules), t('Found @count core modules that we can try to enable in this test.', array('@count' => count($modules))));
+    $this->assertTrue(count($modules), format_string('Found @count core modules that we can try to enable in this test.', array('@count' => count($modules))));
 
     // Enable the dblog module first, since we will be asserting the presence
     // of log messages throughout the test.
@@ -202,7 +202,7 @@ class EnableDisableTestCase extends ModuleTestCase {
         if (count($modules_to_enable) > 1) {
           $this->drupalPost(NULL, array(), t('Continue'));
         }
-        $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+        $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
 
         // Check that hook_modules_installed() and hook_modules_enabled() were
         // invoked with the expected list of modules, that each module's
@@ -268,7 +268,7 @@ class EnableDisableTestCase extends ModuleTestCase {
       $edit['modules[Core][' . $name . '][enable]'] = $name;
     }
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
   }
 
   /**
@@ -315,7 +315,7 @@ class EnableDisableTestCase extends ModuleTestCase {
     $edit = array();
     $edit['modules[Core][' . $module . '][enable]'] = FALSE;
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
     $this->assertModules(array($module), FALSE);
 
     // Check that the appropriate hook was fired and the appropriate log
@@ -331,7 +331,7 @@ class EnableDisableTestCase extends ModuleTestCase {
     $edit['uninstall[' . $module . ']'] = $module;
     $this->drupalPost('admin/modules/uninstall', $edit, t('Uninstall'));
     $this->drupalPost(NULL, NULL, t('Uninstall'));
-    $this->assertText(t('The selected modules have been uninstalled.'), t('Modules status has been updated.'));
+    $this->assertText(t('The selected modules have been uninstalled.'), 'Modules status has been updated.');
     $this->assertModules(array($module), FALSE);
 
     // Check that the appropriate hook was fired and the appropriate log
@@ -372,7 +372,7 @@ class HookRequirementsTestCase extends ModuleTestCase {
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
 
     // Makes sure the module was NOT installed.
-    $this->assertText(t('Requirements 1 Test failed requirements'), t('Modules status has been updated.'));
+    $this->assertText(t('Requirements 1 Test failed requirements'), 'Modules status has been updated.');
     $this->assertModules(array('requirements1_test'), FALSE);
   }
 }
@@ -397,7 +397,7 @@ class ModuleDependencyTestCase extends ModuleTestCase {
     $edit = array();
     $edit['modules[Core][translation][enable]'] = 'translation';
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('Some required modules must be enabled'), t('Dependency required.'));
+    $this->assertText(t('Some required modules must be enabled'), 'Dependency required.');
 
     $this->assertModules(array('translation', 'locale'), FALSE);
 
@@ -406,7 +406,7 @@ class ModuleDependencyTestCase extends ModuleTestCase {
     $this->assertTableCount('locale', FALSE);
 
     $this->drupalPost(NULL, NULL, t('Continue'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
 
     $this->assertModules(array('translation', 'locale'), TRUE);
 
@@ -422,9 +422,9 @@ class ModuleDependencyTestCase extends ModuleTestCase {
     // Test that the system_dependencies_test module is marked
     // as missing a dependency.
     $this->drupalGet('admin/modules');
-    $this->assertRaw(t('@module (<span class="admin-missing">missing</span>)', array('@module' => drupal_ucfirst('_missing_dependency'))), t('A module with missing dependencies is marked as such.'));
+    $this->assertRaw(t('@module (<span class="admin-missing">missing</span>)', array('@module' => drupal_ucfirst('_missing_dependency'))), 'A module with missing dependencies is marked as such.');
     $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[Testing][system_dependencies_test][enable]"]');
-    $this->assert(count($checkbox) == 1, t('Checkbox for the module is disabled.'));
+    $this->assert(count($checkbox) == 1, 'Checkbox for the module is disabled.');
 
     // Force enable the system_dependencies_test module.
     module_enable(array('system_dependencies_test'), FALSE);
@@ -432,7 +432,7 @@ class ModuleDependencyTestCase extends ModuleTestCase {
     // Verify that the module is forced to be disabled when submitting
     // the module page.
     $this->drupalPost('admin/modules', array(), t('Save configuration'));
-    $this->assertText(t('The @module module is missing, so the following module will be disabled: @depends.', array('@module' => '_missing_dependency', '@depends' => 'system_dependencies_test')), t('The module missing dependencies will be disabled.'));
+    $this->assertText(t('The @module module is missing, so the following module will be disabled: @depends.', array('@module' => '_missing_dependency', '@depends' => 'system_dependencies_test')), 'The module missing dependencies will be disabled.');
 
     // Confirm.
     $this->drupalPost(NULL, NULL, t('Continue'));
@@ -453,7 +453,7 @@ class ModuleDependencyTestCase extends ModuleTestCase {
       '@version' => '1.0',
     )), 'A module that depends on an incompatible version of a module is marked as such.');
     $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[Testing][system_incompatible_module_version_dependencies_test][enable]"]');
-    $this->assert(count($checkbox) == 1, t('Checkbox for the module is disabled.'));
+    $this->assert(count($checkbox) == 1, 'Checkbox for the module is disabled.');
   }
 
   /**
@@ -467,7 +467,7 @@ class ModuleDependencyTestCase extends ModuleTestCase {
       '@module' => 'System incompatible core version test',
     )), 'A module that depends on a module with an incompatible core version is marked as such.');
     $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[Testing][system_incompatible_core_version_dependencies_test][enable]"]');
-    $this->assert(count($checkbox) == 1, t('Checkbox for the module is disabled.'));
+    $this->assert(count($checkbox) == 1, 'Checkbox for the module is disabled.');
   }
 
   /**
@@ -484,7 +484,7 @@ class ModuleDependencyTestCase extends ModuleTestCase {
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
 
     // Makes sure the modules were NOT installed.
-    $this->assertText(t('Requirements 1 Test failed requirements'), t('Modules status has been updated.'));
+    $this->assertText(t('Requirements 1 Test failed requirements'), 'Modules status has been updated.');
     $this->assertModules(array('requirements1_test'), FALSE);
     $this->assertModules(array('requirements2_test'), FALSE);
 
@@ -543,18 +543,18 @@ class ModuleDependencyTestCase extends ModuleTestCase {
     // Check that the taxonomy module cannot be uninstalled.
     $this->drupalGet('admin/modules/uninstall');
     $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="uninstall[comment]"]');
-    $this->assert(count($checkbox) == 1, t('Checkbox for uninstalling the comment module is disabled.'));
+    $this->assert(count($checkbox) == 1, 'Checkbox for uninstalling the comment module is disabled.');
 
     // Uninstall the forum module, and check that taxonomy now can also be
     // uninstalled.
     $edit = array('uninstall[forum]' => 'forum');
     $this->drupalPost('admin/modules/uninstall', $edit, t('Uninstall'));
     $this->drupalPost(NULL, NULL, t('Uninstall'));
-    $this->assertText(t('The selected modules have been uninstalled.'), t('Modules status has been updated.'));
+    $this->assertText(t('The selected modules have been uninstalled.'), 'Modules status has been updated.');
     $edit = array('uninstall[comment]' => 'comment');
     $this->drupalPost('admin/modules/uninstall', $edit, t('Uninstall'));
     $this->drupalPost(NULL, NULL, t('Uninstall'));
-    $this->assertText(t('The selected modules have been uninstalled.'), t('Modules status has been updated.'));
+    $this->assertText(t('The selected modules have been uninstalled.'), 'Modules status has been updated.');
   }
 }
 
@@ -643,7 +643,7 @@ class ModuleRequiredTestCase extends ModuleTestCase {
       if (!empty($info['required'])) {
         $field_name = "modules[{$info['package']}][$module][enable]";
         if (empty($info['hidden'])) {
-          $this->assertFieldByXPath("//input[@name='$field_name' and @disabled='disabled' and @checked='checked']", '', t('Field @name was disabled and checked.', array('@name' => $field_name)));
+          $this->assertFieldByXPath("//input[@name='$field_name' and @disabled='disabled' and @checked='checked']", '', format_string('Field @name was disabled and checked.', array('@name' => $field_name)));
         }
         else {
           $this->assertNoFieldByName($field_name);
@@ -783,14 +783,14 @@ class CronRunTestCase extends DrupalWebTestCase {
     variable_set('cron_last', $cron_last);
     variable_set('cron_safe_threshold', $cron_safe_threshold);
     $this->drupalGet('');
-    $this->assertTrue($cron_last == variable_get('cron_last', NULL), t('Cron does not run when the cron threshold is not passed.'));
+    $this->assertTrue($cron_last == variable_get('cron_last', NULL), 'Cron does not run when the cron threshold is not passed.');
 
     // Test if cron runs when the cron threshold was passed.
     $cron_last = time() - 200;
     variable_set('cron_last', $cron_last);
     $this->drupalGet('');
     sleep(1);
-    $this->assertTrue($cron_last < variable_get('cron_last', NULL), t('Cron runs when the cron threshold is passed.'));
+    $this->assertTrue($cron_last < variable_get('cron_last', NULL), 'Cron runs when the cron threshold is passed.');
 
     // Disable the cron threshold through the interface.
     $admin_user = $this->drupalCreateUser(array('administer site configuration'));
@@ -803,7 +803,7 @@ class CronRunTestCase extends DrupalWebTestCase {
     $cron_last = time() - 200;
     variable_set('cron_last', $cron_last);
     $this->drupalGet('');
-    $this->assertTrue($cron_last == variable_get('cron_last', NULL), t('Cron does not run when the cron threshold is disabled.'));
+    $this->assertTrue($cron_last == variable_get('cron_last', NULL), 'Cron does not run when the cron threshold is disabled.');
   }
 
   /**
@@ -823,7 +823,7 @@ class CronRunTestCase extends DrupalWebTestCase {
       ))
       ->condition('fid', $temp_old->fid)
       ->execute();
-    $this->assertTrue(file_exists($temp_old->uri), t('Old temp file was created correctly.'));
+    $this->assertTrue(file_exists($temp_old->uri), 'Old temp file was created correctly.');
 
     // Temporary file that is less than DRUPAL_MAXIMUM_TEMP_FILE_AGE.
     $temp_new = file_save_data('');
@@ -831,7 +831,7 @@ class CronRunTestCase extends DrupalWebTestCase {
       ->fields(array('status' => 0))
       ->condition('fid', $temp_new->fid)
       ->execute();
-    $this->assertTrue(file_exists($temp_new->uri), t('New temp file was created correctly.'));
+    $this->assertTrue(file_exists($temp_new->uri), 'New temp file was created correctly.');
 
     // Permanent file that is older than DRUPAL_MAXIMUM_TEMP_FILE_AGE.
     $perm_old = file_save_data('');
@@ -839,18 +839,18 @@ class CronRunTestCase extends DrupalWebTestCase {
       ->fields(array('timestamp' => 1))
       ->condition('fid', $temp_old->fid)
       ->execute();
-    $this->assertTrue(file_exists($perm_old->uri), t('Old permanent file was created correctly.'));
+    $this->assertTrue(file_exists($perm_old->uri), 'Old permanent file was created correctly.');
 
     // Permanent file that is newer than DRUPAL_MAXIMUM_TEMP_FILE_AGE.
     $perm_new = file_save_data('');
-    $this->assertTrue(file_exists($perm_new->uri), t('New permanent file was created correctly.'));
+    $this->assertTrue(file_exists($perm_new->uri), 'New permanent file was created correctly.');
 
     // Run cron and then ensure that only the old, temp file was deleted.
     $this->cronRun();
-    $this->assertFalse(file_exists($temp_old->uri), t('Old temp file was correctly removed.'));
-    $this->assertTrue(file_exists($temp_new->uri), t('New temp file was correctly ignored.'));
-    $this->assertTrue(file_exists($perm_old->uri), t('Old permanent file was correctly ignored.'));
-    $this->assertTrue(file_exists($perm_new->uri), t('New permanent file was correctly ignored.'));
+    $this->assertFalse(file_exists($temp_old->uri), 'Old temp file was correctly removed.');
+    $this->assertTrue(file_exists($temp_new->uri), 'New temp file was correctly ignored.');
+    $this->assertTrue(file_exists($perm_old->uri), 'Old permanent file was correctly ignored.');
+    $this->assertTrue(file_exists($perm_new->uri), 'New permanent file was correctly ignored.');
   }
 
   /**
@@ -863,7 +863,7 @@ class CronRunTestCase extends DrupalWebTestCase {
     // The common_test_cron_helper module sets the 'common_test_cron' variable.
     $this->cronRun();
     $result = variable_get('common_test_cron');
-    $this->assertEqual($result, 'success', t('Cron correctly handles exceptions thrown during hook_cron() invocations.'));
+    $this->assertEqual($result, 'success', 'Cron correctly handles exceptions thrown during hook_cron() invocations.');
   }
 }
 
@@ -886,7 +886,7 @@ class AdminMetaTagTestCase extends DrupalWebTestCase {
     list($version, ) = explode('.', VERSION);
     $string = '<meta name="Generator" content="Drupal ' . $version . ' (http://drupal.org)" />';
     $this->drupalGet('node');
-    $this->assertRaw($string, t('Fingerprinting meta tag generated correctly.'), t('System'));
+    $this->assertRaw($string, 'Fingerprinting meta tag generated correctly.', 'System');
   }
 }
 
@@ -913,7 +913,7 @@ class AccessDeniedTestCase extends DrupalWebTestCase {
 
   function testAccessDenied() {
     $this->drupalGet('admin');
-    $this->assertText(t('Access denied'), t('Found the default 403 page'));
+    $this->assertText(t('Access denied'), 'Found the default 403 page');
     $this->assertResponse(403);
 
     $this->drupalLogin($this->admin_user);
@@ -928,14 +928,14 @@ class AccessDeniedTestCase extends DrupalWebTestCase {
 
     $this->drupalLogout();
     $this->drupalGet('admin');
-    $this->assertText($node->title, t('Found the custom 403 page'));
+    $this->assertText($node->title, 'Found the custom 403 page');
 
     // Logout and check that the user login block is shown on custom 403 pages.
     $this->drupalLogout();
 
     $this->drupalGet('admin');
-    $this->assertText($node->title, t('Found the custom 403 page'));
-    $this->assertText(t('User login'), t('Blocks are shown on the custom 403 page'));
+    $this->assertText($node->title, 'Found the custom 403 page');
+    $this->assertText(t('User login'), 'Blocks are shown on the custom 403 page');
 
     // Log back in and remove the custom 403 page.
     $this->drupalLogin($this->admin_user);
@@ -945,9 +945,9 @@ class AccessDeniedTestCase extends DrupalWebTestCase {
     $this->drupalLogout();
 
     $this->drupalGet('admin');
-    $this->assertText(t('Access denied'), t('Found the default 403 page'));
+    $this->assertText(t('Access denied'), 'Found the default 403 page');
     $this->assertResponse(403);
-    $this->assertText(t('User login'), t('Blocks are shown on the default 403 page'));
+    $this->assertText(t('User login'), 'Blocks are shown on the default 403 page');
 
     // Log back in, set the custom 403 page to /user and remove the block
     $this->drupalLogin($this->admin_user);
@@ -994,7 +994,7 @@ class PageNotFoundTestCase extends DrupalWebTestCase {
 
   function testPageNotFound() {
     $this->drupalGet($this->randomName(10));
-    $this->assertText(t('Page not found'), t('Found the default 404 page'));
+    $this->assertText(t('Page not found'), 'Found the default 404 page');
 
     $edit = array(
       'title' => $this->randomName(10),
@@ -1006,7 +1006,7 @@ class PageNotFoundTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/config/system/site-information', array('site_404' => 'node/' . $node->nid), t('Save configuration'));
 
     $this->drupalGet($this->randomName(10));
-    $this->assertText($node->title, t('Found the custom 404 page'));
+    $this->assertText($node->title, 'Found the custom 404 page');
   }
 }
 
@@ -1049,7 +1049,7 @@ class SiteMaintenanceTestCase extends DrupalWebTestCase {
     $offline_message = t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal')));
 
     $this->drupalGet('');
-    $this->assertRaw($admin_message, t('Found the site maintenance mode message.'));
+    $this->assertRaw($admin_message, 'Found the site maintenance mode message.');
 
     // Logout and verify that offline message is displayed.
     $this->drupalLogout();
@@ -1079,7 +1079,7 @@ class SiteMaintenanceTestCase extends DrupalWebTestCase {
     $this->drupalLogout();
     $this->drupalLogin($this->admin_user);
     $this->drupalGet('admin/config/development/maintenance');
-    $this->assertNoRaw($admin_message, t('Site maintenance mode message not displayed.'));
+    $this->assertNoRaw($admin_message, 'Site maintenance mode message not displayed.');
 
     $offline_message = 'Sorry, not online.';
     $edit = array(
@@ -1090,11 +1090,11 @@ class SiteMaintenanceTestCase extends DrupalWebTestCase {
     // Logout and verify that custom site offline message is displayed.
     $this->drupalLogout();
     $this->drupalGet('');
-    $this->assertRaw($offline_message, t('Found the site offline message.'));
+    $this->assertRaw($offline_message, 'Found the site offline message.');
 
     // Verify that custom site offline message is not displayed on user/password.
     $this->drupalGet('user/password');
-    $this->assertText(t('Username or e-mail address'), t('Anonymous users can access user/password'));
+    $this->assertText(t('Username or e-mail address'), 'Anonymous users can access user/password');
 
     // Submit password reset form.
     $edit = array(
@@ -1149,18 +1149,18 @@ class DateTimeFunctionalTest extends DrupalWebTestCase {
 
     // Confirm date format and time zone.
     $this->drupalGet("node/$node1->nid");
-    $this->assertText('2007-01-31 21:00:00 -1000', t('Date should be identical, with GMT offset of -10 hours.'));
+    $this->assertText('2007-01-31 21:00:00 -1000', 'Date should be identical, with GMT offset of -10 hours.');
     $this->drupalGet("node/$node2->nid");
-    $this->assertText('2007-07-31 21:00:00 -1000', t('Date should be identical, with GMT offset of -10 hours.'));
+    $this->assertText('2007-07-31 21:00:00 -1000', 'Date should be identical, with GMT offset of -10 hours.');
 
     // Set time zone to Los Angeles time.
     variable_set('date_default_timezone', 'America/Los_Angeles');
 
     // Confirm date format and time zone.
     $this->drupalGet("node/$node1->nid");
-    $this->assertText('2007-01-31 23:00:00 -0800', t('Date should be two hours ahead, with GMT offset of -8 hours.'));
+    $this->assertText('2007-01-31 23:00:00 -0800', 'Date should be two hours ahead, with GMT offset of -8 hours.');
     $this->drupalGet("node/$node2->nid");
-    $this->assertText('2007-08-01 00:00:00 -0700', t('Date should be three hours ahead, with GMT offset of -7 hours.'));
+    $this->assertText('2007-08-01 00:00:00 -0700', 'Date should be three hours ahead, with GMT offset of -7 hours.');
   }
 
   /**
@@ -1183,7 +1183,7 @@ class DateTimeFunctionalTest extends DrupalWebTestCase {
       'date_format' => $date_format,
     );
     $this->drupalPost('admin/config/regional/date-time/types/add', $edit, t('Add date type'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->assertText(t('New date type added successfully.'), 'Date type added confirmation message appears.');
     $this->assertText($date_type, 'Custom date type appears in the date type list.');
     $this->assertText(t('delete'), 'Delete link for custom date type appears.');
@@ -1191,7 +1191,7 @@ class DateTimeFunctionalTest extends DrupalWebTestCase {
     // Delete custom date type.
     $this->clickLink(t('delete'));
     $this->drupalPost('admin/config/regional/date-time/types/' . $machine_name . '/delete', array(), t('Remove'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->assertText(t('Removed date type ' . $date_type), 'Custom date type removed.');
   }
 
@@ -1209,7 +1209,7 @@ class DateTimeFunctionalTest extends DrupalWebTestCase {
       'date_format' => 'Y',
     );
     $this->drupalPost('admin/config/regional/date-time/formats/add', $edit, t('Add format'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->assertNoText(t('No custom date formats available.'), 'No custom date formats message does not appear.');
     $this->assertText(t('Custom date format added.'), 'Custom date format added.');
 
@@ -1224,13 +1224,13 @@ class DateTimeFunctionalTest extends DrupalWebTestCase {
       'date_format' => 'Y m',
     );
     $this->drupalPost($this->getUrl(), $edit, t('Save format'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->assertText(t('Custom date format updated.'), 'Custom date format successfully updated.');
 
     // Delete custom date format.
     $this->clickLink(t('delete'));
     $this->drupalPost($this->getUrl(), array(), t('Remove'));
-    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), t('Correct page redirection.'));
+    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), 'Correct page redirection.');
     $this->assertText(t('Removed date format'), 'Custom date format removed successfully.');
   }
 
@@ -1347,11 +1347,11 @@ class PageTitleFiltering extends DrupalWebTestCase {
     // drupal_set_title's $filter is CHECK_PLAIN by default, so the title should be
     // returned with check_plain().
     drupal_set_title($title, CHECK_PLAIN);
-    $this->assertTrue(strpos(drupal_get_title(), '<em>') === FALSE, t('Tags in title converted to entities when $output is CHECK_PLAIN.'));
+    $this->assertTrue(strpos(drupal_get_title(), '<em>') === FALSE, 'Tags in title converted to entities when $output is CHECK_PLAIN.');
     // drupal_set_title's $filter is passed as PASS_THROUGH, so the title should be
     // returned with HTML.
     drupal_set_title($title, PASS_THROUGH);
-    $this->assertTrue(strpos(drupal_get_title(), '<em>') !== FALSE, t('Tags in title are not converted to entities when $output is PASS_THROUGH.'));
+    $this->assertTrue(strpos(drupal_get_title(), '<em>') !== FALSE, 'Tags in title are not converted to entities when $output is PASS_THROUGH.');
     // Generate node content.
     $langcode = LANGUAGE_NONE;
     $edit = array(
@@ -1437,11 +1437,11 @@ class FrontPageTestCase extends DrupalWebTestCase {
    */
   function testDrupalIsFrontPage() {
     $this->drupalGet('');
-    $this->assertText(t('On front page.'), t('Path is the front page.'));
+    $this->assertText(t('On front page.'), 'Path is the front page.');
     $this->drupalGet('node');
-    $this->assertText(t('On front page.'), t('Path is the front page.'));
+    $this->assertText(t('On front page.'), 'Path is the front page.');
     $this->drupalGet($this->node_path);
-    $this->assertNoText(t('On front page.'), t('Path is not the front page.'));
+    $this->assertNoText(t('On front page.'), 'Path is not the front page.');
 
     // Change the front page to an invalid path.
     $edit = array('site_frontpage' => 'kittens');
@@ -1451,14 +1451,14 @@ class FrontPageTestCase extends DrupalWebTestCase {
     // Change the front page to a valid path.
     $edit['site_frontpage'] = $this->node_path;
     $this->drupalPost('admin/config/system/site-information', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('The front page path has been saved.'));
+    $this->assertText(t('The configuration options have been saved.'), 'The front page path has been saved.');
 
     $this->drupalGet('');
-    $this->assertText(t('On front page.'), t('Path is the front page.'));
+    $this->assertText(t('On front page.'), 'Path is the front page.');
     $this->drupalGet('node');
-    $this->assertNoText(t('On front page.'), t('Path is not the front page.'));
+    $this->assertNoText(t('On front page.'), 'Path is not the front page.');
     $this->drupalGet($this->node_path);
-    $this->assertText(t('On front page.'), t('Path is the front page.'));
+    $this->assertText(t('On front page.'), 'Path is the front page.');
   }
 }
 
@@ -1568,47 +1568,47 @@ class SystemMainContentFallback extends DrupalWebTestCase {
     // Disable the dashboard module, which depends on the block module.
     $edit['modules[Core][dashboard][enable]'] = FALSE;
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
     // Disable the block module.
     $edit['modules[Core][block][enable]'] = FALSE;
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
     module_list(TRUE);
-    $this->assertFalse(module_exists('block'), t('Block module disabled.'));
+    $this->assertFalse(module_exists('block'), 'Block module disabled.');
 
     // At this point, no region is filled and fallback should be triggered.
     $this->drupalGet('admin/config/system/site-information');
-    $this->assertField('site_name', t('Admin interface still available.'));
+    $this->assertField('site_name', 'Admin interface still available.');
 
     // Fallback should not trigger when another module is handling content.
     $this->drupalGet('system-test/main-content-handling');
-    $this->assertRaw('id="system-test-content"', t('Content handled by another module'));
-    $this->assertText(t('Content to test main content fallback'), t('Main content still displayed.'));
+    $this->assertRaw('id="system-test-content"', 'Content handled by another module');
+    $this->assertText(t('Content to test main content fallback'), 'Main content still displayed.');
 
     // Fallback should trigger when another module
     // indicates that it is not handling the content.
     $this->drupalGet('system-test/main-content-fallback');
-    $this->assertText(t('Content to test main content fallback'), t('Main content fallback properly triggers.'));
+    $this->assertText(t('Content to test main content fallback'), 'Main content fallback properly triggers.');
 
     // Fallback should not trigger when another module is handling content.
     // Note that this test ensures that no duplicate
     // content gets created by the fallback.
     $this->drupalGet('system-test/main-content-duplication');
-    $this->assertNoText(t('Content to test main content fallback'), t('Main content not duplicated.'));
+    $this->assertNoText(t('Content to test main content fallback'), 'Main content not duplicated.');
 
     // Request a user* page and see if it is displayed.
     $this->drupalLogin($this->web_user);
     $this->drupalGet('user/' . $this->web_user->uid . '/edit');
-    $this->assertField('mail', t('User interface still available.'));
+    $this->assertField('mail', 'User interface still available.');
 
     // Enable the block module again.
     $this->drupalLogin($this->admin_user);
     $edit = array();
     $edit['modules[Core][block][enable]'] = 'block';
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
+    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
     module_list(TRUE);
-    $this->assertTrue(module_exists('block'), t('Block module re-enabled.'));
+    $this->assertTrue(module_exists('block'), 'Block module re-enabled.');
   }
 }
 
@@ -1746,16 +1746,16 @@ class SystemThemeFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/appearance', $edit, t('Save configuration'));
 
     $this->drupalGet('admin/config');
-    $this->assertRaw('themes/seven', t('Administration theme used on an administration page.'));
+    $this->assertRaw('themes/seven', 'Administration theme used on an administration page.');
 
     $this->drupalGet('node/' . $this->node->nid);
-    $this->assertRaw('themes/stark', t('Site default theme used on node page.'));
+    $this->assertRaw('themes/stark', 'Site default theme used on node page.');
 
     $this->drupalGet('node/add');
-    $this->assertRaw('themes/seven', t('Administration theme used on the add content page.'));
+    $this->assertRaw('themes/seven', 'Administration theme used on the add content page.');
 
     $this->drupalGet('node/' . $this->node->nid . '/edit');
-    $this->assertRaw('themes/seven', t('Administration theme used on the edit content page.'));
+    $this->assertRaw('themes/seven', 'Administration theme used on the edit content page.');
 
     // Disable the admin theme on the node admin pages.
     $edit = array(
@@ -1764,10 +1764,10 @@ class SystemThemeFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/appearance', $edit, t('Save configuration'));
 
     $this->drupalGet('admin/config');
-    $this->assertRaw('themes/seven', t('Administration theme used on an administration page.'));
+    $this->assertRaw('themes/seven', 'Administration theme used on an administration page.');
 
     $this->drupalGet('node/add');
-    $this->assertRaw('themes/stark', t('Site default theme used on the add content page.'));
+    $this->assertRaw('themes/stark', 'Site default theme used on the add content page.');
 
     // Reset to the default theme settings.
     variable_set('theme_default', 'bartik');
@@ -1778,10 +1778,10 @@ class SystemThemeFunctionalTest extends DrupalWebTestCase {
     $this->drupalPost('admin/appearance', $edit, t('Save configuration'));
 
     $this->drupalGet('admin');
-    $this->assertRaw('themes/bartik', t('Site default theme used on administration page.'));
+    $this->assertRaw('themes/bartik', 'Site default theme used on administration page.');
 
     $this->drupalGet('node/add');
-    $this->assertRaw('themes/bartik', t('Site default theme used on the add content page.'));
+    $this->assertRaw('themes/bartik', 'Site default theme used on the add content page.');
   }
 
   /**
@@ -1792,16 +1792,16 @@ class SystemThemeFunctionalTest extends DrupalWebTestCase {
     theme_enable(array('stark'));
     $this->drupalGet('admin/appearance');
     $this->clickLink(t('Set default'), 1);
-    $this->assertTrue(variable_get('theme_default', '') == 'stark', t('Site default theme switched successfully.'));
+    $this->assertTrue(variable_get('theme_default', '') == 'stark', 'Site default theme switched successfully.');
 
     // Test the default theme on the secondary links (blocks admin page).
     $this->drupalGet('admin/structure/block');
-    $this->assertText('Stark(' . t('active tab') . ')', t('Default local task on blocks admin page is the default theme.'));
+    $this->assertText('Stark(' . t('active tab') . ')', 'Default local task on blocks admin page is the default theme.');
     // Switch back to Bartik and test again to test that the menu cache is cleared.
     $this->drupalGet('admin/appearance');
     $this->clickLink(t('Set default'), 0);
     $this->drupalGet('admin/structure/block');
-    $this->assertText('Bartik(' . t('active tab') . ')', t('Default local task on blocks admin page has changed.'));
+    $this->assertText('Bartik(' . t('active tab') . ')', 'Default local task on blocks admin page has changed.');
   }
 }
 
@@ -1849,14 +1849,14 @@ class QueueTestCase extends DrupalWebTestCase {
     $new_items[] = $item->data;
 
     // First two dequeued items should match the first two items we queued.
-    $this->assertEqual($this->queueScore($data, $new_items), 2, t('Two items matched'));
+    $this->assertEqual($this->queueScore($data, $new_items), 2, 'Two items matched');
 
     // Add two more items.
     $queue1->createItem($data[2]);
     $queue1->createItem($data[3]);
 
-    $this->assertTrue($queue1->numberOfItems(), t('Queue 1 is not empty after adding items.'));
-    $this->assertFalse($queue2->numberOfItems(), t('Queue 2 is empty while Queue 1 has items'));
+    $this->assertTrue($queue1->numberOfItems(), 'Queue 1 is not empty after adding items.');
+    $this->assertFalse($queue2->numberOfItems(), 'Queue 2 is empty while Queue 1 has items');
 
     $items[] = $item = $queue1->claimItem();
     $new_items[] = $item->data;
@@ -1866,10 +1866,10 @@ class QueueTestCase extends DrupalWebTestCase {
 
     // All dequeued items should match the items we queued exactly once,
     // therefore the score must be exactly 4.
-    $this->assertEqual($this->queueScore($data, $new_items), 4, t('Four items matched'));
+    $this->assertEqual($this->queueScore($data, $new_items), 4, 'Four items matched');
 
     // There should be no duplicate items.
-    $this->assertEqual($this->queueScore($new_items, $new_items), 4, t('Four items matched'));
+    $this->assertEqual($this->queueScore($new_items, $new_items), 4, 'Four items matched');
 
     // Delete all items from queue1.
     foreach ($items as $item) {
@@ -1877,8 +1877,8 @@ class QueueTestCase extends DrupalWebTestCase {
     }
 
     // Check that both queues are empty.
-    $this->assertFalse($queue1->numberOfItems(), t('Queue 1 is empty'));
-    $this->assertFalse($queue2->numberOfItems(), t('Queue 2 is empty'));
+    $this->assertFalse($queue1->numberOfItems(), 'Queue 1 is empty');
+    $this->assertFalse($queue2->numberOfItems(), 'Queue 2 is empty');
   }
 
   /**
@@ -1949,10 +1949,10 @@ class TokenReplaceTestCase extends DrupalWebTestCase {
     // token, [node:title].
     $raw_tokens = array('title' => '[node:title]');
     $generated = token_generate('node', $raw_tokens, array('node' => $node));
-    $this->assertEqual($generated['[node:title]'], check_plain($node->title), t('Token sanitized.'));
+    $this->assertEqual($generated['[node:title]'], check_plain($node->title), 'Token sanitized.');
 
     $generated = token_generate('node', $raw_tokens, array('node' => $node), array('sanitize' => FALSE));
-    $this->assertEqual($generated['[node:title]'], $node->title, t('Unsanitized token generated properly.'));
+    $this->assertEqual($generated['[node:title]'], $node->title, 'Unsanitized token generated properly.');
 
     // Test token replacement when the string contains no tokens.
     $this->assertEqual(token_replace('No tokens here.'), 'No tokens here.');
@@ -1983,7 +1983,7 @@ class TokenReplaceTestCase extends DrupalWebTestCase {
       $input = $test['prefix'] . '[site:name]' . $test['suffix'];
       $expected = $test['prefix'] . 'Drupal' . $test['suffix'];
       $output = token_replace($input, array(), array('language' => $language));
-      $this->assertTrue($output == $expected, t('Token recognized in string %string', array('%string' => $input)));
+      $this->assertTrue($output == $expected, format_string('Token recognized in string %string', array('%string' => $input)));
     }
   }
 
@@ -2011,11 +2011,11 @@ class TokenReplaceTestCase extends DrupalWebTestCase {
     $tests['[site:login-url]'] = url('user', $url_options);
 
     // Test to make sure that we generated something for each token.
-    $this->assertFalse(in_array(0, array_map('strlen', $tests)), t('No empty tokens generated.'));
+    $this->assertFalse(in_array(0, array_map('strlen', $tests)), 'No empty tokens generated.');
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array(), array('language' => $language));
-      $this->assertEqual($output, $expected, t('Sanitized system site information token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Sanitized system site information token %token replaced.', array('%token' => $input)));
     }
 
     // Generate and test unsanitized tokens.
@@ -2024,7 +2024,7 @@ class TokenReplaceTestCase extends DrupalWebTestCase {
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array(), array('language' => $language, 'sanitize' => FALSE));
-      $this->assertEqual($output, $expected, t('Unsanitized system site information token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Unsanitized system site information token %token replaced.', array('%token' => $input)));
     }
   }
 
@@ -2047,11 +2047,11 @@ class TokenReplaceTestCase extends DrupalWebTestCase {
     $tests['[date:raw]'] = filter_xss($date);
 
     // Test to make sure that we generated something for each token.
-    $this->assertFalse(in_array(0, array_map('strlen', $tests)), t('No empty tokens generated.'));
+    $this->assertFalse(in_array(0, array_map('strlen', $tests)), 'No empty tokens generated.');
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('date' => $date), array('language' => $language));
-      $this->assertEqual($output, $expected, t('Date token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Date token %token replaced.', array('%token' => $input)));
     }
   }
 }
@@ -2115,15 +2115,15 @@ array_space[a b] = Value';
 
     $parsed = drupal_parse_info_format($config);
 
-    $this->assertEqual($parsed['simple'], $expected['simple'], t('Set a simple value.'));
-    $this->assertEqual($parsed['quoted'], $expected['quoted'], t('Set a simple value in quotes.'));
-    $this->assertEqual($parsed['multiline'], $expected['multiline'], t('Set a multiline value.'));
-    $this->assertEqual($parsed['array'], $expected['array'], t('Set a simple array.'));
-    $this->assertEqual($parsed['array_assoc'], $expected['array_assoc'], t('Set an associative array.'));
-    $this->assertEqual($parsed['array_deep'], $expected['array_deep'], t('Set a nested array.'));
-    $this->assertEqual($parsed['array_deep_assoc'], $expected['array_deep_assoc'], t('Set a nested associative array.'));
-    $this->assertEqual($parsed['array_space'], $expected['array_space'], t('Set an array with a whitespace in the key.'));
-    $this->assertEqual($parsed, $expected, t('Entire parsed .info string and expected array are identical.'));
+    $this->assertEqual($parsed['simple'], $expected['simple'], 'Set a simple value.');
+    $this->assertEqual($parsed['quoted'], $expected['quoted'], 'Set a simple value in quotes.');
+    $this->assertEqual($parsed['multiline'], $expected['multiline'], 'Set a multiline value.');
+    $this->assertEqual($parsed['array'], $expected['array'], 'Set a simple array.');
+    $this->assertEqual($parsed['array_assoc'], $expected['array_assoc'], 'Set an associative array.');
+    $this->assertEqual($parsed['array_deep'], $expected['array_deep'], 'Set a nested array.');
+    $this->assertEqual($parsed['array_deep_assoc'], $expected['array_deep_assoc'], 'Set a nested associative array.');
+    $this->assertEqual($parsed['array_space'], $expected['array_space'], 'Set an array with a whitespace in the key.');
+    $this->assertEqual($parsed, $expected, 'Entire parsed .info string and expected array are identical.');
   }
 }
 
@@ -2149,32 +2149,32 @@ class SystemInfoAlterTestCase extends DrupalWebTestCase {
     // thing necessary to use the rebuilt {system}.info.
     module_enable(array('module_test'), FALSE);
     drupal_flush_all_caches();
-    $this->assertTrue(module_exists('module_test'), t('Test module is enabled.'));
+    $this->assertTrue(module_exists('module_test'), 'Test module is enabled.');
 
     $info = $this->getSystemInfo('seven', 'theme');
-    $this->assertTrue(isset($info['regions']['test_region']), t('Altered theme info was added to {system}.info.'));
+    $this->assertTrue(isset($info['regions']['test_region']), 'Altered theme info was added to {system}.info.');
     $seven_regions = system_region_list('seven');
-    $this->assertTrue(isset($seven_regions['test_region']), t('Altered theme info was returned by system_region_list().'));
+    $this->assertTrue(isset($seven_regions['test_region']), 'Altered theme info was returned by system_region_list().');
     $system_list_themes = system_list('theme');
     $info = $system_list_themes['seven']->info;
-    $this->assertTrue(isset($info['regions']['test_region']), t('Altered theme info was returned by system_list().'));
+    $this->assertTrue(isset($info['regions']['test_region']), 'Altered theme info was returned by system_list().');
     $list_themes = list_themes();
-    $this->assertTrue(isset($list_themes['seven']->info['regions']['test_region']), t('Altered theme info was returned by list_themes().'));
+    $this->assertTrue(isset($list_themes['seven']->info['regions']['test_region']), 'Altered theme info was returned by list_themes().');
 
     // Disable the module and verify that {system}.info is rebuilt without it.
     module_disable(array('module_test'), FALSE);
     drupal_flush_all_caches();
-    $this->assertFalse(module_exists('module_test'), t('Test module is disabled.'));
+    $this->assertFalse(module_exists('module_test'), 'Test module is disabled.');
 
     $info = $this->getSystemInfo('seven', 'theme');
-    $this->assertFalse(isset($info['regions']['test_region']), t('Altered theme info was removed from {system}.info.'));
+    $this->assertFalse(isset($info['regions']['test_region']), 'Altered theme info was removed from {system}.info.');
     $seven_regions = system_region_list('seven');
-    $this->assertFalse(isset($seven_regions['test_region']), t('Altered theme info was not returned by system_region_list().'));
+    $this->assertFalse(isset($seven_regions['test_region']), 'Altered theme info was not returned by system_region_list().');
     $system_list_themes = system_list('theme');
     $info = $system_list_themes['seven']->info;
-    $this->assertFalse(isset($info['regions']['test_region']), t('Altered theme info was not returned by system_list().'));
+    $this->assertFalse(isset($info['regions']['test_region']), 'Altered theme info was not returned by system_list().');
     $list_themes = list_themes();
-    $this->assertFalse(isset($list_themes['seven']->info['regions']['test_region']), t('Altered theme info was not returned by list_themes().'));
+    $this->assertFalse(isset($list_themes['seven']->info['regions']['test_region']), 'Altered theme info was not returned by list_themes().');
   }
 
   /**
@@ -2256,7 +2256,7 @@ class UpdateScriptFunctionalTest extends DrupalWebTestCase {
     // go through the update process uninterrupted.
     $this->drupalGet($this->update_url, array('external' => TRUE));
     $this->drupalPost(NULL, array(), t('Continue'));
-    $this->assertText(t('No pending updates.'), t('End of update process was reached.'));
+    $this->assertText(t('No pending updates.'), 'End of update process was reached.');
     // Confirm that all caches were cleared.
     $this->assertText(t('hook_flush_caches() invoked for update_script_test.module.'), 'Caches were cleared when there were no requirements warnings or errors.');
 
@@ -2274,7 +2274,7 @@ class UpdateScriptFunctionalTest extends DrupalWebTestCase {
     $this->assertNoText('This is a requirements warning provided by the update_script_test module.');
     $this->drupalPost(NULL, array(), t('Continue'));
     $this->drupalPost(NULL, array(), t('Apply pending updates'));
-    $this->assertText(t('The update_script_test_update_7000() update was executed successfully.'), t('End of update process was reached.'));
+    $this->assertText(t('The update_script_test_update_7000() update was executed successfully.'), 'End of update process was reached.');
     // Confirm that all caches were cleared.
     $this->assertText(t('hook_flush_caches() invoked for update_script_test.module.'), 'Caches were cleared after resolving a requirements warning and applying updates.');
 
@@ -2284,7 +2284,7 @@ class UpdateScriptFunctionalTest extends DrupalWebTestCase {
     $this->clickLink('try again');
     $this->assertNoText('This is a requirements warning provided by the update_script_test module.');
     $this->drupalPost(NULL, array(), t('Continue'));
-    $this->assertText(t('No pending updates.'), t('End of update process was reached.'));
+    $this->assertText(t('No pending updates.'), 'End of update process was reached.');
     // Confirm that all caches were cleared.
     $this->assertText(t('hook_flush_caches() invoked for update_script_test.module.'), 'Caches were cleared after applying updates and re-running the script.');
 
@@ -2309,7 +2309,7 @@ class UpdateScriptFunctionalTest extends DrupalWebTestCase {
     $this->drupalLogin($this->update_user);
     $this->drupalGet($this->update_url, array('external' => TRUE));
     $final_theme_data = db_query("SELECT * FROM {system} WHERE type = 'theme' ORDER BY name")->fetchAll();
-    $this->assertEqual($original_theme_data, $final_theme_data, t('Visiting update.php does not alter the information about themes stored in the database.'));
+    $this->assertEqual($original_theme_data, $final_theme_data, 'Visiting update.php does not alter the information about themes stored in the database.');
   }
 
   /**
@@ -2422,7 +2422,7 @@ class RetrieveFileTestCase extends DrupalWebTestCase {
     $filename = 'Файл для тестирования ' . $this->randomName();
     $url = file_create_url($sourcedir . '/' . $filename);
     $retrieved_file = system_retrieve_file($url);
-    $this->assertFalse($retrieved_file, t('Non-existent file not fetched.'));
+    $this->assertFalse($retrieved_file, 'Non-existent file not fetched.');
 
     // Actually create that file, download it via HTTP and test the returned path.
     file_put_contents($sourcedir . '/' . $filename, 'testing');
@@ -2432,17 +2432,17 @@ class RetrieveFileTestCase extends DrupalWebTestCase {
     // has to be encoded.
     $encoded_filename = rawurlencode($filename);
 
-    $this->assertEqual($retrieved_file, 'public://' . $encoded_filename, t('Sane path for downloaded file returned (public:// scheme).'));
-    $this->assertTrue(is_file($retrieved_file), t('Downloaded file does exist (public:// scheme).'));
-    $this->assertEqual(filesize($retrieved_file), 7, t('File size of downloaded file is correct (public:// scheme).'));
+    $this->assertEqual($retrieved_file, 'public://' . $encoded_filename, 'Sane path for downloaded file returned (public:// scheme).');
+    $this->assertTrue(is_file($retrieved_file), 'Downloaded file does exist (public:// scheme).');
+    $this->assertEqual(filesize($retrieved_file), 7, 'File size of downloaded file is correct (public:// scheme).');
     file_unmanaged_delete($retrieved_file);
 
     // Test downloading file to a different location.
     drupal_mkdir($targetdir = 'temporary://' . $this->randomName());
     $retrieved_file = system_retrieve_file($url, $targetdir);
-    $this->assertEqual($retrieved_file, "$targetdir/$encoded_filename", t('Sane path for downloaded file returned (temporary:// scheme).'));
-    $this->assertTrue(is_file($retrieved_file), t('Downloaded file does exist (temporary:// scheme).'));
-    $this->assertEqual(filesize($retrieved_file), 7, t('File size of downloaded file is correct (temporary:// scheme).'));
+    $this->assertEqual($retrieved_file, "$targetdir/$encoded_filename", 'Sane path for downloaded file returned (temporary:// scheme).');
+    $this->assertTrue(is_file($retrieved_file), 'Downloaded file does exist (temporary:// scheme).');
+    $this->assertEqual(filesize($retrieved_file), 7, 'File size of downloaded file is correct (temporary:// scheme).');
     file_unmanaged_delete($retrieved_file);
 
     file_unmanaged_delete_recursive($sourcedir);
@@ -2580,18 +2580,18 @@ class SystemAdminTestCase extends DrupalWebTestCase {
    */
   function testCompactMode() {
     $this->drupalGet('admin/compact/on');
-    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], t('Compact mode turns on.'));
+    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'Compact mode turns on.');
     $this->drupalGet('admin/compact/on');
-    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], t('Compact mode remains on after a repeat call.'));
+    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'Compact mode remains on after a repeat call.');
     $this->drupalGet('');
-    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], t('Compact mode persists on new requests.'));
+    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'Compact mode persists on new requests.');
 
     $this->drupalGet('admin/compact/off');
-    $this->assertEqual($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'deleted', t('Compact mode turns off.'));
+    $this->assertEqual($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'deleted', 'Compact mode turns off.');
     $this->drupalGet('admin/compact/off');
-    $this->assertEqual($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'deleted', t('Compact mode remains off after a repeat call.'));
+    $this->assertEqual($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'deleted', 'Compact mode remains off after a repeat call.');
     $this->drupalGet('');
-    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], t('Compact mode persists on new requests.'));
+    $this->assertTrue($this->cookies['Drupal.visitor.admin_compact_mode']['value'], 'Compact mode persists on new requests.');
   }
 }
 
@@ -2671,13 +2671,44 @@ class SystemIndexPhpTest extends DrupalWebTestCase {
     $index_php = $GLOBALS['base_url'] . '/index.php';
 
     $this->drupalGet($index_php, array('external' => TRUE));
-    $this->assertResponse(200, t('Make sure index.php returns a valid page.'));
+    $this->assertResponse(200, 'Make sure index.php returns a valid page.');
 
     $this->drupalGet($index_php, array('external' => TRUE, 'query' => array('q' => 'user')));
-    $this->assertResponse(200, t('Make sure index.php?q=user returns a valid page.'));
+    $this->assertResponse(200, 'Make sure index.php?q=user returns a valid page.');
 
     $this->drupalGet($index_php .'/user', array('external' => TRUE));
-    $this->assertResponse(404, t("Make sure index.php/user returns a 'page not found'."));
+    $this->assertResponse(404, "Make sure index.php/user returns a 'page not found'.");
+  }
+}
+
+/**
+ * Test token replacement in strings.
+ */
+class TokenScanTest extends DrupalWebTestCase {
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Token scanning',
+      'description' => 'Scan token-like patterns in a dummy text to check token scanning.',
+      'group' => 'System',
+    );
+  }
+
+  /**
+   * Scans dummy text, then tests the output.
+   */
+  function testTokenScan() {
+    // Define text with valid and not valid, fake and existing token-like
+    // strings.
+    $text = 'First a [valid:simple], but dummy token, and a dummy [valid:token with: spaces].';
+    $text .= 'Then a [not valid:token].';
+    $text .= 'Last an existing token: [node:author:name].';
+    $token_wannabes = token_scan($text);
+
+    $this->assertTrue(isset($token_wannabes['valid']['simple']), 'A simple valid token has been matched.');
+    $this->assertTrue(isset($token_wannabes['valid']['token with: spaces']), 'A valid token with space characters in the token name has been matched.');
+    $this->assertFalse(isset($token_wannabes['not valid']), 'An invalid token with spaces in the token type has not been matched.');
+    $this->assertTrue(isset($token_wannabes['node']), 'An existing valid token has been matched.');
   }
 }
 
diff --git a/modules/system/system.updater.inc b/modules/system/system.updater.inc
index 0df1ad9..a14d788 100644
--- a/modules/system/system.updater.inc
+++ b/modules/system/system.updater.inc
@@ -73,8 +73,12 @@ class ModuleUpdater extends Updater implements DrupalUpdaterInterface {
     return array();
   }
 
+  /**
+   * Returns a list of post install actions.
+   */
   public function postInstallTasks() {
     return array(
+      l(t('Install another module'), 'admin/modules/install'),
       l(t('Enable newly added modules'), 'admin/modules'),
       l(t('Administration pages'), 'admin'),
     );
diff --git a/modules/system/theme.api.php b/modules/system/theme.api.php
index 6865421..56e9ba1 100644
--- a/modules/system/theme.api.php
+++ b/modules/system/theme.api.php
@@ -62,6 +62,8 @@
  *
  * @see theme()
  * @see hook_theme()
+ * @see hooks
+ * @see callbacks
  *
  * @} End of "defgroup themeable".
  */
diff --git a/modules/taxonomy/taxonomy-term.tpl.php b/modules/taxonomy/taxonomy-term.tpl.php
index d410d1e..a225c3a 100644
--- a/modules/taxonomy/taxonomy-term.tpl.php
+++ b/modules/taxonomy/taxonomy-term.tpl.php
@@ -5,7 +5,8 @@
  * Default theme implementation to display a term.
  *
  * Available variables:
- * - $name: the (sanitized) name of the term.
+ * - $name: (deprecated) The unsanitized name of the term. Use $term_name
+ *   instead.
  * - $content: An array of items for the content of the term (fields and
  *   description). Use render($content) to print them all, or print a subset
  *   such as render($content['field_example']). Use
diff --git a/modules/taxonomy/taxonomy.api.php b/modules/taxonomy/taxonomy.api.php
index 5667eb9..b9c23db 100644
--- a/modules/taxonomy/taxonomy.api.php
+++ b/modules/taxonomy/taxonomy.api.php
@@ -20,12 +20,15 @@
  *   An array of taxonomy vocabulary objects.
  */
 function hook_taxonomy_vocabulary_load($vocabularies) {
-  foreach ($vocabularies as $vocabulary) {
-    $vocabulary->synonyms = variable_get('taxonomy_' . $vocabulary->vid . '_synonyms', FALSE);
+  $result = db_select('mytable', 'm')
+    ->fields('m', array('vid', 'foo'))
+    ->condition('m.vid', array_keys($vocabularies), 'IN')
+    ->execute();
+  foreach ($result as $record) {
+    $vocabularies[$record->vid]->foo = $record->foo;
   }
 }
 
-
 /**
  * Act on taxonomy vocabularies before they are saved.
  *
@@ -49,8 +52,8 @@ function hook_taxonomy_vocabulary_presave($vocabulary) {
  *   A taxonomy vocabulary object.
  */
 function hook_taxonomy_vocabulary_insert($vocabulary) {
-  if ($vocabulary->synonyms) {
-    variable_set('taxonomy_' . $vocabulary->vid . '_synonyms', TRUE);
+  if ($vocabulary->machine_name == 'my_vocabulary') {
+    $vocabulary->weight = 100;
   }
 }
 
@@ -63,10 +66,10 @@ function hook_taxonomy_vocabulary_insert($vocabulary) {
  *   A taxonomy vocabulary object.
  */
 function hook_taxonomy_vocabulary_update($vocabulary) {
-  $status = $vocabulary->synonyms ? TRUE : FALSE;
-  if ($vocabulary->synonyms) {
-    variable_set('taxonomy_' . $vocabulary->vid . '_synonyms', $status);
-  }
+  db_update('mytable')
+    ->fields(array('foo' => $vocabulary->foo))
+    ->condition('vid', $vocabulary->vid)
+    ->execute();
 }
 
 /**
@@ -79,9 +82,9 @@ function hook_taxonomy_vocabulary_update($vocabulary) {
  *   A taxonomy vocabulary object.
  */
 function hook_taxonomy_vocabulary_delete($vocabulary) {
-  if (variable_get('taxonomy_' . $vocabulary->vid . '_synonyms', FALSE)) {
-    variable_del('taxonomy_' . $vocabulary->vid . '_synonyms');
-  }
+  db_delete('mytable')
+    ->condition('vid', $vocabulary->vid)
+    ->execute();
 }
 
 /**
@@ -101,7 +104,10 @@ function hook_taxonomy_vocabulary_delete($vocabulary) {
  *   An array of term objects, indexed by tid.
  */
 function hook_taxonomy_term_load($terms) {
-  $result = db_query('SELECT tid, foo FROM {mytable} WHERE tid IN (:tids)', array(':tids' => array_keys($terms)));
+  $result = db_select('mytable', 'm')
+    ->fields('m', array('tid', 'foo'))
+    ->condition('m.tid', array_keys($terms), 'IN')
+    ->execute();
   foreach ($result as $record) {
     $terms[$record->tid]->foo = $record->foo;
   }
@@ -130,18 +136,12 @@ function hook_taxonomy_term_presave($term) {
  *   A taxonomy term object.
  */
 function hook_taxonomy_term_insert($term) {
-  if (!empty($term->synonyms)) {
-    foreach (explode ("\n", str_replace("\r", '', $term->synonyms)) as $synonym) {
-      if ($synonym) {
-        db_insert('taxonomy_term_synonym')
-        ->fields(array(
-          'tid' => $term->tid,
-          'name' => rtrim($synonym),
-        ))
-        ->execute();
-      }
-    }
-  }
+  db_insert('mytable')
+    ->fields(array(
+      'tid' => $term->tid,
+      'foo' => $term->foo,
+    ))
+    ->execute();
 }
 
 /**
@@ -153,19 +153,10 @@ function hook_taxonomy_term_insert($term) {
  *   A taxonomy term object.
  */
 function hook_taxonomy_term_update($term) {
-  hook_taxonomy_term_delete($term);
-  if (!empty($term->synonyms)) {
-    foreach (explode ("\n", str_replace("\r", '', $term->synonyms)) as $synonym) {
-      if ($synonym) {
-        db_insert('taxonomy_term_synonym')
-        ->fields(array(
-          'tid' => $term->tid,
-          'name' => rtrim($synonym),
-        ))
-        ->execute();
-      }
-    }
-  }
+  db_update('mytable')
+    ->fields(array('foo' => $term->foo))
+    ->condition('tid', $term->tid)
+    ->execute();
 }
 
 /**
@@ -178,7 +169,9 @@ function hook_taxonomy_term_update($term) {
  *   A taxonomy term object.
  */
 function hook_taxonomy_term_delete($term) {
-  db_delete('term_synoynm')->condition('tid', $term->tid)->execute();
+  db_delete('mytable')
+    ->condition('tid', $term->tid)
+    ->execute();
 }
 
 /**
diff --git a/modules/taxonomy/taxonomy.install b/modules/taxonomy/taxonomy.install
index c353c9c..2d44d3d 100644
--- a/modules/taxonomy/taxonomy.install
+++ b/modules/taxonomy/taxonomy.install
@@ -682,6 +682,14 @@ function taxonomy_update_7005(&$sandbox) {
     $query->orderBy('tn.vid');
     $query->orderBy('td.weight');
     $query->orderBy('tn.tid');
+
+    // Work around a bug in the PostgreSQL driver that would result in fatal
+    // errors when this subquery is used in the insert query below. See
+    // https://drupal.org/node/2057693.
+    $fields = &$query->getFields();
+    unset($fields['td.weight']);
+    unset($fields['tn.tid']);
+
     db_insert('taxonomy_update_7005')
       ->from($query)
       ->execute();
diff --git a/modules/taxonomy/taxonomy.module b/modules/taxonomy/taxonomy.module
index 9be7dfc..7ad28e9 100644
--- a/modules/taxonomy/taxonomy.module
+++ b/modules/taxonomy/taxonomy.module
@@ -140,7 +140,7 @@ function taxonomy_entity_info() {
 }
 
 /**
- * Entity URI callback.
+ * Implements callback_entity_info_uri().
  */
 function taxonomy_term_uri($term) {
   return array(
diff --git a/modules/taxonomy/taxonomy.pages.inc b/modules/taxonomy/taxonomy.pages.inc
index 299c7bb..975ff12 100644
--- a/modules/taxonomy/taxonomy.pages.inc
+++ b/modules/taxonomy/taxonomy.pages.inc
@@ -118,7 +118,7 @@ function taxonomy_term_feed($term) {
  * @see taxonomy_menu()
  * @see taxonomy_field_widget_info()
  */
-function taxonomy_autocomplete($field_name, $tags_typed = '') {
+function taxonomy_autocomplete($field_name = '', $tags_typed = '') {
   // If the request has a '/' in the search text, then the menu system will have
   // split it into multiple arguments, recover the intended $tags_typed.
   $args = func_get_args();
@@ -138,7 +138,7 @@ function taxonomy_autocomplete($field_name, $tags_typed = '') {
   $tags_typed = drupal_explode_tags($tags_typed);
   $tag_last = drupal_strtolower(array_pop($tags_typed));
 
-  $matches = array();
+  $term_matches = array();
   if ($tag_last != '') {
 
     // Part of the criteria for the query come from the field's own settings.
@@ -167,7 +167,6 @@ function taxonomy_autocomplete($field_name, $tags_typed = '') {
 
     $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';
 
-    $term_matches = array();
     foreach ($tags_return as $tid => $name) {
       $n = $name;
       // Term names containing commas or quotes must be wrapped in quotes.
diff --git a/modules/taxonomy/taxonomy.test b/modules/taxonomy/taxonomy.test
index 123bdce..665f9ae 100644
--- a/modules/taxonomy/taxonomy.test
+++ b/modules/taxonomy/taxonomy.test
@@ -170,7 +170,8 @@ class TaxonomyVocabularyFunctionalTest extends TaxonomyWebTestCase {
 
     // Check the created vocabulary.
     $vocabularies = taxonomy_get_vocabularies();
-    $vid = $vocabularies[count($vocabularies) - 1]->vid;
+    $vocabularies_keys = array_keys($vocabularies);
+    $vid = $vocabularies[end($vocabularies_keys)]->vid;
     entity_get_controller('taxonomy_vocabulary')->resetCache();
     $vocabulary = taxonomy_vocabulary_load($vid);
     $this->assertTrue($vocabulary, 'Vocabulary found in database.');
@@ -722,6 +723,13 @@ class TaxonomyTermTestCase extends TaxonomyWebTestCase {
     $this->assertFalse(field_info_field($field_name), format_string('Field %field_name does not exist.', array('%field_name' => $field_name)));
     $this->drupalGet('taxonomy/autocomplete/' . $field_name . '/' . $tag);
     $this->assertRaw($message, 'Autocomplete returns correct error message when the taxonomy field does not exist.');
+
+    // Test the autocomplete path without passing a field_name and terms.
+    // This should not trigger a PHP notice.
+    $field_name = '';
+    $message = t("Taxonomy field @field_name not found.", array('@field_name' => $field_name));
+    $this->drupalGet('taxonomy/autocomplete');
+    $this->assertRaw($message, 'Autocomplete returns correct error message when no taxonomy field is given.');
   }
 
   /**
diff --git a/modules/tracker/tracker.test b/modules/tracker/tracker.test
index d429210..66ebb84 100644
--- a/modules/tracker/tracker.test
+++ b/modules/tracker/tracker.test
@@ -59,14 +59,14 @@ class TrackerTest extends DrupalWebTestCase {
     ));
 
     $this->drupalGet('tracker');
-    $this->assertNoText($unpublished->title, t('Unpublished node do not show up in the tracker listing.'));
-    $this->assertText($published->title, t('Published node show up in the tracker listing.'));
-    $this->assertLink(t('My recent content'), 0, t('User tab shows up on the global tracker page.'));
+    $this->assertNoText($unpublished->title, 'Unpublished node do not show up in the tracker listing.');
+    $this->assertText($published->title, 'Published node show up in the tracker listing.');
+    $this->assertLink(t('My recent content'), 0, 'User tab shows up on the global tracker page.');
 
     // Delete a node and ensure it no longer appears on the tracker.
     node_delete($published->nid);
     $this->drupalGet('tracker');
-    $this->assertNoText($published->title, t('Deleted node do not show up in the tracker listing.'));
+    $this->assertNoText($published->title, 'Deleted node do not show up in the tracker listing.');
   }
 
   /**
@@ -102,10 +102,10 @@ class TrackerTest extends DrupalWebTestCase {
     $this->drupalPost('comment/reply/' . $other_published_my_comment->nid, $comment, t('Save'));
 
     $this->drupalGet('user/' . $this->user->uid . '/track');
-    $this->assertNoText($unpublished->title, t("Unpublished nodes do not show up in the users's tracker listing."));
-    $this->assertText($my_published->title, t("Published nodes show up in the user's tracker listing."));
-    $this->assertNoText($other_published_no_comment->title, t("Other user's nodes do not show up in the user's tracker listing."));
-    $this->assertText($other_published_my_comment->title, t("Nodes that the user has commented on appear in the user's tracker listing."));
+    $this->assertNoText($unpublished->title, "Unpublished nodes do not show up in the users's tracker listing.");
+    $this->assertText($my_published->title, "Published nodes show up in the user's tracker listing.");
+    $this->assertNoText($other_published_no_comment->title, "Other user's nodes do not show up in the user's tracker listing.");
+    $this->assertText($other_published_my_comment->title, "Nodes that the user has commented on appear in the user's tracker listing.");
 
     // Verify that unpublished comments are removed from the tracker.
     $admin_user = $this->drupalCreateUser(array('administer comments', 'access user profiles'));
@@ -128,19 +128,19 @@ class TrackerTest extends DrupalWebTestCase {
     $node = $this->drupalCreateNode($edit);
     $title = $edit['title'];
     $this->drupalGet('tracker');
-    $this->assertPattern('/' . $title . '.*new/', t('New nodes are flagged as such in the tracker listing.'));
+    $this->assertPattern('/' . $title . '.*new/', 'New nodes are flagged as such in the tracker listing.');
 
     $this->drupalGet('node/' . $node->nid);
     $this->drupalGet('tracker');
-    $this->assertNoPattern('/' . $title . '.*new/', t('Visited nodes are not flagged as new.'));
+    $this->assertNoPattern('/' . $title . '.*new/', 'Visited nodes are not flagged as new.');
 
     $this->drupalLogin($this->other_user);
     $this->drupalGet('tracker');
-    $this->assertPattern('/' . $title . '.*new/', t('For another user, new nodes are flagged as such in the tracker listing.'));
+    $this->assertPattern('/' . $title . '.*new/', 'For another user, new nodes are flagged as such in the tracker listing.');
 
     $this->drupalGet('node/' . $node->nid);
     $this->drupalGet('tracker');
-    $this->assertNoPattern('/' . $title . '.*new/', t('For another user, visited nodes are not flagged as new.'));
+    $this->assertNoPattern('/' . $title . '.*new/', 'For another user, visited nodes are not flagged as new.');
   }
 
   /**
@@ -164,7 +164,7 @@ class TrackerTest extends DrupalWebTestCase {
 
     $this->drupalLogin($this->other_user);
     $this->drupalGet('tracker');
-    $this->assertText('1 new', t('New comments are counted on the tracker listing pages.'));
+    $this->assertText('1 new', 'New comments are counted on the tracker listing pages.');
     $this->drupalGet('node/' . $node->nid);
 
     // Add another comment as other_user.
@@ -179,7 +179,7 @@ class TrackerTest extends DrupalWebTestCase {
 
     $this->drupalLogin($this->user);
     $this->drupalGet('tracker');
-    $this->assertText('1 new', t('New comments are counted on the tracker listing pages.'));
+    $this->assertText('1 new', 'New comments are counted on the tracker listing pages.');
   }
 
   /**
@@ -224,19 +224,19 @@ class TrackerTest extends DrupalWebTestCase {
 
     // Assert that all node titles are displayed.
     foreach ($nodes as $i => $node) {
-      $this->assertText($node->title, t('Node @i is displayed on the tracker listing pages.', array('@i' => $i)));
+      $this->assertText($node->title, format_string('Node @i is displayed on the tracker listing pages.', array('@i' => $i)));
     }
-    $this->assertText('1 new', t('New comment is counted on the tracker listing pages.'));
-    $this->assertText('updated', t('Node is listed as updated'));
+    $this->assertText('1 new', 'New comment is counted on the tracker listing pages.');
+    $this->assertText('updated', 'Node is listed as updated');
 
     // Fetch the site-wide tracker.
     $this->drupalGet('tracker');
 
     // Assert that all node titles are displayed.
     foreach ($nodes as $i => $node) {
-      $this->assertText($node->title, t('Node @i is displayed on the tracker listing pages.', array('@i' => $i)));
+      $this->assertText($node->title, format_string('Node @i is displayed on the tracker listing pages.', array('@i' => $i)));
     }
-    $this->assertText('1 new', t('New comment is counted on the tracker listing pages.'));
+    $this->assertText('1 new', 'New comment is counted on the tracker listing pages.');
   }
 
   /**
@@ -253,7 +253,7 @@ class TrackerTest extends DrupalWebTestCase {
 
     // Assert that the node is displayed.
     $this->drupalGet('tracker');
-    $this->assertText($node->title, t('Node is displayed on the tracker listing pages.'));
+    $this->assertText($node->title, 'Node is displayed on the tracker listing pages.');
 
     // Unpublish the node and ensure that it's no longer displayed.
     $edit = array(
@@ -263,6 +263,6 @@ class TrackerTest extends DrupalWebTestCase {
     $this->drupalPost('admin/content', $edit, t('Update'));
 
     $this->drupalGet('tracker');
-    $this->assertText(t('No content available.'), t('Node is displayed on the tracker listing pages.'));
+    $this->assertText(t('No content available.'), 'Node is displayed on the tracker listing pages.');
   }
 }
diff --git a/modules/translation/translation.test b/modules/translation/translation.test
index e64f9cb..4d272f3 100644
--- a/modules/translation/translation.test
+++ b/modules/translation/translation.test
@@ -43,7 +43,7 @@ class TranslationTestCase extends DrupalWebTestCase {
     $edit = array();
     $edit['language_content_type'] = 2;
     $this->drupalPost('admin/structure/types/manage/page', $edit, t('Save content type'));
-    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Basic page')), t('Basic page content type has been updated.'));
+    $this->assertRaw(t('The content type %type has been updated.', array('%type' => 'Basic page')), 'Basic page content type has been updated.');
 
     // Enable the language switcher block.
     $language_type = LANGUAGE_TYPE_INTERFACE;
@@ -54,7 +54,7 @@ class TranslationTestCase extends DrupalWebTestCase {
     // block appear.
     $edit = array('language[enabled][locale-url]' => TRUE);
     $this->drupalPost('admin/config/regional/language/configure', $edit, t('Save settings'));
-    $this->assertRaw(t('Language negotiation configuration saved.'), t('URL language detection enabled.'));
+    $this->assertRaw(t('Language negotiation configuration saved.'), 'URL language detection enabled.');
     $this->resetCaches();
 
     $this->drupalLogin($this->translator);
@@ -80,7 +80,7 @@ class TranslationTestCase extends DrupalWebTestCase {
     // Check that the "add translation" link uses a localized path.
     $languages = language_list();
     $this->drupalGet('node/' . $node->nid . '/translate');
-    $this->assertLinkByHref($languages['es']->prefix . '/node/add/' . str_replace('_', '-', $node->type), 0, t('The "add translation" link for %language points to the localized path of the target language.', array('%language' => $languages['es']->name)));
+    $this->assertLinkByHref($languages['es']->prefix . '/node/add/' . str_replace('_', '-', $node->type), 0, format_string('The "add translation" link for %language points to the localized path of the target language.', array('%language' => $languages['es']->name)));
 
     // Submit translation in Spanish.
     $node_translation_title = $this->randomName();
@@ -90,13 +90,13 @@ class TranslationTestCase extends DrupalWebTestCase {
     // Check that the "edit translation" and "view node" links use localized
     // paths.
     $this->drupalGet('node/' . $node->nid . '/translate');
-    $this->assertLinkByHref($languages['es']->prefix . '/node/' . $node_translation->nid . '/edit', 0, t('The "edit" link for the translation in %language points to the localized path of the translation language.', array('%language' => $languages['es']->name)));
-    $this->assertLinkByHref($languages['es']->prefix . '/node/' . $node_translation->nid, 0, t('The "view" link for the translation in %language points to the localized path of the translation language.', array('%language' => $languages['es']->name)));
+    $this->assertLinkByHref($languages['es']->prefix . '/node/' . $node_translation->nid . '/edit', 0, format_string('The "edit" link for the translation in %language points to the localized path of the translation language.', array('%language' => $languages['es']->name)));
+    $this->assertLinkByHref($languages['es']->prefix . '/node/' . $node_translation->nid, 0, format_string('The "view" link for the translation in %language points to the localized path of the translation language.', array('%language' => $languages['es']->name)));
 
     // Attempt to submit a duplicate translation by visiting the node/add page
     // with identical query string.
     $this->drupalGet('node/add/page', array('query' => array('translation' => $node->nid, 'target' => 'es')));
-    $this->assertRaw(t('A translation of %title in %language already exists', array('%title' => $node_title, '%language' => $languages['es']->name)), t('Message regarding attempted duplicate translation is displayed.'));
+    $this->assertRaw(t('A translation of %title in %language already exists', array('%title' => $node_title, '%language' => $languages['es']->name)), 'Message regarding attempted duplicate translation is displayed.');
 
     // Attempt a resubmission of the form - this emulates using the back button
     // to return to the page then resubmitting the form without a refresh.
@@ -106,7 +106,7 @@ class TranslationTestCase extends DrupalWebTestCase {
     $edit["body[$langcode][0][value]"] = $this->randomName();
     $this->drupalPost('node/add/page', $edit, t('Save'), array('query' => array('translation' => $node->nid, 'language' => 'es')));
     $duplicate = $this->drupalGetNodeByTitle($edit["title"]);
-    $this->assertEqual($duplicate->tnid, 0, t('The node does not have a tnid.'));
+    $this->assertEqual($duplicate->tnid, 0, 'The node does not have a tnid.');
 
     // Update original and mark translation as outdated.
     $node_body = $this->randomName();
@@ -115,32 +115,32 @@ class TranslationTestCase extends DrupalWebTestCase {
     $edit["body[$langcode][0][value]"] = $node_body;
     $edit['translation[retranslate]'] = TRUE;
     $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
-    $this->assertRaw(t('Basic page %title has been updated.', array('%title' => $node_title)), t('Original node updated.'));
+    $this->assertRaw(t('Basic page %title has been updated.', array('%title' => $node_title)), 'Original node updated.');
 
     // Check to make sure that interface shows translation as outdated.
     $this->drupalGet('node/' . $node->nid . '/translate');
-    $this->assertRaw('<span class="marker">' . t('outdated') . '</span>', t('Translation marked as outdated.'));
+    $this->assertRaw('<span class="marker">' . t('outdated') . '</span>', 'Translation marked as outdated.');
 
     // Update translation and mark as updated.
     $edit = array();
     $edit["body[$langcode][0][value]"] = $this->randomName();
     $edit['translation[status]'] = FALSE;
     $this->drupalPost('node/' . $node_translation->nid . '/edit', $edit, t('Save'));
-    $this->assertRaw(t('Basic page %title has been updated.', array('%title' => $node_translation_title)), t('Translated node updated.'));
+    $this->assertRaw(t('Basic page %title has been updated.', array('%title' => $node_translation_title)), 'Translated node updated.');
 
     // Confirm that disabled languages are an option for translators when
     // creating nodes.
     $this->drupalGet('node/add/page');
-    $this->assertFieldByXPath('//select[@name="language"]//option', 'it', t('Italian (disabled) is available in language selection.'));
+    $this->assertFieldByXPath('//select[@name="language"]//option', 'it', 'Italian (disabled) is available in language selection.');
     $translation_it = $this->createTranslation($node, $this->randomName(), $this->randomName(), 'it');
-    $this->assertRaw($translation_it->body[LANGUAGE_NONE][0]['value'], t('Content created in Italian (disabled).'));
+    $this->assertRaw($translation_it->body[LANGUAGE_NONE][0]['value'], 'Content created in Italian (disabled).');
 
     // Confirm that language neutral is an option for translators when there are
     // disabled languages.
     $this->drupalGet('node/add/page');
-    $this->assertFieldByXPath('//select[@name="language"]//option', LANGUAGE_NONE, t('Language neutral is available in language selection with disabled languages.'));
+    $this->assertFieldByXPath('//select[@name="language"]//option', LANGUAGE_NONE, 'Language neutral is available in language selection with disabled languages.');
     $node2 = $this->createPage($this->randomName(), $this->randomName(), LANGUAGE_NONE);
-    $this->assertRaw($node2->body[LANGUAGE_NONE][0]['value'], t('Language neutral content created with disabled languages available.'));
+    $this->assertRaw($node2->body[LANGUAGE_NONE][0]['value'], 'Language neutral content created with disabled languages available.');
 
     // Leave just one language enabled and check that the translation overview
     // page is still accessible.
@@ -149,7 +149,7 @@ class TranslationTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/config/regional/language', $edit, t('Save configuration'));
     $this->drupalLogin($this->translator);
     $this->drupalGet('node/' . $node->nid . '/translate');
-    $this->assertRaw(t('Translations of %title', array('%title' => $node->title)), t('Translation overview page available with only one language enabled.'));
+    $this->assertRaw(t('Translations of %title', array('%title' => $node->title)), 'Translation overview page available with only one language enabled.');
   }
 
   /**
@@ -294,10 +294,10 @@ class TranslationTestCase extends DrupalWebTestCase {
       // Make sure we are not using a stale list.
       drupal_static_reset('language_list');
       $languages = language_list('language');
-      $this->assertTrue(array_key_exists($language_code, $languages), t('Language was installed successfully.'));
+      $this->assertTrue(array_key_exists($language_code, $languages), 'Language was installed successfully.');
 
       if (array_key_exists($language_code, $languages)) {
-        $this->assertRaw(t('The language %language has been created and can now be used. More information is available on the <a href="@locale-help">help screen</a>.', array('%language' => $languages[$language_code]->name, '@locale-help' => url('admin/help/locale'))), t('Language has been created.'));
+        $this->assertRaw(t('The language %language has been created and can now be used. More information is available on the <a href="@locale-help">help screen</a>.', array('%language' => $languages[$language_code]->name, '@locale-help' => url('admin/help/locale'))), 'Language has been created.');
       }
     }
     elseif ($this->xpath('//input[@type="checkbox" and @name=:name and @checked="checked"]', array(':name' => 'enabled[' . $language_code . ']'))) {
@@ -308,7 +308,7 @@ class TranslationTestCase extends DrupalWebTestCase {
       // It's installed but not enabled. Enable it.
       $this->assertTrue(true, 'Language [' . $language_code . '] already installed.');
       $this->drupalPost(NULL, array('enabled[' . $language_code . ']' => TRUE), t('Save configuration'));
-      $this->assertRaw(t('Configuration saved.'), t('Language successfully enabled.'));
+      $this->assertRaw(t('Configuration saved.'), 'Language successfully enabled.');
     }
   }
 
@@ -334,11 +334,11 @@ class TranslationTestCase extends DrupalWebTestCase {
       $edit['language'] = $language;
     }
     $this->drupalPost('node/add/page', $edit, t('Save'));
-    $this->assertRaw(t('Basic page %title has been created.', array('%title' => $title)), t('Basic page created.'));
+    $this->assertRaw(t('Basic page %title has been created.', array('%title' => $title)), 'Basic page created.');
 
     // Check to make sure the node was created.
     $node = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($node, t('Node found in database.'));
+    $this->assertTrue($node, 'Node found in database.');
 
     return $node;
   }
@@ -370,12 +370,12 @@ class TranslationTestCase extends DrupalWebTestCase {
     $edit["title"] = $title;
     $edit[$body_key] = $body;
     $this->drupalPost(NULL, $edit, t('Save'));
-    $this->assertRaw(t('Basic page %title has been created.', array('%title' => $title)), t('Translation created.'));
+    $this->assertRaw(t('Basic page %title has been created.', array('%title' => $title)), 'Translation created.');
 
     // Check to make sure that translation was successful.
     $translation = $this->drupalGetNodeByTitle($title);
-    $this->assertTrue($translation, t('Node found in database.'));
-    $this->assertTrue($translation->tnid == $node->nid, t('Translation set id correctly stored.'));
+    $this->assertTrue($translation, 'Node found in database.');
+    $this->assertTrue($translation->tnid == $node->nid, 'Translation set id correctly stored.');
 
     return $translation;
   }
@@ -438,10 +438,10 @@ class TranslationTestCase extends DrupalWebTestCase {
     foreach ($types as $type) {
       $args = array('%translation_language' => $translation_language->native, '%page_language' => $page_language->native, '%type' => $type);
       if ($find) {
-        $message = t('[%page_language] Language switch item found for %translation_language language in the %type page area.', $args);
+        $message = format_string('[%page_language] Language switch item found for %translation_language language in the %type page area.', $args);
       }
       else {
-        $message = t('[%page_language] Language switch item not found for %translation_language language in the %type page area.', $args);
+        $message = format_string('[%page_language] Language switch item not found for %translation_language language in the %type page area.', $args);
       }
 
       if (!empty($translation->nid)) {
diff --git a/modules/trigger/trigger.test b/modules/trigger/trigger.test
index 829e189..72e0f72 100644
--- a/modules/trigger/trigger.test
+++ b/modules/trigger/trigger.test
@@ -114,10 +114,10 @@ class TriggerContentTestCase extends TriggerWebTestCase {
     // Assign an action to the node save/update trigger.
     $test_user = $this->drupalCreateUser(array('administer actions', 'administer nodes', 'create page content', 'access administration pages', 'access content overview'));
     $this->drupalLogin($test_user);
+    $nodes = array();
 
     for ($index = 0; $index < 3; $index++) {
-      $edit = array('title' => $this->randomName());
-      $this->drupalPost('node/add/page', $edit, t('Save'));
+      $nodes[] = $this->drupalCreateNode(array('type' => 'page'));
     }
 
     $action_id = 'trigger_test_generic_any_action';
@@ -127,8 +127,8 @@ class TriggerContentTestCase extends TriggerWebTestCase {
 
     $edit = array(
       'operation' => 'unpublish',
-      'nodes[1]' => TRUE,
-      'nodes[2]' => TRUE,
+      'nodes[' . $nodes[0]->nid . ']' => TRUE,
+      'nodes[' . $nodes[1]->nid . ']' => TRUE,
     );
     $this->drupalPost('admin/content', $edit, t('Update'));
     $count = variable_get('trigger_test_generic_any_action', 0);
diff --git a/modules/update/update.module b/modules/update/update.module
index 85c0968..d5728be 100644
--- a/modules/update/update.module
+++ b/modules/update/update.module
@@ -139,10 +139,10 @@ function update_init() {
       if (!empty($verbose)) {
         if (isset($status[$type]['severity'])) {
           if ($status[$type]['severity'] == REQUIREMENT_ERROR) {
-            drupal_set_message($status[$type]['description'], 'error');
+            drupal_set_message($status[$type]['description'], 'error', FALSE);
           }
           elseif ($status[$type]['severity'] == REQUIREMENT_WARNING) {
-            drupal_set_message($status[$type]['description'], 'warning');
+            drupal_set_message($status[$type]['description'], 'warning', FALSE);
           }
         }
       }
@@ -152,7 +152,7 @@ function update_init() {
         if (isset($status[$type])
             && isset($status[$type]['reason'])
             && $status[$type]['reason'] === UPDATE_NOT_SECURE) {
-          drupal_set_message($status[$type]['description'], 'error');
+          drupal_set_message($status[$type]['description'], 'error', FALSE);
         }
       }
     }
diff --git a/modules/update/update.test b/modules/update/update.test
index b29f6ac..9e04cda 100644
--- a/modules/update/update.test
+++ b/modules/update/update.test
@@ -51,7 +51,7 @@ class UpdateTestHelper extends DrupalWebTestCase {
    */
   protected function standardTests() {
     $this->assertRaw('<h3>' . t('Drupal core') . '</h3>');
-    $this->assertRaw(l(t('Drupal'), 'http://example.com/project/drupal'), t('Link to the Drupal project appears.'));
+    $this->assertRaw(l(t('Drupal'), 'http://example.com/project/drupal'), 'Link to the Drupal project appears.');
     $this->assertNoText(t('No available releases found'));
   }
 
@@ -98,9 +98,9 @@ class UpdateCoreTestCase extends UpdateTestHelper {
     $this->assertNoText(t('Up to date'));
     $this->assertText(t('Update available'));
     $this->assertNoText(t('Security update required!'));
-    $this->assertRaw(l('7.1', 'http://example.com/drupal-7-1-release'), t('Link to release appears.'));
-    $this->assertRaw(l(t('Download'), 'http://example.com/drupal-7-1.tar.gz'), t('Link to download appears.'));
-    $this->assertRaw(l(t('Release notes'), 'http://example.com/drupal-7-1-release'), t('Link to release notes appears.'));
+    $this->assertRaw(l('7.1', 'http://example.com/drupal-7-1-release'), 'Link to release appears.');
+    $this->assertRaw(l(t('Download'), 'http://example.com/drupal-7-1.tar.gz'), 'Link to download appears.');
+    $this->assertRaw(l(t('Release notes'), 'http://example.com/drupal-7-1-release'), 'Link to release notes appears.');
   }
 
   /**
@@ -113,9 +113,9 @@ class UpdateCoreTestCase extends UpdateTestHelper {
     $this->assertNoText(t('Up to date'));
     $this->assertNoText(t('Update available'));
     $this->assertText(t('Security update required!'));
-    $this->assertRaw(l('7.2', 'http://example.com/drupal-7-2-release'), t('Link to release appears.'));
-    $this->assertRaw(l(t('Download'), 'http://example.com/drupal-7-2.tar.gz'), t('Link to download appears.'));
-    $this->assertRaw(l(t('Release notes'), 'http://example.com/drupal-7-2-release'), t('Link to release notes appears.'));
+    $this->assertRaw(l('7.2', 'http://example.com/drupal-7-2-release'), 'Link to release appears.');
+    $this->assertRaw(l(t('Download'), 'http://example.com/drupal-7-2.tar.gz'), 'Link to download appears.');
+    $this->assertRaw(l(t('Release notes'), 'http://example.com/drupal-7-2-release'), 'Link to release notes appears.');
   }
 
   /**
@@ -346,7 +346,7 @@ class UpdateTestContribCase extends UpdateTestHelper {
     $this->assertText(t('Up to date'));
     $this->assertRaw('<h3>' . t('Modules') . '</h3>');
     $this->assertNoText(t('Update available'));
-    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), t('Link to aaa_update_test project appears.'));
+    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), 'Link to aaa_update_test project appears.');
   }
 
   /**
@@ -407,10 +407,10 @@ class UpdateTestContribCase extends UpdateTestHelper {
     $this->assertText(t('CCC Update test'));
     // We want aaa_update_test included in the ccc_update_test project, not as
     // its own project on the report.
-    $this->assertNoRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), t('Link to aaa_update_test project does not appear.'));
+    $this->assertNoRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), 'Link to aaa_update_test project does not appear.');
     // The other two should be listed as projects.
-    $this->assertRaw(l(t('BBB Update test'), 'http://example.com/project/bbb_update_test'), t('Link to bbb_update_test project appears.'));
-    $this->assertRaw(l(t('CCC Update test'), 'http://example.com/project/ccc_update_test'), t('Link to bbb_update_test project appears.'));
+    $this->assertRaw(l(t('BBB Update test'), 'http://example.com/project/bbb_update_test'), 'Link to bbb_update_test project appears.');
+    $this->assertRaw(l(t('CCC Update test'), 'http://example.com/project/ccc_update_test'), 'Link to bbb_update_test project appears.');
 
     // We want to make sure we see the BBB project before the CCC project.
     // Instead of just searching for 'BBB Update test' or something, we want
@@ -459,7 +459,7 @@ class UpdateTestContribCase extends UpdateTestHelper {
     );
     $this->refreshUpdateStatus($xml_mapping);
     $this->assertText(t('Security update required!'));
-    $this->assertRaw(l(t('Update test base theme'), 'http://example.com/project/update_test_basetheme'), t('Link to the Update test base theme project appears.'));
+    $this->assertRaw(l(t('Update test base theme'), 'http://example.com/project/update_test_basetheme'), 'Link to the Update test base theme project appears.');
   }
 
   /**
@@ -512,13 +512,13 @@ class UpdateTestContribCase extends UpdateTestHelper {
       $this->assertNoText(t('Themes'));
       if ($check_disabled) {
         $this->assertText(t('Disabled themes'));
-        $this->assertRaw($base_theme_project_link, t('Link to the Update test base theme project appears.'));
-        $this->assertRaw($sub_theme_project_link, t('Link to the Update test subtheme project appears.'));
+        $this->assertRaw($base_theme_project_link, 'Link to the Update test base theme project appears.');
+        $this->assertRaw($sub_theme_project_link, 'Link to the Update test subtheme project appears.');
       }
       else {
         $this->assertNoText(t('Disabled themes'));
-        $this->assertNoRaw($base_theme_project_link, t('Link to the Update test base theme project does not appear.'));
-        $this->assertNoRaw($sub_theme_project_link, t('Link to the Update test subtheme project does not appear.'));
+        $this->assertNoRaw($base_theme_project_link, 'Link to the Update test base theme project does not appear.');
+        $this->assertNoRaw($sub_theme_project_link, 'Link to the Update test subtheme project does not appear.');
       }
     }
   }
@@ -574,9 +574,9 @@ class UpdateTestContribCase extends UpdateTestHelper {
     $this->assertUniqueText(t('Failed to get available update data for one project.'));
 
     // The other two should be listed as projects.
-    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), t('Link to aaa_update_test project appears.'));
-    $this->assertNoRaw(l(t('BBB Update test'), 'http://example.com/project/bbb_update_test'), t('Link to bbb_update_test project does not appear.'));
-    $this->assertRaw(l(t('CCC Update test'), 'http://example.com/project/ccc_update_test'), t('Link to bbb_update_test project appears.'));
+    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), 'Link to aaa_update_test project appears.');
+    $this->assertNoRaw(l(t('BBB Update test'), 'http://example.com/project/bbb_update_test'), 'Link to bbb_update_test project does not appear.');
+    $this->assertRaw(l(t('CCC Update test'), 'http://example.com/project/ccc_update_test'), 'Link to bbb_update_test project appears.');
   }
 
   /**
@@ -618,7 +618,7 @@ class UpdateTestContribCase extends UpdateTestHelper {
     $this->drupalGet('admin/reports/updates');
     $this->assertRaw('<h3>' . t('Modules') . '</h3>');
     $this->assertText(t('Security update required!'));
-    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), t('Link to aaa_update_test project appears.'));
+    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), 'Link to aaa_update_test project appears.');
 
     // Visit the reports page again without the altering and make sure the
     // status is back to normal.
@@ -626,7 +626,7 @@ class UpdateTestContribCase extends UpdateTestHelper {
     $this->drupalGet('admin/reports/updates');
     $this->assertRaw('<h3>' . t('Modules') . '</h3>');
     $this->assertNoText(t('Security update required!'));
-    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), t('Link to aaa_update_test project appears.'));
+    $this->assertRaw(l(t('AAA Update test'), 'http://example.com/project/aaa_update_test'), 'Link to aaa_update_test project appears.');
 
     // Turn the altering back on and visit the Update manager UI.
     variable_set('update_test_update_status', $update_status);
@@ -695,9 +695,9 @@ class UpdateTestUploadCase extends UpdateTestHelper {
   function testFileNameExtensionMerging() {
     $this->drupalGet('admin/modules/install');
     // Make sure the bogus extension supported by update_test.module is there.
-    $this->assertPattern('/file extensions are supported:.*update-test-extension/', t("Found 'update-test-extension' extension"));
+    $this->assertPattern('/file extensions are supported:.*update-test-extension/', "Found 'update-test-extension' extension");
     // Make sure it didn't clobber the first option from core.
-    $this->assertPattern('/file extensions are supported:.*tar/', t("Found 'tar' extension"));
+    $this->assertPattern('/file extensions are supported:.*tar/', "Found 'tar' extension");
   }
 
   /**
diff --git a/modules/user/user.admin.inc b/modules/user/user.admin.inc
index 1cc2c4a..6ca330b 100644
--- a/modules/user/user.admin.inc
+++ b/modules/user/user.admin.inc
@@ -5,6 +5,21 @@
  * Admin page callback file for the user module.
  */
 
+/**
+ * Page callback: Generates the appropriate user administration form.
+ *
+ * This function generates the user registration, multiple user cancellation,
+ * or filtered user list admin form, depending on the argument and the POST
+ * form values.
+ *
+ * @param string $callback_arg
+ *   (optional) Indicates which form to build. Defaults to '', which will
+ *   trigger the user filter form. If the POST value 'op' is present, this
+ *   function uses that value as the callback argument.
+ *
+ * @return string
+ *   A renderable form array for the respective request.
+ */
 function user_admin($callback_arg = '') {
   $op = isset($_POST['op']) ? $_POST['op'] : $callback_arg;
 
@@ -391,7 +406,7 @@ function user_admin_settings() {
     $form['personalization']['pictures']['settings']['user_picture_style'] = array(
       '#type' => 'select',
       '#title' => t('Picture display style'),
-      '#options' => image_style_options(TRUE),
+      '#options' => image_style_options(TRUE, PASS_THROUGH),
       '#default_value' => variable_get('user_picture_style', ''),
       '#description' => t('The style selected will be used on display, while the original image is retained. Styles may be configured in the <a href="!url">Image styles</a> administration area.', array('!url' => url('admin/config/media/image-styles'))),
     );
diff --git a/modules/user/user.api.php b/modules/user/user.api.php
index 64c863f..3afc88a 100644
--- a/modules/user/user.api.php
+++ b/modules/user/user.api.php
@@ -214,9 +214,11 @@ function hook_user_categories() {
  * to have their data serialized on save.
  *
  * @param $edit
- *   The array of form values submitted by the user.
+ *   The array of form values submitted by the user. Assign values to this
+ *   array to save changes in the database.
  * @param $account
- *   The user object on which the operation is performed.
+ *   The user object on which the operation is performed. Values assigned in
+ *   this object will not be saved in the database.
  * @param $category
  *   The active category of user information being edited.
  *
diff --git a/modules/user/user.install b/modules/user/user.install
index cff873a..4e1a3c2 100644
--- a/modules/user/user.install
+++ b/modules/user/user.install
@@ -535,7 +535,7 @@ function user_update_7002(&$sandbox) {
     if ($sandbox['user_from'] == $sandbox['user_count']) {
       if ($sandbox['user_not_migrated'] > 0) {
         variable_set('empty_timezone_message', 1);
-        drupal_set_message('Some user time zones have been emptied and need to be set to the correct values. Use the new ' . l('time zone options', 'admin/config/regional/settings') . ' to choose whether to remind users at login to set the correct time zone.', 'warning');
+        drupal_set_message(format_string('Some user time zones have been emptied and need to be set to the correct values. Use the new <a href="@config-url">time zone options</a> to choose whether to remind users at login to set the correct time zone.', array('@config-url' => url('admin/config/regional/settings'))), 'warning');
       }
       return t('Migrated user time zones');
     }
diff --git a/modules/user/user.module b/modules/user/user.module
index 622fe4d..5124207 100644
--- a/modules/user/user.module
+++ b/modules/user/user.module
@@ -187,7 +187,7 @@ function user_entity_info() {
 }
 
 /**
- * Entity URI callback.
+ * Implements callback_entity_info_uri().
  */
 function user_uri($user) {
   return array(
@@ -321,7 +321,7 @@ class UserController extends DrupalDefaultEntityController {
     }
 
     // Add the full file objects for user pictures if enabled.
-    if (!empty($picture_fids) && variable_get('user_pictures', 1) == 1) {
+    if (!empty($picture_fids) && variable_get('user_pictures', 0)) {
       $pictures = file_load_multiple($picture_fids);
       foreach ($queried_users as $account) {
         if (!empty($account->picture) && isset($pictures[$account->picture])) {
@@ -1083,6 +1083,9 @@ function user_account_form(&$form, &$form_state) {
         '#access' => !empty($protected_values),
         '#description' => $current_pass_description,
         '#weight' => -5,
+        // Do not let web browsers remember this password, since we are trying
+        // to confirm that the person submitting the form actually knows the
+        // current one.
         '#attributes' => array('autocomplete' => 'off'),
       );
       $form['#validate'][] = 'user_validate_current_pass';
@@ -1517,15 +1520,33 @@ function theme_user_list($variables) {
   return theme('item_list', array('items' => $items, 'title' => $title));
 }
 
+/**
+ * Determines if the current user is anonymous.
+ *
+ * @return bool
+ *   TRUE if the user is anonymous, FALSE if the user is authenticated.
+ */
 function user_is_anonymous() {
   // Menu administrators can see items for anonymous when administering.
   return !$GLOBALS['user']->uid || !empty($GLOBALS['menu_admin']);
 }
 
+/**
+ * Determines if the current user is logged in.
+ *
+ * @return bool
+ *   TRUE if the user is logged in, FALSE if the user is anonymous.
+ */
 function user_is_logged_in() {
   return (bool) $GLOBALS['user']->uid;
 }
 
+/**
+ * Determines if the current user has access to the user registration page.
+ *
+ * @return bool
+ *   TRUE if the user is not already logged in and can register for an account.
+ */
 function user_register_access() {
   return user_is_anonymous() && variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL);
 }
@@ -2174,7 +2195,7 @@ function user_login_final_validate($form, &$form_state) {
       }
     }
     else {
-      form_set_error('name', t('Sorry, unrecognized username or password. <a href="@password">Have you forgotten your password?</a>', array('@password' => url('user/password'))));
+      form_set_error('name', t('Sorry, unrecognized username or password. <a href="@password">Have you forgotten your password?</a>', array('@password' => url('user/password', array('query' => array('name' => $form_state['values']['name']))))));
       watchdog('user', 'Login attempt failed for %user.', array('%user' => $form_state['values']['name']));
     }
   }
@@ -2220,7 +2241,12 @@ function user_authenticate($name, $password) {
  * Finalize the login process. Must be called when logging in a user.
  *
  * The function records a watchdog message about the new session, saves the
- * login timestamp, calls hook_user op 'login' and generates a new session. *
+ * login timestamp, calls hook_user_login(), and generates a new session.
+ *
+ * @param array $edit
+ *   The array of form values submitted by the user.
+ *
+ * @see hook_user_login()
  */
 function user_login_finalize(&$edit = array()) {
   global $user;
@@ -2393,6 +2419,14 @@ function user_cancel($edit, $uid, $method) {
       array('_user_cancel', array($edit, $account, $method)),
     ),
   );
+
+  // After cancelling account, ensure that user is logged out.
+  if ($account->uid == $user->uid) {
+    // Batch API stores data in the session, so use the finished operation to
+    // manipulate the current user's session id.
+    $batch['finished'] = '_user_cancel_session_regenerate';
+  }
+
   batch_set($batch);
 
   // Batch processing is either handled via Form API or has to be invoked
@@ -2435,10 +2469,12 @@ function _user_cancel($edit, $account, $method) {
       break;
   }
 
-  // After cancelling account, ensure that user is logged out.
+  // After cancelling account, ensure that user is logged out. We can't destroy
+  // their session though, as we might have information in it, and we can't
+  // regenerate it because batch API uses the session ID, we will regenerate it
+  // in _user_cancel_session_regenerate().
   if ($account->uid == $user->uid) {
-    // Destroy the current session, and reset $user to the anonymous user.
-    session_destroy();
+    $user = drupal_anonymous_user();
   }
 
   // Clear the cache for anonymous users.
@@ -2446,6 +2482,17 @@ function _user_cancel($edit, $account, $method) {
 }
 
 /**
+ * Finished batch processing callback for cancelling a user account.
+ *
+ * @see user_cancel()
+ */
+function _user_cancel_session_regenerate() {
+  // Regenerate the users session instead of calling session_destroy() as we
+  // want to preserve any messages that might have been set.
+  drupal_session_regenerate();
+}
+
+/**
  * Delete a user.
  *
  * @param $uid
@@ -3353,7 +3400,7 @@ function user_filters() {
   $options = array();
   foreach (module_implements('permission') as $module) {
     $function = $module . '_permission';
-    if ($permissions = $function('permission')) {
+    if ($permissions = $function()) {
       asort($permissions);
       foreach ($permissions as $permission => $description) {
         $options[t('@module module', array('@module' => $module))][$permission] = t($permission);
@@ -3654,7 +3701,7 @@ function user_block_user_action(&$entity, $context = array()) {
 function user_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
   $instance = $form['#instance'];
 
-  if ($instance['entity_type'] == 'user') {
+  if ($instance['entity_type'] == 'user' && !$form['#field']['locked']) {
     $form['instance']['settings']['user_register_form'] = array(
       '#type' => 'checkbox',
       '#title' => t('Display on user registration form.'),
diff --git a/modules/user/user.pages.inc b/modules/user/user.pages.inc
index c4b68b9..4cdbc40 100644
--- a/modules/user/user.pages.inc
+++ b/modules/user/user.pages.inc
@@ -36,6 +36,7 @@ function user_pass() {
     '#size' => 60,
     '#maxlength' => max(USERNAME_MAX_LENGTH, EMAIL_MAX_LENGTH),
     '#required' => TRUE,
+    '#default_value' => isset($_GET['name']) ? $_GET['name'] : '',
   );
   // Allow logged in users to request this also.
   if ($user->uid > 0) {
@@ -128,12 +129,12 @@ function user_pass_reset($form, &$form_state, $uid, $timestamp, $hashed_pass, $a
       elseif ($account->uid && $timestamp >= $account->login && $timestamp <= $current && $hashed_pass == user_pass_rehash($account->pass, $timestamp, $account->login)) {
         // First stage is a confirmation form, then login
         if ($action == 'login') {
-          watchdog('user', 'User %name used one-time login link at time %timestamp.', array('%name' => $account->name, '%timestamp' => $timestamp));
           // Set the new user.
           $user = $account;
           // user_login_finalize() also updates the login timestamp of the
           // user, which invalidates further use of the one-time login link.
           user_login_finalize();
+          watchdog('user', 'User %name used one-time login link at time %timestamp.', array('%name' => $account->name, '%timestamp' => $timestamp));
           drupal_set_message(t('You have just used your one-time login link. It is no longer necessary to use this link to log in. Please change your password.'));
           // Let the user's password be changed without the current password check.
           $token = drupal_hash_base64(drupal_random_bytes(55));
diff --git a/modules/user/user.test b/modules/user/user.test
index 26e93ed..e2086d4 100644
--- a/modules/user/user.test
+++ b/modules/user/user.test
@@ -25,7 +25,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     // Set registration to administrator only.
     variable_set('user_register', USER_REGISTER_ADMINISTRATORS_ONLY);
     $this->drupalGet('user/register');
-    $this->assertResponse(403, t('Registration page is inaccessible when only administrators can create accounts.'));
+    $this->assertResponse(403, 'Registration page is inaccessible when only administrators can create accounts.');
 
     // Allow registration by site visitors without administrator approval.
     variable_set('user_register', USER_REGISTER_VISITORS);
@@ -33,10 +33,10 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     $edit['name'] = $name = $this->randomName();
     $edit['mail'] = $mail = $edit['name'] . '@example.com';
     $this->drupalPost('user/register', $edit, t('Create new account'));
-    $this->assertText(t('A welcome message with further instructions has been sent to your e-mail address.'), t('User registered successfully.'));
+    $this->assertText(t('A welcome message with further instructions has been sent to your e-mail address.'), 'User registered successfully.');
     $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
     $new_user = reset($accounts);
-    $this->assertTrue($new_user->status, t('New account is active after registration.'));
+    $this->assertTrue($new_user->status, 'New account is active after registration.');
 
     // Allow registration by site visitors, but require administrator approval.
     variable_set('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL);
@@ -46,7 +46,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     $this->drupalPost('user/register', $edit, t('Create new account'));
     $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
     $new_user = reset($accounts);
-    $this->assertFalse($new_user->status, t('New account is blocked until approved by an administrator.'));
+    $this->assertFalse($new_user->status, 'New account is blocked until approved by an administrator.');
   }
 
   function testRegistrationWithoutEmailVerification() {
@@ -63,7 +63,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     $edit['pass[pass1]'] = '99999.0';
     $edit['pass[pass2]'] = '99999';
     $this->drupalPost('user/register', $edit, t('Create new account'));
-    $this->assertText(t('The specified passwords do not match.'), t('Typing mismatched passwords displays an error message.'));
+    $this->assertText(t('The specified passwords do not match.'), 'Typing mismatched passwords displays an error message.');
 
     // Enter a correct password.
     $edit['pass[pass1]'] = $new_pass = $this->randomName();
@@ -71,7 +71,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     $this->drupalPost('user/register', $edit, t('Create new account'));
     $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
     $new_user = reset($accounts);
-    $this->assertText(t('Registration successful. You are now logged in.'), t('Users are logged in after registering.'));
+    $this->assertText(t('Registration successful. You are now logged in.'), 'Users are logged in after registering.');
     $this->drupalLogout();
 
     // Allow registration by site visitors, but require administrator approval.
@@ -82,7 +82,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     $edit['pass[pass1]'] = $pass = $this->randomName();
     $edit['pass[pass2]'] = $pass;
     $this->drupalPost('user/register', $edit, t('Create new account'));
-    $this->assertText(t('Thank you for applying for an account. Your account is currently pending approval by the site administrator.'), t('Users are notified of pending approval'));
+    $this->assertText(t('Thank you for applying for an account. Your account is currently pending approval by the site administrator.'), 'Users are notified of pending approval');
 
     // Try to login before administrator approval.
     $auth = array(
@@ -90,7 +90,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
       'pass' => $pass,
     );
     $this->drupalPost('user/login', $auth, t('Log in'));
-    $this->assertText(t('The username @name has not been activated or is blocked.', array('@name' => $name)), t('User cannot login yet.'));
+    $this->assertText(t('The username @name has not been activated or is blocked.', array('@name' => $name)), 'User cannot login yet.');
 
     // Activate the new account.
     $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
@@ -105,7 +105,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
 
     // Login after administrator approval.
     $this->drupalPost('user/login', $auth, t('Log in'));
-    $this->assertText(t('Member for'), t('User can log in after administrator approval.'));
+    $this->assertText(t('Member for'), 'User can log in after administrator approval.');
   }
 
   function testRegistrationEmailDuplicates() {
@@ -124,13 +124,13 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
 
     // Attempt to create a new account using an existing e-mail address.
     $this->drupalPost('user/register', $edit, t('Create new account'));
-    $this->assertText(t('The e-mail address @email is already registered.', array('@email' => $duplicate_user->mail)), t('Supplying an exact duplicate email address displays an error message'));
+    $this->assertText(t('The e-mail address @email is already registered.', array('@email' => $duplicate_user->mail)), 'Supplying an exact duplicate email address displays an error message');
 
     // Attempt to bypass duplicate email registration validation by adding spaces.
     $edit['mail'] = '   ' . $duplicate_user->mail . '   ';
 
     $this->drupalPost('user/register', $edit, t('Create new account'));
-    $this->assertText(t('The e-mail address @email is already registered.', array('@email' => $duplicate_user->mail)), t('Supplying a duplicate email address with added whitespace displays an error message'));
+    $this->assertText(t('The e-mail address @email is already registered.', array('@email' => $duplicate_user->mail)), 'Supplying a duplicate email address with added whitespace displays an error message');
   }
 
   function testRegistrationDefaultValues() {
@@ -147,7 +147,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     // Check that the account information fieldset's options are not displayed
     // is a fieldset if there is not more than one fieldset in the form.
     $this->drupalGet('user/register');
-    $this->assertNoRaw('<fieldset id="edit-account"><legend>Account information</legend>', t('Account settings fieldset was hidden.'));
+    $this->assertNoRaw('<fieldset id="edit-account"><legend>Account information</legend>', 'Account settings fieldset was hidden.');
 
     $edit = array();
     $edit['name'] = $name = $this->randomName();
@@ -159,16 +159,16 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     // Check user fields.
     $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
     $new_user = reset($accounts);
-    $this->assertEqual($new_user->name, $name, t('Username matches.'));
-    $this->assertEqual($new_user->mail, $mail, t('E-mail address matches.'));
-    $this->assertEqual($new_user->theme, '', t('Correct theme field.'));
-    $this->assertEqual($new_user->signature, '', t('Correct signature field.'));
-    $this->assertTrue(($new_user->created > REQUEST_TIME - 20 ), t('Correct creation time.'));
-    $this->assertEqual($new_user->status, variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL) == USER_REGISTER_VISITORS ? 1 : 0, t('Correct status field.'));
-    $this->assertEqual($new_user->timezone, variable_get('date_default_timezone'), t('Correct time zone field.'));
-    $this->assertEqual($new_user->language, '', t('Correct language field.'));
-    $this->assertEqual($new_user->picture, '', t('Correct picture field.'));
-    $this->assertEqual($new_user->init, $mail, t('Correct init field.'));
+    $this->assertEqual($new_user->name, $name, 'Username matches.');
+    $this->assertEqual($new_user->mail, $mail, 'E-mail address matches.');
+    $this->assertEqual($new_user->theme, '', 'Correct theme field.');
+    $this->assertEqual($new_user->signature, '', 'Correct signature field.');
+    $this->assertTrue(($new_user->created > REQUEST_TIME - 20 ), 'Correct creation time.');
+    $this->assertEqual($new_user->status, variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL) == USER_REGISTER_VISITORS ? 1 : 0, 'Correct status field.');
+    $this->assertEqual($new_user->timezone, variable_get('date_default_timezone'), 'Correct time zone field.');
+    $this->assertEqual($new_user->language, '', 'Correct language field.');
+    $this->assertEqual($new_user->picture, '', 'Correct picture field.');
+    $this->assertEqual($new_user->init, $mail, 'Correct init field.');
   }
 
   /**
@@ -194,13 +194,13 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
 
     // Check that the field does not appear on the registration form.
     $this->drupalGet('user/register');
-    $this->assertNoText($instance['label'], t('The field does not appear on user registration form'));
+    $this->assertNoText($instance['label'], 'The field does not appear on user registration form');
 
     // Have the field appear on the registration form.
     $instance['settings']['user_register_form'] = TRUE;
     field_update_instance($instance);
     $this->drupalGet('user/register');
-    $this->assertText($instance['label'], t('The field appears on user registration form'));
+    $this->assertText($instance['label'], 'The field appears on user registration form');
 
     // Check that validation errors are correctly reported.
     $edit = array();
@@ -209,11 +209,11 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     // Missing input in required field.
     $edit['test_user_field[und][0][value]'] = '';
     $this->drupalPost(NULL, $edit, t('Create new account'));
-    $this->assertRaw(t('@name field is required.', array('@name' => $instance['label'])), t('Field validation error was correctly reported.'));
+    $this->assertRaw(t('@name field is required.', array('@name' => $instance['label'])), 'Field validation error was correctly reported.');
     // Invalid input.
     $edit['test_user_field[und][0][value]'] = '-1';
     $this->drupalPost(NULL, $edit, t('Create new account'));
-    $this->assertRaw(t('%name does not accept the value -1.', array('%name' => $instance['label'])), t('Field validation error was correctly reported.'));
+    $this->assertRaw(t('%name does not accept the value -1.', array('%name' => $instance['label'])), 'Field validation error was correctly reported.');
 
     // Submit with valid data.
     $value = rand(1, 255);
@@ -222,7 +222,7 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
     // Check user fields.
     $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
     $new_user = reset($accounts);
-    $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][0]['value'], $value, t('The field value was correclty saved.'));
+    $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][0]['value'], $value, 'The field value was correctly saved.');
 
     // Check that the 'add more' button works.
     $field['cardinality'] = FIELD_CARDINALITY_UNLIMITED;
@@ -250,9 +250,9 @@ class UserRegistrationTestCase extends DrupalWebTestCase {
       // Check user fields.
       $accounts = user_load_multiple(array(), array('name' => $name, 'mail' => $mail));
       $new_user = reset($accounts);
-      $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][0]['value'], $value, t('@js : The field value was correclty saved.', array('@js' => $js)));
-      $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][1]['value'], $value + 1, t('@js : The field value was correclty saved.', array('@js' => $js)));
-      $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][2]['value'], $value + 2, t('@js : The field value was correclty saved.', array('@js' => $js)));
+      $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][0]['value'], $value, format_string('@js : The field value was correclty saved.', array('@js' => $js)));
+      $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][1]['value'], $value + 1, format_string('@js : The field value was correclty saved.', array('@js' => $js)));
+      $this->assertEqual($new_user->test_user_field[LANGUAGE_NONE][2]['value'], $value + 2, format_string('@js : The field value was correclty saved.', array('@js' => $js)));
     }
   }
 }
@@ -435,7 +435,7 @@ class UserLoginTestCase extends DrupalWebTestCase {
       'pass' => $account->pass_raw,
     );
     $this->drupalPost('user', $edit, t('Log in'));
-    $this->assertNoFieldByXPath("//input[@name='pass' and @value!='']", NULL, t('Password value attribute is blank.'));
+    $this->assertNoFieldByXPath("//input[@name='pass' and @value!='']", NULL, 'Password value attribute is blank.');
     if (isset($flood_trigger)) {
       if ($flood_trigger == 'user') {
         $this->assertRaw(format_plural(variable_get('user_failed_login_user_limit', 5), 'Sorry, there has been more than one failed login attempt for this account. It is temporarily blocked. Try again later or <a href="@url">request a new password</a>.', 'Sorry, there have been more than @count failed login attempts for this account. It is temporarily blocked. Try again later or <a href="@url">request a new password</a>.', array('@url' => url('user/password'))));
@@ -501,6 +501,24 @@ class UserPasswordResetTestCase extends DrupalWebTestCase {
     $this->drupalGet("user/reset/$account->uid/$bogus_timestamp/" . user_pass_rehash($account->pass, $bogus_timestamp, $account->login));
     $this->assertText(t('You have tried to use a one-time login link that has expired. Please request a new one using the form below.'), 'Expired password reset request rejected.');
   }
+
+  /**
+   * Prefill the text box on incorrect login via link to password reset page.
+   */
+  function testUserPasswordTextboxFilled() {
+    $this->drupalGet('user/login');
+    $edit = array(
+      'name' => $this->randomName(),
+      'pass' => $this->randomName(),
+    );
+    $this->drupalPost('user', $edit, t('Log in'));
+    $this->assertRaw(t('Sorry, unrecognized username or password. <a href="@password">Have you forgotten your password?</a>',
+      array('@password' => url('user/password', array('query' => array('name' => $edit['name']))))));
+    unset($edit['pass']);
+    $this->drupalGet('user/password', array('query' => array('name' => $edit['name'])));
+    $this->assertFieldByName('name', $edit['name'], 'User name found.');
+  }
+
 }
 
 /**
@@ -536,18 +554,18 @@ class UserCancelTestCase extends DrupalWebTestCase {
 
     // Attempt to cancel account.
     $this->drupalGet('user/' . $account->uid . '/edit');
-    $this->assertNoRaw(t('Cancel account'), t('No cancel account button displayed.'));
+    $this->assertNoRaw(t('Cancel account'), 'No cancel account button displayed.');
 
     // Attempt bogus account cancellation request confirmation.
     $timestamp = $account->login;
     $this->drupalGet("user/$account->uid/cancel/confirm/$timestamp/" . user_pass_rehash($account->pass, $timestamp, $account->login));
-    $this->assertResponse(403, t('Bogus cancelling request rejected.'));
+    $this->assertResponse(403, 'Bogus cancelling request rejected.');
     $account = user_load($account->uid);
-    $this->assertTrue($account->status == 1, t('User account was not canceled.'));
+    $this->assertTrue($account->status == 1, 'User account was not canceled.');
 
     // Confirm user's content has not been altered.
     $test_node = node_load($node->nid, NULL, TRUE);
-    $this->assertTrue(($test_node->uid == $account->uid && $test_node->status == 1), t('Node of the user has not been altered.'));
+    $this->assertTrue(($test_node->uid == $account->uid && $test_node->status == 1), 'Node of the user has not been altered.');
   }
 
   /**
@@ -585,7 +603,7 @@ class UserCancelTestCase extends DrupalWebTestCase {
 
     // Verify that uid 1's account was not cancelled.
     $user1 = user_load(1, TRUE);
-    $this->assertEqual($user1->status, 1, t('User #1 still exists and is not blocked.'));
+    $this->assertEqual($user1->status, 1, 'User #1 still exists and is not blocked.');
   }
 
   /**
@@ -609,25 +627,25 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Confirm account cancellation.
     $timestamp = time();
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), t('Account cancellation request mailed message displayed.'));
+    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), 'Account cancellation request mailed message displayed.');
 
     // Attempt bogus account cancellation request confirmation.
     $bogus_timestamp = $timestamp + 60;
     $this->drupalGet("user/$account->uid/cancel/confirm/$bogus_timestamp/" . user_pass_rehash($account->pass, $bogus_timestamp, $account->login));
-    $this->assertText(t('You have tried to use an account cancellation link that has expired. Please request a new one using the form below.'), t('Bogus cancelling request rejected.'));
+    $this->assertText(t('You have tried to use an account cancellation link that has expired. Please request a new one using the form below.'), 'Bogus cancelling request rejected.');
     $account = user_load($account->uid);
-    $this->assertTrue($account->status == 1, t('User account was not canceled.'));
+    $this->assertTrue($account->status == 1, 'User account was not canceled.');
 
     // Attempt expired account cancellation request confirmation.
     $bogus_timestamp = $timestamp - 86400 - 60;
     $this->drupalGet("user/$account->uid/cancel/confirm/$bogus_timestamp/" . user_pass_rehash($account->pass, $bogus_timestamp, $account->login));
-    $this->assertText(t('You have tried to use an account cancellation link that has expired. Please request a new one using the form below.'), t('Expired cancel account request rejected.'));
+    $this->assertText(t('You have tried to use an account cancellation link that has expired. Please request a new one using the form below.'), 'Expired cancel account request rejected.');
     $accounts = user_load_multiple(array($account->uid), array('status' => 1));
-    $this->assertTrue(reset($accounts), t('User account was not canceled.'));
+    $this->assertTrue(reset($accounts), 'User account was not canceled.');
 
     // Confirm user's content has not been altered.
     $test_node = node_load($node->nid, NULL, TRUE);
-    $this->assertTrue(($test_node->uid == $account->uid && $test_node->status == 1), t('Node of the user has not been altered.'));
+    $this->assertTrue(($test_node->uid == $account->uid && $test_node->status == 1), 'Node of the user has not been altered.');
   }
 
   /**
@@ -646,23 +664,23 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Attempt to cancel account.
     $this->drupalGet('user/' . $account->uid . '/edit');
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('Are you sure you want to cancel your account?'), t('Confirmation form to cancel account displayed.'));
-    $this->assertText(t('Your account will be blocked and you will no longer be able to log in. All of your content will remain attributed to your user name.'), t('Informs that all content will be remain as is.'));
-    $this->assertNoText(t('Select the method to cancel the account above.'), t('Does not allow user to select account cancellation method.'));
+    $this->assertText(t('Are you sure you want to cancel your account?'), 'Confirmation form to cancel account displayed.');
+    $this->assertText(t('Your account will be blocked and you will no longer be able to log in. All of your content will remain attributed to your user name.'), 'Informs that all content will be remain as is.');
+    $this->assertNoText(t('Select the method to cancel the account above.'), 'Does not allow user to select account cancellation method.');
 
     // Confirm account cancellation.
     $timestamp = time();
 
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), t('Account cancellation request mailed message displayed.'));
+    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), 'Account cancellation request mailed message displayed.');
 
     // Confirm account cancellation request.
     $this->drupalGet("user/$account->uid/cancel/confirm/$timestamp/" . user_pass_rehash($account->pass, $timestamp, $account->login));
     $account = user_load($account->uid, TRUE);
-    $this->assertTrue($account->status == 0, t('User has been blocked.'));
+    $this->assertTrue($account->status == 0, 'User has been blocked.');
 
-    // Confirm user is logged out.
-    $this->assertNoText($account->name, t('Logged out.'));
+    // Confirm that the confirmation message made it through to the end user.
+    $this->assertRaw(t('%name has been disabled.', array('%name' => $account->name)), "Confirmation message displayed to user.");
   }
 
   /**
@@ -686,27 +704,27 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Attempt to cancel account.
     $this->drupalGet('user/' . $account->uid . '/edit');
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('Are you sure you want to cancel your account?'), t('Confirmation form to cancel account displayed.'));
-    $this->assertText(t('Your account will be blocked and you will no longer be able to log in. All of your content will be hidden from everyone but administrators.'), t('Informs that all content will be unpublished.'));
+    $this->assertText(t('Are you sure you want to cancel your account?'), 'Confirmation form to cancel account displayed.');
+    $this->assertText(t('Your account will be blocked and you will no longer be able to log in. All of your content will be hidden from everyone but administrators.'), 'Informs that all content will be unpublished.');
 
     // Confirm account cancellation.
     $timestamp = time();
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), t('Account cancellation request mailed message displayed.'));
+    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), 'Account cancellation request mailed message displayed.');
 
     // Confirm account cancellation request.
     $this->drupalGet("user/$account->uid/cancel/confirm/$timestamp/" . user_pass_rehash($account->pass, $timestamp, $account->login));
     $account = user_load($account->uid, TRUE);
-    $this->assertTrue($account->status == 0, t('User has been blocked.'));
+    $this->assertTrue($account->status == 0, 'User has been blocked.');
 
     // Confirm user's content has been unpublished.
     $test_node = node_load($node->nid, NULL, TRUE);
-    $this->assertTrue($test_node->status == 0, t('Node of the user has been unpublished.'));
+    $this->assertTrue($test_node->status == 0, 'Node of the user has been unpublished.');
     $test_node = node_load($node->nid, $node->vid, TRUE);
-    $this->assertTrue($test_node->status == 0, t('Node revision of the user has been unpublished.'));
+    $this->assertTrue($test_node->status == 0, 'Node revision of the user has been unpublished.');
 
-    // Confirm user is logged out.
-    $this->assertNoText($account->name, t('Logged out.'));
+    // Confirm that the confirmation message made it through to the end user.
+    $this->assertRaw(t('%name has been disabled.', array('%name' => $account->name)), "Confirmation message displayed to user.");
   }
 
   /**
@@ -736,28 +754,28 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Attempt to cancel account.
     $this->drupalGet('user/' . $account->uid . '/edit');
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('Are you sure you want to cancel your account?'), t('Confirmation form to cancel account displayed.'));
-    $this->assertRaw(t('Your account will be removed and all account information deleted. All of your content will be assigned to the %anonymous-name user.', array('%anonymous-name' => variable_get('anonymous', t('Anonymous')))), t('Informs that all content will be attributed to anonymous account.'));
+    $this->assertText(t('Are you sure you want to cancel your account?'), 'Confirmation form to cancel account displayed.');
+    $this->assertRaw(t('Your account will be removed and all account information deleted. All of your content will be assigned to the %anonymous-name user.', array('%anonymous-name' => variable_get('anonymous', t('Anonymous')))), 'Informs that all content will be attributed to anonymous account.');
 
     // Confirm account cancellation.
     $timestamp = time();
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), t('Account cancellation request mailed message displayed.'));
+    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), 'Account cancellation request mailed message displayed.');
 
     // Confirm account cancellation request.
     $this->drupalGet("user/$account->uid/cancel/confirm/$timestamp/" . user_pass_rehash($account->pass, $timestamp, $account->login));
-    $this->assertFalse(user_load($account->uid, TRUE), t('User is not found in the database.'));
+    $this->assertFalse(user_load($account->uid, TRUE), 'User is not found in the database.');
 
     // Confirm that user's content has been attributed to anonymous user.
     $test_node = node_load($node->nid, NULL, TRUE);
-    $this->assertTrue(($test_node->uid == 0 && $test_node->status == 1), t('Node of the user has been attributed to anonymous user.'));
+    $this->assertTrue(($test_node->uid == 0 && $test_node->status == 1), 'Node of the user has been attributed to anonymous user.');
     $test_node = node_load($revision_node->nid, $revision, TRUE);
-    $this->assertTrue(($test_node->revision_uid == 0 && $test_node->status == 1), t('Node revision of the user has been attributed to anonymous user.'));
+    $this->assertTrue(($test_node->revision_uid == 0 && $test_node->status == 1), 'Node revision of the user has been attributed to anonymous user.');
     $test_node = node_load($revision_node->nid, NULL, TRUE);
-    $this->assertTrue(($test_node->uid != 0 && $test_node->status == 1), t("Current revision of the user's node was not attributed to anonymous user."));
+    $this->assertTrue(($test_node->uid != 0 && $test_node->status == 1), "Current revision of the user's node was not attributed to anonymous user.");
 
-    // Confirm that user is logged out.
-    $this->assertNoText($account->name, t('Logged out.'));
+    // Confirm that the confirmation message made it through to the end user.
+    $this->assertRaw(t('%name has been deleted.', array('%name' => $account->name)), "Confirmation message displayed to user.");
   }
 
   /**
@@ -786,7 +804,7 @@ class UserCancelTestCase extends DrupalWebTestCase {
     $this->assertText(t('Your comment has been posted.'));
     $comments = comment_load_multiple(array(), array('subject' => $edit['subject']));
     $comment = reset($comments);
-    $this->assertTrue($comment->cid, t('Comment found.'));
+    $this->assertTrue($comment->cid, 'Comment found.');
 
     // Create a node with two revisions, the initial one belonging to the
     // cancelling user.
@@ -800,26 +818,26 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Attempt to cancel account.
     $this->drupalGet('user/' . $account->uid . '/edit');
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('Are you sure you want to cancel your account?'), t('Confirmation form to cancel account displayed.'));
-    $this->assertText(t('Your account will be removed and all account information deleted. All of your content will also be deleted.'), t('Informs that all content will be deleted.'));
+    $this->assertText(t('Are you sure you want to cancel your account?'), 'Confirmation form to cancel account displayed.');
+    $this->assertText(t('Your account will be removed and all account information deleted. All of your content will also be deleted.'), 'Informs that all content will be deleted.');
 
     // Confirm account cancellation.
     $timestamp = time();
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), t('Account cancellation request mailed message displayed.'));
+    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), 'Account cancellation request mailed message displayed.');
 
     // Confirm account cancellation request.
     $this->drupalGet("user/$account->uid/cancel/confirm/$timestamp/" . user_pass_rehash($account->pass, $timestamp, $account->login));
-    $this->assertFalse(user_load($account->uid, TRUE), t('User is not found in the database.'));
+    $this->assertFalse(user_load($account->uid, TRUE), 'User is not found in the database.');
 
     // Confirm that user's content has been deleted.
-    $this->assertFalse(node_load($node->nid, NULL, TRUE), t('Node of the user has been deleted.'));
-    $this->assertFalse(node_load($node->nid, $revision, TRUE), t('Node revision of the user has been deleted.'));
-    $this->assertTrue(node_load($revision_node->nid, NULL, TRUE), t("Current revision of the user's node was not deleted."));
-    $this->assertFalse(comment_load($comment->cid), t('Comment of the user has been deleted.'));
+    $this->assertFalse(node_load($node->nid, NULL, TRUE), 'Node of the user has been deleted.');
+    $this->assertFalse(node_load($node->nid, $revision, TRUE), 'Node revision of the user has been deleted.');
+    $this->assertTrue(node_load($revision_node->nid, NULL, TRUE), "Current revision of the user's node was not deleted.");
+    $this->assertFalse(comment_load($comment->cid), 'Comment of the user has been deleted.');
 
-    // Confirm that user is logged out.
-    $this->assertNoText($account->name, t('Logged out.'));
+    // Confirm that the confirmation message made it through to the end user.
+    $this->assertRaw(t('%name has been deleted.', array('%name' => $account->name)), "Confirmation message displayed to user.");
   }
 
   /**
@@ -838,13 +856,13 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Delete regular user.
     $this->drupalGet('user/' . $account->uid . '/edit');
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertRaw(t('Are you sure you want to cancel the account %name?', array('%name' => $account->name)), t('Confirmation form to cancel account displayed.'));
-    $this->assertText(t('Select the method to cancel the account above.'), t('Allows to select account cancellation method.'));
+    $this->assertRaw(t('Are you sure you want to cancel the account %name?', array('%name' => $account->name)), 'Confirmation form to cancel account displayed.');
+    $this->assertText(t('Select the method to cancel the account above.'), 'Allows to select account cancellation method.');
 
     // Confirm deletion.
     $this->drupalPost(NULL, NULL, t('Cancel account'));
-    $this->assertRaw(t('%name has been deleted.', array('%name' => $account->name)), t('User deleted.'));
-    $this->assertFalse(user_load($account->uid), t('User is not found in the database.'));
+    $this->assertRaw(t('%name has been deleted.', array('%name' => $account->name)), 'User deleted.');
+    $this->assertFalse(user_load($account->uid), 'User is not found in the database.');
   }
 
   /**
@@ -876,10 +894,10 @@ class UserCancelTestCase extends DrupalWebTestCase {
     // Also try to cancel uid 1.
     $edit['accounts[1]'] = TRUE;
     $this->drupalPost('admin/people', $edit, t('Update'));
-    $this->assertText(t('Are you sure you want to cancel these user accounts?'), t('Confirmation form to cancel accounts displayed.'));
-    $this->assertText(t('When cancelling these accounts'), t('Allows to select account cancellation method.'));
-    $this->assertText(t('Require e-mail confirmation to cancel account.'), t('Allows to send confirmation mail.'));
-    $this->assertText(t('Notify user when account is canceled.'), t('Allows to send notification mail.'));
+    $this->assertText(t('Are you sure you want to cancel these user accounts?'), 'Confirmation form to cancel accounts displayed.');
+    $this->assertText(t('When cancelling these accounts'), 'Allows to select account cancellation method.');
+    $this->assertText(t('Require e-mail confirmation to cancel account.'), 'Allows to send confirmation mail.');
+    $this->assertText(t('Notify user when account is canceled.'), 'Allows to send notification mail.');
 
     // Confirm deletion.
     $this->drupalPost(NULL, NULL, t('Cancel accounts'));
@@ -888,16 +906,16 @@ class UserCancelTestCase extends DrupalWebTestCase {
       $status = $status && (strpos($this->content, t('%name has been deleted.', array('%name' => $account->name))) !== FALSE);
       $status = $status && !user_load($account->uid, TRUE);
     }
-    $this->assertTrue($status, t('Users deleted and not found in the database.'));
+    $this->assertTrue($status, 'Users deleted and not found in the database.');
 
     // Ensure that admin account was not cancelled.
-    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), t('Account cancellation request mailed message displayed.'));
+    $this->assertText(t('A confirmation request to cancel your account has been sent to your e-mail address.'), 'Account cancellation request mailed message displayed.');
     $admin_user = user_load($admin_user->uid);
-    $this->assertTrue($admin_user->status == 1, t('Administrative user is found in the database and enabled.'));
+    $this->assertTrue($admin_user->status == 1, 'Administrative user is found in the database and enabled.');
 
     // Verify that uid 1's account was not cancelled.
     $user1 = user_load(1, TRUE);
-    $this->assertEqual($user1->status, 1, t('User #1 still exists and is not blocked.'));
+    $this->assertEqual($user1->status, 1, 'User #1 still exists and is not blocked.');
   }
 }
 
@@ -939,7 +957,7 @@ class UserPictureTestCase extends DrupalWebTestCase {
     // Try to upload a file that is not an image for the user picture.
     $not_an_image = current($this->drupalGetTestFiles('html'));
     $this->saveUserPicture($not_an_image);
-    $this->assertRaw(t('Only JPEG, PNG and GIF images are allowed.'), t('Non-image files are not accepted.'));
+    $this->assertRaw(t('Only JPEG, PNG and GIF images are allowed.'), 'Non-image files are not accepted.');
   }
 
   /**
@@ -965,13 +983,13 @@ class UserPictureTestCase extends DrupalWebTestCase {
       // Check that the image was resized and is being displayed on the
       // user's profile page.
       $text = t('The image was resized to fit within the maximum allowed dimensions of %dimensions pixels.', array('%dimensions' => $test_dim));
-      $this->assertRaw($text, t('Image was resized.'));
+      $this->assertRaw($text, 'Image was resized.');
       $alt = t("@user's picture", array('@user' => format_username($this->user)));
       $style = variable_get('user_picture_style', '');
-      $this->assertRaw(check_plain(image_style_url($style, $pic_path)), t("Image is displayed in user's edit page"));
+      $this->assertRaw(check_plain(image_style_url($style, $pic_path)), "Image is displayed in user's edit page");
 
       // Check if file is located in proper directory.
-      $this->assertTrue(is_file($pic_path), t("File is located in proper directory"));
+      $this->assertTrue(is_file($pic_path), "File is located in proper directory");
     }
   }
 
@@ -1002,12 +1020,12 @@ class UserPictureTestCase extends DrupalWebTestCase {
 
       // Test that the upload failed and that the correct reason was cited.
       $text = t('The specified file %filename could not be uploaded.', array('%filename' => $image->filename));
-      $this->assertRaw($text, t('Upload failed.'));
+      $this->assertRaw($text, 'Upload failed.');
       $text = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size(filesize($image->uri)), '%maxsize' => format_size($test_size * 1024)));
-      $this->assertRaw($text, t('File size cited as reason for failure.'));
+      $this->assertRaw($text, 'File size cited as reason for failure.');
 
       // Check if file is not uploaded.
-      $this->assertFalse(is_file($pic_path), t('File was not uploaded.'));
+      $this->assertFalse(is_file($pic_path), 'File was not uploaded.');
     }
   }
 
@@ -1034,12 +1052,12 @@ class UserPictureTestCase extends DrupalWebTestCase {
 
       // Test that the upload failed and that the correct reason was cited.
       $text = t('The specified file %filename could not be uploaded.', array('%filename' => $image->filename));
-      $this->assertRaw($text, t('Upload failed.'));
+      $this->assertRaw($text, 'Upload failed.');
       $text = t('The image is too large; the maximum dimensions are %dimensions pixels.', array('%dimensions' => $test_dim));
-      $this->assertRaw($text, t('Checking response on invalid image (dimensions).'));
+      $this->assertRaw($text, 'Checking response on invalid image (dimensions).');
 
       // Check if file is not uploaded.
-      $this->assertFalse(is_file($pic_path), t('File was not uploaded.'));
+      $this->assertFalse(is_file($pic_path), 'File was not uploaded.');
     }
   }
 
@@ -1067,12 +1085,12 @@ class UserPictureTestCase extends DrupalWebTestCase {
 
       // Test that the upload failed and that the correct reason was cited.
       $text = t('The specified file %filename could not be uploaded.', array('%filename' => $image->filename));
-      $this->assertRaw($text, t('Upload failed.'));
+      $this->assertRaw($text, 'Upload failed.');
       $text = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size(filesize($image->uri)), '%maxsize' => format_size($test_size * 1024)));
-      $this->assertRaw($text, t('File size cited as reason for failure.'));
+      $this->assertRaw($text, 'File size cited as reason for failure.');
 
       // Check if file is not uploaded.
-      $this->assertFalse(is_file($pic_path), t('File was not uploaded.'));
+      $this->assertFalse(is_file($pic_path), 'File was not uploaded.');
     }
   }
 
@@ -1098,17 +1116,17 @@ class UserPictureTestCase extends DrupalWebTestCase {
 
       // Check if image is displayed in user's profile page.
       $this->drupalGet('user');
-      $this->assertRaw(file_uri_target($pic_path), t("Image is displayed in user's profile page"));
+      $this->assertRaw(file_uri_target($pic_path), "Image is displayed in user's profile page");
 
       // Check if file is located in proper directory.
-      $this->assertTrue(is_file($pic_path), t('File is located in proper directory'));
+      $this->assertTrue(is_file($pic_path), 'File is located in proper directory');
 
       // Set new picture dimensions.
       $test_dim = ($info['width'] + 5) . 'x' . ($info['height'] + 5);
       variable_set('user_picture_dimensions', $test_dim);
 
       $pic_path2 = $this->saveUserPicture($image);
-      $this->assertNotEqual($pic_path, $pic_path2, t('Filename of second picture is different.'));
+      $this->assertNotEqual($pic_path, $pic_path2, 'Filename of second picture is different.');
     }
   }
 
@@ -1128,8 +1146,8 @@ class UserPictureTestCase extends DrupalWebTestCase {
 
     // Get the user picture image via xpath.
     $elements = $this->xpath('//div[@class="user-picture"]/img');
-    $this->assertEqual(count($elements), 1, t("There is exactly one user picture on the user's profile page"));
-    $this->assertEqual($pic_path, (string) $elements[0]['src'], t("User picture source is correct."));
+    $this->assertEqual(count($elements), 1, "There is exactly one user picture on the user's profile page");
+    $this->assertEqual($pic_path, (string) $elements[0]['src'], "User picture source is correct.");
   }
 
   /**
@@ -1237,24 +1255,24 @@ class UserPermissionsTestCase extends DrupalWebTestCase {
     $account = $this->admin_user;
 
     // Add a permission.
-    $this->assertFalse(user_access('administer nodes', $account), t('User does not have "administer nodes" permission.'));
+    $this->assertFalse(user_access('administer nodes', $account), 'User does not have "administer nodes" permission.');
     $edit = array();
     $edit[$rid . '[administer nodes]'] = TRUE;
     $this->drupalPost('admin/people/permissions', $edit, t('Save permissions'));
-    $this->assertText(t('The changes have been saved.'), t('Successful save message displayed.'));
+    $this->assertText(t('The changes have been saved.'), 'Successful save message displayed.');
     drupal_static_reset('user_access');
     drupal_static_reset('user_role_permissions');
-    $this->assertTrue(user_access('administer nodes', $account), t('User now has "administer nodes" permission.'));
+    $this->assertTrue(user_access('administer nodes', $account), 'User now has "administer nodes" permission.');
 
     // Remove a permission.
-    $this->assertTrue(user_access('access user profiles', $account), t('User has "access user profiles" permission.'));
+    $this->assertTrue(user_access('access user profiles', $account), 'User has "access user profiles" permission.');
     $edit = array();
     $edit[$rid . '[access user profiles]'] = FALSE;
     $this->drupalPost('admin/people/permissions', $edit, t('Save permissions'));
-    $this->assertText(t('The changes have been saved.'), t('Successful save message displayed.'));
+    $this->assertText(t('The changes have been saved.'), 'Successful save message displayed.');
     drupal_static_reset('user_access');
     drupal_static_reset('user_role_permissions');
-    $this->assertFalse(user_access('access user profiles', $account), t('User no longer has "access user profiles" permission.'));
+    $this->assertFalse(user_access('access user profiles', $account), 'User no longer has "access user profiles" permission.');
   }
 
   /**
@@ -1274,7 +1292,7 @@ class UserPermissionsTestCase extends DrupalWebTestCase {
     $edit = array();
     $edit['modules[Core][aggregator][enable]'] = TRUE;
     $this->drupalPost('admin/modules', $edit, t('Save configuration'));
-    $this->assertTrue(user_access('administer news feeds', $this->admin_user), t('The permission was automatically assigned to the administrator role'));
+    $this->assertTrue(user_access('administer news feeds', $this->admin_user), 'The permission was automatically assigned to the administrator role');
   }
 
   /**
@@ -1285,9 +1303,9 @@ class UserPermissionsTestCase extends DrupalWebTestCase {
     $account = $this->admin_user;
 
     // Verify current permissions.
-    $this->assertFalse(user_access('administer nodes', $account), t('User does not have "administer nodes" permission.'));
-    $this->assertTrue(user_access('access user profiles', $account), t('User has "access user profiles" permission.'));
-    $this->assertTrue(user_access('administer site configuration', $account), t('User has "administer site configuration" permission.'));
+    $this->assertFalse(user_access('administer nodes', $account), 'User does not have "administer nodes" permission.');
+    $this->assertTrue(user_access('access user profiles', $account), 'User has "access user profiles" permission.');
+    $this->assertTrue(user_access('administer site configuration', $account), 'User has "administer site configuration" permission.');
 
     // Change permissions.
     $permissions = array(
@@ -1297,9 +1315,9 @@ class UserPermissionsTestCase extends DrupalWebTestCase {
     user_role_change_permissions($rid, $permissions);
 
     // Verify proper permission changes.
-    $this->assertTrue(user_access('administer nodes', $account), t('User now has "administer nodes" permission.'));
-    $this->assertFalse(user_access('access user profiles', $account), t('User no longer has "access user profiles" permission.'));
-    $this->assertTrue(user_access('administer site configuration', $account), t('User still has "administer site configuration" permission.'));
+    $this->assertTrue(user_access('administer nodes', $account), 'User now has "administer nodes" permission.');
+    $this->assertFalse(user_access('access user profiles', $account), 'User no longer has "access user profiles" permission.');
+    $this->assertTrue(user_access('administer site configuration', $account), 'User still has "administer site configuration" permission.');
   }
 }
 
@@ -1325,14 +1343,14 @@ class UserAdminTestCase extends DrupalWebTestCase {
     $admin_user = $this->drupalCreateUser(array('administer users'));
     $this->drupalLogin($admin_user);
     $this->drupalGet('admin/people');
-    $this->assertText($user_a->name, t('Found user A on admin users page'));
-    $this->assertText($user_b->name, t('Found user B on admin users page'));
-    $this->assertText($user_c->name, t('Found user C on admin users page'));
-    $this->assertText($admin_user->name, t('Found Admin user on admin users page'));
+    $this->assertText($user_a->name, 'Found user A on admin users page');
+    $this->assertText($user_b->name, 'Found user B on admin users page');
+    $this->assertText($user_c->name, 'Found user C on admin users page');
+    $this->assertText($admin_user->name, 'Found Admin user on admin users page');
 
     // Test for existence of edit link in table.
     $link = l(t('edit'), "user/$user_a->uid/edit", array('query' => array('destination' => 'admin/people')));
-    $this->assertRaw($link, t('Found user A edit link on admin users page'));
+    $this->assertRaw($link, 'Found user A edit link on admin users page');
 
     // Filter the users by permission 'administer taxonomy'.
     $edit = array();
@@ -1340,18 +1358,18 @@ class UserAdminTestCase extends DrupalWebTestCase {
     $this->drupalPost('admin/people', $edit, t('Filter'));
 
     // Check if the correct users show up.
-    $this->assertNoText($user_a->name, t('User A not on filtered by perm admin users page'));
-    $this->assertText($user_b->name, t('Found user B on filtered by perm admin users page'));
-    $this->assertText($user_c->name, t('Found user C on filtered by perm admin users page'));
+    $this->assertNoText($user_a->name, 'User A not on filtered by perm admin users page');
+    $this->assertText($user_b->name, 'Found user B on filtered by perm admin users page');
+    $this->assertText($user_c->name, 'Found user C on filtered by perm admin users page');
 
     // Filter the users by role. Grab the system-generated role name for User C.
     $edit['role'] = max(array_flip($user_c->roles));
     $this->drupalPost('admin/people', $edit, t('Refine'));
 
     // Check if the correct users show up when filtered by role.
-    $this->assertNoText($user_a->name, t('User A not on filtered by role on admin users page'));
-    $this->assertNoText($user_b->name, t('User B not on filtered by role on admin users page'));
-    $this->assertText($user_c->name, t('User C on filtered by role on admin users page'));
+    $this->assertNoText($user_a->name, 'User A not on filtered by role on admin users page');
+    $this->assertNoText($user_b->name, 'User B not on filtered by role on admin users page');
+    $this->assertText($user_c->name, 'User C on filtered by role on admin users page');
 
     // Test blocking of a user.
     $account = user_load($user_c->uid);
@@ -1422,26 +1440,26 @@ class UserTimeZoneFunctionalTest extends DrupalWebTestCase {
 
     // Confirm date format and time zone.
     $this->drupalGet("node/$node1->nid");
-    $this->assertText('2007-03-09 21:00 PST', t('Date should be PST.'));
+    $this->assertText('2007-03-09 21:00 PST', 'Date should be PST.');
     $this->drupalGet("node/$node2->nid");
-    $this->assertText('2007-03-11 01:00 PST', t('Date should be PST.'));
+    $this->assertText('2007-03-11 01:00 PST', 'Date should be PST.');
     $this->drupalGet("node/$node3->nid");
-    $this->assertText('2007-03-20 21:00 PDT', t('Date should be PDT.'));
+    $this->assertText('2007-03-20 21:00 PDT', 'Date should be PDT.');
 
     // Change user time zone to Santiago time.
     $edit = array();
     $edit['mail'] = $web_user->mail;
     $edit['timezone'] = 'America/Santiago';
     $this->drupalPost("user/$web_user->uid/edit", $edit, t('Save'));
-    $this->assertText(t('The changes have been saved.'), t('Time zone changed to Santiago time.'));
+    $this->assertText(t('The changes have been saved.'), 'Time zone changed to Santiago time.');
 
     // Confirm date format and time zone.
     $this->drupalGet("node/$node1->nid");
-    $this->assertText('2007-03-10 02:00 CLST', t('Date should be Chile summer time; five hours ahead of PST.'));
+    $this->assertText('2007-03-10 02:00 CLST', 'Date should be Chile summer time; five hours ahead of PST.');
     $this->drupalGet("node/$node2->nid");
-    $this->assertText('2007-03-11 05:00 CLT', t('Date should be Chile time; four hours ahead of PST'));
+    $this->assertText('2007-03-11 05:00 CLT', 'Date should be Chile time; four hours ahead of PST');
     $this->drupalGet("node/$node3->nid");
-    $this->assertText('2007-03-21 00:00 CLT', t('Date should be Chile time; three hours ahead of PDT.'));
+    $this->assertText('2007-03-21 00:00 CLT', 'Date should be Chile time; three hours ahead of PDT.');
   }
 }
 
@@ -1472,16 +1490,16 @@ class UserAutocompleteTestCase extends DrupalWebTestCase {
     // Check access from unprivileged user, should be denied.
     $this->drupalLogin($this->unprivileged_user);
     $this->drupalGet('user/autocomplete/' . $this->unprivileged_user->name[0]);
-    $this->assertResponse(403, t('Autocompletion access denied to user without permission.'));
+    $this->assertResponse(403, 'Autocompletion access denied to user without permission.');
 
     // Check access from privileged user.
     $this->drupalLogout();
     $this->drupalLogin($this->privileged_user);
     $this->drupalGet('user/autocomplete/' . $this->unprivileged_user->name[0]);
-    $this->assertResponse(200, t('Autocompletion access allowed.'));
+    $this->assertResponse(200, 'Autocompletion access allowed.');
 
     // Using first letter of the user's name, make sure the user's full name is in the results.
-    $this->assertRaw($this->unprivileged_user->name, t('User name found in autocompletion results.'));
+    $this->assertRaw($this->unprivileged_user->name, 'User name found in autocompletion results.');
   }
 }
 
@@ -1547,11 +1565,13 @@ class UserAccountLinksUnitTests extends DrupalWebTestCase {
 
     // Verify that the 'My account' link is enabled.
     $this->drupalGet('admin/structure/menu/manage/user-menu');
-    $this->assertFieldChecked('edit-mlid2-hidden', "The 'My account' link is enabled by default.");
+    $label = $this->xpath('//label[contains(.,:text)]/@for', array(':text' => 'Enable My account menu link'));
+    $this->assertFieldChecked((string) $label[0], "The 'My account' link is enabled by default.");
 
     // Disable the 'My account' link.
+    $input = $this->xpath('//input[@id=:field_id]/@name', array(':field_id' => (string)$label[0]));
     $edit = array(
-      'mlid:2[hidden]' => FALSE,
+      (string) $input[0] => FALSE,
     );
     $this->drupalPost('admin/structure/menu/manage/user-menu', $edit, t('Save configuration'));
 
@@ -1593,23 +1613,23 @@ class UserBlocksUnitTests extends DrupalWebTestCase {
     $edit['name'] = $user->name;
     $edit['pass'] = $user->pass_raw;
     $this->drupalPost('admin/people/permissions', $edit, t('Log in'));
-    $this->assertNoText(t('User login'), t('Logged in.'));
+    $this->assertNoText(t('User login'), 'Logged in.');
 
     // Check that we are still on the same page.
-    $this->assertEqual(url('admin/people/permissions', array('absolute' => TRUE)), $this->getUrl(), t('Still on the same page after login for access denied page'));
+    $this->assertEqual(url('admin/people/permissions', array('absolute' => TRUE)), $this->getUrl(), 'Still on the same page after login for access denied page');
 
     // Now, log out and repeat with a non-403 page.
     $this->drupalLogout();
     $this->drupalPost('filter/tips', $edit, t('Log in'));
-    $this->assertNoText(t('User login'), t('Logged in.'));
-    $this->assertPattern('!<title.*?' . t('Compose tips') . '.*?</title>!', t('Still on the same page after login for allowed page'));
+    $this->assertNoText(t('User login'), 'Logged in.');
+    $this->assertPattern('!<title.*?' . t('Compose tips') . '.*?</title>!', 'Still on the same page after login for allowed page');
 
     // Check that the user login block is not vulnerable to information
     // disclosure to third party sites.
     $this->drupalLogout();
     $this->drupalPost('http://example.com/', $edit, t('Log in'), array('external' => FALSE));
     // Check that we remain on the site after login.
-    $this->assertEqual(url('user/' . $user->uid, array('absolute' => TRUE)), $this->getUrl(), t('Redirected to user profile page after login from the frontpage'));
+    $this->assertEqual(url('user/' . $user->uid, array('absolute' => TRUE)), $this->getUrl(), 'Redirected to user profile page after login from the frontpage');
   }
 
   /**
@@ -1620,12 +1640,12 @@ class UserBlocksUnitTests extends DrupalWebTestCase {
     $user1 = $this->drupalCreateUser(array());
     $user2 = $this->drupalCreateUser(array());
     $user3 = $this->drupalCreateUser(array());
-    $this->assertEqual(db_query("SELECT COUNT(*) FROM {sessions}")->fetchField(), 0, t('Sessions table is empty.'));
+    $this->assertEqual(db_query("SELECT COUNT(*) FROM {sessions}")->fetchField(), 0, 'Sessions table is empty.');
 
     // Insert a user with two sessions.
     $this->insertSession(array('uid' => $user1->uid));
     $this->insertSession(array('uid' => $user1->uid));
-    $this->assertEqual(db_query("SELECT COUNT(*) FROM {sessions} WHERE uid = :uid", array(':uid' => $user1->uid))->fetchField(), 2, t('Duplicate user session has been inserted.'));
+    $this->assertEqual(db_query("SELECT COUNT(*) FROM {sessions} WHERE uid = :uid", array(':uid' => $user1->uid))->fetchField(), 2, 'Duplicate user session has been inserted.');
 
     // Insert a user with only one session.
     $this->insertSession(array('uid' => $user2->uid, 'timestamp' => REQUEST_TIME + 1));
@@ -1640,11 +1660,11 @@ class UserBlocksUnitTests extends DrupalWebTestCase {
     // Test block output.
     $block = user_block_view('online');
     $this->drupalSetContent($block['content']);
-    $this->assertRaw(t('2 users'), t('Correct number of online users (2 users).'));
-    $this->assertText($user1->name, t('Active user 1 found in online list.'));
-    $this->assertText($user2->name, t('Active user 2 found in online list.'));
-    $this->assertNoText($user3->name, t("Inactive user not found in online list."));
-    $this->assertTrue(strpos($this->drupalGetContent(), $user1->name) > strpos($this->drupalGetContent(), $user2->name), t('Online users are ordered correctly.'));
+    $this->assertRaw(t('2 users'), 'Correct number of online users (2 users).');
+    $this->assertText($user1->name, 'Active user 1 found in online list.');
+    $this->assertText($user2->name, 'Active user 2 found in online list.');
+    $this->assertNoText($user3->name, "Inactive user not found in online list.");
+    $this->assertTrue(strpos($this->drupalGetContent(), $user1->name) > strpos($this->drupalGetContent(), $user2->name), 'Online users are ordered correctly.');
   }
 
   /**
@@ -1660,7 +1680,7 @@ class UserBlocksUnitTests extends DrupalWebTestCase {
     db_insert('sessions')
       ->fields($fields)
       ->execute();
-    $this->assertEqual(db_query("SELECT COUNT(*) FROM {sessions} WHERE uid = :uid AND sid = :sid AND timestamp = :timestamp", array(':uid' => $fields['uid'], ':sid' => $fields['sid'], ':timestamp' => $fields['timestamp']))->fetchField(), 1, t('Session record inserted.'));
+    $this->assertEqual(db_query("SELECT COUNT(*) FROM {sessions} WHERE uid = :uid AND sid = :sid AND timestamp = :timestamp", array(':uid' => $fields['uid'], ':sid' => $fields['sid'], ':timestamp' => $fields['timestamp']))->fetchField(), 1, 'Session record inserted.');
   }
 }
 
@@ -1696,14 +1716,14 @@ class UserSaveTestCase extends DrupalWebTestCase {
       'status' => 1,
     );
     $user_by_return = user_save(drupal_anonymous_user(), $user);
-    $this->assertTrue($user_by_return, t('Loading user by return of user_save().'));
+    $this->assertTrue($user_by_return, 'Loading user by return of user_save().');
 
     // Test if created user exists.
     $user_by_uid = user_load($test_uid);
-    $this->assertTrue($user_by_uid, t('Loading user by uid.'));
+    $this->assertTrue($user_by_uid, 'Loading user by uid.');
 
     $user_by_name = user_load_by_name($test_name);
-    $this->assertTrue($user_by_name, t('Loading user by name.'));
+    $this->assertTrue($user_by_name, 'Loading user by name.');
   }
 }
 
@@ -1791,12 +1811,12 @@ class UserEditTestCase extends DrupalWebTestCase {
     $edit['pass[pass1]'] = '';
     $edit['pass[pass2]'] = $this->randomName();
     $this->drupalPost("user/$user1->uid/edit", $edit, t('Save'));
-    $this->assertText(t("The specified passwords do not match."), t('Typing mismatched passwords displays an error message.'));
+    $this->assertText(t("The specified passwords do not match."), 'Typing mismatched passwords displays an error message.');
 
     $edit['pass[pass1]'] = $this->randomName();
     $edit['pass[pass2]'] = '';
     $this->drupalPost("user/$user1->uid/edit", $edit, t('Save'));
-    $this->assertText(t("The specified passwords do not match."), t('Typing mismatched passwords displays an error message.'));
+    $this->assertText(t("The specified passwords do not match."), 'Typing mismatched passwords displays an error message.');
 
     // Test that the error message appears when attempting to change the mail or
     // pass without the current password.
@@ -1979,36 +1999,36 @@ class UserRoleAdminTestCase extends DrupalWebTestCase {
     $role_name = '123';
     $edit = array('name' => $role_name);
     $this->drupalPost('admin/people/permissions/roles', $edit, t('Add role'));
-    $this->assertText(t('The role has been added.'), t('The role has been added.'));
+    $this->assertText(t('The role has been added.'), 'The role has been added.');
     $role = user_role_load_by_name($role_name);
-    $this->assertTrue(is_object($role), t('The role was successfully retrieved from the database.'));
+    $this->assertTrue(is_object($role), 'The role was successfully retrieved from the database.');
 
     // Try adding a duplicate role.
     $this->drupalPost(NULL, $edit, t('Add role'));
-    $this->assertRaw(t('The role name %name already exists. Choose another role name.', array('%name' => $role_name)), t('Duplicate role warning displayed.'));
+    $this->assertRaw(t('The role name %name already exists. Choose another role name.', array('%name' => $role_name)), 'Duplicate role warning displayed.');
 
     // Test renaming a role.
     $old_name = $role_name;
     $role_name = '456';
     $edit = array('name' => $role_name);
     $this->drupalPost("admin/people/permissions/roles/edit/{$role->rid}", $edit, t('Save role'));
-    $this->assertText(t('The role has been renamed.'), t('The role has been renamed.'));
-    $this->assertFalse(user_role_load_by_name($old_name), t('The role can no longer be retrieved from the database using its old name.'));
-    $this->assertTrue(is_object(user_role_load_by_name($role_name)), t('The role can be retrieved from the database using its new name.'));
+    $this->assertText(t('The role has been renamed.'), 'The role has been renamed.');
+    $this->assertFalse(user_role_load_by_name($old_name), 'The role can no longer be retrieved from the database using its old name.');
+    $this->assertTrue(is_object(user_role_load_by_name($role_name)), 'The role can be retrieved from the database using its new name.');
 
     // Test deleting a role.
     $this->drupalPost("admin/people/permissions/roles/edit/{$role->rid}", NULL, t('Delete role'));
     $this->drupalPost(NULL, NULL, t('Delete'));
-    $this->assertText(t('The role has been deleted.'), t('The role has been deleted'));
-    $this->assertNoLinkByHref("admin/people/permissions/roles/edit/{$role->rid}", t('Role edit link removed.'));
-    $this->assertFalse(user_role_load_by_name($role_name), t('A deleted role can no longer be loaded.'));
+    $this->assertText(t('The role has been deleted.'), 'The role has been deleted');
+    $this->assertNoLinkByHref("admin/people/permissions/roles/edit/{$role->rid}", 'Role edit link removed.');
+    $this->assertFalse(user_role_load_by_name($role_name), 'A deleted role can no longer be loaded.');
 
     // Make sure that the system-defined roles cannot be edited via the user
     // interface.
     $this->drupalGet('admin/people/permissions/roles/edit/' . DRUPAL_ANONYMOUS_RID);
-    $this->assertResponse(403, t('Access denied when trying to edit the built-in anonymous role.'));
+    $this->assertResponse(403, 'Access denied when trying to edit the built-in anonymous role.');
     $this->drupalGet('admin/people/permissions/roles/edit/' . DRUPAL_AUTHENTICATED_RID);
-    $this->assertResponse(403, t('Access denied when trying to edit the built-in authenticated role.'));
+    $this->assertResponse(403, 'Access denied when trying to edit the built-in authenticated role.');
   }
 
   /**
@@ -2025,12 +2045,12 @@ class UserRoleAdminTestCase extends DrupalWebTestCase {
     // Change the role weight and submit the form.
     $edit = array('roles['. $rid .'][weight]' => $old_weight + 1);
     $this->drupalPost('admin/people/permissions/roles', $edit, t('Save order'));
-    $this->assertText(t('The role settings have been updated.'), t('The role settings form submitted successfully.'));
+    $this->assertText(t('The role settings have been updated.'), 'The role settings form submitted successfully.');
 
     // Retrieve the saved role and compare its weight.
     $role = user_role_load($rid);
     $new_weight = $role->weight;
-    $this->assertTrue(($old_weight + 1) == $new_weight, t('Role weight updated successfully.'));
+    $this->assertTrue(($old_weight + 1) == $new_weight, 'Role weight updated successfully.');
   }
 }
 
@@ -2080,11 +2100,11 @@ class UserTokenReplaceTestCase extends DrupalWebTestCase {
     $tests['[current-user:name]'] = check_plain(format_username($global_account));
 
     // Test to make sure that we generated something for each token.
-    $this->assertFalse(in_array(0, array_map('strlen', $tests)), t('No empty tokens generated.'));
+    $this->assertFalse(in_array(0, array_map('strlen', $tests)), 'No empty tokens generated.');
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('user' => $account), array('language' => $language));
-      $this->assertEqual($output, $expected, t('Sanitized user token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Sanitized user token %token replaced.', array('%token' => $input)));
     }
 
     // Generate and test unsanitized tokens.
@@ -2094,7 +2114,7 @@ class UserTokenReplaceTestCase extends DrupalWebTestCase {
 
     foreach ($tests as $input => $expected) {
       $output = token_replace($input, array('user' => $account), array('language' => $language, 'sanitize' => FALSE));
-      $this->assertEqual($output, $expected, t('Unsanitized user token %token replaced.', array('%token' => $input)));
+      $this->assertEqual($output, $expected, format_string('Unsanitized user token %token replaced.', array('%token' => $input)));
     }
   }
 }
@@ -2157,9 +2177,9 @@ class UserRolesAssignmentTestCase extends DrupalWebTestCase {
 
   public static function getInfo() {
     return array(
-      'name' => t('Role assignment'),
-      'description' => t('Tests that users can be assigned and unassigned roles.'),
-      'group' => t('User')
+      'name' => 'Role assignment',
+      'description' => 'Tests that users can be assigned and unassigned roles.',
+      'group' => 'User'
     );
   }
 
@@ -2180,13 +2200,13 @@ class UserRolesAssignmentTestCase extends DrupalWebTestCase {
     // Assign the role to the user.
     $this->drupalPost('user/' . $account->uid . '/edit', array("roles[$rid]" => $rid), t('Save'));
     $this->assertText(t('The changes have been saved.'));
-    $this->assertFieldChecked('edit-roles-' . $rid, t('Role is assigned.'));
+    $this->assertFieldChecked('edit-roles-' . $rid, 'Role is assigned.');
     $this->userLoadAndCheckRoleAssigned($account, $rid);
 
     // Remove the role from the user.
     $this->drupalPost('user/' . $account->uid . '/edit', array("roles[$rid]" => FALSE), t('Save'));
     $this->assertText(t('The changes have been saved.'));
-    $this->assertNoFieldChecked('edit-roles-' . $rid, t('Role is removed from user.'));
+    $this->assertNoFieldChecked('edit-roles-' . $rid, 'Role is removed from user.');
     $this->userLoadAndCheckRoleAssigned($account, $rid, FALSE);
   }
 
@@ -2210,13 +2230,13 @@ class UserRolesAssignmentTestCase extends DrupalWebTestCase {
     $account = user_load_by_name($edit['name']);
 
     $this->drupalGet('user/' . $account->uid . '/edit');
-    $this->assertFieldChecked('edit-roles-' . $rid, t('Role is assigned.'));
+    $this->assertFieldChecked('edit-roles-' . $rid, 'Role is assigned.');
     $this->userLoadAndCheckRoleAssigned($account, $rid);
 
     // Remove the role again.
     $this->drupalPost('user/' . $account->uid . '/edit', array("roles[$rid]" => FALSE), t('Save'));
     $this->assertText(t('The changes have been saved.'));
-    $this->assertNoFieldChecked('edit-roles-' . $rid, t('Role is removed from user.'));
+    $this->assertNoFieldChecked('edit-roles-' . $rid, 'Role is removed from user.');
     $this->userLoadAndCheckRoleAssigned($account, $rid, FALSE);
   }
 
@@ -2234,10 +2254,10 @@ class UserRolesAssignmentTestCase extends DrupalWebTestCase {
   private function userLoadAndCheckRoleAssigned($account, $rid, $is_assigned = TRUE) {
     $account = user_load($account->uid, TRUE);
     if ($is_assigned) {
-      $this->assertTrue(array_key_exists($rid, $account->roles), t('The role is present in the user object.'));
+      $this->assertTrue(array_key_exists($rid, $account->roles), 'The role is present in the user object.');
     }
     else {
-      $this->assertFalse(array_key_exists($rid, $account->roles), t('The role is not present in the user object.'));
+      $this->assertFalse(array_key_exists($rid, $account->roles), 'The role is not present in the user object.');
     }
   }
 }
@@ -2249,9 +2269,9 @@ class UserRolesAssignmentTestCase extends DrupalWebTestCase {
 class UserAuthmapAssignmentTestCase extends DrupalWebTestCase {
   public static function getInfo() {
     return array(
-      'name' => t('Authmap assignment'),
-      'description' => t('Tests that users can be assigned and unassigned authmaps.'),
-      'group' => t('User')
+      'name' => 'Authmap assignment',
+      'description' => 'Tests that users can be assigned and unassigned authmaps.',
+      'group' => 'User'
     );
   }
 
@@ -2278,7 +2298,7 @@ class UserAuthmapAssignmentTestCase extends DrupalWebTestCase {
       ),
     );
     foreach ($expected_authmaps as $authname => $expected_output) {
-      $this->assertIdentical(user_get_authmaps($authname), $expected_output, t('Authmap for authname %authname was set correctly.', array('%authname' => $authname)));
+      $this->assertIdentical(user_get_authmaps($authname), $expected_output, format_string('Authmap for authname %authname was set correctly.', array('%authname' => $authname)));
     }
 
     // Remove authmap for module poll, add authmap for module blog.
@@ -2291,13 +2311,13 @@ class UserAuthmapAssignmentTestCase extends DrupalWebTestCase {
     // Assert that external username one does not have authmaps.
     $remove_username = 'external username one';
     unset($expected_authmaps[$remove_username]);
-    $this->assertFalse(user_get_authmaps($remove_username), t('Authmap for %authname was removed.', array('%authname' => $remove_username)));
+    $this->assertFalse(user_get_authmaps($remove_username), format_string('Authmap for %authname was removed.', array('%authname' => $remove_username)));
 
     // Assert that a new authmap was created for external username three, and
     // existing authmaps for external username two were unchanged.
     $expected_authmaps['external username three'] = array('blog' => 'external username three');
     foreach ($expected_authmaps as $authname => $expected_output) {
-      $this->assertIdentical(user_get_authmaps($authname), $expected_output, t('Authmap for authname %authname was set correctly.', array('%authname' => $authname)));
+      $this->assertIdentical(user_get_authmaps($authname), $expected_output, format_string('Authmap for authname %authname was set correctly.', array('%authname' => $authname)));
     }
   }
 }
diff --git a/scripts/run-tests.sh b/scripts/run-tests.sh
index 3345015..189d7f2 100755
--- a/scripts/run-tests.sh
+++ b/scripts/run-tests.sh
@@ -362,6 +362,8 @@ function simpletest_script_run_one_test($test_id, $test_class) {
     // Bootstrap Drupal.
     drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);
 
+    simpletest_classloader_register();
+
     $test = new $test_class($test_id);
     $test->run();
     $info = $test->getInfo();
@@ -395,7 +397,7 @@ function simpletest_script_command($test_id, $test_class) {
   if ($args['color']) {
     $command .= ' --color';
   }
-  $command .= " --php " . escapeshellarg($php) . " --test-id $test_id --execute-test $test_class";
+  $command .= " --php " . escapeshellarg($php) . " --test-id $test_id --execute-test " . escapeshellarg($test_class);
   return $command;
 }
 
diff --git a/sites/default/default.settings.php b/sites/default/default.settings.php
index 2b207f2..40f552e 100644
--- a/sites/default/default.settings.php
+++ b/sites/default/default.settings.php
@@ -147,7 +147,7 @@
  *     'authmap'   => 'shared_',
  *   ),
  * @endcode
- * You can also use a reference to a schema/database as a prefix. This maybe
+ * You can also use a reference to a schema/database as a prefix. This may be
  * useful if your Drupal installation exists in a schema that is not the default
  * or you want to access several databases from the same code base at the same
  * time.
@@ -435,7 +435,7 @@ ini_set('session.cookie_lifetime', 2000000);
 /**
  * String overrides:
  *
- * To override specific strings on your site with or without enabling locale
+ * To override specific strings on your site with or without enabling the Locale
  * module, add an entry to this list. This functionality allows you to change
  * a small number of your site's default English language interface strings.
  *
diff --git a/themes/seven/template.php b/themes/seven/template.php
index 437e9a7..5c086fa 100644
--- a/themes/seven/template.php
+++ b/themes/seven/template.php
@@ -104,12 +104,15 @@ function seven_css_alter(&$css) {
   // Use Seven's vertical tabs style instead of the default one.
   if (isset($css['misc/vertical-tabs.css'])) {
     $css['misc/vertical-tabs.css']['data'] = drupal_get_path('theme', 'seven') . '/vertical-tabs.css';
+    $css['misc/vertical-tabs.css']['type'] = 'file';
   }
   if (isset($css['misc/vertical-tabs-rtl.css'])) {
     $css['misc/vertical-tabs-rtl.css']['data'] = drupal_get_path('theme', 'seven') . '/vertical-tabs-rtl.css';
+    $css['misc/vertical-tabs-rtl.css']['type'] = 'file';
   }
   // Use Seven's jQuery UI theme style instead of the default one.
   if (isset($css['misc/ui/jquery.ui.theme.css'])) {
     $css['misc/ui/jquery.ui.theme.css']['data'] = drupal_get_path('theme', 'seven') . '/jquery.ui.theme.css';
+    $css['misc/ui/jquery.ui.theme.css']['type'] = 'file';
   }
 }
diff --git a/update.php b/update.php
index 0c2aaf8..331e632 100644
--- a/update.php
+++ b/update.php
@@ -1,7 +1,7 @@
 <?php
 
 /**
- * Root directory of Drupal installation.
+ * Defines the root directory of the Drupal installation.
  */
 define('DRUPAL_ROOT', getcwd());
 
@@ -27,6 +27,9 @@ define('DRUPAL_ROOT', getcwd());
  */
 define('MAINTENANCE_MODE', 'update');
 
+/**
+ * Renders a form with a list of available database updates.
+ */
 function update_selection_page() {
   drupal_set_title('Drupal database update');
   $elements = drupal_get_form('update_script_selection_form');
@@ -37,6 +40,9 @@ function update_selection_page() {
   return $output;
 }
 
+/**
+ * Form constructor for the list of available database module updates.
+ */
 function update_script_selection_form($form, &$form_state) {
   $count = 0;
   $incompatible_count = 0;
@@ -141,9 +147,10 @@ function update_script_selection_form($form, &$form_state) {
   return $form;
 }
 
+/**
+ * Provides links to the homepage and administration pages.
+ */
 function update_helpful_links() {
-  // NOTE: we can't use l() here because the URL would point to
-  // 'update.php?q=admin'.
   $links[] = '<a href="' . base_path() . '">Front page</a>';
   if (user_access('access administration pages')) {
     $links[] = '<a href="' . base_path() . '?q=admin">Administration pages</a>';
@@ -151,6 +158,9 @@ function update_helpful_links() {
   return $links;
 }
 
+/**
+ * Displays results of the update script with any accompanying errors.
+ */
 function update_results_page() {
   drupal_set_title('Drupal database update');
   $links = update_helpful_links();
@@ -231,6 +241,15 @@ function update_results_page() {
   return $output;
 }
 
+/**
+ * Provides an overview of the Drupal database update.
+ *
+ * This page provides cautionary suggestions that should happen before
+ * proceeding with the update to ensure data integrity.
+ *
+ * @return
+ *   Rendered HTML form.
+ */
 function update_info_page() {
   // Change query-strings on css/js files to enforce reload for all users.
   _drupal_flush_css_js();
@@ -256,6 +275,12 @@ function update_info_page() {
   return $output;
 }
 
+/**
+ * Renders a 403 access denied page for update.php.
+ *
+ * @return
+ *   Rendered HTML warning with 403 status.
+ */
 function update_access_denied_page() {
   drupal_add_http_header('Status', '403 Forbidden');
   watchdog('access denied', 'update.php', NULL, WATCHDOG_WARNING);
@@ -294,7 +319,7 @@ function update_access_allowed() {
 }
 
 /**
- * Add the update task list to the current page.
+ * Adds the update task list to the current page.
  */
 function update_task_list($active = NULL) {
   // Default list of tasks.
@@ -310,8 +335,7 @@ function update_task_list($active = NULL) {
 }
 
 /**
- * Returns (and optionally stores) extra requirements that only apply during
- * particular parts of the update.php process.
+ * Returns and stores extra requirements that apply during the update process.
  */
 function update_extra_requirements($requirements = NULL) {
   static $extra_requirements = array();
@@ -322,7 +346,7 @@ function update_extra_requirements($requirements = NULL) {
 }
 
 /**
- * Check update requirements and report any errors or (optionally) warnings.
+ * Checks update requirements and reports errors and (optionally) warnings.
  *
  * @param $skip_warnings
  *   (optional) If set to TRUE, requirement warnings will be ignored, and a
diff --git a/web.config b/web.config
index 34afd0a..09983d9 100644
--- a/web.config
+++ b/web.config
@@ -12,6 +12,9 @@
         <rule name="Force simple error message for requests for non-existent favicon.ico" stopProcessing="true">
           <match url="favicon\.ico" />
           <action type="CustomResponse" statusCode="404" subStatusCode="1" statusReason="File Not Found" statusDescription="The requested file favicon.ico was not found" />
+          <conditions>
+            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
+          </conditions>
         </rule>
         <!-- Rewrite URLs of the form 'x' to the form 'index.php?q=x'. -->
         <rule name="Short URLs" stopProcessing="true">
